import {
  animate,
  keyframes,
  state,
  style,
  transition,
  trigger
} from "./chunk-UTMNAG5J.js";
import {
  C,
  C2,
  H2 as H,
  L2 as L,
  L3 as L2,
  L39 as L3,
  d14 as d3,
  d4 as d,
  d7 as d2,
  e13 as e4,
  e2 as e,
  e3 as e2,
  e7 as e3,
  l,
  l2,
  o,
  o10 as o8,
  o2,
  o26 as o9,
  o5 as o3,
  o6 as o4,
  o7 as o5,
  o8 as o6,
  o9 as o7,
  r13 as r4,
  r6 as r2,
  r7 as r3
} from "./chunk-QI4RCN2H.js";
import "./chunk-7IHWMCNT.js";
import {
  r2 as r
} from "./chunk-LHJGLX4A.js";
import {
  RouterLink,
  RouterLinkActive,
  RouterModule
} from "./chunk-OMMITIX3.js";
import "./chunk-47N53SJK.js";
import "./chunk-7L6NILIT.js";
import {
  AsyncPipe,
  CommonModule,
  DOCUMENT,
  FormStyle,
  FormatWidth,
  NgClass,
  NgForOf,
  NgIf,
  NgSwitch,
  NgSwitchCase,
  NgTemplateOutlet,
  SlicePipe,
  TranslationWidth,
  getDOM,
  getLocaleDateFormat,
  getLocaleDayNames,
  getLocaleFirstDayOfWeek,
  getLocaleMonthNames,
  isPlatformBrowser
} from "./chunk-CVWQJADW.js";
import {
  APP_ID,
  ApplicationRef,
  Attribute,
  CSP_NONCE,
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  Component,
  ComponentFactoryResolver$1,
  ContentChild,
  ContentChildren,
  Directive,
  ElementRef,
  EnvironmentInjector,
  EventEmitter,
  Host,
  HostBinding,
  HostListener,
  Inject,
  Injectable,
  InjectionToken,
  Injector,
  Input,
  IterableDiffers,
  KeyValueDiffers,
  LOCALE_ID,
  NgModule,
  NgZone,
  Optional,
  Output,
  PLATFORM_ID,
  QueryList,
  Renderer2,
  RendererFactory2,
  RuntimeError,
  Self,
  SkipSelf,
  TemplateRef,
  Type,
  VERSION,
  Version,
  ViewChild,
  ViewContainerRef,
  ViewEncapsulation,
  afterNextRender,
  booleanAttribute,
  computed,
  createComponent,
  forwardRef,
  inject,
  isPromise,
  isSubscribable,
  numberAttribute,
  setClassMetadata,
  signal,
  untracked,
  ɵɵHostDirectivesFeature,
  ɵɵInheritDefinitionFeature,
  ɵɵInputTransformsFeature,
  ɵɵNgOnChangesFeature,
  ɵɵProvidersFeature,
  ɵɵadvance,
  ɵɵattribute,
  ɵɵclassMap,
  ɵɵclassProp,
  ɵɵcontentQuery,
  ɵɵdefineComponent,
  ɵɵdefineDirective,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdirectiveInject,
  ɵɵelement,
  ɵɵelementContainer,
  ɵɵelementContainerEnd,
  ɵɵelementContainerStart,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵgetCurrentView,
  ɵɵgetInheritedFactory,
  ɵɵhostProperty,
  ɵɵinject,
  ɵɵinjectAttribute,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnextContext,
  ɵɵpipe,
  ɵɵpipeBind1,
  ɵɵpipeBind3,
  ɵɵprojection,
  ɵɵprojectionDef,
  ɵɵproperty,
  ɵɵpropertyInterpolate,
  ɵɵpropertyInterpolate1,
  ɵɵpureFunction1,
  ɵɵpureFunction2,
  ɵɵqueryRefresh,
  ɵɵreference,
  ɵɵresetView,
  ɵɵresolveDocument,
  ɵɵresolveWindow,
  ɵɵrestoreView,
  ɵɵsanitizeUrl,
  ɵɵstyleProp,
  ɵɵsyntheticHostListener,
  ɵɵsyntheticHostProperty,
  ɵɵtemplate,
  ɵɵtemplateRefExtractor,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵtextInterpolate2,
  ɵɵtextInterpolate3,
  ɵɵtwoWayBindingSet,
  ɵɵtwoWayListener,
  ɵɵtwoWayProperty,
  ɵɵviewQuery
} from "./chunk-5XCMJPT6.js";
import {
  BehaviorSubject,
  ConnectableObservable,
  EMPTY,
  Observable,
  ReplaySubject,
  Subject,
  Subscription,
  animationFrameScheduler,
  asapScheduler,
  auditTime,
  combineLatest,
  concat,
  debounceTime,
  distinctUntilChanged,
  filter,
  first,
  forkJoin,
  from,
  fromEvent,
  interval,
  isObservable,
  map,
  merge,
  of,
  pairwise,
  shareReplay,
  skip,
  skipUntil,
  startWith,
  switchMap,
  take,
  takeUntil,
  tap
} from "./chunk-CC5DZCVS.js";
import {
  __spreadProps,
  __spreadValues
} from "./chunk-LYPDEF35.js";

// node_modules/@angular/forms/fesm2022/forms.mjs
var BaseControlValueAccessor = class _BaseControlValueAccessor {
  _renderer;
  _elementRef;
  /**
   * The registered callback function called when a change or input event occurs on the input
   * element.
   * @nodoc
   */
  onChange = (_) => {
  };
  /**
   * The registered callback function called when a blur event occurs on the input element.
   * @nodoc
   */
  onTouched = () => {
  };
  constructor(_renderer, _elementRef) {
    this._renderer = _renderer;
    this._elementRef = _elementRef;
  }
  /**
   * Helper method that sets a property on a target element using the current Renderer
   * implementation.
   * @nodoc
   */
  setProperty(key, value) {
    this._renderer.setProperty(this._elementRef.nativeElement, key, value);
  }
  /**
   * Registers a function called when the control is touched.
   * @nodoc
   */
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = fn;
  }
  /**
   * Sets the "disabled" property on the range input element.
   * @nodoc
   */
  setDisabledState(isDisabled) {
    this.setProperty("disabled", isDisabled);
  }
  static ɵfac = function BaseControlValueAccessor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BaseControlValueAccessor)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _BaseControlValueAccessor
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseControlValueAccessor, [{
    type: Directive
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }], null);
})();
var BuiltInControlValueAccessor = class _BuiltInControlValueAccessor extends BaseControlValueAccessor {
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵBuiltInControlValueAccessor_BaseFactory;
    return function BuiltInControlValueAccessor_Factory(__ngFactoryType__) {
      return (ɵBuiltInControlValueAccessor_BaseFactory || (ɵBuiltInControlValueAccessor_BaseFactory = ɵɵgetInheritedFactory(_BuiltInControlValueAccessor)))(__ngFactoryType__ || _BuiltInControlValueAccessor);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _BuiltInControlValueAccessor,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BuiltInControlValueAccessor, [{
    type: Directive
  }], null, null);
})();
var NG_VALUE_ACCESSOR = new InjectionToken(ngDevMode ? "NgValueAccessor" : "");
var CHECKBOX_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => CheckboxControlValueAccessor),
  multi: true
};
var CheckboxControlValueAccessor = class _CheckboxControlValueAccessor extends BuiltInControlValueAccessor {
  /**
   * Sets the "checked" property on the input element.
   * @nodoc
   */
  writeValue(value) {
    this.setProperty("checked", value);
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵCheckboxControlValueAccessor_BaseFactory;
    return function CheckboxControlValueAccessor_Factory(__ngFactoryType__) {
      return (ɵCheckboxControlValueAccessor_BaseFactory || (ɵCheckboxControlValueAccessor_BaseFactory = ɵɵgetInheritedFactory(_CheckboxControlValueAccessor)))(__ngFactoryType__ || _CheckboxControlValueAccessor);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _CheckboxControlValueAccessor,
    selectors: [["input", "type", "checkbox", "formControlName", ""], ["input", "type", "checkbox", "formControl", ""], ["input", "type", "checkbox", "ngModel", ""]],
    hostBindings: function CheckboxControlValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("change", function CheckboxControlValueAccessor_change_HostBindingHandler($event) {
          return ctx.onChange($event.target.checked);
        })("blur", function CheckboxControlValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([CHECKBOX_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckboxControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]",
      host: {
        "(change)": "onChange($event.target.checked)",
        "(blur)": "onTouched()"
      },
      providers: [CHECKBOX_VALUE_ACCESSOR],
      standalone: false
    }]
  }], null, null);
})();
var DEFAULT_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => DefaultValueAccessor),
  multi: true
};
function _isAndroid() {
  const userAgent = getDOM() ? getDOM().getUserAgent() : "";
  return /android (\d+)/.test(userAgent.toLowerCase());
}
var COMPOSITION_BUFFER_MODE = new InjectionToken(ngDevMode ? "CompositionEventMode" : "");
var DefaultValueAccessor = class _DefaultValueAccessor extends BaseControlValueAccessor {
  _compositionMode;
  /** Whether the user is creating a composition string (IME events). */
  _composing = false;
  constructor(renderer, elementRef, _compositionMode) {
    super(renderer, elementRef);
    this._compositionMode = _compositionMode;
    if (this._compositionMode == null) {
      this._compositionMode = !_isAndroid();
    }
  }
  /**
   * Sets the "value" property on the input element.
   * @nodoc
   */
  writeValue(value) {
    const normalizedValue = value == null ? "" : value;
    this.setProperty("value", normalizedValue);
  }
  /** @internal */
  _handleInput(value) {
    if (!this._compositionMode || this._compositionMode && !this._composing) {
      this.onChange(value);
    }
  }
  /** @internal */
  _compositionStart() {
    this._composing = true;
  }
  /** @internal */
  _compositionEnd(value) {
    this._composing = false;
    this._compositionMode && this.onChange(value);
  }
  static ɵfac = function DefaultValueAccessor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DefaultValueAccessor)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(COMPOSITION_BUFFER_MODE, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DefaultValueAccessor,
    selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]],
    hostBindings: function DefaultValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("input", function DefaultValueAccessor_input_HostBindingHandler($event) {
          return ctx._handleInput($event.target.value);
        })("blur", function DefaultValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        })("compositionstart", function DefaultValueAccessor_compositionstart_HostBindingHandler() {
          return ctx._compositionStart();
        })("compositionend", function DefaultValueAccessor_compositionend_HostBindingHandler($event) {
          return ctx._compositionEnd($event.target.value);
        });
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([DEFAULT_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DefaultValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]",
      // TODO: vsavkin replace the above selector with the one below it once
      // https://github.com/angular/angular/issues/3011 is implemented
      // selector: '[ngModel],[formControl],[formControlName]',
      host: {
        "(input)": "$any(this)._handleInput($event.target.value)",
        "(blur)": "onTouched()",
        "(compositionstart)": "$any(this)._compositionStart()",
        "(compositionend)": "$any(this)._compositionEnd($event.target.value)"
      },
      providers: [DEFAULT_VALUE_ACCESSOR],
      standalone: false
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [COMPOSITION_BUFFER_MODE]
    }]
  }], null);
})();
function isEmptyInputValue(value) {
  return value == null || (typeof value === "string" || Array.isArray(value)) && value.length === 0;
}
function hasValidLength(value) {
  return value != null && typeof value.length === "number";
}
var NG_VALIDATORS = new InjectionToken(ngDevMode ? "NgValidators" : "");
var NG_ASYNC_VALIDATORS = new InjectionToken(ngDevMode ? "NgAsyncValidators" : "");
var EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
function minValidator(min) {
  return (control) => {
    if (isEmptyInputValue(control.value) || isEmptyInputValue(min)) {
      return null;
    }
    const value = parseFloat(control.value);
    return !isNaN(value) && value < min ? {
      "min": {
        "min": min,
        "actual": control.value
      }
    } : null;
  };
}
function maxValidator(max) {
  return (control) => {
    if (isEmptyInputValue(control.value) || isEmptyInputValue(max)) {
      return null;
    }
    const value = parseFloat(control.value);
    return !isNaN(value) && value > max ? {
      "max": {
        "max": max,
        "actual": control.value
      }
    } : null;
  };
}
function requiredValidator(control) {
  return isEmptyInputValue(control.value) ? {
    "required": true
  } : null;
}
function requiredTrueValidator(control) {
  return control.value === true ? null : {
    "required": true
  };
}
function emailValidator(control) {
  if (isEmptyInputValue(control.value)) {
    return null;
  }
  return EMAIL_REGEXP.test(control.value) ? null : {
    "email": true
  };
}
function minLengthValidator(minLength) {
  return (control) => {
    if (isEmptyInputValue(control.value) || !hasValidLength(control.value)) {
      return null;
    }
    return control.value.length < minLength ? {
      "minlength": {
        "requiredLength": minLength,
        "actualLength": control.value.length
      }
    } : null;
  };
}
function maxLengthValidator(maxLength) {
  return (control) => {
    return hasValidLength(control.value) && control.value.length > maxLength ? {
      "maxlength": {
        "requiredLength": maxLength,
        "actualLength": control.value.length
      }
    } : null;
  };
}
function patternValidator(pattern) {
  if (!pattern) return nullValidator;
  let regex;
  let regexStr;
  if (typeof pattern === "string") {
    regexStr = "";
    if (pattern.charAt(0) !== "^") regexStr += "^";
    regexStr += pattern;
    if (pattern.charAt(pattern.length - 1) !== "$") regexStr += "$";
    regex = new RegExp(regexStr);
  } else {
    regexStr = pattern.toString();
    regex = pattern;
  }
  return (control) => {
    if (isEmptyInputValue(control.value)) {
      return null;
    }
    const value = control.value;
    return regex.test(value) ? null : {
      "pattern": {
        "requiredPattern": regexStr,
        "actualValue": value
      }
    };
  };
}
function nullValidator(control) {
  return null;
}
function isPresent(o10) {
  return o10 != null;
}
function toObservable(value) {
  const obs = isPromise(value) ? from(value) : value;
  if ((typeof ngDevMode === "undefined" || ngDevMode) && !isSubscribable(obs)) {
    let errorMessage = `Expected async validator to return Promise or Observable.`;
    if (typeof value === "object") {
      errorMessage += " Are you using a synchronous validator where an async validator is expected?";
    }
    throw new RuntimeError(-1101, errorMessage);
  }
  return obs;
}
function mergeErrors(arrayOfErrors) {
  let res = {};
  arrayOfErrors.forEach((errors) => {
    res = errors != null ? __spreadValues(__spreadValues({}, res), errors) : res;
  });
  return Object.keys(res).length === 0 ? null : res;
}
function executeValidators(control, validators) {
  return validators.map((validator) => validator(control));
}
function isValidatorFn(validator) {
  return !validator.validate;
}
function normalizeValidators(validators) {
  return validators.map((validator) => {
    return isValidatorFn(validator) ? validator : (c) => validator.validate(c);
  });
}
function compose(validators) {
  if (!validators) return null;
  const presentValidators = validators.filter(isPresent);
  if (presentValidators.length == 0) return null;
  return function(control) {
    return mergeErrors(executeValidators(control, presentValidators));
  };
}
function composeValidators(validators) {
  return validators != null ? compose(normalizeValidators(validators)) : null;
}
function composeAsync(validators) {
  if (!validators) return null;
  const presentValidators = validators.filter(isPresent);
  if (presentValidators.length == 0) return null;
  return function(control) {
    const observables = executeValidators(control, presentValidators).map(toObservable);
    return forkJoin(observables).pipe(map(mergeErrors));
  };
}
function composeAsyncValidators(validators) {
  return validators != null ? composeAsync(normalizeValidators(validators)) : null;
}
function mergeValidators(controlValidators, dirValidator) {
  if (controlValidators === null) return [dirValidator];
  return Array.isArray(controlValidators) ? [...controlValidators, dirValidator] : [controlValidators, dirValidator];
}
function getControlValidators(control) {
  return control._rawValidators;
}
function getControlAsyncValidators(control) {
  return control._rawAsyncValidators;
}
function makeValidatorsArray(validators) {
  if (!validators) return [];
  return Array.isArray(validators) ? validators : [validators];
}
function hasValidator(validators, validator) {
  return Array.isArray(validators) ? validators.includes(validator) : validators === validator;
}
function addValidators(validators, currentValidators) {
  const current = makeValidatorsArray(currentValidators);
  const validatorsToAdd = makeValidatorsArray(validators);
  validatorsToAdd.forEach((v) => {
    if (!hasValidator(current, v)) {
      current.push(v);
    }
  });
  return current;
}
function removeValidators(validators, currentValidators) {
  return makeValidatorsArray(currentValidators).filter((v) => !hasValidator(validators, v));
}
var AbstractControlDirective = class {
  /**
   * @description
   * Reports the value of the control if it is present, otherwise null.
   */
  get value() {
    return this.control ? this.control.value : null;
  }
  /**
   * @description
   * Reports whether the control is valid. A control is considered valid if no
   * validation errors exist with the current value.
   * If the control is not present, null is returned.
   */
  get valid() {
    return this.control ? this.control.valid : null;
  }
  /**
   * @description
   * Reports whether the control is invalid, meaning that an error exists in the input value.
   * If the control is not present, null is returned.
   */
  get invalid() {
    return this.control ? this.control.invalid : null;
  }
  /**
   * @description
   * Reports whether a control is pending, meaning that async validation is occurring and
   * errors are not yet available for the input value. If the control is not present, null is
   * returned.
   */
  get pending() {
    return this.control ? this.control.pending : null;
  }
  /**
   * @description
   * Reports whether the control is disabled, meaning that the control is disabled
   * in the UI and is exempt from validation checks and excluded from aggregate
   * values of ancestor controls. If the control is not present, null is returned.
   */
  get disabled() {
    return this.control ? this.control.disabled : null;
  }
  /**
   * @description
   * Reports whether the control is enabled, meaning that the control is included in ancestor
   * calculations of validity or value. If the control is not present, null is returned.
   */
  get enabled() {
    return this.control ? this.control.enabled : null;
  }
  /**
   * @description
   * Reports the control's validation errors. If the control is not present, null is returned.
   */
  get errors() {
    return this.control ? this.control.errors : null;
  }
  /**
   * @description
   * Reports whether the control is pristine, meaning that the user has not yet changed
   * the value in the UI. If the control is not present, null is returned.
   */
  get pristine() {
    return this.control ? this.control.pristine : null;
  }
  /**
   * @description
   * Reports whether the control is dirty, meaning that the user has changed
   * the value in the UI. If the control is not present, null is returned.
   */
  get dirty() {
    return this.control ? this.control.dirty : null;
  }
  /**
   * @description
   * Reports whether the control is touched, meaning that the user has triggered
   * a `blur` event on it. If the control is not present, null is returned.
   */
  get touched() {
    return this.control ? this.control.touched : null;
  }
  /**
   * @description
   * Reports the validation status of the control. Possible values include:
   * 'VALID', 'INVALID', 'DISABLED', and 'PENDING'.
   * If the control is not present, null is returned.
   */
  get status() {
    return this.control ? this.control.status : null;
  }
  /**
   * @description
   * Reports whether the control is untouched, meaning that the user has not yet triggered
   * a `blur` event on it. If the control is not present, null is returned.
   */
  get untouched() {
    return this.control ? this.control.untouched : null;
  }
  /**
   * @description
   * Returns a multicasting observable that emits a validation status whenever it is
   * calculated for the control. If the control is not present, null is returned.
   */
  get statusChanges() {
    return this.control ? this.control.statusChanges : null;
  }
  /**
   * @description
   * Returns a multicasting observable of value changes for the control that emits every time the
   * value of the control changes in the UI or programmatically.
   * If the control is not present, null is returned.
   */
  get valueChanges() {
    return this.control ? this.control.valueChanges : null;
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return null;
  }
  /**
   * Contains the result of merging synchronous validators into a single validator function
   * (combined using `Validators.compose`).
   */
  _composedValidatorFn;
  /**
   * Contains the result of merging asynchronous validators into a single validator function
   * (combined using `Validators.composeAsync`).
   */
  _composedAsyncValidatorFn;
  /**
   * Set of synchronous validators as they were provided while calling `setValidators` function.
   * @internal
   */
  _rawValidators = [];
  /**
   * Set of asynchronous validators as they were provided while calling `setAsyncValidators`
   * function.
   * @internal
   */
  _rawAsyncValidators = [];
  /**
   * Sets synchronous validators for this directive.
   * @internal
   */
  _setValidators(validators) {
    this._rawValidators = validators || [];
    this._composedValidatorFn = composeValidators(this._rawValidators);
  }
  /**
   * Sets asynchronous validators for this directive.
   * @internal
   */
  _setAsyncValidators(validators) {
    this._rawAsyncValidators = validators || [];
    this._composedAsyncValidatorFn = composeAsyncValidators(this._rawAsyncValidators);
  }
  /**
   * @description
   * Synchronous validator function composed of all the synchronous validators registered with this
   * directive.
   */
  get validator() {
    return this._composedValidatorFn || null;
  }
  /**
   * @description
   * Asynchronous validator function composed of all the asynchronous validators registered with
   * this directive.
   */
  get asyncValidator() {
    return this._composedAsyncValidatorFn || null;
  }
  /*
   * The set of callbacks to be invoked when directive instance is being destroyed.
   */
  _onDestroyCallbacks = [];
  /**
   * Internal function to register callbacks that should be invoked
   * when directive instance is being destroyed.
   * @internal
   */
  _registerOnDestroy(fn) {
    this._onDestroyCallbacks.push(fn);
  }
  /**
   * Internal function to invoke all registered "on destroy" callbacks.
   * Note: calling this function also clears the list of callbacks.
   * @internal
   */
  _invokeOnDestroyCallbacks() {
    this._onDestroyCallbacks.forEach((fn) => fn());
    this._onDestroyCallbacks = [];
  }
  /**
   * @description
   * Resets the control with the provided value if the control is present.
   */
  reset(value = void 0) {
    if (this.control) this.control.reset(value);
  }
  /**
   * @description
   * Reports whether the control with the given path has the error specified.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```ts
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * If no path is given, this method checks for the error on the current control.
   *
   * @returns whether the given error is present in the control at the given path.
   *
   * If the control is not present, false is returned.
   */
  hasError(errorCode, path) {
    return this.control ? this.control.hasError(errorCode, path) : false;
  }
  /**
   * @description
   * Reports error data for the control with the given path.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```ts
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * @returns error data for that particular error. If the control or error is not present,
   * null is returned.
   */
  getError(errorCode, path) {
    return this.control ? this.control.getError(errorCode, path) : null;
  }
};
var ControlContainer = class extends AbstractControlDirective {
  /**
   * @description
   * The name for the control
   */
  // TODO(issue/24571): remove '!'.
  name;
  /**
   * @description
   * The top-level form directive for the control.
   */
  get formDirective() {
    return null;
  }
  /**
   * @description
   * The path to this group.
   */
  get path() {
    return null;
  }
};
var NgControl = class extends AbstractControlDirective {
  /**
   * @description
   * The parent form for the control.
   *
   * @internal
   */
  _parent = null;
  /**
   * @description
   * The name for the control
   */
  name = null;
  /**
   * @description
   * The value accessor for the control
   */
  valueAccessor = null;
};
var AbstractControlStatus = class {
  _cd;
  constructor(cd) {
    this._cd = cd;
  }
  get isTouched() {
    this._cd?.control?._touched?.();
    return !!this._cd?.control?.touched;
  }
  get isUntouched() {
    return !!this._cd?.control?.untouched;
  }
  get isPristine() {
    this._cd?.control?._pristine?.();
    return !!this._cd?.control?.pristine;
  }
  get isDirty() {
    return !!this._cd?.control?.dirty;
  }
  get isValid() {
    this._cd?.control?._status?.();
    return !!this._cd?.control?.valid;
  }
  get isInvalid() {
    return !!this._cd?.control?.invalid;
  }
  get isPending() {
    return !!this._cd?.control?.pending;
  }
  get isSubmitted() {
    this._cd?._submitted?.();
    return !!this._cd?.submitted;
  }
};
var ngControlStatusHost = {
  "[class.ng-untouched]": "isUntouched",
  "[class.ng-touched]": "isTouched",
  "[class.ng-pristine]": "isPristine",
  "[class.ng-dirty]": "isDirty",
  "[class.ng-valid]": "isValid",
  "[class.ng-invalid]": "isInvalid",
  "[class.ng-pending]": "isPending"
};
var ngGroupStatusHost = __spreadProps(__spreadValues({}, ngControlStatusHost), {
  "[class.ng-submitted]": "isSubmitted"
});
var NgControlStatus = class _NgControlStatus extends AbstractControlStatus {
  constructor(cd) {
    super(cd);
  }
  static ɵfac = function NgControlStatus_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgControlStatus)(ɵɵdirectiveInject(NgControl, 2));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NgControlStatus,
    selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]],
    hostVars: 14,
    hostBindings: function NgControlStatus_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("ng-untouched", ctx.isUntouched)("ng-touched", ctx.isTouched)("ng-pristine", ctx.isPristine)("ng-dirty", ctx.isDirty)("ng-valid", ctx.isValid)("ng-invalid", ctx.isInvalid)("ng-pending", ctx.isPending);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgControlStatus, [{
    type: Directive,
    args: [{
      selector: "[formControlName],[ngModel],[formControl]",
      host: ngControlStatusHost,
      standalone: false
    }]
  }], () => [{
    type: NgControl,
    decorators: [{
      type: Self
    }]
  }], null);
})();
var NgControlStatusGroup = class _NgControlStatusGroup extends AbstractControlStatus {
  constructor(cd) {
    super(cd);
  }
  static ɵfac = function NgControlStatusGroup_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgControlStatusGroup)(ɵɵdirectiveInject(ControlContainer, 10));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NgControlStatusGroup,
    selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]],
    hostVars: 16,
    hostBindings: function NgControlStatusGroup_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("ng-untouched", ctx.isUntouched)("ng-touched", ctx.isTouched)("ng-pristine", ctx.isPristine)("ng-dirty", ctx.isDirty)("ng-valid", ctx.isValid)("ng-invalid", ctx.isInvalid)("ng-pending", ctx.isPending)("ng-submitted", ctx.isSubmitted);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgControlStatusGroup, [{
    type: Directive,
    args: [{
      selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]",
      host: ngGroupStatusHost,
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }]
  }], null);
})();
var formControlNameExample = `
  <div [formGroup]="myGroup">
    <input formControlName="firstName">
  </div>

  In your class:

  this.myGroup = new FormGroup({
      firstName: new FormControl()
  });`;
var formGroupNameExample = `
  <div [formGroup]="myGroup">
      <div formGroupName="person">
        <input formControlName="firstName">
      </div>
  </div>

  In your class:

  this.myGroup = new FormGroup({
      person: new FormGroup({ firstName: new FormControl() })
  });`;
var formArrayNameExample = `
  <div [formGroup]="myGroup">
    <div formArrayName="cities">
      <div *ngFor="let city of cityArray.controls; index as i">
        <input [formControlName]="i">
      </div>
    </div>
  </div>

  In your class:

  this.cityArray = new FormArray([new FormControl('SF')]);
  this.myGroup = new FormGroup({
    cities: this.cityArray
  });`;
var ngModelGroupExample = `
  <form>
      <div ngModelGroup="person">
        <input [(ngModel)]="person.name" name="firstName">
      </div>
  </form>`;
var ngModelWithFormGroupExample = `
  <div [formGroup]="myGroup">
      <input formControlName="firstName">
      <input [(ngModel)]="showMoreControls" [ngModelOptions]="{standalone: true}">
  </div>
`;
function controlParentException(nameOrIndex) {
  return new RuntimeError(1050, `formControlName must be used with a parent formGroup directive. You'll want to add a formGroup
      directive and pass it an existing FormGroup instance (you can create one in your class).

      ${describeFormControl(nameOrIndex)}

    Example:

    ${formControlNameExample}`);
}
function describeFormControl(nameOrIndex) {
  if (nameOrIndex == null || nameOrIndex === "") {
    return "";
  }
  const valueType = typeof nameOrIndex === "string" ? "name" : "index";
  return `Affected Form Control ${valueType}: "${nameOrIndex}"`;
}
function ngModelGroupException() {
  return new RuntimeError(1051, `formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents
      that also have a "form" prefix: formGroupName, formArrayName, or formGroup.

      Option 1:  Update the parent to be formGroupName (reactive form strategy)

      ${formGroupNameExample}

      Option 2: Use ngModel instead of formControlName (template-driven strategy)

      ${ngModelGroupExample}`);
}
function missingFormException() {
  return new RuntimeError(1052, `formGroup expects a FormGroup instance. Please pass one in.

      Example:

      ${formControlNameExample}`);
}
function groupParentException() {
  return new RuntimeError(1053, `formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup
    directive and pass it an existing FormGroup instance (you can create one in your class).

    Example:

    ${formGroupNameExample}`);
}
function arrayParentException() {
  return new RuntimeError(1054, `formArrayName must be used with a parent formGroup directive.  You'll want to add a formGroup
      directive and pass it an existing FormGroup instance (you can create one in your class).

      Example:

      ${formArrayNameExample}`);
}
var disabledAttrWarning = `
  It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true
  when you set up this control in your component class, the disabled attribute will actually be set in the DOM for
  you. We recommend using this approach to avoid 'changed after checked' errors.

  Example:
  // Specify the \`disabled\` property at control creation time:
  form = new FormGroup({
    first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),
    last: new FormControl('Drew', Validators.required)
  });

  // Controls can also be enabled/disabled after creation:
  form.get('first')?.enable();
  form.get('last')?.disable();
`;
var asyncValidatorsDroppedWithOptsWarning = `
  It looks like you're constructing using a FormControl with both an options argument and an
  async validators argument. Mixing these arguments will cause your async validators to be dropped.
  You should either put all your validators in the options object, or in separate validators
  arguments. For example:

  // Using validators arguments
  fc = new FormControl(42, Validators.required, myAsyncValidator);

  // Using AbstractControlOptions
  fc = new FormControl(42, {validators: Validators.required, asyncValidators: myAV});

  // Do NOT mix them: async validators will be dropped!
  fc = new FormControl(42, {validators: Validators.required}, /* Oops! */ myAsyncValidator);
`;
function ngModelWarning(directiveName) {
  return `
  It looks like you're using ngModel on the same form field as ${directiveName}.
  Support for using the ngModel input property and ngModelChange event with
  reactive form directives has been deprecated in Angular v6 and will be removed
  in a future version of Angular.

  For more information on this, see our API docs here:
  https://angular.io/api/forms/${directiveName === "formControl" ? "FormControlDirective" : "FormControlName"}#use-with-ngmodel
  `;
}
function describeKey(isFormGroup, key) {
  return isFormGroup ? `with name: '${key}'` : `at index: ${key}`;
}
function noControlsError(isFormGroup) {
  return `
    There are no form controls registered with this ${isFormGroup ? "group" : "array"} yet. If you're using ngModel,
    you may want to check next tick (e.g. use setTimeout).
  `;
}
function missingControlError(isFormGroup, key) {
  return `Cannot find form control ${describeKey(isFormGroup, key)}`;
}
function missingControlValueError(isFormGroup, key) {
  return `Must supply a value for form control ${describeKey(isFormGroup, key)}`;
}
var VALID = "VALID";
var INVALID = "INVALID";
var PENDING = "PENDING";
var DISABLED = "DISABLED";
var ControlEvent = class {
};
var ValueChangeEvent = class extends ControlEvent {
  value;
  source;
  constructor(value, source) {
    super();
    this.value = value;
    this.source = source;
  }
};
var PristineChangeEvent = class extends ControlEvent {
  pristine;
  source;
  constructor(pristine, source) {
    super();
    this.pristine = pristine;
    this.source = source;
  }
};
var TouchedChangeEvent = class extends ControlEvent {
  touched;
  source;
  constructor(touched, source) {
    super();
    this.touched = touched;
    this.source = source;
  }
};
var StatusChangeEvent = class extends ControlEvent {
  status;
  source;
  constructor(status, source) {
    super();
    this.status = status;
    this.source = source;
  }
};
var FormSubmittedEvent = class extends ControlEvent {
  source;
  constructor(source) {
    super();
    this.source = source;
  }
};
var FormResetEvent = class extends ControlEvent {
  source;
  constructor(source) {
    super();
    this.source = source;
  }
};
function pickValidators(validatorOrOpts) {
  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.validators : validatorOrOpts) || null;
}
function coerceToValidator(validator) {
  return Array.isArray(validator) ? composeValidators(validator) : validator || null;
}
function pickAsyncValidators(asyncValidator, validatorOrOpts) {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (isOptionsObj(validatorOrOpts) && asyncValidator) {
      console.warn(asyncValidatorsDroppedWithOptsWarning);
    }
  }
  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.asyncValidators : asyncValidator) || null;
}
function coerceToAsyncValidator(asyncValidator) {
  return Array.isArray(asyncValidator) ? composeAsyncValidators(asyncValidator) : asyncValidator || null;
}
function isOptionsObj(validatorOrOpts) {
  return validatorOrOpts != null && !Array.isArray(validatorOrOpts) && typeof validatorOrOpts === "object";
}
function assertControlPresent(parent, isGroup, key) {
  const controls = parent.controls;
  const collection = isGroup ? Object.keys(controls) : controls;
  if (!collection.length) {
    throw new RuntimeError(1e3, typeof ngDevMode === "undefined" || ngDevMode ? noControlsError(isGroup) : "");
  }
  if (!controls[key]) {
    throw new RuntimeError(1001, typeof ngDevMode === "undefined" || ngDevMode ? missingControlError(isGroup, key) : "");
  }
}
function assertAllValuesPresent(control, isGroup, value) {
  control._forEachChild((_, key) => {
    if (value[key] === void 0) {
      throw new RuntimeError(1002, typeof ngDevMode === "undefined" || ngDevMode ? missingControlValueError(isGroup, key) : "");
    }
  });
}
var AbstractControl = class {
  /** @internal */
  _pendingDirty = false;
  /**
   * Indicates that a control has its own pending asynchronous validation in progress.
   * It also stores if the control should emit events when the validation status changes.
   *
   * @internal
   */
  _hasOwnPendingAsyncValidator = null;
  /** @internal */
  _pendingTouched = false;
  /** @internal */
  _onCollectionChange = () => {
  };
  /** @internal */
  _updateOn;
  _parent = null;
  _asyncValidationSubscription;
  /**
   * Contains the result of merging synchronous validators into a single validator function
   * (combined using `Validators.compose`).
   *
   * @internal
   */
  _composedValidatorFn;
  /**
   * Contains the result of merging asynchronous validators into a single validator function
   * (combined using `Validators.composeAsync`).
   *
   * @internal
   */
  _composedAsyncValidatorFn;
  /**
   * Synchronous validators as they were provided:
   *  - in `AbstractControl` constructor
   *  - as an argument while calling `setValidators` function
   *  - while calling the setter on the `validator` field (e.g. `control.validator = validatorFn`)
   *
   * @internal
   */
  _rawValidators;
  /**
   * Asynchronous validators as they were provided:
   *  - in `AbstractControl` constructor
   *  - as an argument while calling `setAsyncValidators` function
   *  - while calling the setter on the `asyncValidator` field (e.g. `control.asyncValidator =
   * asyncValidatorFn`)
   *
   * @internal
   */
  _rawAsyncValidators;
  /**
   * The current value of the control.
   *
   * * For a `FormControl`, the current value.
   * * For an enabled `FormGroup`, the values of enabled controls as an object
   * with a key-value pair for each member of the group.
   * * For a disabled `FormGroup`, the values of all controls as an object
   * with a key-value pair for each member of the group.
   * * For a `FormArray`, the values of enabled controls as an array.
   *
   */
  value;
  /**
   * Initialize the AbstractControl instance.
   *
   * @param validators The function or array of functions that is used to determine the validity of
   *     this control synchronously.
   * @param asyncValidators The function or array of functions that is used to determine validity of
   *     this control asynchronously.
   */
  constructor(validators, asyncValidators) {
    this._assignValidators(validators);
    this._assignAsyncValidators(asyncValidators);
  }
  /**
   * Returns the function that is used to determine the validity of this control synchronously.
   * If multiple validators have been added, this will be a single composed function.
   * See `Validators.compose()` for additional information.
   */
  get validator() {
    return this._composedValidatorFn;
  }
  set validator(validatorFn) {
    this._rawValidators = this._composedValidatorFn = validatorFn;
  }
  /**
   * Returns the function that is used to determine the validity of this control asynchronously.
   * If multiple validators have been added, this will be a single composed function.
   * See `Validators.compose()` for additional information.
   */
  get asyncValidator() {
    return this._composedAsyncValidatorFn;
  }
  set asyncValidator(asyncValidatorFn) {
    this._rawAsyncValidators = this._composedAsyncValidatorFn = asyncValidatorFn;
  }
  /**
   * The parent control.
   */
  get parent() {
    return this._parent;
  }
  /**
   * The validation status of the control.
   *
   * @see {@link FormControlStatus}
   *
   * These status values are mutually exclusive, so a control cannot be
   * both valid AND invalid or invalid AND disabled.
   */
  get status() {
    return untracked(this.statusReactive);
  }
  set status(v) {
    untracked(() => this.statusReactive.set(v));
  }
  /** @internal */
  _status = computed(() => this.statusReactive());
  statusReactive = signal(void 0);
  /**
   * A control is `valid` when its `status` is `VALID`.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if the control has passed all of its validation tests,
   * false otherwise.
   */
  get valid() {
    return this.status === VALID;
  }
  /**
   * A control is `invalid` when its `status` is `INVALID`.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if this control has failed one or more of its validation checks,
   * false otherwise.
   */
  get invalid() {
    return this.status === INVALID;
  }
  /**
   * A control is `pending` when its `status` is `PENDING`.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if this control is in the process of conducting a validation check,
   * false otherwise.
   */
  get pending() {
    return this.status == PENDING;
  }
  /**
   * A control is `disabled` when its `status` is `DISABLED`.
   *
   * Disabled controls are exempt from validation checks and
   * are not included in the aggregate value of their ancestor
   * controls.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if the control is disabled, false otherwise.
   */
  get disabled() {
    return this.status === DISABLED;
  }
  /**
   * A control is `enabled` as long as its `status` is not `DISABLED`.
   *
   * @returns True if the control has any status other than 'DISABLED',
   * false if the status is 'DISABLED'.
   *
   * @see {@link AbstractControl.status}
   *
   */
  get enabled() {
    return this.status !== DISABLED;
  }
  /**
   * An object containing any errors generated by failing validation,
   * or null if there are no errors.
   */
  errors;
  /**
   * A control is `pristine` if the user has not yet changed
   * the value in the UI.
   *
   * @returns True if the user has not yet changed the value in the UI; compare `dirty`.
   * Programmatic changes to a control's value do not mark it dirty.
   */
  get pristine() {
    return untracked(this.pristineReactive);
  }
  set pristine(v) {
    untracked(() => this.pristineReactive.set(v));
  }
  /** @internal */
  _pristine = computed(() => this.pristineReactive());
  pristineReactive = signal(true);
  /**
   * A control is `dirty` if the user has changed the value
   * in the UI.
   *
   * @returns True if the user has changed the value of this control in the UI; compare `pristine`.
   * Programmatic changes to a control's value do not mark it dirty.
   */
  get dirty() {
    return !this.pristine;
  }
  /**
   * True if the control is marked as `touched`.
   *
   * A control is marked `touched` once the user has triggered
   * a `blur` event on it.
   */
  get touched() {
    return untracked(this.touchedReactive);
  }
  set touched(v) {
    untracked(() => this.touchedReactive.set(v));
  }
  /** @internal */
  _touched = computed(() => this.touchedReactive());
  touchedReactive = signal(false);
  /**
   * True if the control has not been marked as touched
   *
   * A control is `untouched` if the user has not yet triggered
   * a `blur` event on it.
   */
  get untouched() {
    return !this.touched;
  }
  /**
   * Exposed as observable, see below.
   *
   * @internal
   */
  _events = new Subject();
  /**
   * A multicasting observable that emits an event every time the state of the control changes.
   * It emits for value, status, pristine or touched changes.
   *
   * **Note**: On value change, the emit happens right after a value of this control is updated. The
   * value of a parent control (for example if this FormControl is a part of a FormGroup) is updated
   * later, so accessing a value of a parent control (using the `value` property) from the callback
   * of this event might result in getting a value that has not been updated yet. Subscribe to the
   * `events` of the parent control instead.
   * For other event types, the events are emitted after the parent control has been updated.
   *
   */
  events = this._events.asObservable();
  /**
   * A multicasting observable that emits an event every time the value of the control changes, in
   * the UI or programmatically. It also emits an event each time you call enable() or disable()
   * without passing along {emitEvent: false} as a function argument.
   *
   * **Note**: the emit happens right after a value of this control is updated. The value of a
   * parent control (for example if this FormControl is a part of a FormGroup) is updated later, so
   * accessing a value of a parent control (using the `value` property) from the callback of this
   * event might result in getting a value that has not been updated yet. Subscribe to the
   * `valueChanges` event of the parent control instead.
   *
   * TODO: this should be piped from events() but is breaking in G3
   */
  valueChanges;
  /**
   * A multicasting observable that emits an event every time the validation `status` of the control
   * recalculates.
   *
   * @see {@link FormControlStatus}
   * @see {@link AbstractControl.status}
   *
   * TODO: this should be piped from events() but is breaking in G3
   */
  statusChanges;
  /**
   * Reports the update strategy of the `AbstractControl` (meaning
   * the event on which the control updates itself).
   * Possible values: `'change'` | `'blur'` | `'submit'`
   * Default value: `'change'`
   */
  get updateOn() {
    return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change";
  }
  /**
   * Sets the synchronous validators that are active on this control.  Calling
   * this overwrites any existing synchronous validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * If you want to add a new validator without affecting existing ones, consider
   * using `addValidators()` method instead.
   */
  setValidators(validators) {
    this._assignValidators(validators);
  }
  /**
   * Sets the asynchronous validators that are active on this control. Calling this
   * overwrites any existing asynchronous validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * If you want to add a new validator without affecting existing ones, consider
   * using `addAsyncValidators()` method instead.
   */
  setAsyncValidators(validators) {
    this._assignAsyncValidators(validators);
  }
  /**
   * Add a synchronous validator or validators to this control, without affecting other validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * Adding a validator that already exists will have no effect. If duplicate validator functions
   * are present in the `validators` array, only the first instance would be added to a form
   * control.
   *
   * @param validators The new validator function or functions to add to this control.
   */
  addValidators(validators) {
    this.setValidators(addValidators(validators, this._rawValidators));
  }
  /**
   * Add an asynchronous validator or validators to this control, without affecting other
   * validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * Adding a validator that already exists will have no effect.
   *
   * @param validators The new asynchronous validator function or functions to add to this control.
   */
  addAsyncValidators(validators) {
    this.setAsyncValidators(addValidators(validators, this._rawAsyncValidators));
  }
  /**
   * Remove a synchronous validator from this control, without affecting other validators.
   * Validators are compared by function reference; you must pass a reference to the exact same
   * validator function as the one that was originally set. If a provided validator is not found,
   * it is ignored.
   *
   * @usageNotes
   *
   * ### Reference to a ValidatorFn
   *
   * ```
   * // Reference to the RequiredValidator
   * const ctrl = new FormControl<string | null>('', Validators.required);
   * ctrl.removeValidators(Validators.required);
   *
   * // Reference to anonymous function inside MinValidator
   * const minValidator = Validators.min(3);
   * const ctrl = new FormControl<string | null>('', minValidator);
   * expect(ctrl.hasValidator(minValidator)).toEqual(true)
   * expect(ctrl.hasValidator(Validators.min(3))).toEqual(false)
   *
   * ctrl.removeValidators(minValidator);
   * ```
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * @param validators The validator or validators to remove.
   */
  removeValidators(validators) {
    this.setValidators(removeValidators(validators, this._rawValidators));
  }
  /**
   * Remove an asynchronous validator from this control, without affecting other validators.
   * Validators are compared by function reference; you must pass a reference to the exact same
   * validator function as the one that was originally set. If a provided validator is not found, it
   * is ignored.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * @param validators The asynchronous validator or validators to remove.
   */
  removeAsyncValidators(validators) {
    this.setAsyncValidators(removeValidators(validators, this._rawAsyncValidators));
  }
  /**
   * Check whether a synchronous validator function is present on this control. The provided
   * validator must be a reference to the exact same function that was provided.
   *
   * @usageNotes
   *
   * ### Reference to a ValidatorFn
   *
   * ```
   * // Reference to the RequiredValidator
   * const ctrl = new FormControl<number | null>(0, Validators.required);
   * expect(ctrl.hasValidator(Validators.required)).toEqual(true)
   *
   * // Reference to anonymous function inside MinValidator
   * const minValidator = Validators.min(3);
   * const ctrl = new FormControl<number | null>(0, minValidator);
   * expect(ctrl.hasValidator(minValidator)).toEqual(true)
   * expect(ctrl.hasValidator(Validators.min(3))).toEqual(false)
   * ```
   *
   * @param validator The validator to check for presence. Compared by function reference.
   * @returns Whether the provided validator was found on this control.
   */
  hasValidator(validator) {
    return hasValidator(this._rawValidators, validator);
  }
  /**
   * Check whether an asynchronous validator function is present on this control. The provided
   * validator must be a reference to the exact same function that was provided.
   *
   * @param validator The asynchronous validator to check for presence. Compared by function
   *     reference.
   * @returns Whether the provided asynchronous validator was found on this control.
   */
  hasAsyncValidator(validator) {
    return hasValidator(this._rawAsyncValidators, validator);
  }
  /**
   * Empties out the synchronous validator list.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   */
  clearValidators() {
    this.validator = null;
  }
  /**
   * Empties out the async validator list.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   */
  clearAsyncValidators() {
    this.asyncValidator = null;
  }
  markAsTouched(opts = {}) {
    const changed = this.touched === false;
    this.touched = true;
    const sourceControl = opts.sourceControl ?? this;
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsTouched(__spreadProps(__spreadValues({}, opts), {
        sourceControl
      }));
    }
    if (changed && opts.emitEvent !== false) {
      this._events.next(new TouchedChangeEvent(true, sourceControl));
    }
  }
  /**
   * Marks the control and all its descendant controls as `touched`.
   * @see {@link markAsTouched()}
   *
   * @param opts Configuration options that determine how the control propagates changes
   * and emits events after marking is applied.
   * * `emitEvent`: When true or not supplied (the default), the `events`
   * observable emits a `TouchedChangeEvent` with the `touched` property being `true`.
   * When false, no events are emitted.
   */
  markAllAsTouched(opts = {}) {
    this.markAsTouched({
      onlySelf: true,
      emitEvent: opts.emitEvent,
      sourceControl: this
    });
    this._forEachChild((control) => control.markAllAsTouched(opts));
  }
  markAsUntouched(opts = {}) {
    const changed = this.touched === true;
    this.touched = false;
    this._pendingTouched = false;
    const sourceControl = opts.sourceControl ?? this;
    this._forEachChild((control) => {
      control.markAsUntouched({
        onlySelf: true,
        emitEvent: opts.emitEvent,
        sourceControl
      });
    });
    if (this._parent && !opts.onlySelf) {
      this._parent._updateTouched(opts, sourceControl);
    }
    if (changed && opts.emitEvent !== false) {
      this._events.next(new TouchedChangeEvent(false, sourceControl));
    }
  }
  markAsDirty(opts = {}) {
    const changed = this.pristine === true;
    this.pristine = false;
    const sourceControl = opts.sourceControl ?? this;
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsDirty(__spreadProps(__spreadValues({}, opts), {
        sourceControl
      }));
    }
    if (changed && opts.emitEvent !== false) {
      this._events.next(new PristineChangeEvent(false, sourceControl));
    }
  }
  markAsPristine(opts = {}) {
    const changed = this.pristine === false;
    this.pristine = true;
    this._pendingDirty = false;
    const sourceControl = opts.sourceControl ?? this;
    this._forEachChild((control) => {
      control.markAsPristine({
        onlySelf: true,
        emitEvent: opts.emitEvent
      });
    });
    if (this._parent && !opts.onlySelf) {
      this._parent._updatePristine(opts, sourceControl);
    }
    if (changed && opts.emitEvent !== false) {
      this._events.next(new PristineChangeEvent(true, sourceControl));
    }
  }
  markAsPending(opts = {}) {
    this.status = PENDING;
    const sourceControl = opts.sourceControl ?? this;
    if (opts.emitEvent !== false) {
      this._events.next(new StatusChangeEvent(this.status, sourceControl));
      this.statusChanges.emit(this.status);
    }
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsPending(__spreadProps(__spreadValues({}, opts), {
        sourceControl
      }));
    }
  }
  disable(opts = {}) {
    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
    this.status = DISABLED;
    this.errors = null;
    this._forEachChild((control) => {
      control.disable(__spreadProps(__spreadValues({}, opts), {
        onlySelf: true
      }));
    });
    this._updateValue();
    const sourceControl = opts.sourceControl ?? this;
    if (opts.emitEvent !== false) {
      this._events.next(new ValueChangeEvent(this.value, sourceControl));
      this._events.next(new StatusChangeEvent(this.status, sourceControl));
      this.valueChanges.emit(this.value);
      this.statusChanges.emit(this.status);
    }
    this._updateAncestors(__spreadProps(__spreadValues({}, opts), {
      skipPristineCheck
    }), this);
    this._onDisabledChange.forEach((changeFn) => changeFn(true));
  }
  /**
   * Enables the control. This means the control is included in validation checks and
   * the aggregate value of its parent. Its status recalculates based on its value and
   * its validators.
   *
   * By default, if the control has children, all children are enabled.
   *
   * @see {@link AbstractControl.status}
   *
   * @param opts Configure options that control how the control propagates changes and
   * emits events when marked as untouched
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   * * `emitEvent`: When true or not supplied (the default), the `statusChanges`,
   * `valueChanges` and `events`
   * observables emit events with the latest status and value when the control is enabled.
   * When false, no events are emitted.
   */
  enable(opts = {}) {
    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
    this.status = VALID;
    this._forEachChild((control) => {
      control.enable(__spreadProps(__spreadValues({}, opts), {
        onlySelf: true
      }));
    });
    this.updateValueAndValidity({
      onlySelf: true,
      emitEvent: opts.emitEvent
    });
    this._updateAncestors(__spreadProps(__spreadValues({}, opts), {
      skipPristineCheck
    }), this);
    this._onDisabledChange.forEach((changeFn) => changeFn(false));
  }
  _updateAncestors(opts, sourceControl) {
    if (this._parent && !opts.onlySelf) {
      this._parent.updateValueAndValidity(opts);
      if (!opts.skipPristineCheck) {
        this._parent._updatePristine({}, sourceControl);
      }
      this._parent._updateTouched({}, sourceControl);
    }
  }
  /**
   * Sets the parent of the control
   *
   * @param parent The new parent.
   */
  setParent(parent) {
    this._parent = parent;
  }
  /**
   * The raw value of this control. For most control implementations, the raw value will include
   * disabled children.
   */
  getRawValue() {
    return this.value;
  }
  updateValueAndValidity(opts = {}) {
    this._setInitialStatus();
    this._updateValue();
    if (this.enabled) {
      const shouldHaveEmitted = this._cancelExistingSubscription();
      this.errors = this._runValidator();
      this.status = this._calculateStatus();
      if (this.status === VALID || this.status === PENDING) {
        this._runAsyncValidator(shouldHaveEmitted, opts.emitEvent);
      }
    }
    const sourceControl = opts.sourceControl ?? this;
    if (opts.emitEvent !== false) {
      this._events.next(new ValueChangeEvent(this.value, sourceControl));
      this._events.next(new StatusChangeEvent(this.status, sourceControl));
      this.valueChanges.emit(this.value);
      this.statusChanges.emit(this.status);
    }
    if (this._parent && !opts.onlySelf) {
      this._parent.updateValueAndValidity(__spreadProps(__spreadValues({}, opts), {
        sourceControl
      }));
    }
  }
  /** @internal */
  _updateTreeValidity(opts = {
    emitEvent: true
  }) {
    this._forEachChild((ctrl) => ctrl._updateTreeValidity(opts));
    this.updateValueAndValidity({
      onlySelf: true,
      emitEvent: opts.emitEvent
    });
  }
  _setInitialStatus() {
    this.status = this._allControlsDisabled() ? DISABLED : VALID;
  }
  _runValidator() {
    return this.validator ? this.validator(this) : null;
  }
  _runAsyncValidator(shouldHaveEmitted, emitEvent) {
    if (this.asyncValidator) {
      this.status = PENDING;
      this._hasOwnPendingAsyncValidator = {
        emitEvent: emitEvent !== false
      };
      const obs = toObservable(this.asyncValidator(this));
      this._asyncValidationSubscription = obs.subscribe((errors) => {
        this._hasOwnPendingAsyncValidator = null;
        this.setErrors(errors, {
          emitEvent,
          shouldHaveEmitted
        });
      });
    }
  }
  _cancelExistingSubscription() {
    if (this._asyncValidationSubscription) {
      this._asyncValidationSubscription.unsubscribe();
      const shouldHaveEmitted = this._hasOwnPendingAsyncValidator?.emitEvent ?? false;
      this._hasOwnPendingAsyncValidator = null;
      return shouldHaveEmitted;
    }
    return false;
  }
  setErrors(errors, opts = {}) {
    this.errors = errors;
    this._updateControlsErrors(opts.emitEvent !== false, this, opts.shouldHaveEmitted);
  }
  /**
   * Retrieves a child control given the control's name or path.
   *
   * @param path A dot-delimited string or array of string/number values that define the path to the
   * control. If a string is provided, passing it as a string literal will result in improved type
   * information. Likewise, if an array is provided, passing it `as const` will cause improved type
   * information to be available.
   *
   * @usageNotes
   * ### Retrieve a nested control
   *
   * For example, to get a `name` control nested within a `person` sub-group:
   *
   * * `this.form.get('person.name');`
   *
   * -OR-
   *
   * * `this.form.get(['person', 'name'] as const);` // `as const` gives improved typings
   *
   * ### Retrieve a control in a FormArray
   *
   * When accessing an element inside a FormArray, you can use an element index.
   * For example, to get a `price` control from the first element in an `items` array you can use:
   *
   * * `this.form.get('items.0.price');`
   *
   * -OR-
   *
   * * `this.form.get(['items', 0, 'price']);`
   */
  get(path) {
    let currPath = path;
    if (currPath == null) return null;
    if (!Array.isArray(currPath)) currPath = currPath.split(".");
    if (currPath.length === 0) return null;
    return currPath.reduce((control, name) => control && control._find(name), this);
  }
  /**
   * @description
   * Reports error data for the control with the given path.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```ts
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * @returns error data for that particular error. If the control or error is not present,
   * null is returned.
   */
  getError(errorCode, path) {
    const control = path ? this.get(path) : this;
    return control && control.errors ? control.errors[errorCode] : null;
  }
  /**
   * @description
   * Reports whether the control with the given path has the error specified.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```ts
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * If no path is given, this method checks for the error on the current control.
   *
   * @returns whether the given error is present in the control at the given path.
   *
   * If the control is not present, false is returned.
   */
  hasError(errorCode, path) {
    return !!this.getError(errorCode, path);
  }
  /**
   * Retrieves the top-level ancestor of this control.
   */
  get root() {
    let x = this;
    while (x._parent) {
      x = x._parent;
    }
    return x;
  }
  /** @internal */
  _updateControlsErrors(emitEvent, changedControl, shouldHaveEmitted) {
    this.status = this._calculateStatus();
    if (emitEvent) {
      this.statusChanges.emit(this.status);
    }
    if (emitEvent || shouldHaveEmitted) {
      this._events.next(new StatusChangeEvent(this.status, changedControl));
    }
    if (this._parent) {
      this._parent._updateControlsErrors(emitEvent, changedControl, shouldHaveEmitted);
    }
  }
  /** @internal */
  _initObservables() {
    this.valueChanges = new EventEmitter();
    this.statusChanges = new EventEmitter();
  }
  _calculateStatus() {
    if (this._allControlsDisabled()) return DISABLED;
    if (this.errors) return INVALID;
    if (this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(PENDING)) return PENDING;
    if (this._anyControlsHaveStatus(INVALID)) return INVALID;
    return VALID;
  }
  /** @internal */
  _anyControlsHaveStatus(status) {
    return this._anyControls((control) => control.status === status);
  }
  /** @internal */
  _anyControlsDirty() {
    return this._anyControls((control) => control.dirty);
  }
  /** @internal */
  _anyControlsTouched() {
    return this._anyControls((control) => control.touched);
  }
  /** @internal */
  _updatePristine(opts, changedControl) {
    const newPristine = !this._anyControlsDirty();
    const changed = this.pristine !== newPristine;
    this.pristine = newPristine;
    if (this._parent && !opts.onlySelf) {
      this._parent._updatePristine(opts, changedControl);
    }
    if (changed) {
      this._events.next(new PristineChangeEvent(this.pristine, changedControl));
    }
  }
  /** @internal */
  _updateTouched(opts = {}, changedControl) {
    this.touched = this._anyControlsTouched();
    this._events.next(new TouchedChangeEvent(this.touched, changedControl));
    if (this._parent && !opts.onlySelf) {
      this._parent._updateTouched(opts, changedControl);
    }
  }
  /** @internal */
  _onDisabledChange = [];
  /** @internal */
  _registerOnCollectionChange(fn) {
    this._onCollectionChange = fn;
  }
  /** @internal */
  _setUpdateStrategy(opts) {
    if (isOptionsObj(opts) && opts.updateOn != null) {
      this._updateOn = opts.updateOn;
    }
  }
  /**
   * Check to see if parent has been marked artificially dirty.
   *
   * @internal
   */
  _parentMarkedDirty(onlySelf) {
    const parentDirty = this._parent && this._parent.dirty;
    return !onlySelf && !!parentDirty && !this._parent._anyControlsDirty();
  }
  /** @internal */
  _find(name) {
    return null;
  }
  /**
   * Internal implementation of the `setValidators` method. Needs to be separated out into a
   * different method, because it is called in the constructor and it can break cases where
   * a control is extended.
   */
  _assignValidators(validators) {
    this._rawValidators = Array.isArray(validators) ? validators.slice() : validators;
    this._composedValidatorFn = coerceToValidator(this._rawValidators);
  }
  /**
   * Internal implementation of the `setAsyncValidators` method. Needs to be separated out into a
   * different method, because it is called in the constructor and it can break cases where
   * a control is extended.
   */
  _assignAsyncValidators(validators) {
    this._rawAsyncValidators = Array.isArray(validators) ? validators.slice() : validators;
    this._composedAsyncValidatorFn = coerceToAsyncValidator(this._rawAsyncValidators);
  }
};
var FormGroup = class extends AbstractControl {
  /**
   * Creates a new `FormGroup` instance.
   *
   * @param controls A collection of child controls. The key for each child is the name
   * under which it is registered.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of
   * such functions, or an `AbstractControlOptions` object that contains validation functions
   * and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator functions
   *
   */
  constructor(controls, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    (typeof ngDevMode === "undefined" || ngDevMode) && validateFormGroupControls(controls);
    this.controls = controls;
    this._initObservables();
    this._setUpdateStrategy(validatorOrOpts);
    this._setUpControls();
    this.updateValueAndValidity({
      onlySelf: true,
      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
      // `VALID` or `INVALID`. The status should be broadcasted via the `statusChanges` observable,
      // so we set `emitEvent` to `true` to allow that during the control creation process.
      emitEvent: !!this.asyncValidator
    });
  }
  controls;
  registerControl(name, control) {
    if (this.controls[name]) return this.controls[name];
    this.controls[name] = control;
    control.setParent(this);
    control._registerOnCollectionChange(this._onCollectionChange);
    return control;
  }
  addControl(name, control, options = {}) {
    this.registerControl(name, control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Remove a control from this group. In a strongly-typed group, required controls cannot be
   * removed.
   *
   * This method also updates the value and validity of the control.
   *
   * @param name The control name to remove from the collection
   * @param options Specifies whether this FormGroup instance should emit events after a
   *     control is removed.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * removed. When false, no events are emitted.
   */
  removeControl(name, options = {}) {
    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {
    });
    delete this.controls[name];
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  setControl(name, control, options = {}) {
    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {
    });
    delete this.controls[name];
    if (control) this.registerControl(name, control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  contains(controlName) {
    return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;
  }
  /**
   * Sets the value of the `FormGroup`. It accepts an object that matches
   * the structure of the group, with control names as keys.
   *
   * @usageNotes
   * ### Set the complete value for the form group
   *
   * ```ts
   * const form = new FormGroup({
   *   first: new FormControl(),
   *   last: new FormControl()
   * });
   *
   * console.log(form.value);   // {first: null, last: null}
   *
   * form.setValue({first: 'Nancy', last: 'Drew'});
   * console.log(form.value);   // {first: 'Nancy', last: 'Drew'}
   * ```
   *
   * @throws When strict checks fail, such as setting the value of a control
   * that doesn't exist or if you exclude a value of a control that does exist.
   *
   * @param value The new value for the control that matches the structure of the group.
   * @param options Configuration options that determine how the control propagates changes
   * and emits events after the value changes.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is
   * false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control value is updated.
   * When false, no events are emitted.
   */
  setValue(value, options = {}) {
    assertAllValuesPresent(this, true, value);
    Object.keys(value).forEach((name) => {
      assertControlPresent(this, true, name);
      this.controls[name].setValue(value[name], {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Patches the value of the `FormGroup`. It accepts an object with control
   * names as keys, and does its best to match the values to the correct controls
   * in the group.
   *
   * It accepts both super-sets and sub-sets of the group without throwing an error.
   *
   * @usageNotes
   * ### Patch the value for a form group
   *
   * ```ts
   * const form = new FormGroup({
   *    first: new FormControl(),
   *    last: new FormControl()
   * });
   * console.log(form.value);   // {first: null, last: null}
   *
   * form.patchValue({first: 'Nancy'});
   * console.log(form.value);   // {first: 'Nancy', last: null}
   * ```
   *
   * @param value The object that matches the structure of the group.
   * @param options Configuration options that determine how the control propagates changes and
   * emits events after the value is patched.
   * * `onlySelf`: When true, each change only affects this control and not its parent. Default is
   * true.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control value
   * is updated. When false, no events are emitted. The configuration options are passed to
   * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.
   */
  patchValue(value, options = {}) {
    if (value == null) return;
    Object.keys(value).forEach((name) => {
      const control = this.controls[name];
      if (control) {
        control.patchValue(
          /* Guaranteed to be present, due to the outer forEach. */
          value[name],
          {
            onlySelf: true,
            emitEvent: options.emitEvent
          }
        );
      }
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Resets the `FormGroup`, marks all descendants `pristine` and `untouched` and sets
   * the value of all descendants to their default values, or null if no defaults were provided.
   *
   * You reset to a specific form state by passing in a map of states
   * that matches the structure of your form, with control names as keys. The state
   * is a standalone value or a form state object with both a value and a disabled
   * status.
   *
   * @param value Resets the control with an initial value,
   * or an object that defines the initial value and disabled state.
   *
   * @param options Configuration options that determine how the control propagates changes
   * and emits events when the group is reset.
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is
   * false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is reset.
   * When false, no events are emitted.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   *
   * @usageNotes
   *
   * ### Reset the form group values
   *
   * ```ts
   * const form = new FormGroup({
   *   first: new FormControl('first name'),
   *   last: new FormControl('last name')
   * });
   *
   * console.log(form.value);  // {first: 'first name', last: 'last name'}
   *
   * form.reset({ first: 'name', last: 'last name' });
   *
   * console.log(form.value);  // {first: 'name', last: 'last name'}
   * ```
   *
   * ### Reset the form group values and disabled status
   *
   * ```ts
   * const form = new FormGroup({
   *   first: new FormControl('first name'),
   *   last: new FormControl('last name')
   * });
   *
   * form.reset({
   *   first: {value: 'name', disabled: true},
   *   last: 'last'
   * });
   *
   * console.log(form.value);  // {last: 'last'}
   * console.log(form.get('first').status);  // 'DISABLED'
   * ```
   */
  reset(value = {}, options = {}) {
    this._forEachChild((control, name) => {
      control.reset(value ? value[name] : null, {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this._updatePristine(options, this);
    this._updateTouched(options, this);
    this.updateValueAndValidity(options);
  }
  /**
   * The aggregate value of the `FormGroup`, including any disabled controls.
   *
   * Retrieves all values regardless of disabled status.
   */
  getRawValue() {
    return this._reduceChildren({}, (acc, control, name) => {
      acc[name] = control.getRawValue();
      return acc;
    });
  }
  /** @internal */
  _syncPendingControls() {
    let subtreeUpdated = this._reduceChildren(false, (updated, child) => {
      return child._syncPendingControls() ? true : updated;
    });
    if (subtreeUpdated) this.updateValueAndValidity({
      onlySelf: true
    });
    return subtreeUpdated;
  }
  /** @internal */
  _forEachChild(cb) {
    Object.keys(this.controls).forEach((key) => {
      const control = this.controls[key];
      control && cb(control, key);
    });
  }
  /** @internal */
  _setUpControls() {
    this._forEachChild((control) => {
      control.setParent(this);
      control._registerOnCollectionChange(this._onCollectionChange);
    });
  }
  /** @internal */
  _updateValue() {
    this.value = this._reduceValue();
  }
  /** @internal */
  _anyControls(condition) {
    for (const [controlName, control] of Object.entries(this.controls)) {
      if (this.contains(controlName) && condition(control)) {
        return true;
      }
    }
    return false;
  }
  /** @internal */
  _reduceValue() {
    let acc = {};
    return this._reduceChildren(acc, (acc2, control, name) => {
      if (control.enabled || this.disabled) {
        acc2[name] = control.value;
      }
      return acc2;
    });
  }
  /** @internal */
  _reduceChildren(initValue, fn) {
    let res = initValue;
    this._forEachChild((control, name) => {
      res = fn(res, control, name);
    });
    return res;
  }
  /** @internal */
  _allControlsDisabled() {
    for (const controlName of Object.keys(this.controls)) {
      if (this.controls[controlName].enabled) {
        return false;
      }
    }
    return Object.keys(this.controls).length > 0 || this.disabled;
  }
  /** @internal */
  _find(name) {
    return this.controls.hasOwnProperty(name) ? this.controls[name] : null;
  }
};
function validateFormGroupControls(controls) {
  const invalidKeys = Object.keys(controls).filter((key) => key.includes("."));
  if (invalidKeys.length > 0) {
    console.warn(`FormGroup keys cannot include \`.\`, please replace the keys for: ${invalidKeys.join(",")}.`);
  }
}
var FormRecord = class extends FormGroup {
};
var CALL_SET_DISABLED_STATE = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "CallSetDisabledState" : "", {
  providedIn: "root",
  factory: () => setDisabledStateDefault
});
var setDisabledStateDefault = "always";
function controlPath(name, parent) {
  return [...parent.path, name];
}
function setUpControl(control, dir, callSetDisabledState = setDisabledStateDefault) {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (!control) _throwError(dir, "Cannot find control with");
    if (!dir.valueAccessor) _throwMissingValueAccessorError(dir);
  }
  setUpValidators(control, dir);
  dir.valueAccessor.writeValue(control.value);
  if (control.disabled || callSetDisabledState === "always") {
    dir.valueAccessor.setDisabledState?.(control.disabled);
  }
  setUpViewChangePipeline(control, dir);
  setUpModelChangePipeline(control, dir);
  setUpBlurPipeline(control, dir);
  setUpDisabledChangeHandler(control, dir);
}
function cleanUpControl(control, dir, validateControlPresenceOnChange = true) {
  const noop = () => {
    if (validateControlPresenceOnChange && (typeof ngDevMode === "undefined" || ngDevMode)) {
      _noControlError(dir);
    }
  };
  if (dir.valueAccessor) {
    dir.valueAccessor.registerOnChange(noop);
    dir.valueAccessor.registerOnTouched(noop);
  }
  cleanUpValidators(control, dir);
  if (control) {
    dir._invokeOnDestroyCallbacks();
    control._registerOnCollectionChange(() => {
    });
  }
}
function registerOnValidatorChange(validators, onChange) {
  validators.forEach((validator) => {
    if (validator.registerOnValidatorChange) validator.registerOnValidatorChange(onChange);
  });
}
function setUpDisabledChangeHandler(control, dir) {
  if (dir.valueAccessor.setDisabledState) {
    const onDisabledChange = (isDisabled) => {
      dir.valueAccessor.setDisabledState(isDisabled);
    };
    control.registerOnDisabledChange(onDisabledChange);
    dir._registerOnDestroy(() => {
      control._unregisterOnDisabledChange(onDisabledChange);
    });
  }
}
function setUpValidators(control, dir) {
  const validators = getControlValidators(control);
  if (dir.validator !== null) {
    control.setValidators(mergeValidators(validators, dir.validator));
  } else if (typeof validators === "function") {
    control.setValidators([validators]);
  }
  const asyncValidators = getControlAsyncValidators(control);
  if (dir.asyncValidator !== null) {
    control.setAsyncValidators(mergeValidators(asyncValidators, dir.asyncValidator));
  } else if (typeof asyncValidators === "function") {
    control.setAsyncValidators([asyncValidators]);
  }
  const onValidatorChange = () => control.updateValueAndValidity();
  registerOnValidatorChange(dir._rawValidators, onValidatorChange);
  registerOnValidatorChange(dir._rawAsyncValidators, onValidatorChange);
}
function cleanUpValidators(control, dir) {
  let isControlUpdated = false;
  if (control !== null) {
    if (dir.validator !== null) {
      const validators = getControlValidators(control);
      if (Array.isArray(validators) && validators.length > 0) {
        const updatedValidators = validators.filter((validator) => validator !== dir.validator);
        if (updatedValidators.length !== validators.length) {
          isControlUpdated = true;
          control.setValidators(updatedValidators);
        }
      }
    }
    if (dir.asyncValidator !== null) {
      const asyncValidators = getControlAsyncValidators(control);
      if (Array.isArray(asyncValidators) && asyncValidators.length > 0) {
        const updatedAsyncValidators = asyncValidators.filter((asyncValidator) => asyncValidator !== dir.asyncValidator);
        if (updatedAsyncValidators.length !== asyncValidators.length) {
          isControlUpdated = true;
          control.setAsyncValidators(updatedAsyncValidators);
        }
      }
    }
  }
  const noop = () => {
  };
  registerOnValidatorChange(dir._rawValidators, noop);
  registerOnValidatorChange(dir._rawAsyncValidators, noop);
  return isControlUpdated;
}
function setUpViewChangePipeline(control, dir) {
  dir.valueAccessor.registerOnChange((newValue) => {
    control._pendingValue = newValue;
    control._pendingChange = true;
    control._pendingDirty = true;
    if (control.updateOn === "change") updateControl(control, dir);
  });
}
function setUpBlurPipeline(control, dir) {
  dir.valueAccessor.registerOnTouched(() => {
    control._pendingTouched = true;
    if (control.updateOn === "blur" && control._pendingChange) updateControl(control, dir);
    if (control.updateOn !== "submit") control.markAsTouched();
  });
}
function updateControl(control, dir) {
  if (control._pendingDirty) control.markAsDirty();
  control.setValue(control._pendingValue, {
    emitModelToViewChange: false
  });
  dir.viewToModelUpdate(control._pendingValue);
  control._pendingChange = false;
}
function setUpModelChangePipeline(control, dir) {
  const onChange = (newValue, emitModelEvent) => {
    dir.valueAccessor.writeValue(newValue);
    if (emitModelEvent) dir.viewToModelUpdate(newValue);
  };
  control.registerOnChange(onChange);
  dir._registerOnDestroy(() => {
    control._unregisterOnChange(onChange);
  });
}
function setUpFormContainer(control, dir) {
  if (control == null && (typeof ngDevMode === "undefined" || ngDevMode)) _throwError(dir, "Cannot find control with");
  setUpValidators(control, dir);
}
function cleanUpFormContainer(control, dir) {
  return cleanUpValidators(control, dir);
}
function _noControlError(dir) {
  return _throwError(dir, "There is no FormControl instance attached to form control element with");
}
function _throwError(dir, message) {
  const messageEnd = _describeControlLocation(dir);
  throw new Error(`${message} ${messageEnd}`);
}
function _describeControlLocation(dir) {
  const path = dir.path;
  if (path && path.length > 1) return `path: '${path.join(" -> ")}'`;
  if (path?.[0]) return `name: '${path}'`;
  return "unspecified name attribute";
}
function _throwMissingValueAccessorError(dir) {
  const loc = _describeControlLocation(dir);
  throw new RuntimeError(-1203, `No value accessor for form control ${loc}.`);
}
function _throwInvalidValueAccessorError(dir) {
  const loc = _describeControlLocation(dir);
  throw new RuntimeError(1200, `Value accessor was not provided as an array for form control with ${loc}. Check that the \`NG_VALUE_ACCESSOR\` token is configured as a \`multi: true\` provider.`);
}
function isPropertyUpdated(changes, viewModel) {
  if (!changes.hasOwnProperty("model")) return false;
  const change = changes["model"];
  if (change.isFirstChange()) return true;
  return !Object.is(viewModel, change.currentValue);
}
function isBuiltInAccessor(valueAccessor) {
  return Object.getPrototypeOf(valueAccessor.constructor) === BuiltInControlValueAccessor;
}
function syncPendingControls(form, directives) {
  form._syncPendingControls();
  directives.forEach((dir) => {
    const control = dir.control;
    if (control.updateOn === "submit" && control._pendingChange) {
      dir.viewToModelUpdate(control._pendingValue);
      control._pendingChange = false;
    }
  });
}
function selectValueAccessor(dir, valueAccessors) {
  if (!valueAccessors) return null;
  if (!Array.isArray(valueAccessors) && (typeof ngDevMode === "undefined" || ngDevMode)) _throwInvalidValueAccessorError(dir);
  let defaultAccessor = void 0;
  let builtinAccessor = void 0;
  let customAccessor = void 0;
  valueAccessors.forEach((v) => {
    if (v.constructor === DefaultValueAccessor) {
      defaultAccessor = v;
    } else if (isBuiltInAccessor(v)) {
      if (builtinAccessor && (typeof ngDevMode === "undefined" || ngDevMode)) _throwError(dir, "More than one built-in value accessor matches form control with");
      builtinAccessor = v;
    } else {
      if (customAccessor && (typeof ngDevMode === "undefined" || ngDevMode)) _throwError(dir, "More than one custom value accessor matches form control with");
      customAccessor = v;
    }
  });
  if (customAccessor) return customAccessor;
  if (builtinAccessor) return builtinAccessor;
  if (defaultAccessor) return defaultAccessor;
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    _throwError(dir, "No valid value accessor for form control with");
  }
  return null;
}
function removeListItem$1(list, el) {
  const index = list.indexOf(el);
  if (index > -1) list.splice(index, 1);
}
function _ngModelWarning(name, type, instance, warningConfig) {
  if (warningConfig === "never") return;
  if ((warningConfig === null || warningConfig === "once") && !type._ngModelWarningSentOnce || warningConfig === "always" && !instance._ngModelWarningSent) {
    console.warn(ngModelWarning(name));
    type._ngModelWarningSentOnce = true;
    instance._ngModelWarningSent = true;
  }
}
var formDirectiveProvider$1 = {
  provide: ControlContainer,
  useExisting: forwardRef(() => NgForm)
};
var resolvedPromise$1 = (() => Promise.resolve())();
var NgForm = class _NgForm extends ControlContainer {
  callSetDisabledState;
  /**
   * @description
   * Returns whether the form submission has been triggered.
   */
  get submitted() {
    return untracked(this.submittedReactive);
  }
  /** @internal */
  _submitted = computed(() => this.submittedReactive());
  submittedReactive = signal(false);
  _directives = /* @__PURE__ */ new Set();
  /**
   * @description
   * The `FormGroup` instance created for this form.
   */
  form;
  /**
   * @description
   * Event emitter for the "ngSubmit" event
   */
  ngSubmit = new EventEmitter();
  /**
   * @description
   * Tracks options for the `NgForm` instance.
   *
   * **updateOn**: Sets the default `updateOn` value for all child `NgModels` below it
   * unless explicitly set by a child `NgModel` using `ngModelOptions`). Defaults to 'change'.
   * Possible values: `'change'` | `'blur'` | `'submit'`.
   *
   */
  // TODO(issue/24571): remove '!'.
  options;
  constructor(validators, asyncValidators, callSetDisabledState) {
    super();
    this.callSetDisabledState = callSetDisabledState;
    this.form = new FormGroup({}, composeValidators(validators), composeAsyncValidators(asyncValidators));
  }
  /** @nodoc */
  ngAfterViewInit() {
    this._setUpdateStrategy();
  }
  /**
   * @description
   * The directive instance.
   */
  get formDirective() {
    return this;
  }
  /**
   * @description
   * The internal `FormGroup` instance.
   */
  get control() {
    return this.form;
  }
  /**
   * @description
   * Returns an array representing the path to this group. Because this directive
   * always lives at the top level of a form, it is always an empty array.
   */
  get path() {
    return [];
  }
  /**
   * @description
   * Returns a map of the controls in this group.
   */
  get controls() {
    return this.form.controls;
  }
  /**
   * @description
   * Method that sets up the control directive in this group, re-calculates its value
   * and validity, and adds the instance to the internal list of directives.
   *
   * @param dir The `NgModel` directive instance.
   */
  addControl(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      dir.control = container.registerControl(dir.name, dir.control);
      setUpControl(dir.control, dir, this.callSetDisabledState);
      dir.control.updateValueAndValidity({
        emitEvent: false
      });
      this._directives.add(dir);
    });
  }
  /**
   * @description
   * Retrieves the `FormControl` instance from the provided `NgModel` directive.
   *
   * @param dir The `NgModel` directive instance.
   */
  getControl(dir) {
    return this.form.get(dir.path);
  }
  /**
   * @description
   * Removes the `NgModel` instance from the internal list of directives
   *
   * @param dir The `NgModel` directive instance.
   */
  removeControl(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      if (container) {
        container.removeControl(dir.name);
      }
      this._directives.delete(dir);
    });
  }
  /**
   * @description
   * Adds a new `NgModelGroup` directive instance to the form.
   *
   * @param dir The `NgModelGroup` directive instance.
   */
  addFormGroup(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      const group = new FormGroup({});
      setUpFormContainer(group, dir);
      container.registerControl(dir.name, group);
      group.updateValueAndValidity({
        emitEvent: false
      });
    });
  }
  /**
   * @description
   * Removes the `NgModelGroup` directive instance from the form.
   *
   * @param dir The `NgModelGroup` directive instance.
   */
  removeFormGroup(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      if (container) {
        container.removeControl(dir.name);
      }
    });
  }
  /**
   * @description
   * Retrieves the `FormGroup` for a provided `NgModelGroup` directive instance
   *
   * @param dir The `NgModelGroup` directive instance.
   */
  getFormGroup(dir) {
    return this.form.get(dir.path);
  }
  /**
   * Sets the new value for the provided `NgControl` directive.
   *
   * @param dir The `NgControl` directive instance.
   * @param value The new value for the directive's control.
   */
  updateModel(dir, value) {
    resolvedPromise$1.then(() => {
      const ctrl = this.form.get(dir.path);
      ctrl.setValue(value);
    });
  }
  /**
   * @description
   * Sets the value for this `FormGroup`.
   *
   * @param value The new value
   */
  setValue(value) {
    this.control.setValue(value);
  }
  /**
   * @description
   * Method called when the "submit" event is triggered on the form.
   * Triggers the `ngSubmit` emitter to emit the "submit" event as its payload.
   *
   * @param $event The "submit" event object
   */
  onSubmit($event) {
    this.submittedReactive.set(true);
    syncPendingControls(this.form, this._directives);
    this.ngSubmit.emit($event);
    return $event?.target?.method === "dialog";
  }
  /**
   * @description
   * Method called when the "reset" event is triggered on the form.
   */
  onReset() {
    this.resetForm();
  }
  /**
   * @description
   * Resets the form to an initial value and resets its submitted status.
   *
   * @param value The new value for the form.
   */
  resetForm(value = void 0) {
    this.form.reset(value);
    this.submittedReactive.set(false);
  }
  _setUpdateStrategy() {
    if (this.options && this.options.updateOn != null) {
      this.form._updateOn = this.options.updateOn;
    }
  }
  _findContainer(path) {
    path.pop();
    return path.length ? this.form.get(path) : this.form;
  }
  static ɵfac = function NgForm_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgForm)(ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10), ɵɵdirectiveInject(CALL_SET_DISABLED_STATE, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NgForm,
    selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", ""], ["ng-form"], ["", "ngForm", ""]],
    hostBindings: function NgForm_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("submit", function NgForm_submit_HostBindingHandler($event) {
          return ctx.onSubmit($event);
        })("reset", function NgForm_reset_HostBindingHandler() {
          return ctx.onReset();
        });
      }
    },
    inputs: {
      options: [0, "ngFormOptions", "options"]
    },
    outputs: {
      ngSubmit: "ngSubmit"
    },
    exportAs: ["ngForm"],
    standalone: false,
    features: [ɵɵProvidersFeature([formDirectiveProvider$1]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgForm, [{
    type: Directive,
    args: [{
      selector: "form:not([ngNoForm]):not([formGroup]),ng-form,[ngForm]",
      providers: [formDirectiveProvider$1],
      host: {
        "(submit)": "onSubmit($event)",
        "(reset)": "onReset()"
      },
      outputs: ["ngSubmit"],
      exportAs: "ngForm",
      standalone: false
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    options: [{
      type: Input,
      args: ["ngFormOptions"]
    }]
  });
})();
function removeListItem(list, el) {
  const index = list.indexOf(el);
  if (index > -1) list.splice(index, 1);
}
function isFormControlState(formState) {
  return typeof formState === "object" && formState !== null && Object.keys(formState).length === 2 && "value" in formState && "disabled" in formState;
}
var FormControl = class FormControl2 extends AbstractControl {
  /** @publicApi */
  defaultValue = null;
  /** @internal */
  _onChange = [];
  /** @internal */
  _pendingValue;
  /** @internal */
  _pendingChange = false;
  constructor(formState = null, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    this._applyFormState(formState);
    this._setUpdateStrategy(validatorOrOpts);
    this._initObservables();
    this.updateValueAndValidity({
      onlySelf: true,
      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
      // `VALID` or `INVALID`.
      // The status should be broadcasted via the `statusChanges` observable, so we set
      // `emitEvent` to `true` to allow that during the control creation process.
      emitEvent: !!this.asyncValidator
    });
    if (isOptionsObj(validatorOrOpts) && (validatorOrOpts.nonNullable || validatorOrOpts.initialValueIsDefault)) {
      if (isFormControlState(formState)) {
        this.defaultValue = formState.value;
      } else {
        this.defaultValue = formState;
      }
    }
  }
  setValue(value, options = {}) {
    this.value = this._pendingValue = value;
    if (this._onChange.length && options.emitModelToViewChange !== false) {
      this._onChange.forEach((changeFn) => changeFn(this.value, options.emitViewToModelChange !== false));
    }
    this.updateValueAndValidity(options);
  }
  patchValue(value, options = {}) {
    this.setValue(value, options);
  }
  reset(formState = this.defaultValue, options = {}) {
    this._applyFormState(formState);
    this.markAsPristine(options);
    this.markAsUntouched(options);
    this.setValue(this.value, options);
    this._pendingChange = false;
  }
  /**  @internal */
  _updateValue() {
  }
  /**  @internal */
  _anyControls(condition) {
    return false;
  }
  /**  @internal */
  _allControlsDisabled() {
    return this.disabled;
  }
  registerOnChange(fn) {
    this._onChange.push(fn);
  }
  /** @internal */
  _unregisterOnChange(fn) {
    removeListItem(this._onChange, fn);
  }
  registerOnDisabledChange(fn) {
    this._onDisabledChange.push(fn);
  }
  /** @internal */
  _unregisterOnDisabledChange(fn) {
    removeListItem(this._onDisabledChange, fn);
  }
  /** @internal */
  _forEachChild(cb) {
  }
  /** @internal */
  _syncPendingControls() {
    if (this.updateOn === "submit") {
      if (this._pendingDirty) this.markAsDirty();
      if (this._pendingTouched) this.markAsTouched();
      if (this._pendingChange) {
        this.setValue(this._pendingValue, {
          onlySelf: true,
          emitModelToViewChange: false
        });
        return true;
      }
    }
    return false;
  }
  _applyFormState(formState) {
    if (isFormControlState(formState)) {
      this.value = this._pendingValue = formState.value;
      formState.disabled ? this.disable({
        onlySelf: true,
        emitEvent: false
      }) : this.enable({
        onlySelf: true,
        emitEvent: false
      });
    } else {
      this.value = this._pendingValue = formState;
    }
  }
};
var isFormControl = (control) => control instanceof FormControl;
var AbstractFormGroupDirective = class _AbstractFormGroupDirective extends ControlContainer {
  /**
   * @description
   * The parent control for the group
   *
   * @internal
   */
  // TODO(issue/24571): remove '!'.
  _parent;
  /** @nodoc */
  ngOnInit() {
    this._checkParentType();
    this.formDirective.addFormGroup(this);
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this.formDirective) {
      this.formDirective.removeFormGroup(this);
    }
  }
  /**
   * @description
   * The `FormGroup` bound to this directive.
   */
  get control() {
    return this.formDirective.getFormGroup(this);
  }
  /**
   * @description
   * The path to this group from the top-level directive.
   */
  get path() {
    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
  }
  /**
   * @description
   * The top-level directive for this group if present, otherwise null.
   */
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  /** @internal */
  _checkParentType() {
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵAbstractFormGroupDirective_BaseFactory;
    return function AbstractFormGroupDirective_Factory(__ngFactoryType__) {
      return (ɵAbstractFormGroupDirective_BaseFactory || (ɵAbstractFormGroupDirective_BaseFactory = ɵɵgetInheritedFactory(_AbstractFormGroupDirective)))(__ngFactoryType__ || _AbstractFormGroupDirective);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _AbstractFormGroupDirective,
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AbstractFormGroupDirective, [{
    type: Directive,
    args: [{
      standalone: false
    }]
  }], null, null);
})();
function modelParentException() {
  return new RuntimeError(1350, `
    ngModel cannot be used to register form controls with a parent formGroup directive.  Try using
    formGroup's partner directive "formControlName" instead.  Example:

    ${formControlNameExample}

    Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions:

    Example:

    ${ngModelWithFormGroupExample}`);
}
function formGroupNameException() {
  return new RuntimeError(1351, `
    ngModel cannot be used to register form controls with a parent formGroupName or formArrayName directive.

    Option 1: Use formControlName instead of ngModel (reactive strategy):

    ${formGroupNameExample}

    Option 2:  Update ngModel's parent be ngModelGroup (template-driven strategy):

    ${ngModelGroupExample}`);
}
function missingNameException() {
  return new RuntimeError(1352, `If ngModel is used within a form tag, either the name attribute must be set or the form
    control must be defined as 'standalone' in ngModelOptions.

    Example 1: <input [(ngModel)]="person.firstName" name="first">
    Example 2: <input [(ngModel)]="person.firstName" [ngModelOptions]="{standalone: true}">`);
}
function modelGroupParentException() {
  return new RuntimeError(1353, `
    ngModelGroup cannot be used with a parent formGroup directive.

    Option 1: Use formGroupName instead of ngModelGroup (reactive strategy):

    ${formGroupNameExample}

    Option 2:  Use a regular form tag instead of the formGroup directive (template-driven strategy):

    ${ngModelGroupExample}`);
}
var modelGroupProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => NgModelGroup)
};
var NgModelGroup = class _NgModelGroup extends AbstractFormGroupDirective {
  /**
   * @description
   * Tracks the name of the `NgModelGroup` bound to the directive. The name corresponds
   * to a key in the parent `NgForm`.
   */
  name = "";
  constructor(parent, validators, asyncValidators) {
    super();
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  /** @internal */
  _checkParentType() {
    if (!(this._parent instanceof _NgModelGroup) && !(this._parent instanceof NgForm) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw modelGroupParentException();
    }
  }
  static ɵfac = function NgModelGroup_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgModelGroup)(ɵɵdirectiveInject(ControlContainer, 5), ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NgModelGroup,
    selectors: [["", "ngModelGroup", ""]],
    inputs: {
      name: [0, "ngModelGroup", "name"]
    },
    exportAs: ["ngModelGroup"],
    standalone: false,
    features: [ɵɵProvidersFeature([modelGroupProvider]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgModelGroup, [{
    type: Directive,
    args: [{
      selector: "[ngModelGroup]",
      providers: [modelGroupProvider],
      exportAs: "ngModelGroup",
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }], {
    name: [{
      type: Input,
      args: ["ngModelGroup"]
    }]
  });
})();
var formControlBinding$1 = {
  provide: NgControl,
  useExisting: forwardRef(() => NgModel)
};
var resolvedPromise = (() => Promise.resolve())();
var NgModel = class _NgModel extends NgControl {
  _changeDetectorRef;
  callSetDisabledState;
  control = new FormControl();
  // At runtime we coerce arbitrary values assigned to the "disabled" input to a "boolean".
  // This is not reflected in the type of the property because outside of templates, consumers
  // should only deal with booleans. In templates, a string is allowed for convenience and to
  // match the native "disabled attribute" semantics which can be observed on input elements.
  // This static member tells the compiler that values of type "string" can also be assigned
  // to the input in a template.
  /** @nodoc */
  static ngAcceptInputType_isDisabled;
  /** @internal */
  _registered = false;
  /**
   * Internal reference to the view model value.
   * @nodoc
   */
  viewModel;
  /**
   * @description
   * Tracks the name bound to the directive. If a parent form exists, it
   * uses this name as a key to retrieve this control's value.
   */
  name = "";
  /**
   * @description
   * Tracks whether the control is disabled.
   */
  // TODO(issue/24571): remove '!'.
  isDisabled;
  /**
   * @description
   * Tracks the value bound to this directive.
   */
  model;
  /**
   * @description
   * Tracks the configuration options for this `ngModel` instance.
   *
   * **name**: An alternative to setting the name attribute on the form control element. See
   * the [example](api/forms/NgModel#using-ngmodel-on-a-standalone-control) for using `NgModel`
   * as a standalone control.
   *
   * **standalone**: When set to true, the `ngModel` will not register itself with its parent form,
   * and acts as if it's not in the form. Defaults to false. If no parent form exists, this option
   * has no effect.
   *
   * **updateOn**: Defines the event upon which the form control value and validity update.
   * Defaults to 'change'. Possible values: `'change'` | `'blur'` | `'submit'`.
   *
   */
  // TODO(issue/24571): remove '!'.
  options;
  /**
   * @description
   * Event emitter for producing the `ngModelChange` event after
   * the view model updates.
   */
  update = new EventEmitter();
  constructor(parent, validators, asyncValidators, valueAccessors, _changeDetectorRef, callSetDisabledState) {
    super();
    this._changeDetectorRef = _changeDetectorRef;
    this.callSetDisabledState = callSetDisabledState;
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
    this.valueAccessor = selectValueAccessor(this, valueAccessors);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    this._checkForErrors();
    if (!this._registered || "name" in changes) {
      if (this._registered) {
        this._checkName();
        if (this.formDirective) {
          const oldName = changes["name"].previousValue;
          this.formDirective.removeControl({
            name: oldName,
            path: this._getPath(oldName)
          });
        }
      }
      this._setUpControl();
    }
    if ("isDisabled" in changes) {
      this._updateDisabled(changes);
    }
    if (isPropertyUpdated(changes, this.viewModel)) {
      this._updateValue(this.model);
      this.viewModel = this.model;
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    this.formDirective && this.formDirective.removeControl(this);
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return this._getPath(this.name);
  }
  /**
   * @description
   * The top-level directive for this control if present, otherwise null.
   */
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  /**
   * @description
   * Sets the new value for the view model and emits an `ngModelChange` event.
   *
   * @param newValue The new value emitted by `ngModelChange`.
   */
  viewToModelUpdate(newValue) {
    this.viewModel = newValue;
    this.update.emit(newValue);
  }
  _setUpControl() {
    this._setUpdateStrategy();
    this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this);
    this._registered = true;
  }
  _setUpdateStrategy() {
    if (this.options && this.options.updateOn != null) {
      this.control._updateOn = this.options.updateOn;
    }
  }
  _isStandalone() {
    return !this._parent || !!(this.options && this.options.standalone);
  }
  _setUpStandalone() {
    setUpControl(this.control, this, this.callSetDisabledState);
    this.control.updateValueAndValidity({
      emitEvent: false
    });
  }
  _checkForErrors() {
    if ((typeof ngDevMode === "undefined" || ngDevMode) && !this._isStandalone()) {
      this._checkParentType();
    }
    this._checkName();
  }
  _checkParentType() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (!(this._parent instanceof NgModelGroup) && this._parent instanceof AbstractFormGroupDirective) {
        throw formGroupNameException();
      } else if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm)) {
        throw modelParentException();
      }
    }
  }
  _checkName() {
    if (this.options && this.options.name) this.name = this.options.name;
    if (!this._isStandalone() && !this.name && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw missingNameException();
    }
  }
  _updateValue(value) {
    resolvedPromise.then(() => {
      this.control.setValue(value, {
        emitViewToModelChange: false
      });
      this._changeDetectorRef?.markForCheck();
    });
  }
  _updateDisabled(changes) {
    const disabledValue = changes["isDisabled"].currentValue;
    const isDisabled = disabledValue !== 0 && booleanAttribute(disabledValue);
    resolvedPromise.then(() => {
      if (isDisabled && !this.control.disabled) {
        this.control.disable();
      } else if (!isDisabled && this.control.disabled) {
        this.control.enable();
      }
      this._changeDetectorRef?.markForCheck();
    });
  }
  _getPath(controlName) {
    return this._parent ? controlPath(controlName, this._parent) : [controlName];
  }
  static ɵfac = function NgModel_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgModel)(ɵɵdirectiveInject(ControlContainer, 9), ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10), ɵɵdirectiveInject(NG_VALUE_ACCESSOR, 10), ɵɵdirectiveInject(ChangeDetectorRef, 8), ɵɵdirectiveInject(CALL_SET_DISABLED_STATE, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NgModel,
    selectors: [["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]],
    inputs: {
      name: "name",
      isDisabled: [0, "disabled", "isDisabled"],
      model: [0, "ngModel", "model"],
      options: [0, "ngModelOptions", "options"]
    },
    outputs: {
      update: "ngModelChange"
    },
    exportAs: ["ngModel"],
    standalone: false,
    features: [ɵɵProvidersFeature([formControlBinding$1]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgModel, [{
    type: Directive,
    args: [{
      selector: "[ngModel]:not([formControlName]):not([formControl])",
      providers: [formControlBinding$1],
      exportAs: "ngModel",
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }, {
    type: ChangeDetectorRef,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [ChangeDetectorRef]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    name: [{
      type: Input
    }],
    isDisabled: [{
      type: Input,
      args: ["disabled"]
    }],
    model: [{
      type: Input,
      args: ["ngModel"]
    }],
    options: [{
      type: Input,
      args: ["ngModelOptions"]
    }],
    update: [{
      type: Output,
      args: ["ngModelChange"]
    }]
  });
})();
var ɵNgNoValidate = class _ɵNgNoValidate {
  static ɵfac = function ɵNgNoValidate_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ɵNgNoValidate)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ɵNgNoValidate,
    selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]],
    hostAttrs: ["novalidate", ""],
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ɵNgNoValidate, [{
    type: Directive,
    args: [{
      selector: "form:not([ngNoForm]):not([ngNativeValidate])",
      host: {
        "novalidate": ""
      },
      standalone: false
    }]
  }], null, null);
})();
var NUMBER_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => NumberValueAccessor),
  multi: true
};
var NumberValueAccessor = class _NumberValueAccessor extends BuiltInControlValueAccessor {
  /**
   * Sets the "value" property on the input element.
   * @nodoc
   */
  writeValue(value) {
    const normalizedValue = value == null ? "" : value;
    this.setProperty("value", normalizedValue);
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = (value) => {
      fn(value == "" ? null : parseFloat(value));
    };
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵNumberValueAccessor_BaseFactory;
    return function NumberValueAccessor_Factory(__ngFactoryType__) {
      return (ɵNumberValueAccessor_BaseFactory || (ɵNumberValueAccessor_BaseFactory = ɵɵgetInheritedFactory(_NumberValueAccessor)))(__ngFactoryType__ || _NumberValueAccessor);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _NumberValueAccessor,
    selectors: [["input", "type", "number", "formControlName", ""], ["input", "type", "number", "formControl", ""], ["input", "type", "number", "ngModel", ""]],
    hostBindings: function NumberValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("input", function NumberValueAccessor_input_HostBindingHandler($event) {
          return ctx.onChange($event.target.value);
        })("blur", function NumberValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([NUMBER_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumberValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]",
      host: {
        "(input)": "onChange($event.target.value)",
        "(blur)": "onTouched()"
      },
      providers: [NUMBER_VALUE_ACCESSOR],
      standalone: false
    }]
  }], null, null);
})();
var RADIO_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => RadioControlValueAccessor),
  multi: true
};
function throwNameError() {
  throw new RuntimeError(1202, `
      If you define both a name and a formControlName attribute on your radio button, their values
      must match. Ex: <input type="radio" formControlName="food" name="food">
    `);
}
var RadioControlRegistry = class _RadioControlRegistry {
  _accessors = [];
  /**
   * @description
   * Adds a control to the internal registry. For internal use only.
   */
  add(control, accessor) {
    this._accessors.push([control, accessor]);
  }
  /**
   * @description
   * Removes a control from the internal registry. For internal use only.
   */
  remove(accessor) {
    for (let i = this._accessors.length - 1; i >= 0; --i) {
      if (this._accessors[i][1] === accessor) {
        this._accessors.splice(i, 1);
        return;
      }
    }
  }
  /**
   * @description
   * Selects a radio button. For internal use only.
   */
  select(accessor) {
    this._accessors.forEach((c) => {
      if (this._isSameGroup(c, accessor) && c[1] !== accessor) {
        c[1].fireUncheck(accessor.value);
      }
    });
  }
  _isSameGroup(controlPair, accessor) {
    if (!controlPair[0].control) return false;
    return controlPair[0]._parent === accessor._control._parent && controlPair[1].name === accessor.name;
  }
  static ɵfac = function RadioControlRegistry_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RadioControlRegistry)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _RadioControlRegistry,
    factory: _RadioControlRegistry.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioControlRegistry, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var RadioControlValueAccessor = class _RadioControlValueAccessor extends BuiltInControlValueAccessor {
  _registry;
  _injector;
  /** @internal */
  // TODO(issue/24571): remove '!'.
  _state;
  /** @internal */
  // TODO(issue/24571): remove '!'.
  _control;
  /** @internal */
  // TODO(issue/24571): remove '!'.
  _fn;
  setDisabledStateFired = false;
  /**
   * The registered callback function called when a change event occurs on the input element.
   * Note: we declare `onChange` here (also used as host listener) as a function with no arguments
   * to override the `onChange` function (which expects 1 argument) in the parent
   * `BaseControlValueAccessor` class.
   * @nodoc
   */
  onChange = () => {
  };
  /**
   * @description
   * Tracks the name of the radio input element.
   */
  // TODO(issue/24571): remove '!'.
  name;
  /**
   * @description
   * Tracks the name of the `FormControl` bound to the directive. The name corresponds
   * to a key in the parent `FormGroup` or `FormArray`.
   */
  // TODO(issue/24571): remove '!'.
  formControlName;
  /**
   * @description
   * Tracks the value of the radio input element
   */
  value;
  callSetDisabledState = inject(CALL_SET_DISABLED_STATE, {
    optional: true
  }) ?? setDisabledStateDefault;
  constructor(renderer, elementRef, _registry, _injector) {
    super(renderer, elementRef);
    this._registry = _registry;
    this._injector = _injector;
  }
  /** @nodoc */
  ngOnInit() {
    this._control = this._injector.get(NgControl);
    this._checkName();
    this._registry.add(this._control, this);
  }
  /** @nodoc */
  ngOnDestroy() {
    this._registry.remove(this);
  }
  /**
   * Sets the "checked" property value on the radio input element.
   * @nodoc
   */
  writeValue(value) {
    this._state = value === this.value;
    this.setProperty("checked", this._state);
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this._fn = fn;
    this.onChange = () => {
      fn(this.value);
      this._registry.select(this);
    };
  }
  /** @nodoc */
  setDisabledState(isDisabled) {
    if (this.setDisabledStateFired || isDisabled || this.callSetDisabledState === "whenDisabledForLegacyCode") {
      this.setProperty("disabled", isDisabled);
    }
    this.setDisabledStateFired = true;
  }
  /**
   * Sets the "value" on the radio input element and unchecks it.
   *
   * @param value
   */
  fireUncheck(value) {
    this.writeValue(value);
  }
  _checkName() {
    if (this.name && this.formControlName && this.name !== this.formControlName && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throwNameError();
    }
    if (!this.name && this.formControlName) this.name = this.formControlName;
  }
  static ɵfac = function RadioControlValueAccessor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RadioControlValueAccessor)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(RadioControlRegistry), ɵɵdirectiveInject(Injector));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _RadioControlValueAccessor,
    selectors: [["input", "type", "radio", "formControlName", ""], ["input", "type", "radio", "formControl", ""], ["input", "type", "radio", "ngModel", ""]],
    hostBindings: function RadioControlValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("change", function RadioControlValueAccessor_change_HostBindingHandler() {
          return ctx.onChange();
        })("blur", function RadioControlValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    inputs: {
      name: "name",
      formControlName: "formControlName",
      value: "value"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([RADIO_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]",
      host: {
        "(change)": "onChange()",
        "(blur)": "onTouched()"
      },
      providers: [RADIO_VALUE_ACCESSOR],
      standalone: false
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: RadioControlRegistry
  }, {
    type: Injector
  }], {
    name: [{
      type: Input
    }],
    formControlName: [{
      type: Input
    }],
    value: [{
      type: Input
    }]
  });
})();
var RANGE_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => RangeValueAccessor),
  multi: true
};
var RangeValueAccessor = class _RangeValueAccessor extends BuiltInControlValueAccessor {
  /**
   * Sets the "value" property on the input element.
   * @nodoc
   */
  writeValue(value) {
    this.setProperty("value", parseFloat(value));
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = (value) => {
      fn(value == "" ? null : parseFloat(value));
    };
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵRangeValueAccessor_BaseFactory;
    return function RangeValueAccessor_Factory(__ngFactoryType__) {
      return (ɵRangeValueAccessor_BaseFactory || (ɵRangeValueAccessor_BaseFactory = ɵɵgetInheritedFactory(_RangeValueAccessor)))(__ngFactoryType__ || _RangeValueAccessor);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _RangeValueAccessor,
    selectors: [["input", "type", "range", "formControlName", ""], ["input", "type", "range", "formControl", ""], ["input", "type", "range", "ngModel", ""]],
    hostBindings: function RangeValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("change", function RangeValueAccessor_change_HostBindingHandler($event) {
          return ctx.onChange($event.target.value);
        })("input", function RangeValueAccessor_input_HostBindingHandler($event) {
          return ctx.onChange($event.target.value);
        })("blur", function RangeValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([RANGE_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RangeValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]",
      host: {
        "(change)": "onChange($event.target.value)",
        "(input)": "onChange($event.target.value)",
        "(blur)": "onTouched()"
      },
      providers: [RANGE_VALUE_ACCESSOR],
      standalone: false
    }]
  }], null, null);
})();
var NG_MODEL_WITH_FORM_CONTROL_WARNING = new InjectionToken(ngDevMode ? "NgModelWithFormControlWarning" : "");
var formControlBinding = {
  provide: NgControl,
  useExisting: forwardRef(() => FormControlDirective)
};
var FormControlDirective = class _FormControlDirective extends NgControl {
  _ngModelWarningConfig;
  callSetDisabledState;
  /**
   * Internal reference to the view model value.
   * @nodoc
   */
  viewModel;
  /**
   * @description
   * Tracks the `FormControl` instance bound to the directive.
   */
  // TODO(issue/24571): remove '!'.
  form;
  /**
   * @description
   * Triggers a warning in dev mode that this input should not be used with reactive forms.
   */
  set isDisabled(isDisabled) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      console.warn(disabledAttrWarning);
    }
  }
  // TODO(kara): remove next 4 properties once deprecation period is over
  /** @deprecated as of v6 */
  model;
  /** @deprecated as of v6 */
  update = new EventEmitter();
  /**
   * @description
   * Static property used to track whether any ngModel warnings have been sent across
   * all instances of FormControlDirective. Used to support warning config of "once".
   *
   * @internal
   */
  static _ngModelWarningSentOnce = false;
  /**
   * @description
   * Instance property used to track whether an ngModel warning has been sent out for this
   * particular `FormControlDirective` instance. Used to support warning config of "always".
   *
   * @internal
   */
  _ngModelWarningSent = false;
  constructor(validators, asyncValidators, valueAccessors, _ngModelWarningConfig, callSetDisabledState) {
    super();
    this._ngModelWarningConfig = _ngModelWarningConfig;
    this.callSetDisabledState = callSetDisabledState;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
    this.valueAccessor = selectValueAccessor(this, valueAccessors);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    if (this._isControlChanged(changes)) {
      const previousForm = changes["form"].previousValue;
      if (previousForm) {
        cleanUpControl(
          previousForm,
          this,
          /* validateControlPresenceOnChange */
          false
        );
      }
      setUpControl(this.form, this, this.callSetDisabledState);
      this.form.updateValueAndValidity({
        emitEvent: false
      });
    }
    if (isPropertyUpdated(changes, this.viewModel)) {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        _ngModelWarning("formControl", _FormControlDirective, this, this._ngModelWarningConfig);
      }
      this.form.setValue(this.model);
      this.viewModel = this.model;
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this.form) {
      cleanUpControl(
        this.form,
        this,
        /* validateControlPresenceOnChange */
        false
      );
    }
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return [];
  }
  /**
   * @description
   * The `FormControl` bound to this directive.
   */
  get control() {
    return this.form;
  }
  /**
   * @description
   * Sets the new value for the view model and emits an `ngModelChange` event.
   *
   * @param newValue The new value for the view model.
   */
  viewToModelUpdate(newValue) {
    this.viewModel = newValue;
    this.update.emit(newValue);
  }
  _isControlChanged(changes) {
    return changes.hasOwnProperty("form");
  }
  static ɵfac = function FormControlDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormControlDirective)(ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10), ɵɵdirectiveInject(NG_VALUE_ACCESSOR, 10), ɵɵdirectiveInject(NG_MODEL_WITH_FORM_CONTROL_WARNING, 8), ɵɵdirectiveInject(CALL_SET_DISABLED_STATE, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FormControlDirective,
    selectors: [["", "formControl", ""]],
    inputs: {
      form: [0, "formControl", "form"],
      isDisabled: [0, "disabled", "isDisabled"],
      model: [0, "ngModel", "model"]
    },
    outputs: {
      update: "ngModelChange"
    },
    exportAs: ["ngForm"],
    standalone: false,
    features: [ɵɵProvidersFeature([formControlBinding]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormControlDirective, [{
    type: Directive,
    args: [{
      selector: "[formControl]",
      providers: [formControlBinding],
      exportAs: "ngForm",
      standalone: false
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NG_MODEL_WITH_FORM_CONTROL_WARNING]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    form: [{
      type: Input,
      args: ["formControl"]
    }],
    isDisabled: [{
      type: Input,
      args: ["disabled"]
    }],
    model: [{
      type: Input,
      args: ["ngModel"]
    }],
    update: [{
      type: Output,
      args: ["ngModelChange"]
    }]
  });
})();
var formDirectiveProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => FormGroupDirective)
};
var FormGroupDirective = class _FormGroupDirective extends ControlContainer {
  callSetDisabledState;
  /**
   * @description
   * Reports whether the form submission has been triggered.
   */
  get submitted() {
    return untracked(this._submittedReactive);
  }
  // TODO(atscott): Remove once invalid API usage is cleaned up internally
  set submitted(value) {
    this._submittedReactive.set(value);
  }
  /** @internal */
  _submitted = computed(() => this._submittedReactive());
  _submittedReactive = signal(false);
  /**
   * Reference to an old form group input value, which is needed to cleanup
   * old instance in case it was replaced with a new one.
   */
  _oldForm;
  /**
   * Callback that should be invoked when controls in FormGroup or FormArray collection change
   * (added or removed). This callback triggers corresponding DOM updates.
   */
  _onCollectionChange = () => this._updateDomValue();
  /**
   * @description
   * Tracks the list of added `FormControlName` instances
   */
  directives = [];
  /**
   * @description
   * Tracks the `FormGroup` bound to this directive.
   */
  form = null;
  /**
   * @description
   * Emits an event when the form submission has been triggered.
   */
  ngSubmit = new EventEmitter();
  constructor(validators, asyncValidators, callSetDisabledState) {
    super();
    this.callSetDisabledState = callSetDisabledState;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    this._checkFormPresent();
    if (changes.hasOwnProperty("form")) {
      this._updateValidators();
      this._updateDomValue();
      this._updateRegistrations();
      this._oldForm = this.form;
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this.form) {
      cleanUpValidators(this.form, this);
      if (this.form._onCollectionChange === this._onCollectionChange) {
        this.form._registerOnCollectionChange(() => {
        });
      }
    }
  }
  /**
   * @description
   * Returns this directive's instance.
   */
  get formDirective() {
    return this;
  }
  /**
   * @description
   * Returns the `FormGroup` bound to this directive.
   */
  get control() {
    return this.form;
  }
  /**
   * @description
   * Returns an array representing the path to this group. Because this directive
   * always lives at the top level of a form, it always an empty array.
   */
  get path() {
    return [];
  }
  /**
   * @description
   * Method that sets up the control directive in this group, re-calculates its value
   * and validity, and adds the instance to the internal list of directives.
   *
   * @param dir The `FormControlName` directive instance.
   */
  addControl(dir) {
    const ctrl = this.form.get(dir.path);
    setUpControl(ctrl, dir, this.callSetDisabledState);
    ctrl.updateValueAndValidity({
      emitEvent: false
    });
    this.directives.push(dir);
    return ctrl;
  }
  /**
   * @description
   * Retrieves the `FormControl` instance from the provided `FormControlName` directive
   *
   * @param dir The `FormControlName` directive instance.
   */
  getControl(dir) {
    return this.form.get(dir.path);
  }
  /**
   * @description
   * Removes the `FormControlName` instance from the internal list of directives
   *
   * @param dir The `FormControlName` directive instance.
   */
  removeControl(dir) {
    cleanUpControl(
      dir.control || null,
      dir,
      /* validateControlPresenceOnChange */
      false
    );
    removeListItem$1(this.directives, dir);
  }
  /**
   * Adds a new `FormGroupName` directive instance to the form.
   *
   * @param dir The `FormGroupName` directive instance.
   */
  addFormGroup(dir) {
    this._setUpFormContainer(dir);
  }
  /**
   * Performs the necessary cleanup when a `FormGroupName` directive instance is removed from the
   * view.
   *
   * @param dir The `FormGroupName` directive instance.
   */
  removeFormGroup(dir) {
    this._cleanUpFormContainer(dir);
  }
  /**
   * @description
   * Retrieves the `FormGroup` for a provided `FormGroupName` directive instance
   *
   * @param dir The `FormGroupName` directive instance.
   */
  getFormGroup(dir) {
    return this.form.get(dir.path);
  }
  /**
   * Performs the necessary setup when a `FormArrayName` directive instance is added to the view.
   *
   * @param dir The `FormArrayName` directive instance.
   */
  addFormArray(dir) {
    this._setUpFormContainer(dir);
  }
  /**
   * Performs the necessary cleanup when a `FormArrayName` directive instance is removed from the
   * view.
   *
   * @param dir The `FormArrayName` directive instance.
   */
  removeFormArray(dir) {
    this._cleanUpFormContainer(dir);
  }
  /**
   * @description
   * Retrieves the `FormArray` for a provided `FormArrayName` directive instance.
   *
   * @param dir The `FormArrayName` directive instance.
   */
  getFormArray(dir) {
    return this.form.get(dir.path);
  }
  /**
   * Sets the new value for the provided `FormControlName` directive.
   *
   * @param dir The `FormControlName` directive instance.
   * @param value The new value for the directive's control.
   */
  updateModel(dir, value) {
    const ctrl = this.form.get(dir.path);
    ctrl.setValue(value);
  }
  /**
   * @description
   * Method called with the "submit" event is triggered on the form.
   * Triggers the `ngSubmit` emitter to emit the "submit" event as its payload.
   *
   * @param $event The "submit" event object
   */
  onSubmit($event) {
    this._submittedReactive.set(true);
    syncPendingControls(this.form, this.directives);
    this.ngSubmit.emit($event);
    this.form._events.next(new FormSubmittedEvent(this.control));
    return $event?.target?.method === "dialog";
  }
  /**
   * @description
   * Method called when the "reset" event is triggered on the form.
   */
  onReset() {
    this.resetForm();
  }
  /**
   * @description
   * Resets the form to an initial value and resets its submitted status.
   *
   * @param value The new value for the form.
   */
  resetForm(value = void 0) {
    this.form.reset(value);
    this._submittedReactive.set(false);
    this.form._events.next(new FormResetEvent(this.form));
  }
  /** @internal */
  _updateDomValue() {
    this.directives.forEach((dir) => {
      const oldCtrl = dir.control;
      const newCtrl = this.form.get(dir.path);
      if (oldCtrl !== newCtrl) {
        cleanUpControl(oldCtrl || null, dir);
        if (isFormControl(newCtrl)) {
          setUpControl(newCtrl, dir, this.callSetDisabledState);
          dir.control = newCtrl;
        }
      }
    });
    this.form._updateTreeValidity({
      emitEvent: false
    });
  }
  _setUpFormContainer(dir) {
    const ctrl = this.form.get(dir.path);
    setUpFormContainer(ctrl, dir);
    ctrl.updateValueAndValidity({
      emitEvent: false
    });
  }
  _cleanUpFormContainer(dir) {
    if (this.form) {
      const ctrl = this.form.get(dir.path);
      if (ctrl) {
        const isControlUpdated = cleanUpFormContainer(ctrl, dir);
        if (isControlUpdated) {
          ctrl.updateValueAndValidity({
            emitEvent: false
          });
        }
      }
    }
  }
  _updateRegistrations() {
    this.form._registerOnCollectionChange(this._onCollectionChange);
    if (this._oldForm) {
      this._oldForm._registerOnCollectionChange(() => {
      });
    }
  }
  _updateValidators() {
    setUpValidators(this.form, this);
    if (this._oldForm) {
      cleanUpValidators(this._oldForm, this);
    }
  }
  _checkFormPresent() {
    if (!this.form && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw missingFormException();
    }
  }
  static ɵfac = function FormGroupDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormGroupDirective)(ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10), ɵɵdirectiveInject(CALL_SET_DISABLED_STATE, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FormGroupDirective,
    selectors: [["", "formGroup", ""]],
    hostBindings: function FormGroupDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("submit", function FormGroupDirective_submit_HostBindingHandler($event) {
          return ctx.onSubmit($event);
        })("reset", function FormGroupDirective_reset_HostBindingHandler() {
          return ctx.onReset();
        });
      }
    },
    inputs: {
      form: [0, "formGroup", "form"]
    },
    outputs: {
      ngSubmit: "ngSubmit"
    },
    exportAs: ["ngForm"],
    standalone: false,
    features: [ɵɵProvidersFeature([formDirectiveProvider]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormGroupDirective, [{
    type: Directive,
    args: [{
      selector: "[formGroup]",
      providers: [formDirectiveProvider],
      host: {
        "(submit)": "onSubmit($event)",
        "(reset)": "onReset()"
      },
      exportAs: "ngForm",
      standalone: false
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    form: [{
      type: Input,
      args: ["formGroup"]
    }],
    ngSubmit: [{
      type: Output
    }]
  });
})();
var formGroupNameProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => FormGroupName)
};
var FormGroupName = class _FormGroupName extends AbstractFormGroupDirective {
  /**
   * @description
   * Tracks the name of the `FormGroup` bound to the directive. The name corresponds
   * to a key in the parent `FormGroup` or `FormArray`.
   * Accepts a name as a string or a number.
   * The name in the form of a string is useful for individual forms,
   * while the numerical form allows for form groups to be bound
   * to indices when iterating over groups in a `FormArray`.
   */
  name = null;
  constructor(parent, validators, asyncValidators) {
    super();
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  /** @internal */
  _checkParentType() {
    if (_hasInvalidParent(this._parent) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw groupParentException();
    }
  }
  static ɵfac = function FormGroupName_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormGroupName)(ɵɵdirectiveInject(ControlContainer, 13), ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FormGroupName,
    selectors: [["", "formGroupName", ""]],
    inputs: {
      name: [0, "formGroupName", "name"]
    },
    standalone: false,
    features: [ɵɵProvidersFeature([formGroupNameProvider]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormGroupName, [{
    type: Directive,
    args: [{
      selector: "[formGroupName]",
      providers: [formGroupNameProvider],
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }], {
    name: [{
      type: Input,
      args: ["formGroupName"]
    }]
  });
})();
var formArrayNameProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => FormArrayName)
};
var FormArrayName = class _FormArrayName extends ControlContainer {
  /** @internal */
  _parent;
  /**
   * @description
   * Tracks the name of the `FormArray` bound to the directive. The name corresponds
   * to a key in the parent `FormGroup` or `FormArray`.
   * Accepts a name as a string or a number.
   * The name in the form of a string is useful for individual forms,
   * while the numerical form allows for form arrays to be bound
   * to indices when iterating over arrays in a `FormArray`.
   */
  name = null;
  constructor(parent, validators, asyncValidators) {
    super();
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  /**
   * A lifecycle method called when the directive's inputs are initialized. For internal use only.
   * @throws If the directive does not have a valid parent.
   * @nodoc
   */
  ngOnInit() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      this._checkParentType();
    }
    this.formDirective.addFormArray(this);
  }
  /**
   * A lifecycle method called before the directive's instance is destroyed. For internal use only.
   * @nodoc
   */
  ngOnDestroy() {
    if (this.formDirective) {
      this.formDirective.removeFormArray(this);
    }
  }
  /**
   * @description
   * The `FormArray` bound to this directive.
   */
  get control() {
    return this.formDirective.getFormArray(this);
  }
  /**
   * @description
   * The top-level directive for this group if present, otherwise null.
   */
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
  }
  _checkParentType() {
    if (_hasInvalidParent(this._parent) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw arrayParentException();
    }
  }
  static ɵfac = function FormArrayName_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormArrayName)(ɵɵdirectiveInject(ControlContainer, 13), ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FormArrayName,
    selectors: [["", "formArrayName", ""]],
    inputs: {
      name: [0, "formArrayName", "name"]
    },
    standalone: false,
    features: [ɵɵProvidersFeature([formArrayNameProvider]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormArrayName, [{
    type: Directive,
    args: [{
      selector: "[formArrayName]",
      providers: [formArrayNameProvider],
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }], {
    name: [{
      type: Input,
      args: ["formArrayName"]
    }]
  });
})();
function _hasInvalidParent(parent) {
  return !(parent instanceof FormGroupName) && !(parent instanceof FormGroupDirective) && !(parent instanceof FormArrayName);
}
var controlNameBinding = {
  provide: NgControl,
  useExisting: forwardRef(() => FormControlName)
};
var FormControlName = class _FormControlName extends NgControl {
  _ngModelWarningConfig;
  _added = false;
  /**
   * Internal reference to the view model value.
   * @internal
   */
  viewModel;
  /**
   * @description
   * Tracks the `FormControl` instance bound to the directive.
   */
  // TODO(issue/24571): remove '!'.
  control;
  /**
   * @description
   * Tracks the name of the `FormControl` bound to the directive. The name corresponds
   * to a key in the parent `FormGroup` or `FormArray`.
   * Accepts a name as a string or a number.
   * The name in the form of a string is useful for individual forms,
   * while the numerical form allows for form controls to be bound
   * to indices when iterating over controls in a `FormArray`.
   */
  name = null;
  /**
   * @description
   * Triggers a warning in dev mode that this input should not be used with reactive forms.
   */
  set isDisabled(isDisabled) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      console.warn(disabledAttrWarning);
    }
  }
  // TODO(kara): remove next 4 properties once deprecation period is over
  /** @deprecated as of v6 */
  model;
  /** @deprecated as of v6 */
  update = new EventEmitter();
  /**
   * @description
   * Static property used to track whether any ngModel warnings have been sent across
   * all instances of FormControlName. Used to support warning config of "once".
   *
   * @internal
   */
  static _ngModelWarningSentOnce = false;
  /**
   * @description
   * Instance property used to track whether an ngModel warning has been sent out for this
   * particular FormControlName instance. Used to support warning config of "always".
   *
   * @internal
   */
  _ngModelWarningSent = false;
  constructor(parent, validators, asyncValidators, valueAccessors, _ngModelWarningConfig) {
    super();
    this._ngModelWarningConfig = _ngModelWarningConfig;
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
    this.valueAccessor = selectValueAccessor(this, valueAccessors);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    if (!this._added) this._setUpControl();
    if (isPropertyUpdated(changes, this.viewModel)) {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        _ngModelWarning("formControlName", _FormControlName, this, this._ngModelWarningConfig);
      }
      this.viewModel = this.model;
      this.formDirective.updateModel(this, this.model);
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this.formDirective) {
      this.formDirective.removeControl(this);
    }
  }
  /**
   * @description
   * Sets the new value for the view model and emits an `ngModelChange` event.
   *
   * @param newValue The new value for the view model.
   */
  viewToModelUpdate(newValue) {
    this.viewModel = newValue;
    this.update.emit(newValue);
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
  }
  /**
   * @description
   * The top-level directive for this group if present, otherwise null.
   */
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  _checkParentType() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (!(this._parent instanceof FormGroupName) && this._parent instanceof AbstractFormGroupDirective) {
        throw ngModelGroupException();
      } else if (!(this._parent instanceof FormGroupName) && !(this._parent instanceof FormGroupDirective) && !(this._parent instanceof FormArrayName)) {
        throw controlParentException(this.name);
      }
    }
  }
  _setUpControl() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      this._checkParentType();
    }
    this.control = this.formDirective.addControl(this);
    this._added = true;
  }
  static ɵfac = function FormControlName_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormControlName)(ɵɵdirectiveInject(ControlContainer, 13), ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10), ɵɵdirectiveInject(NG_VALUE_ACCESSOR, 10), ɵɵdirectiveInject(NG_MODEL_WITH_FORM_CONTROL_WARNING, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FormControlName,
    selectors: [["", "formControlName", ""]],
    inputs: {
      name: [0, "formControlName", "name"],
      isDisabled: [0, "disabled", "isDisabled"],
      model: [0, "ngModel", "model"]
    },
    outputs: {
      update: "ngModelChange"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([controlNameBinding]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormControlName, [{
    type: Directive,
    args: [{
      selector: "[formControlName]",
      providers: [controlNameBinding],
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NG_MODEL_WITH_FORM_CONTROL_WARNING]
    }]
  }], {
    name: [{
      type: Input,
      args: ["formControlName"]
    }],
    isDisabled: [{
      type: Input,
      args: ["disabled"]
    }],
    model: [{
      type: Input,
      args: ["ngModel"]
    }],
    update: [{
      type: Output,
      args: ["ngModelChange"]
    }]
  });
})();
var SELECT_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => SelectControlValueAccessor),
  multi: true
};
function _buildValueString$1(id, value) {
  if (id == null) return `${value}`;
  if (value && typeof value === "object") value = "Object";
  return `${id}: ${value}`.slice(0, 50);
}
function _extractId$1(valueString) {
  return valueString.split(":")[0];
}
var SelectControlValueAccessor = class _SelectControlValueAccessor extends BuiltInControlValueAccessor {
  /** @nodoc */
  value;
  /** @internal */
  _optionMap = /* @__PURE__ */ new Map();
  /** @internal */
  _idCounter = 0;
  /**
   * @description
   * Tracks the option comparison algorithm for tracking identities when
   * checking for changes.
   */
  set compareWith(fn) {
    if (typeof fn !== "function" && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw new RuntimeError(1201, `compareWith must be a function, but received ${JSON.stringify(fn)}`);
    }
    this._compareWith = fn;
  }
  _compareWith = Object.is;
  /**
   * Sets the "value" property on the select element.
   * @nodoc
   */
  writeValue(value) {
    this.value = value;
    const id = this._getOptionId(value);
    const valueString = _buildValueString$1(id, value);
    this.setProperty("value", valueString);
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = (valueString) => {
      this.value = this._getOptionValue(valueString);
      fn(this.value);
    };
  }
  /** @internal */
  _registerOption() {
    return (this._idCounter++).toString();
  }
  /** @internal */
  _getOptionId(value) {
    for (const id of this._optionMap.keys()) {
      if (this._compareWith(this._optionMap.get(id), value)) return id;
    }
    return null;
  }
  /** @internal */
  _getOptionValue(valueString) {
    const id = _extractId$1(valueString);
    return this._optionMap.has(id) ? this._optionMap.get(id) : valueString;
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵSelectControlValueAccessor_BaseFactory;
    return function SelectControlValueAccessor_Factory(__ngFactoryType__) {
      return (ɵSelectControlValueAccessor_BaseFactory || (ɵSelectControlValueAccessor_BaseFactory = ɵɵgetInheritedFactory(_SelectControlValueAccessor)))(__ngFactoryType__ || _SelectControlValueAccessor);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _SelectControlValueAccessor,
    selectors: [["select", "formControlName", "", 3, "multiple", ""], ["select", "formControl", "", 3, "multiple", ""], ["select", "ngModel", "", 3, "multiple", ""]],
    hostBindings: function SelectControlValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("change", function SelectControlValueAccessor_change_HostBindingHandler($event) {
          return ctx.onChange($event.target.value);
        })("blur", function SelectControlValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    inputs: {
      compareWith: "compareWith"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([SELECT_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]",
      host: {
        "(change)": "onChange($event.target.value)",
        "(blur)": "onTouched()"
      },
      providers: [SELECT_VALUE_ACCESSOR],
      standalone: false
    }]
  }], null, {
    compareWith: [{
      type: Input
    }]
  });
})();
var NgSelectOption = class _NgSelectOption {
  _element;
  _renderer;
  _select;
  /**
   * @description
   * ID of the option element
   */
  // TODO(issue/24571): remove '!'.
  id;
  constructor(_element, _renderer, _select) {
    this._element = _element;
    this._renderer = _renderer;
    this._select = _select;
    if (this._select) this.id = this._select._registerOption();
  }
  /**
   * @description
   * Tracks the value bound to the option element. Unlike the value binding,
   * ngValue supports binding to objects.
   */
  set ngValue(value) {
    if (this._select == null) return;
    this._select._optionMap.set(this.id, value);
    this._setElementValue(_buildValueString$1(this.id, value));
    this._select.writeValue(this._select.value);
  }
  /**
   * @description
   * Tracks simple string values bound to the option element.
   * For objects, use the `ngValue` input binding.
   */
  set value(value) {
    this._setElementValue(value);
    if (this._select) this._select.writeValue(this._select.value);
  }
  /** @internal */
  _setElementValue(value) {
    this._renderer.setProperty(this._element.nativeElement, "value", value);
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this._select) {
      this._select._optionMap.delete(this.id);
      this._select.writeValue(this._select.value);
    }
  }
  static ɵfac = function NgSelectOption_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgSelectOption)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(SelectControlValueAccessor, 9));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NgSelectOption,
    selectors: [["option"]],
    inputs: {
      ngValue: "ngValue",
      value: "value"
    },
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSelectOption, [{
    type: Directive,
    args: [{
      selector: "option",
      standalone: false
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: SelectControlValueAccessor,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }], {
    ngValue: [{
      type: Input,
      args: ["ngValue"]
    }],
    value: [{
      type: Input,
      args: ["value"]
    }]
  });
})();
var SELECT_MULTIPLE_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => SelectMultipleControlValueAccessor),
  multi: true
};
function _buildValueString(id, value) {
  if (id == null) return `${value}`;
  if (typeof value === "string") value = `'${value}'`;
  if (value && typeof value === "object") value = "Object";
  return `${id}: ${value}`.slice(0, 50);
}
function _extractId(valueString) {
  return valueString.split(":")[0];
}
var SelectMultipleControlValueAccessor = class _SelectMultipleControlValueAccessor extends BuiltInControlValueAccessor {
  /**
   * The current value.
   * @nodoc
   */
  value;
  /** @internal */
  _optionMap = /* @__PURE__ */ new Map();
  /** @internal */
  _idCounter = 0;
  /**
   * @description
   * Tracks the option comparison algorithm for tracking identities when
   * checking for changes.
   */
  set compareWith(fn) {
    if (typeof fn !== "function" && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw new RuntimeError(1201, `compareWith must be a function, but received ${JSON.stringify(fn)}`);
    }
    this._compareWith = fn;
  }
  _compareWith = Object.is;
  /**
   * Sets the "value" property on one or of more of the select's options.
   * @nodoc
   */
  writeValue(value) {
    this.value = value;
    let optionSelectedStateSetter;
    if (Array.isArray(value)) {
      const ids = value.map((v) => this._getOptionId(v));
      optionSelectedStateSetter = (opt, o10) => {
        opt._setSelected(ids.indexOf(o10.toString()) > -1);
      };
    } else {
      optionSelectedStateSetter = (opt, o10) => {
        opt._setSelected(false);
      };
    }
    this._optionMap.forEach(optionSelectedStateSetter);
  }
  /**
   * Registers a function called when the control value changes
   * and writes an array of the selected options.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = (element) => {
      const selected = [];
      const selectedOptions = element.selectedOptions;
      if (selectedOptions !== void 0) {
        const options = selectedOptions;
        for (let i = 0; i < options.length; i++) {
          const opt = options[i];
          const val = this._getOptionValue(opt.value);
          selected.push(val);
        }
      } else {
        const options = element.options;
        for (let i = 0; i < options.length; i++) {
          const opt = options[i];
          if (opt.selected) {
            const val = this._getOptionValue(opt.value);
            selected.push(val);
          }
        }
      }
      this.value = selected;
      fn(selected);
    };
  }
  /** @internal */
  _registerOption(value) {
    const id = (this._idCounter++).toString();
    this._optionMap.set(id, value);
    return id;
  }
  /** @internal */
  _getOptionId(value) {
    for (const id of this._optionMap.keys()) {
      if (this._compareWith(this._optionMap.get(id)._value, value)) return id;
    }
    return null;
  }
  /** @internal */
  _getOptionValue(valueString) {
    const id = _extractId(valueString);
    return this._optionMap.has(id) ? this._optionMap.get(id)._value : valueString;
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵSelectMultipleControlValueAccessor_BaseFactory;
    return function SelectMultipleControlValueAccessor_Factory(__ngFactoryType__) {
      return (ɵSelectMultipleControlValueAccessor_BaseFactory || (ɵSelectMultipleControlValueAccessor_BaseFactory = ɵɵgetInheritedFactory(_SelectMultipleControlValueAccessor)))(__ngFactoryType__ || _SelectMultipleControlValueAccessor);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _SelectMultipleControlValueAccessor,
    selectors: [["select", "multiple", "", "formControlName", ""], ["select", "multiple", "", "formControl", ""], ["select", "multiple", "", "ngModel", ""]],
    hostBindings: function SelectMultipleControlValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("change", function SelectMultipleControlValueAccessor_change_HostBindingHandler($event) {
          return ctx.onChange($event.target);
        })("blur", function SelectMultipleControlValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    inputs: {
      compareWith: "compareWith"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([SELECT_MULTIPLE_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectMultipleControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]",
      host: {
        "(change)": "onChange($event.target)",
        "(blur)": "onTouched()"
      },
      providers: [SELECT_MULTIPLE_VALUE_ACCESSOR],
      standalone: false
    }]
  }], null, {
    compareWith: [{
      type: Input
    }]
  });
})();
var ɵNgSelectMultipleOption = class _ɵNgSelectMultipleOption {
  _element;
  _renderer;
  _select;
  // TODO(issue/24571): remove '!'.
  id;
  /** @internal */
  _value;
  constructor(_element, _renderer, _select) {
    this._element = _element;
    this._renderer = _renderer;
    this._select = _select;
    if (this._select) {
      this.id = this._select._registerOption(this);
    }
  }
  /**
   * @description
   * Tracks the value bound to the option element. Unlike the value binding,
   * ngValue supports binding to objects.
   */
  set ngValue(value) {
    if (this._select == null) return;
    this._value = value;
    this._setElementValue(_buildValueString(this.id, value));
    this._select.writeValue(this._select.value);
  }
  /**
   * @description
   * Tracks simple string values bound to the option element.
   * For objects, use the `ngValue` input binding.
   */
  set value(value) {
    if (this._select) {
      this._value = value;
      this._setElementValue(_buildValueString(this.id, value));
      this._select.writeValue(this._select.value);
    } else {
      this._setElementValue(value);
    }
  }
  /** @internal */
  _setElementValue(value) {
    this._renderer.setProperty(this._element.nativeElement, "value", value);
  }
  /** @internal */
  _setSelected(selected) {
    this._renderer.setProperty(this._element.nativeElement, "selected", selected);
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this._select) {
      this._select._optionMap.delete(this.id);
      this._select.writeValue(this._select.value);
    }
  }
  static ɵfac = function ɵNgSelectMultipleOption_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ɵNgSelectMultipleOption)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(SelectMultipleControlValueAccessor, 9));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ɵNgSelectMultipleOption,
    selectors: [["option"]],
    inputs: {
      ngValue: "ngValue",
      value: "value"
    },
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ɵNgSelectMultipleOption, [{
    type: Directive,
    args: [{
      selector: "option",
      standalone: false
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: SelectMultipleControlValueAccessor,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }], {
    ngValue: [{
      type: Input,
      args: ["ngValue"]
    }],
    value: [{
      type: Input,
      args: ["value"]
    }]
  });
})();
function toInteger(value) {
  return typeof value === "number" ? value : parseInt(value, 10);
}
function toFloat(value) {
  return typeof value === "number" ? value : parseFloat(value);
}
var AbstractValidatorDirective = class _AbstractValidatorDirective {
  _validator = nullValidator;
  _onChange;
  /**
   * A flag that tracks whether this validator is enabled.
   *
   * Marking it `internal` (vs `protected`), so that this flag can be used in host bindings of
   * directive classes that extend this base class.
   * @internal
   */
  _enabled;
  /** @nodoc */
  ngOnChanges(changes) {
    if (this.inputName in changes) {
      const input = this.normalizeInput(changes[this.inputName].currentValue);
      this._enabled = this.enabled(input);
      this._validator = this._enabled ? this.createValidator(input) : nullValidator;
      if (this._onChange) {
        this._onChange();
      }
    }
  }
  /** @nodoc */
  validate(control) {
    return this._validator(control);
  }
  /** @nodoc */
  registerOnValidatorChange(fn) {
    this._onChange = fn;
  }
  /**
   * @description
   * Determines whether this validator should be active or not based on an input.
   * Base class implementation checks whether an input is defined (if the value is different from
   * `null` and `undefined`). Validator classes that extend this base class can override this
   * function with the logic specific to a particular validator directive.
   */
  enabled(input) {
    return input != null;
  }
  static ɵfac = function AbstractValidatorDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AbstractValidatorDirective)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _AbstractValidatorDirective,
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AbstractValidatorDirective, [{
    type: Directive
  }], null, null);
})();
var MAX_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MaxValidator),
  multi: true
};
var MaxValidator = class _MaxValidator extends AbstractValidatorDirective {
  /**
   * @description
   * Tracks changes to the max bound to this directive.
   */
  max;
  /** @internal */
  inputName = "max";
  /** @internal */
  normalizeInput = (input) => toFloat(input);
  /** @internal */
  createValidator = (max) => maxValidator(max);
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵMaxValidator_BaseFactory;
    return function MaxValidator_Factory(__ngFactoryType__) {
      return (ɵMaxValidator_BaseFactory || (ɵMaxValidator_BaseFactory = ɵɵgetInheritedFactory(_MaxValidator)))(__ngFactoryType__ || _MaxValidator);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _MaxValidator,
    selectors: [["input", "type", "number", "max", "", "formControlName", ""], ["input", "type", "number", "max", "", "formControl", ""], ["input", "type", "number", "max", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function MaxValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("max", ctx._enabled ? ctx.max : null);
      }
    },
    inputs: {
      max: "max"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([MAX_VALIDATOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MaxValidator, [{
    type: Directive,
    args: [{
      selector: "input[type=number][max][formControlName],input[type=number][max][formControl],input[type=number][max][ngModel]",
      providers: [MAX_VALIDATOR],
      host: {
        "[attr.max]": "_enabled ? max : null"
      },
      standalone: false
    }]
  }], null, {
    max: [{
      type: Input
    }]
  });
})();
var MIN_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MinValidator),
  multi: true
};
var MinValidator = class _MinValidator extends AbstractValidatorDirective {
  /**
   * @description
   * Tracks changes to the min bound to this directive.
   */
  min;
  /** @internal */
  inputName = "min";
  /** @internal */
  normalizeInput = (input) => toFloat(input);
  /** @internal */
  createValidator = (min) => minValidator(min);
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵMinValidator_BaseFactory;
    return function MinValidator_Factory(__ngFactoryType__) {
      return (ɵMinValidator_BaseFactory || (ɵMinValidator_BaseFactory = ɵɵgetInheritedFactory(_MinValidator)))(__ngFactoryType__ || _MinValidator);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _MinValidator,
    selectors: [["input", "type", "number", "min", "", "formControlName", ""], ["input", "type", "number", "min", "", "formControl", ""], ["input", "type", "number", "min", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function MinValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("min", ctx._enabled ? ctx.min : null);
      }
    },
    inputs: {
      min: "min"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([MIN_VALIDATOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MinValidator, [{
    type: Directive,
    args: [{
      selector: "input[type=number][min][formControlName],input[type=number][min][formControl],input[type=number][min][ngModel]",
      providers: [MIN_VALIDATOR],
      host: {
        "[attr.min]": "_enabled ? min : null"
      },
      standalone: false
    }]
  }], null, {
    min: [{
      type: Input
    }]
  });
})();
var REQUIRED_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => RequiredValidator),
  multi: true
};
var CHECKBOX_REQUIRED_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => CheckboxRequiredValidator),
  multi: true
};
var RequiredValidator = class _RequiredValidator extends AbstractValidatorDirective {
  /**
   * @description
   * Tracks changes to the required attribute bound to this directive.
   */
  required;
  /** @internal */
  inputName = "required";
  /** @internal */
  normalizeInput = booleanAttribute;
  /** @internal */
  createValidator = (input) => requiredValidator;
  /** @nodoc */
  enabled(input) {
    return input;
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵRequiredValidator_BaseFactory;
    return function RequiredValidator_Factory(__ngFactoryType__) {
      return (ɵRequiredValidator_BaseFactory || (ɵRequiredValidator_BaseFactory = ɵɵgetInheritedFactory(_RequiredValidator)))(__ngFactoryType__ || _RequiredValidator);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _RequiredValidator,
    selectors: [["", "required", "", "formControlName", "", 3, "type", "checkbox"], ["", "required", "", "formControl", "", 3, "type", "checkbox"], ["", "required", "", "ngModel", "", 3, "type", "checkbox"]],
    hostVars: 1,
    hostBindings: function RequiredValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("required", ctx._enabled ? "" : null);
      }
    },
    inputs: {
      required: "required"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([REQUIRED_VALIDATOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RequiredValidator, [{
    type: Directive,
    args: [{
      selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]",
      providers: [REQUIRED_VALIDATOR],
      host: {
        "[attr.required]": '_enabled ? "" : null'
      },
      standalone: false
    }]
  }], null, {
    required: [{
      type: Input
    }]
  });
})();
var CheckboxRequiredValidator = class _CheckboxRequiredValidator extends RequiredValidator {
  /** @internal */
  createValidator = (input) => requiredTrueValidator;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵCheckboxRequiredValidator_BaseFactory;
    return function CheckboxRequiredValidator_Factory(__ngFactoryType__) {
      return (ɵCheckboxRequiredValidator_BaseFactory || (ɵCheckboxRequiredValidator_BaseFactory = ɵɵgetInheritedFactory(_CheckboxRequiredValidator)))(__ngFactoryType__ || _CheckboxRequiredValidator);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _CheckboxRequiredValidator,
    selectors: [["input", "type", "checkbox", "required", "", "formControlName", ""], ["input", "type", "checkbox", "required", "", "formControl", ""], ["input", "type", "checkbox", "required", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function CheckboxRequiredValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("required", ctx._enabled ? "" : null);
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([CHECKBOX_REQUIRED_VALIDATOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckboxRequiredValidator, [{
    type: Directive,
    args: [{
      selector: "input[type=checkbox][required][formControlName],input[type=checkbox][required][formControl],input[type=checkbox][required][ngModel]",
      providers: [CHECKBOX_REQUIRED_VALIDATOR],
      host: {
        "[attr.required]": '_enabled ? "" : null'
      },
      standalone: false
    }]
  }], null, null);
})();
var EMAIL_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => EmailValidator),
  multi: true
};
var EmailValidator = class _EmailValidator extends AbstractValidatorDirective {
  /**
   * @description
   * Tracks changes to the email attribute bound to this directive.
   */
  email;
  /** @internal */
  inputName = "email";
  /** @internal */
  normalizeInput = booleanAttribute;
  /** @internal */
  createValidator = (input) => emailValidator;
  /** @nodoc */
  enabled(input) {
    return input;
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵEmailValidator_BaseFactory;
    return function EmailValidator_Factory(__ngFactoryType__) {
      return (ɵEmailValidator_BaseFactory || (ɵEmailValidator_BaseFactory = ɵɵgetInheritedFactory(_EmailValidator)))(__ngFactoryType__ || _EmailValidator);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _EmailValidator,
    selectors: [["", "email", "", "formControlName", ""], ["", "email", "", "formControl", ""], ["", "email", "", "ngModel", ""]],
    inputs: {
      email: "email"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([EMAIL_VALIDATOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EmailValidator, [{
    type: Directive,
    args: [{
      selector: "[email][formControlName],[email][formControl],[email][ngModel]",
      providers: [EMAIL_VALIDATOR],
      standalone: false
    }]
  }], null, {
    email: [{
      type: Input
    }]
  });
})();
var MIN_LENGTH_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MinLengthValidator),
  multi: true
};
var MinLengthValidator = class _MinLengthValidator extends AbstractValidatorDirective {
  /**
   * @description
   * Tracks changes to the minimum length bound to this directive.
   */
  minlength;
  /** @internal */
  inputName = "minlength";
  /** @internal */
  normalizeInput = (input) => toInteger(input);
  /** @internal */
  createValidator = (minlength) => minLengthValidator(minlength);
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵMinLengthValidator_BaseFactory;
    return function MinLengthValidator_Factory(__ngFactoryType__) {
      return (ɵMinLengthValidator_BaseFactory || (ɵMinLengthValidator_BaseFactory = ɵɵgetInheritedFactory(_MinLengthValidator)))(__ngFactoryType__ || _MinLengthValidator);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _MinLengthValidator,
    selectors: [["", "minlength", "", "formControlName", ""], ["", "minlength", "", "formControl", ""], ["", "minlength", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function MinLengthValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("minlength", ctx._enabled ? ctx.minlength : null);
      }
    },
    inputs: {
      minlength: "minlength"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([MIN_LENGTH_VALIDATOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MinLengthValidator, [{
    type: Directive,
    args: [{
      selector: "[minlength][formControlName],[minlength][formControl],[minlength][ngModel]",
      providers: [MIN_LENGTH_VALIDATOR],
      host: {
        "[attr.minlength]": "_enabled ? minlength : null"
      },
      standalone: false
    }]
  }], null, {
    minlength: [{
      type: Input
    }]
  });
})();
var MAX_LENGTH_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MaxLengthValidator),
  multi: true
};
var MaxLengthValidator = class _MaxLengthValidator extends AbstractValidatorDirective {
  /**
   * @description
   * Tracks changes to the maximum length bound to this directive.
   */
  maxlength;
  /** @internal */
  inputName = "maxlength";
  /** @internal */
  normalizeInput = (input) => toInteger(input);
  /** @internal */
  createValidator = (maxlength) => maxLengthValidator(maxlength);
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵMaxLengthValidator_BaseFactory;
    return function MaxLengthValidator_Factory(__ngFactoryType__) {
      return (ɵMaxLengthValidator_BaseFactory || (ɵMaxLengthValidator_BaseFactory = ɵɵgetInheritedFactory(_MaxLengthValidator)))(__ngFactoryType__ || _MaxLengthValidator);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _MaxLengthValidator,
    selectors: [["", "maxlength", "", "formControlName", ""], ["", "maxlength", "", "formControl", ""], ["", "maxlength", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function MaxLengthValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("maxlength", ctx._enabled ? ctx.maxlength : null);
      }
    },
    inputs: {
      maxlength: "maxlength"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([MAX_LENGTH_VALIDATOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MaxLengthValidator, [{
    type: Directive,
    args: [{
      selector: "[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]",
      providers: [MAX_LENGTH_VALIDATOR],
      host: {
        "[attr.maxlength]": "_enabled ? maxlength : null"
      },
      standalone: false
    }]
  }], null, {
    maxlength: [{
      type: Input
    }]
  });
})();
var PATTERN_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => PatternValidator),
  multi: true
};
var PatternValidator = class _PatternValidator extends AbstractValidatorDirective {
  /**
   * @description
   * Tracks changes to the pattern bound to this directive.
   */
  pattern;
  // This input is always defined, since the name matches selector.
  /** @internal */
  inputName = "pattern";
  /** @internal */
  normalizeInput = (input) => input;
  /** @internal */
  createValidator = (input) => patternValidator(input);
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPatternValidator_BaseFactory;
    return function PatternValidator_Factory(__ngFactoryType__) {
      return (ɵPatternValidator_BaseFactory || (ɵPatternValidator_BaseFactory = ɵɵgetInheritedFactory(_PatternValidator)))(__ngFactoryType__ || _PatternValidator);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _PatternValidator,
    selectors: [["", "pattern", "", "formControlName", ""], ["", "pattern", "", "formControl", ""], ["", "pattern", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function PatternValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("pattern", ctx._enabled ? ctx.pattern : null);
      }
    },
    inputs: {
      pattern: "pattern"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([PATTERN_VALIDATOR]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PatternValidator, [{
    type: Directive,
    args: [{
      selector: "[pattern][formControlName],[pattern][formControl],[pattern][ngModel]",
      providers: [PATTERN_VALIDATOR],
      host: {
        "[attr.pattern]": "_enabled ? pattern : null"
      },
      standalone: false
    }]
  }], null, {
    pattern: [{
      type: Input
    }]
  });
})();
var SHARED_FORM_DIRECTIVES = [ɵNgNoValidate, NgSelectOption, ɵNgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator];
var TEMPLATE_DRIVEN_DIRECTIVES = [NgModel, NgModelGroup, NgForm];
var REACTIVE_DRIVEN_DIRECTIVES = [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName];
var ɵInternalFormsSharedModule = class _ɵInternalFormsSharedModule {
  static ɵfac = function ɵInternalFormsSharedModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ɵInternalFormsSharedModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _ɵInternalFormsSharedModule,
    declarations: [ɵNgNoValidate, NgSelectOption, ɵNgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator],
    exports: [ɵNgNoValidate, NgSelectOption, ɵNgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator]
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ɵInternalFormsSharedModule, [{
    type: NgModule,
    args: [{
      declarations: SHARED_FORM_DIRECTIVES,
      exports: SHARED_FORM_DIRECTIVES
    }]
  }], null, null);
})();
var FormArray = class extends AbstractControl {
  /**
   * Creates a new `FormArray` instance.
   *
   * @param controls An array of child controls. Each child control is given an index
   * where it is registered.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of
   * such functions, or an `AbstractControlOptions` object that contains validation functions
   * and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator functions
   *
   */
  constructor(controls, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    this.controls = controls;
    this._initObservables();
    this._setUpdateStrategy(validatorOrOpts);
    this._setUpControls();
    this.updateValueAndValidity({
      onlySelf: true,
      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
      // `VALID` or `INVALID`.
      // The status should be broadcasted via the `statusChanges` observable, so we set `emitEvent`
      // to `true` to allow that during the control creation process.
      emitEvent: !!this.asyncValidator
    });
  }
  controls;
  /**
   * Get the `AbstractControl` at the given `index` in the array.
   *
   * @param index Index in the array to retrieve the control. If `index` is negative, it will wrap
   *     around from the back, and if index is greatly negative (less than `-length`), the result is
   * undefined. This behavior is the same as `Array.at(index)`.
   */
  at(index) {
    return this.controls[this._adjustIndex(index)];
  }
  /**
   * Insert a new `AbstractControl` at the end of the array.
   *
   * @param control Form control to be inserted
   * @param options Specifies whether this FormArray instance should emit events after a new
   *     control is added.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * inserted. When false, no events are emitted.
   */
  push(control, options = {}) {
    this.controls.push(control);
    this._registerControl(control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Insert a new `AbstractControl` at the given `index` in the array.
   *
   * @param index Index in the array to insert the control. If `index` is negative, wraps around
   *     from the back. If `index` is greatly negative (less than `-length`), prepends to the array.
   * This behavior is the same as `Array.splice(index, 0, control)`.
   * @param control Form control to be inserted
   * @param options Specifies whether this FormArray instance should emit events after a new
   *     control is inserted.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * inserted. When false, no events are emitted.
   */
  insert(index, control, options = {}) {
    this.controls.splice(index, 0, control);
    this._registerControl(control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  /**
   * Remove the control at the given `index` in the array.
   *
   * @param index Index in the array to remove the control.  If `index` is negative, wraps around
   *     from the back. If `index` is greatly negative (less than `-length`), removes the first
   *     element. This behavior is the same as `Array.splice(index, 1)`.
   * @param options Specifies whether this FormArray instance should emit events after a
   *     control is removed.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * removed. When false, no events are emitted.
   */
  removeAt(index, options = {}) {
    let adjustedIndex = this._adjustIndex(index);
    if (adjustedIndex < 0) adjustedIndex = 0;
    if (this.controls[adjustedIndex]) this.controls[adjustedIndex]._registerOnCollectionChange(() => {
    });
    this.controls.splice(adjustedIndex, 1);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  /**
   * Replace an existing control.
   *
   * @param index Index in the array to replace the control. If `index` is negative, wraps around
   *     from the back. If `index` is greatly negative (less than `-length`), replaces the first
   *     element. This behavior is the same as `Array.splice(index, 1, control)`.
   * @param control The `AbstractControl` control to replace the existing control
   * @param options Specifies whether this FormArray instance should emit events after an
   *     existing control is replaced with a new one.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * replaced with a new one. When false, no events are emitted.
   */
  setControl(index, control, options = {}) {
    let adjustedIndex = this._adjustIndex(index);
    if (adjustedIndex < 0) adjustedIndex = 0;
    if (this.controls[adjustedIndex]) this.controls[adjustedIndex]._registerOnCollectionChange(() => {
    });
    this.controls.splice(adjustedIndex, 1);
    if (control) {
      this.controls.splice(adjustedIndex, 0, control);
      this._registerControl(control);
    }
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Length of the control array.
   */
  get length() {
    return this.controls.length;
  }
  /**
   * Sets the value of the `FormArray`. It accepts an array that matches
   * the structure of the control.
   *
   * This method performs strict checks, and throws an error if you try
   * to set the value of a control that doesn't exist or if you exclude the
   * value of a control.
   *
   * @usageNotes
   * ### Set the values for the controls in the form array
   *
   * ```ts
   * const arr = new FormArray([
   *   new FormControl(),
   *   new FormControl()
   * ]);
   * console.log(arr.value);   // [null, null]
   *
   * arr.setValue(['Nancy', 'Drew']);
   * console.log(arr.value);   // ['Nancy', 'Drew']
   * ```
   *
   * @param value Array of values for the controls
   * @param options Configure options that determine how the control propagates changes and
   * emits events after the value changes
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
   * is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control value is updated.
   * When false, no events are emitted.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   */
  setValue(value, options = {}) {
    assertAllValuesPresent(this, false, value);
    value.forEach((newValue, index) => {
      assertControlPresent(this, false, index);
      this.at(index).setValue(newValue, {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Patches the value of the `FormArray`. It accepts an array that matches the
   * structure of the control, and does its best to match the values to the correct
   * controls in the group.
   *
   * It accepts both super-sets and sub-sets of the array without throwing an error.
   *
   * @usageNotes
   * ### Patch the values for controls in a form array
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   * console.log(arr.value);   // [null, null]
   *
   * arr.patchValue(['Nancy']);
   * console.log(arr.value);   // ['Nancy', null]
   * ```
   *
   * @param value Array of latest values for the controls
   * @param options Configure options that determine how the control propagates changes and
   * emits events after the value changes
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
   * is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control
   * value is updated. When false, no events are emitted. The configuration options are passed to
   * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.
   */
  patchValue(value, options = {}) {
    if (value == null) return;
    value.forEach((newValue, index) => {
      if (this.at(index)) {
        this.at(index).patchValue(newValue, {
          onlySelf: true,
          emitEvent: options.emitEvent
        });
      }
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Resets the `FormArray` and all descendants are marked `pristine` and `untouched`, and the
   * value of all descendants to null or null maps.
   *
   * You reset to a specific form state by passing in an array of states
   * that matches the structure of the control. The state is a standalone value
   * or a form state object with both a value and a disabled status.
   *
   * @usageNotes
   * ### Reset the values in a form array
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   * arr.reset(['name', 'last name']);
   *
   * console.log(arr.value);  // ['name', 'last name']
   * ```
   *
   * ### Reset the values in a form array and the disabled status for the first control
   *
   * ```ts
   * arr.reset([
   *   {value: 'name', disabled: true},
   *   'last'
   * ]);
   *
   * console.log(arr.value);  // ['last']
   * console.log(arr.at(0).status);  // 'DISABLED'
   * ```
   *
   * @param value Array of values for the controls
   * @param options Configure options that determine how the control propagates changes and
   * emits events after the value changes
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
   * is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is reset.
   * When false, no events are emitted.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   */
  reset(value = [], options = {}) {
    this._forEachChild((control, index) => {
      control.reset(value[index], {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this._updatePristine(options, this);
    this._updateTouched(options, this);
    this.updateValueAndValidity(options);
  }
  /**
   * The aggregate value of the array, including any disabled controls.
   *
   * Reports all values regardless of disabled status.
   */
  getRawValue() {
    return this.controls.map((control) => control.getRawValue());
  }
  /**
   * Remove all controls in the `FormArray`.
   *
   * @param options Specifies whether this FormArray instance should emit events after all
   *     controls are removed.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when all controls
   * in this FormArray instance are removed. When false, no events are emitted.
   *
   * @usageNotes
   * ### Remove all elements from a FormArray
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   * console.log(arr.length);  // 2
   *
   * arr.clear();
   * console.log(arr.length);  // 0
   * ```
   *
   * It's a simpler and more efficient alternative to removing all elements one by one:
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   *
   * while (arr.length) {
   *    arr.removeAt(0);
   * }
   * ```
   */
  clear(options = {}) {
    if (this.controls.length < 1) return;
    this._forEachChild((control) => control._registerOnCollectionChange(() => {
    }));
    this.controls.splice(0);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  /**
   * Adjusts a negative index by summing it with the length of the array. For very negative
   * indices, the result may remain negative.
   * @internal
   */
  _adjustIndex(index) {
    return index < 0 ? index + this.length : index;
  }
  /** @internal */
  _syncPendingControls() {
    let subtreeUpdated = this.controls.reduce((updated, child) => {
      return child._syncPendingControls() ? true : updated;
    }, false);
    if (subtreeUpdated) this.updateValueAndValidity({
      onlySelf: true
    });
    return subtreeUpdated;
  }
  /** @internal */
  _forEachChild(cb) {
    this.controls.forEach((control, index) => {
      cb(control, index);
    });
  }
  /** @internal */
  _updateValue() {
    this.value = this.controls.filter((control) => control.enabled || this.disabled).map((control) => control.value);
  }
  /** @internal */
  _anyControls(condition) {
    return this.controls.some((control) => control.enabled && condition(control));
  }
  /** @internal */
  _setUpControls() {
    this._forEachChild((control) => this._registerControl(control));
  }
  /** @internal */
  _allControlsDisabled() {
    for (const control of this.controls) {
      if (control.enabled) return false;
    }
    return this.controls.length > 0 || this.disabled;
  }
  _registerControl(control) {
    control.setParent(this);
    control._registerOnCollectionChange(this._onCollectionChange);
  }
  /** @internal */
  _find(name) {
    return this.at(name) ?? null;
  }
};
function isAbstractControlOptions(options) {
  return !!options && (options.asyncValidators !== void 0 || options.validators !== void 0 || options.updateOn !== void 0);
}
var FormBuilder = class _FormBuilder {
  useNonNullable = false;
  /**
   * @description
   * Returns a FormBuilder in which automatically constructed `FormControl` elements
   * have `{nonNullable: true}` and are non-nullable.
   *
   * **Constructing non-nullable controls**
   *
   * When constructing a control, it will be non-nullable, and will reset to its initial value.
   *
   * ```ts
   * let nnfb = new FormBuilder().nonNullable;
   * let name = nnfb.control('Alex'); // FormControl<string>
   * name.reset();
   * console.log(name); // 'Alex'
   * ```
   *
   * **Constructing non-nullable groups or arrays**
   *
   * When constructing a group or array, all automatically created inner controls will be
   * non-nullable, and will reset to their initial values.
   *
   * ```ts
   * let nnfb = new FormBuilder().nonNullable;
   * let name = nnfb.group({who: 'Alex'}); // FormGroup<{who: FormControl<string>}>
   * name.reset();
   * console.log(name); // {who: 'Alex'}
   * ```
   * **Constructing *nullable* fields on groups or arrays**
   *
   * It is still possible to have a nullable field. In particular, any `FormControl` which is
   * *already* constructed will not be altered. For example:
   *
   * ```ts
   * let nnfb = new FormBuilder().nonNullable;
   * // FormGroup<{who: FormControl<string|null>}>
   * let name = nnfb.group({who: new FormControl('Alex')});
   * name.reset(); console.log(name); // {who: null}
   * ```
   *
   * Because the inner control is constructed explicitly by the caller, the builder has
   * no control over how it is created, and cannot exclude the `null`.
   */
  get nonNullable() {
    const nnfb = new _FormBuilder();
    nnfb.useNonNullable = true;
    return nnfb;
  }
  group(controls, options = null) {
    const reducedControls = this._reduceControls(controls);
    let newOptions = {};
    if (isAbstractControlOptions(options)) {
      newOptions = options;
    } else if (options !== null) {
      newOptions.validators = options.validator;
      newOptions.asyncValidators = options.asyncValidator;
    }
    return new FormGroup(reducedControls, newOptions);
  }
  /**
   * @description
   * Constructs a new `FormRecord` instance. Accepts a single generic argument, which is an object
   * containing all the keys and corresponding inner control types.
   *
   * @param controls A collection of child controls. The key for each child is the name
   * under which it is registered.
   *
   * @param options Configuration options object for the `FormRecord`. The object should have the
   * `AbstractControlOptions` type and might contain the following fields:
   * * `validators`: A synchronous validator function, or an array of validator functions.
   * * `asyncValidators`: A single async validator or array of async validator functions.
   * * `updateOn`: The event upon which the control should be updated (options: 'change' | 'blur'
   * | submit').
   */
  record(controls, options = null) {
    const reducedControls = this._reduceControls(controls);
    return new FormRecord(reducedControls, options);
  }
  /**
   * @description
   * Constructs a new `FormControl` with the given state, validators and options. Sets
   * `{nonNullable: true}` in the options to get a non-nullable control. Otherwise, the
   * control will be nullable. Accepts a single generic argument, which is the type  of the
   * control's value.
   *
   * @param formState Initializes the control with an initial state value, or
   * with an object that contains both a value and a disabled status.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of
   * such functions, or a `FormControlOptions` object that contains
   * validation functions and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator
   * functions.
   *
   * @usageNotes
   *
   * ### Initialize a control as disabled
   *
   * The following example returns a control with an initial value in a disabled state.
   *
   * {@example forms/ts/formBuilder/form_builder_example.ts region='disabled-control'}
   */
  control(formState, validatorOrOpts, asyncValidator) {
    let newOptions = {};
    if (!this.useNonNullable) {
      return new FormControl(formState, validatorOrOpts, asyncValidator);
    }
    if (isAbstractControlOptions(validatorOrOpts)) {
      newOptions = validatorOrOpts;
    } else {
      newOptions.validators = validatorOrOpts;
      newOptions.asyncValidators = asyncValidator;
    }
    return new FormControl(formState, __spreadProps(__spreadValues({}, newOptions), {
      nonNullable: true
    }));
  }
  /**
   * Constructs a new `FormArray` from the given array of configurations,
   * validators and options. Accepts a single generic argument, which is the type of each control
   * inside the array.
   *
   * @param controls An array of child controls or control configs. Each child control is given an
   *     index when it is registered.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of such functions, or an
   *     `AbstractControlOptions` object that contains
   * validation functions and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator functions.
   */
  array(controls, validatorOrOpts, asyncValidator) {
    const createdControls = controls.map((c) => this._createControl(c));
    return new FormArray(createdControls, validatorOrOpts, asyncValidator);
  }
  /** @internal */
  _reduceControls(controls) {
    const createdControls = {};
    Object.keys(controls).forEach((controlName) => {
      createdControls[controlName] = this._createControl(controls[controlName]);
    });
    return createdControls;
  }
  /** @internal */
  _createControl(controls) {
    if (controls instanceof FormControl) {
      return controls;
    } else if (controls instanceof AbstractControl) {
      return controls;
    } else if (Array.isArray(controls)) {
      const value = controls[0];
      const validator = controls.length > 1 ? controls[1] : null;
      const asyncValidator = controls.length > 2 ? controls[2] : null;
      return this.control(value, validator, asyncValidator);
    } else {
      return this.control(controls);
    }
  }
  static ɵfac = function FormBuilder_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormBuilder)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _FormBuilder,
    factory: _FormBuilder.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var NonNullableFormBuilder = class _NonNullableFormBuilder {
  static ɵfac = function NonNullableFormBuilder_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NonNullableFormBuilder)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _NonNullableFormBuilder,
    factory: () => (() => inject(FormBuilder).nonNullable)(),
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NonNullableFormBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => inject(FormBuilder).nonNullable
    }]
  }], null, null);
})();
var UntypedFormBuilder = class _UntypedFormBuilder extends FormBuilder {
  group(controlsConfig, options = null) {
    return super.group(controlsConfig, options);
  }
  /**
   * Like `FormBuilder#control`, except the resulting control is untyped.
   */
  control(formState, validatorOrOpts, asyncValidator) {
    return super.control(formState, validatorOrOpts, asyncValidator);
  }
  /**
   * Like `FormBuilder#array`, except the resulting array is untyped.
   */
  array(controlsConfig, validatorOrOpts, asyncValidator) {
    return super.array(controlsConfig, validatorOrOpts, asyncValidator);
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵUntypedFormBuilder_BaseFactory;
    return function UntypedFormBuilder_Factory(__ngFactoryType__) {
      return (ɵUntypedFormBuilder_BaseFactory || (ɵUntypedFormBuilder_BaseFactory = ɵɵgetInheritedFactory(_UntypedFormBuilder)))(__ngFactoryType__ || _UntypedFormBuilder);
    };
  })();
  static ɵprov = ɵɵdefineInjectable({
    token: _UntypedFormBuilder,
    factory: _UntypedFormBuilder.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UntypedFormBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var VERSION2 = new Version("19.1.4");
var FormsModule = class _FormsModule {
  /**
   * @description
   * Provides options for configuring the forms module.
   *
   * @param opts An object of configuration options
   * * `callSetDisabledState` Configures whether to `always` call `setDisabledState`, which is more
   * correct, or to only call it `whenDisabled`, which is the legacy behavior.
   */
  static withConfig(opts) {
    return {
      ngModule: _FormsModule,
      providers: [{
        provide: CALL_SET_DISABLED_STATE,
        useValue: opts.callSetDisabledState ?? setDisabledStateDefault
      }]
    };
  }
  static ɵfac = function FormsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormsModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _FormsModule,
    declarations: [NgModel, NgModelGroup, NgForm],
    exports: [ɵInternalFormsSharedModule, NgModel, NgModelGroup, NgForm]
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [ɵInternalFormsSharedModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormsModule, [{
    type: NgModule,
    args: [{
      declarations: TEMPLATE_DRIVEN_DIRECTIVES,
      exports: [ɵInternalFormsSharedModule, TEMPLATE_DRIVEN_DIRECTIVES]
    }]
  }], null, null);
})();
var ReactiveFormsModule = class _ReactiveFormsModule {
  /**
   * @description
   * Provides options for configuring the reactive forms module.
   *
   * @param opts An object of configuration options
   * * `warnOnNgModelWithFormControl` Configures when to emit a warning when an `ngModel`
   * binding is used with reactive form directives.
   * * `callSetDisabledState` Configures whether to `always` call `setDisabledState`, which is more
   * correct, or to only call it `whenDisabled`, which is the legacy behavior.
   */
  static withConfig(opts) {
    return {
      ngModule: _ReactiveFormsModule,
      providers: [{
        provide: NG_MODEL_WITH_FORM_CONTROL_WARNING,
        useValue: opts.warnOnNgModelWithFormControl ?? "always"
      }, {
        provide: CALL_SET_DISABLED_STATE,
        useValue: opts.callSetDisabledState ?? setDisabledStateDefault
      }]
    };
  }
  static ɵfac = function ReactiveFormsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ReactiveFormsModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _ReactiveFormsModule,
    declarations: [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName],
    exports: [ɵInternalFormsSharedModule, FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName]
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [ɵInternalFormsSharedModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ReactiveFormsModule, [{
    type: NgModule,
    args: [{
      declarations: [REACTIVE_DRIVEN_DIRECTIVES],
      exports: [ɵInternalFormsSharedModule, REACTIVE_DRIVEN_DIRECTIVES]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/platform.mjs
var hasV8BreakIterator;
try {
  hasV8BreakIterator = typeof Intl !== "undefined" && Intl.v8BreakIterator;
} catch {
  hasV8BreakIterator = false;
}
var Platform = class _Platform {
  _platformId = inject(PLATFORM_ID);
  // We want to use the Angular platform check because if the Document is shimmed
  // without the navigator, the following checks will fail. This is preferred because
  // sometimes the Document may be shimmed without the user's knowledge or intention
  /** Whether the Angular application is being rendered in the browser. */
  isBrowser = this._platformId ? isPlatformBrowser(this._platformId) : typeof document === "object" && !!document;
  /** Whether the current browser is Microsoft Edge. */
  EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);
  /** Whether the current rendering engine is Microsoft Trident. */
  TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);
  // EdgeHTML and Trident mock Blink specific things and need to be excluded from this check.
  /** Whether the current rendering engine is Blink. */
  BLINK = this.isBrowser && !!(window.chrome || hasV8BreakIterator) && typeof CSS !== "undefined" && !this.EDGE && !this.TRIDENT;
  // Webkit is part of the userAgent in EdgeHTML, Blink and Trident. Therefore we need to
  // ensure that Webkit runs standalone and is not used as another engine's base.
  /** Whether the current rendering engine is WebKit. */
  WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;
  /** Whether the current platform is Apple iOS. */
  IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window);
  // It's difficult to detect the plain Gecko engine, because most of the browsers identify
  // them self as Gecko-like browsers and modify the userAgent's according to that.
  // Since we only cover one explicit Firefox case, we can simply check for Firefox
  // instead of having an unstable check for Gecko.
  /** Whether the current browser is Firefox. */
  FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);
  /** Whether the current platform is Android. */
  // Trident on mobile adds the android platform to the userAgent to trick detections.
  ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;
  // Safari browsers will include the Safari keyword in their userAgent. Some browsers may fake
  // this and just place the Safari keyword in the userAgent. To be more safe about Safari every
  // Safari browser should also use Webkit as its layout engine.
  /** Whether the current browser is Safari. */
  SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;
  constructor() {
  }
  static ɵfac = function Platform_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _Platform)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _Platform,
    factory: _Platform.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Platform, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var PlatformModule = class _PlatformModule {
  static ɵfac = function PlatformModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PlatformModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _PlatformModule
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlatformModule, [{
    type: NgModule,
    args: [{}]
  }], null, null);
})();
var supportsPassiveEvents;
function supportsPassiveEventListeners() {
  if (supportsPassiveEvents == null && typeof window !== "undefined") {
    try {
      window.addEventListener("test", null, Object.defineProperty({}, "passive", {
        get: () => supportsPassiveEvents = true
      }));
    } finally {
      supportsPassiveEvents = supportsPassiveEvents || false;
    }
  }
  return supportsPassiveEvents;
}
function normalizePassiveListenerOptions(options) {
  return supportsPassiveEventListeners() ? options : !!options.capture;
}
var RtlScrollAxisType;
(function(RtlScrollAxisType2) {
  RtlScrollAxisType2[RtlScrollAxisType2["NORMAL"] = 0] = "NORMAL";
  RtlScrollAxisType2[RtlScrollAxisType2["NEGATED"] = 1] = "NEGATED";
  RtlScrollAxisType2[RtlScrollAxisType2["INVERTED"] = 2] = "INVERTED";
})(RtlScrollAxisType || (RtlScrollAxisType = {}));
var rtlScrollAxisType;
var scrollBehaviorSupported;
function supportsScrollBehavior() {
  if (scrollBehaviorSupported == null) {
    if (typeof document !== "object" || !document || typeof Element !== "function" || !Element) {
      scrollBehaviorSupported = false;
      return scrollBehaviorSupported;
    }
    if ("scrollBehavior" in document.documentElement.style) {
      scrollBehaviorSupported = true;
    } else {
      const scrollToFunction = Element.prototype.scrollTo;
      if (scrollToFunction) {
        scrollBehaviorSupported = !/\{\s*\[native code\]\s*\}/.test(scrollToFunction.toString());
      } else {
        scrollBehaviorSupported = false;
      }
    }
  }
  return scrollBehaviorSupported;
}
function getRtlScrollAxisType() {
  if (typeof document !== "object" || !document) {
    return RtlScrollAxisType.NORMAL;
  }
  if (rtlScrollAxisType == null) {
    const scrollContainer = document.createElement("div");
    const containerStyle = scrollContainer.style;
    scrollContainer.dir = "rtl";
    containerStyle.width = "1px";
    containerStyle.overflow = "auto";
    containerStyle.visibility = "hidden";
    containerStyle.pointerEvents = "none";
    containerStyle.position = "absolute";
    const content = document.createElement("div");
    const contentStyle = content.style;
    contentStyle.width = "2px";
    contentStyle.height = "1px";
    scrollContainer.appendChild(content);
    document.body.appendChild(scrollContainer);
    rtlScrollAxisType = RtlScrollAxisType.NORMAL;
    if (scrollContainer.scrollLeft === 0) {
      scrollContainer.scrollLeft = 1;
      rtlScrollAxisType = scrollContainer.scrollLeft === 0 ? RtlScrollAxisType.NEGATED : RtlScrollAxisType.INVERTED;
    }
    scrollContainer.remove();
  }
  return rtlScrollAxisType;
}
var shadowDomIsSupported;
function _supportsShadowDom() {
  if (shadowDomIsSupported == null) {
    const head = typeof document !== "undefined" ? document.head : null;
    shadowDomIsSupported = !!(head && (head.createShadowRoot || head.attachShadow));
  }
  return shadowDomIsSupported;
}
function _getShadowRoot(element) {
  if (_supportsShadowDom()) {
    const rootNode = element.getRootNode ? element.getRootNode() : null;
    if (typeof ShadowRoot !== "undefined" && ShadowRoot && rootNode instanceof ShadowRoot) {
      return rootNode;
    }
  }
  return null;
}
function _getFocusedElementPierceShadowDom() {
  let activeElement = typeof document !== "undefined" && document ? document.activeElement : null;
  while (activeElement && activeElement.shadowRoot) {
    const newActiveElement = activeElement.shadowRoot.activeElement;
    if (newActiveElement === activeElement) {
      break;
    } else {
      activeElement = newActiveElement;
    }
  }
  return activeElement;
}
function _getEventTarget(event) {
  return event.composedPath ? event.composedPath()[0] : event.target;
}

// node_modules/@angular/cdk/fesm2022/private.mjs
var appsWithLoaders = /* @__PURE__ */ new WeakMap();
var _CdkPrivateStyleLoader = class __CdkPrivateStyleLoader {
  _appRef;
  _injector = inject(Injector);
  _environmentInjector = inject(EnvironmentInjector);
  /**
   * Loads a set of styles.
   * @param loader Component which will be instantiated to load the styles.
   */
  load(loader) {
    const appRef = this._appRef = this._appRef || this._injector.get(ApplicationRef);
    let data = appsWithLoaders.get(appRef);
    if (!data) {
      data = {
        loaders: /* @__PURE__ */ new Set(),
        refs: []
      };
      appsWithLoaders.set(appRef, data);
      appRef.onDestroy(() => {
        appsWithLoaders.get(appRef)?.refs.forEach((ref) => ref.destroy());
        appsWithLoaders.delete(appRef);
      });
    }
    if (!data.loaders.has(loader)) {
      data.loaders.add(loader);
      data.refs.push(createComponent(loader, {
        environmentInjector: this._environmentInjector
      }));
    }
  }
  static ɵfac = function _CdkPrivateStyleLoader_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || __CdkPrivateStyleLoader)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: __CdkPrivateStyleLoader,
    factory: __CdkPrivateStyleLoader.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_CdkPrivateStyleLoader, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _VisuallyHiddenLoader = class __VisuallyHiddenLoader {
  static ɵfac = function _VisuallyHiddenLoader_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || __VisuallyHiddenLoader)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: __VisuallyHiddenLoader,
    selectors: [["ng-component"]],
    exportAs: ["cdkVisuallyHidden"],
    decls: 0,
    vars: 0,
    template: function _VisuallyHiddenLoader_Template(rf, ctx) {
    },
    styles: [".cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}"],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_VisuallyHiddenLoader, [{
    type: Component,
    args: [{
      exportAs: "cdkVisuallyHidden",
      encapsulation: ViewEncapsulation.None,
      template: "",
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [".cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}"]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/keycodes.mjs
var SHIFT = 16;
var CONTROL = 17;
var ALT = 18;
var ZERO = 48;
var NINE = 57;
var A = 65;
var Z = 90;
var META = 91;
var MAC_META = 224;

// node_modules/@angular/cdk/fesm2022/coercion/private.mjs
function coerceObservable(data) {
  if (!isObservable(data)) {
    return of(data);
  }
  return data;
}

// node_modules/@angular/cdk/fesm2022/coercion.mjs
function coerceNumberProperty(value, fallbackValue = 0) {
  if (_isNumberValue(value)) {
    return Number(value);
  }
  return arguments.length === 2 ? fallbackValue : 0;
}
function _isNumberValue(value) {
  return !isNaN(parseFloat(value)) && !isNaN(Number(value));
}
function coerceArray(value) {
  return Array.isArray(value) ? value : [value];
}
function coerceElement(elementOrRef) {
  return elementOrRef instanceof ElementRef ? elementOrRef.nativeElement : elementOrRef;
}

// node_modules/@angular/cdk/fesm2022/observers.mjs
function shouldIgnoreRecord(record) {
  if (record.type === "characterData" && record.target instanceof Comment) {
    return true;
  }
  if (record.type === "childList") {
    for (let i = 0; i < record.addedNodes.length; i++) {
      if (!(record.addedNodes[i] instanceof Comment)) {
        return false;
      }
    }
    for (let i = 0; i < record.removedNodes.length; i++) {
      if (!(record.removedNodes[i] instanceof Comment)) {
        return false;
      }
    }
    return true;
  }
  return false;
}
var MutationObserverFactory = class _MutationObserverFactory {
  create(callback) {
    return typeof MutationObserver === "undefined" ? null : new MutationObserver(callback);
  }
  static ɵfac = function MutationObserverFactory_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MutationObserverFactory)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _MutationObserverFactory,
    factory: _MutationObserverFactory.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MutationObserverFactory, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var ContentObserver = class _ContentObserver {
  _mutationObserverFactory = inject(MutationObserverFactory);
  /** Keeps track of the existing MutationObservers so they can be reused. */
  _observedElements = /* @__PURE__ */ new Map();
  _ngZone = inject(NgZone);
  constructor() {
  }
  ngOnDestroy() {
    this._observedElements.forEach((_, element) => this._cleanupObserver(element));
  }
  observe(elementOrRef) {
    const element = coerceElement(elementOrRef);
    return new Observable((observer) => {
      const stream = this._observeElement(element);
      const subscription = stream.pipe(map((records) => records.filter((record) => !shouldIgnoreRecord(record))), filter((records) => !!records.length)).subscribe((records) => {
        this._ngZone.run(() => {
          observer.next(records);
        });
      });
      return () => {
        subscription.unsubscribe();
        this._unobserveElement(element);
      };
    });
  }
  /**
   * Observes the given element by using the existing MutationObserver if available, or creating a
   * new one if not.
   */
  _observeElement(element) {
    return this._ngZone.runOutsideAngular(() => {
      if (!this._observedElements.has(element)) {
        const stream = new Subject();
        const observer = this._mutationObserverFactory.create((mutations) => stream.next(mutations));
        if (observer) {
          observer.observe(element, {
            characterData: true,
            childList: true,
            subtree: true
          });
        }
        this._observedElements.set(element, {
          observer,
          stream,
          count: 1
        });
      } else {
        this._observedElements.get(element).count++;
      }
      return this._observedElements.get(element).stream;
    });
  }
  /**
   * Un-observes the given element and cleans up the underlying MutationObserver if nobody else is
   * observing this element.
   */
  _unobserveElement(element) {
    if (this._observedElements.has(element)) {
      this._observedElements.get(element).count--;
      if (!this._observedElements.get(element).count) {
        this._cleanupObserver(element);
      }
    }
  }
  /** Clean up the underlying MutationObserver for the specified element. */
  _cleanupObserver(element) {
    if (this._observedElements.has(element)) {
      const {
        observer,
        stream
      } = this._observedElements.get(element);
      if (observer) {
        observer.disconnect();
      }
      stream.complete();
      this._observedElements.delete(element);
    }
  }
  static ɵfac = function ContentObserver_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ContentObserver)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ContentObserver,
    factory: _ContentObserver.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContentObserver, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var CdkObserveContent = class _CdkObserveContent {
  _contentObserver = inject(ContentObserver);
  _elementRef = inject(ElementRef);
  /** Event emitted for each change in the element's content. */
  event = new EventEmitter();
  /**
   * Whether observing content is disabled. This option can be used
   * to disconnect the underlying MutationObserver until it is needed.
   */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this._disabled ? this._unsubscribe() : this._subscribe();
  }
  _disabled = false;
  /** Debounce interval for emitting the changes. */
  get debounce() {
    return this._debounce;
  }
  set debounce(value) {
    this._debounce = coerceNumberProperty(value);
    this._subscribe();
  }
  _debounce;
  _currentSubscription = null;
  constructor() {
  }
  ngAfterContentInit() {
    if (!this._currentSubscription && !this.disabled) {
      this._subscribe();
    }
  }
  ngOnDestroy() {
    this._unsubscribe();
  }
  _subscribe() {
    this._unsubscribe();
    const stream = this._contentObserver.observe(this._elementRef);
    this._currentSubscription = (this.debounce ? stream.pipe(debounceTime(this.debounce)) : stream).subscribe(this.event);
  }
  _unsubscribe() {
    this._currentSubscription?.unsubscribe();
  }
  static ɵfac = function CdkObserveContent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkObserveContent)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkObserveContent,
    selectors: [["", "cdkObserveContent", ""]],
    inputs: {
      disabled: [2, "cdkObserveContentDisabled", "disabled", booleanAttribute],
      debounce: "debounce"
    },
    outputs: {
      event: "cdkObserveContent"
    },
    exportAs: ["cdkObserveContent"],
    features: [ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkObserveContent, [{
    type: Directive,
    args: [{
      selector: "[cdkObserveContent]",
      exportAs: "cdkObserveContent"
    }]
  }], () => [], {
    event: [{
      type: Output,
      args: ["cdkObserveContent"]
    }],
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkObserveContentDisabled",
        transform: booleanAttribute
      }]
    }],
    debounce: [{
      type: Input
    }]
  });
})();
var ObserversModule = class _ObserversModule {
  static ɵfac = function ObserversModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ObserversModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _ObserversModule,
    imports: [CdkObserveContent],
    exports: [CdkObserveContent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [MutationObserverFactory]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ObserversModule, [{
    type: NgModule,
    args: [{
      imports: [CdkObserveContent],
      exports: [CdkObserveContent],
      providers: [MutationObserverFactory]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/layout.mjs
var LayoutModule = class _LayoutModule {
  static ɵfac = function LayoutModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LayoutModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _LayoutModule
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LayoutModule, [{
    type: NgModule,
    args: [{}]
  }], null, null);
})();
var mediaQueriesForWebkitCompatibility = /* @__PURE__ */ new Set();
var mediaQueryStyleNode;
var MediaMatcher = class _MediaMatcher {
  _platform = inject(Platform);
  _nonce = inject(CSP_NONCE, {
    optional: true
  });
  /** The internal matchMedia method to return back a MediaQueryList like object. */
  _matchMedia;
  constructor() {
    this._matchMedia = this._platform.isBrowser && window.matchMedia ? (
      // matchMedia is bound to the window scope intentionally as it is an illegal invocation to
      // call it from a different scope.
      window.matchMedia.bind(window)
    ) : noopMatchMedia;
  }
  /**
   * Evaluates the given media query and returns the native MediaQueryList from which results
   * can be retrieved.
   * Confirms the layout engine will trigger for the selector query provided and returns the
   * MediaQueryList for the query provided.
   */
  matchMedia(query) {
    if (this._platform.WEBKIT || this._platform.BLINK) {
      createEmptyStyleRule(query, this._nonce);
    }
    return this._matchMedia(query);
  }
  static ɵfac = function MediaMatcher_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MediaMatcher)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _MediaMatcher,
    factory: _MediaMatcher.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MediaMatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function createEmptyStyleRule(query, nonce) {
  if (mediaQueriesForWebkitCompatibility.has(query)) {
    return;
  }
  try {
    if (!mediaQueryStyleNode) {
      mediaQueryStyleNode = document.createElement("style");
      if (nonce) {
        mediaQueryStyleNode.setAttribute("nonce", nonce);
      }
      mediaQueryStyleNode.setAttribute("type", "text/css");
      document.head.appendChild(mediaQueryStyleNode);
    }
    if (mediaQueryStyleNode.sheet) {
      mediaQueryStyleNode.sheet.insertRule(`@media ${query} {body{ }}`, 0);
      mediaQueriesForWebkitCompatibility.add(query);
    }
  } catch (e5) {
    console.error(e5);
  }
}
function noopMatchMedia(query) {
  return {
    matches: query === "all" || query === "",
    media: query,
    addListener: () => {
    },
    removeListener: () => {
    }
  };
}
var BreakpointObserver = class _BreakpointObserver {
  _mediaMatcher = inject(MediaMatcher);
  _zone = inject(NgZone);
  /**  A map of all media queries currently being listened for. */
  _queries = /* @__PURE__ */ new Map();
  /** A subject for all other observables to takeUntil based on. */
  _destroySubject = new Subject();
  constructor() {
  }
  /** Completes the active subject, signalling to all other observables to complete. */
  ngOnDestroy() {
    this._destroySubject.next();
    this._destroySubject.complete();
  }
  /**
   * Whether one or more media queries match the current viewport size.
   * @param value One or more media queries to check.
   * @returns Whether any of the media queries match.
   */
  isMatched(value) {
    const queries = splitQueries(coerceArray(value));
    return queries.some((mediaQuery) => this._registerQuery(mediaQuery).mql.matches);
  }
  /**
   * Gets an observable of results for the given queries that will emit new results for any changes
   * in matching of the given queries.
   * @param value One or more media queries to check.
   * @returns A stream of matches for the given queries.
   */
  observe(value) {
    const queries = splitQueries(coerceArray(value));
    const observables = queries.map((query) => this._registerQuery(query).observable);
    let stateObservable = combineLatest(observables);
    stateObservable = concat(stateObservable.pipe(take(1)), stateObservable.pipe(skip(1), debounceTime(0)));
    return stateObservable.pipe(map((breakpointStates) => {
      const response = {
        matches: false,
        breakpoints: {}
      };
      breakpointStates.forEach(({
        matches,
        query
      }) => {
        response.matches = response.matches || matches;
        response.breakpoints[query] = matches;
      });
      return response;
    }));
  }
  /** Registers a specific query to be listened for. */
  _registerQuery(query) {
    if (this._queries.has(query)) {
      return this._queries.get(query);
    }
    const mql = this._mediaMatcher.matchMedia(query);
    const queryObservable = new Observable((observer) => {
      const handler = (e5) => this._zone.run(() => observer.next(e5));
      mql.addListener(handler);
      return () => {
        mql.removeListener(handler);
      };
    }).pipe(startWith(mql), map(({
      matches
    }) => ({
      query,
      matches
    })), takeUntil(this._destroySubject));
    const output = {
      observable: queryObservable,
      mql
    };
    this._queries.set(query, output);
    return output;
  }
  static ɵfac = function BreakpointObserver_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BreakpointObserver)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _BreakpointObserver,
    factory: _BreakpointObserver.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BreakpointObserver, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function splitQueries(queries) {
  return queries.map((query) => query.split(",")).reduce((a1, a2) => a1.concat(a2)).map((query) => query.trim());
}

// node_modules/@angular/cdk/fesm2022/a11y.mjs
var ID_DELIMITER = " ";
function addAriaReferencedId(el, attr, id) {
  const ids = getAriaReferenceIds(el, attr);
  id = id.trim();
  if (ids.some((existingId) => existingId.trim() === id)) {
    return;
  }
  ids.push(id);
  el.setAttribute(attr, ids.join(ID_DELIMITER));
}
function removeAriaReferencedId(el, attr, id) {
  const ids = getAriaReferenceIds(el, attr);
  id = id.trim();
  const filteredIds = ids.filter((val) => val !== id);
  if (filteredIds.length) {
    el.setAttribute(attr, filteredIds.join(ID_DELIMITER));
  } else {
    el.removeAttribute(attr);
  }
}
function getAriaReferenceIds(el, attr) {
  const attrValue = el.getAttribute(attr);
  return attrValue?.match(/\S+/g) ?? [];
}
var CDK_DESCRIBEDBY_ID_PREFIX = "cdk-describedby-message";
var CDK_DESCRIBEDBY_HOST_ATTRIBUTE = "cdk-describedby-host";
var nextId = 0;
var AriaDescriber = class _AriaDescriber {
  _platform = inject(Platform);
  _document = inject(DOCUMENT);
  /** Map of all registered message elements that have been placed into the document. */
  _messageRegistry = /* @__PURE__ */ new Map();
  /** Container for all registered messages. */
  _messagesContainer = null;
  /** Unique ID for the service. */
  _id = `${nextId++}`;
  constructor() {
    inject(_CdkPrivateStyleLoader).load(_VisuallyHiddenLoader);
    this._id = inject(APP_ID) + "-" + nextId++;
  }
  describe(hostElement, message, role) {
    if (!this._canBeDescribed(hostElement, message)) {
      return;
    }
    const key = getKey(message, role);
    if (typeof message !== "string") {
      setMessageId(message, this._id);
      this._messageRegistry.set(key, {
        messageElement: message,
        referenceCount: 0
      });
    } else if (!this._messageRegistry.has(key)) {
      this._createMessageElement(message, role);
    }
    if (!this._isElementDescribedByMessage(hostElement, key)) {
      this._addMessageReference(hostElement, key);
    }
  }
  removeDescription(hostElement, message, role) {
    if (!message || !this._isElementNode(hostElement)) {
      return;
    }
    const key = getKey(message, role);
    if (this._isElementDescribedByMessage(hostElement, key)) {
      this._removeMessageReference(hostElement, key);
    }
    if (typeof message === "string") {
      const registeredMessage = this._messageRegistry.get(key);
      if (registeredMessage && registeredMessage.referenceCount === 0) {
        this._deleteMessageElement(key);
      }
    }
    if (this._messagesContainer?.childNodes.length === 0) {
      this._messagesContainer.remove();
      this._messagesContainer = null;
    }
  }
  /** Unregisters all created message elements and removes the message container. */
  ngOnDestroy() {
    const describedElements = this._document.querySelectorAll(`[${CDK_DESCRIBEDBY_HOST_ATTRIBUTE}="${this._id}"]`);
    for (let i = 0; i < describedElements.length; i++) {
      this._removeCdkDescribedByReferenceIds(describedElements[i]);
      describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);
    }
    this._messagesContainer?.remove();
    this._messagesContainer = null;
    this._messageRegistry.clear();
  }
  /**
   * Creates a new element in the visually hidden message container element with the message
   * as its content and adds it to the message registry.
   */
  _createMessageElement(message, role) {
    const messageElement = this._document.createElement("div");
    setMessageId(messageElement, this._id);
    messageElement.textContent = message;
    if (role) {
      messageElement.setAttribute("role", role);
    }
    this._createMessagesContainer();
    this._messagesContainer.appendChild(messageElement);
    this._messageRegistry.set(getKey(message, role), {
      messageElement,
      referenceCount: 0
    });
  }
  /** Deletes the message element from the global messages container. */
  _deleteMessageElement(key) {
    this._messageRegistry.get(key)?.messageElement?.remove();
    this._messageRegistry.delete(key);
  }
  /** Creates the global container for all aria-describedby messages. */
  _createMessagesContainer() {
    if (this._messagesContainer) {
      return;
    }
    const containerClassName = "cdk-describedby-message-container";
    const serverContainers = this._document.querySelectorAll(`.${containerClassName}[platform="server"]`);
    for (let i = 0; i < serverContainers.length; i++) {
      serverContainers[i].remove();
    }
    const messagesContainer = this._document.createElement("div");
    messagesContainer.style.visibility = "hidden";
    messagesContainer.classList.add(containerClassName);
    messagesContainer.classList.add("cdk-visually-hidden");
    if (!this._platform.isBrowser) {
      messagesContainer.setAttribute("platform", "server");
    }
    this._document.body.appendChild(messagesContainer);
    this._messagesContainer = messagesContainer;
  }
  /** Removes all cdk-describedby messages that are hosted through the element. */
  _removeCdkDescribedByReferenceIds(element) {
    const originalReferenceIds = getAriaReferenceIds(element, "aria-describedby").filter((id) => id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0);
    element.setAttribute("aria-describedby", originalReferenceIds.join(" "));
  }
  /**
   * Adds a message reference to the element using aria-describedby and increments the registered
   * message's reference count.
   */
  _addMessageReference(element, key) {
    const registeredMessage = this._messageRegistry.get(key);
    addAriaReferencedId(element, "aria-describedby", registeredMessage.messageElement.id);
    element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, this._id);
    registeredMessage.referenceCount++;
  }
  /**
   * Removes a message reference from the element using aria-describedby
   * and decrements the registered message's reference count.
   */
  _removeMessageReference(element, key) {
    const registeredMessage = this._messageRegistry.get(key);
    registeredMessage.referenceCount--;
    removeAriaReferencedId(element, "aria-describedby", registeredMessage.messageElement.id);
    element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);
  }
  /** Returns true if the element has been described by the provided message ID. */
  _isElementDescribedByMessage(element, key) {
    const referenceIds = getAriaReferenceIds(element, "aria-describedby");
    const registeredMessage = this._messageRegistry.get(key);
    const messageId = registeredMessage && registeredMessage.messageElement.id;
    return !!messageId && referenceIds.indexOf(messageId) != -1;
  }
  /** Determines whether a message can be described on a particular element. */
  _canBeDescribed(element, message) {
    if (!this._isElementNode(element)) {
      return false;
    }
    if (message && typeof message === "object") {
      return true;
    }
    const trimmedMessage = message == null ? "" : `${message}`.trim();
    const ariaLabel = element.getAttribute("aria-label");
    return trimmedMessage ? !ariaLabel || ariaLabel.trim() !== trimmedMessage : false;
  }
  /** Checks whether a node is an Element node. */
  _isElementNode(element) {
    return element.nodeType === this._document.ELEMENT_NODE;
  }
  static ɵfac = function AriaDescriber_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AriaDescriber)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _AriaDescriber,
    factory: _AriaDescriber.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AriaDescriber, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function getKey(message, role) {
  return typeof message === "string" ? `${role || ""}/${message}` : message;
}
function setMessageId(element, serviceId) {
  if (!element.id) {
    element.id = `${CDK_DESCRIBEDBY_ID_PREFIX}-${serviceId}-${nextId++}`;
  }
}
var DEFAULT_TYPEAHEAD_DEBOUNCE_INTERVAL_MS = 200;
var Typeahead = class {
  _letterKeyStream = new Subject();
  _items = [];
  _selectedItemIndex = -1;
  /** Buffer for the letters that the user has pressed */
  _pressedLetters = [];
  _skipPredicateFn;
  _selectedItem = new Subject();
  selectedItem = this._selectedItem;
  constructor(initialItems, config) {
    const typeAheadInterval = typeof config?.debounceInterval === "number" ? config.debounceInterval : DEFAULT_TYPEAHEAD_DEBOUNCE_INTERVAL_MS;
    if (config?.skipPredicate) {
      this._skipPredicateFn = config.skipPredicate;
    }
    if ((typeof ngDevMode === "undefined" || ngDevMode) && initialItems.length && initialItems.some((item) => typeof item.getLabel !== "function")) {
      throw new Error("KeyManager items in typeahead mode must implement the `getLabel` method.");
    }
    this.setItems(initialItems);
    this._setupKeyHandler(typeAheadInterval);
  }
  destroy() {
    this._pressedLetters = [];
    this._letterKeyStream.complete();
    this._selectedItem.complete();
  }
  setCurrentSelectedItemIndex(index) {
    this._selectedItemIndex = index;
  }
  setItems(items) {
    this._items = items;
  }
  handleKey(event) {
    const keyCode = event.keyCode;
    if (event.key && event.key.length === 1) {
      this._letterKeyStream.next(event.key.toLocaleUpperCase());
    } else if (keyCode >= A && keyCode <= Z || keyCode >= ZERO && keyCode <= NINE) {
      this._letterKeyStream.next(String.fromCharCode(keyCode));
    }
  }
  /** Gets whether the user is currently typing into the manager using the typeahead feature. */
  isTyping() {
    return this._pressedLetters.length > 0;
  }
  /** Resets the currently stored sequence of typed letters. */
  reset() {
    this._pressedLetters = [];
  }
  _setupKeyHandler(typeAheadInterval) {
    this._letterKeyStream.pipe(tap((letter) => this._pressedLetters.push(letter)), debounceTime(typeAheadInterval), filter(() => this._pressedLetters.length > 0), map(() => this._pressedLetters.join("").toLocaleUpperCase())).subscribe((inputString) => {
      for (let i = 1; i < this._items.length + 1; i++) {
        const index = (this._selectedItemIndex + i) % this._items.length;
        const item = this._items[index];
        if (!this._skipPredicateFn?.(item) && item.getLabel?.().toLocaleUpperCase().trim().indexOf(inputString) === 0) {
          this._selectedItem.next(item);
          break;
        }
      }
      this._pressedLetters = [];
    });
  }
};
var TreeKeyManager = class {
  /** The index of the currently active (focused) item. */
  _activeItemIndex = -1;
  /** The currently active (focused) item. */
  _activeItem = null;
  /** Whether or not we activate the item when it's focused. */
  _shouldActivationFollowFocus = false;
  /**
   * The orientation that the tree is laid out in. In `rtl` mode, the behavior of Left and
   * Right arrow are switched.
   */
  _horizontalOrientation = "ltr";
  /**
   * Predicate function that can be used to check whether an item should be skipped
   * by the key manager.
   *
   * The default value for this doesn't skip any elements in order to keep tree items focusable
   * when disabled. This aligns with ARIA guidelines:
   * https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#focusabilityofdisabledcontrols.
   */
  _skipPredicateFn = (_item) => false;
  /** Function to determine equivalent items. */
  _trackByFn = (item) => item;
  /** Synchronous cache of the items to manage. */
  _items = [];
  _typeahead;
  _typeaheadSubscription = Subscription.EMPTY;
  _hasInitialFocused = false;
  _initializeFocus() {
    if (this._hasInitialFocused || this._items.length === 0) {
      return;
    }
    let activeIndex = 0;
    for (let i = 0; i < this._items.length; i++) {
      if (!this._skipPredicateFn(this._items[i]) && !this._isItemDisabled(this._items[i])) {
        activeIndex = i;
        break;
      }
    }
    const activeItem = this._items[activeIndex];
    if (activeItem.makeFocusable) {
      this._activeItem?.unfocus();
      this._activeItemIndex = activeIndex;
      this._activeItem = activeItem;
      this._typeahead?.setCurrentSelectedItemIndex(activeIndex);
      activeItem.makeFocusable();
    } else {
      this.focusItem(activeIndex);
    }
    this._hasInitialFocused = true;
  }
  /**
   *
   * @param items List of TreeKeyManager options. Can be synchronous or asynchronous.
   * @param config Optional configuration options. By default, use 'ltr' horizontal orientation. By
   * default, do not skip any nodes. By default, key manager only calls `focus` method when items
   * are focused and does not call `activate`. If `typeaheadDefaultInterval` is `true`, use a
   * default interval of 200ms.
   */
  constructor(items, config) {
    if (items instanceof QueryList) {
      this._items = items.toArray();
      items.changes.subscribe((newItems) => {
        this._items = newItems.toArray();
        this._typeahead?.setItems(this._items);
        this._updateActiveItemIndex(this._items);
        this._initializeFocus();
      });
    } else if (isObservable(items)) {
      items.subscribe((newItems) => {
        this._items = newItems;
        this._typeahead?.setItems(newItems);
        this._updateActiveItemIndex(newItems);
        this._initializeFocus();
      });
    } else {
      this._items = items;
      this._initializeFocus();
    }
    if (typeof config.shouldActivationFollowFocus === "boolean") {
      this._shouldActivationFollowFocus = config.shouldActivationFollowFocus;
    }
    if (config.horizontalOrientation) {
      this._horizontalOrientation = config.horizontalOrientation;
    }
    if (config.skipPredicate) {
      this._skipPredicateFn = config.skipPredicate;
    }
    if (config.trackBy) {
      this._trackByFn = config.trackBy;
    }
    if (typeof config.typeAheadDebounceInterval !== "undefined") {
      this._setTypeAhead(config.typeAheadDebounceInterval);
    }
  }
  /** Stream that emits any time the focused item changes. */
  change = new Subject();
  /** Cleans up the key manager. */
  destroy() {
    this._typeaheadSubscription.unsubscribe();
    this._typeahead?.destroy();
    this.change.complete();
  }
  /**
   * Handles a keyboard event on the tree.
   * @param event Keyboard event that represents the user interaction with the tree.
   */
  onKeydown(event) {
    const key = event.key;
    switch (key) {
      case "Tab":
        return;
      case "ArrowDown":
        this._focusNextItem();
        break;
      case "ArrowUp":
        this._focusPreviousItem();
        break;
      case "ArrowRight":
        this._horizontalOrientation === "rtl" ? this._collapseCurrentItem() : this._expandCurrentItem();
        break;
      case "ArrowLeft":
        this._horizontalOrientation === "rtl" ? this._expandCurrentItem() : this._collapseCurrentItem();
        break;
      case "Home":
        this._focusFirstItem();
        break;
      case "End":
        this._focusLastItem();
        break;
      case "Enter":
      case " ":
        this._activateCurrentItem();
        break;
      default:
        if (event.key === "*") {
          this._expandAllItemsAtCurrentItemLevel();
          break;
        }
        this._typeahead?.handleKey(event);
        return;
    }
    this._typeahead?.reset();
    event.preventDefault();
  }
  /** Index of the currently active item. */
  getActiveItemIndex() {
    return this._activeItemIndex;
  }
  /** The currently active item. */
  getActiveItem() {
    return this._activeItem;
  }
  /** Focus the first available item. */
  _focusFirstItem() {
    this.focusItem(this._findNextAvailableItemIndex(-1));
  }
  /** Focus the last available item. */
  _focusLastItem() {
    this.focusItem(this._findPreviousAvailableItemIndex(this._items.length));
  }
  /** Focus the next available item. */
  _focusNextItem() {
    this.focusItem(this._findNextAvailableItemIndex(this._activeItemIndex));
  }
  /** Focus the previous available item. */
  _focusPreviousItem() {
    this.focusItem(this._findPreviousAvailableItemIndex(this._activeItemIndex));
  }
  focusItem(itemOrIndex, options = {}) {
    options.emitChangeEvent ??= true;
    let index = typeof itemOrIndex === "number" ? itemOrIndex : this._items.findIndex((item) => this._trackByFn(item) === this._trackByFn(itemOrIndex));
    if (index < 0 || index >= this._items.length) {
      return;
    }
    const activeItem = this._items[index];
    if (this._activeItem !== null && this._trackByFn(activeItem) === this._trackByFn(this._activeItem)) {
      return;
    }
    const previousActiveItem = this._activeItem;
    this._activeItem = activeItem ?? null;
    this._activeItemIndex = index;
    this._typeahead?.setCurrentSelectedItemIndex(index);
    this._activeItem?.focus();
    previousActiveItem?.unfocus();
    if (options.emitChangeEvent) {
      this.change.next(this._activeItem);
    }
    if (this._shouldActivationFollowFocus) {
      this._activateCurrentItem();
    }
  }
  _updateActiveItemIndex(newItems) {
    const activeItem = this._activeItem;
    if (!activeItem) {
      return;
    }
    const newIndex = newItems.findIndex((item) => this._trackByFn(item) === this._trackByFn(activeItem));
    if (newIndex > -1 && newIndex !== this._activeItemIndex) {
      this._activeItemIndex = newIndex;
      this._typeahead?.setCurrentSelectedItemIndex(newIndex);
    }
  }
  _setTypeAhead(debounceInterval) {
    this._typeahead = new Typeahead(this._items, {
      debounceInterval: typeof debounceInterval === "number" ? debounceInterval : void 0,
      skipPredicate: (item) => this._skipPredicateFn(item)
    });
    this._typeaheadSubscription = this._typeahead.selectedItem.subscribe((item) => {
      this.focusItem(item);
    });
  }
  _findNextAvailableItemIndex(startingIndex) {
    for (let i = startingIndex + 1; i < this._items.length; i++) {
      if (!this._skipPredicateFn(this._items[i])) {
        return i;
      }
    }
    return startingIndex;
  }
  _findPreviousAvailableItemIndex(startingIndex) {
    for (let i = startingIndex - 1; i >= 0; i--) {
      if (!this._skipPredicateFn(this._items[i])) {
        return i;
      }
    }
    return startingIndex;
  }
  /**
   * If the item is already expanded, we collapse the item. Otherwise, we will focus the parent.
   */
  _collapseCurrentItem() {
    if (!this._activeItem) {
      return;
    }
    if (this._isCurrentItemExpanded()) {
      this._activeItem.collapse();
    } else {
      const parent = this._activeItem.getParent();
      if (!parent || this._skipPredicateFn(parent)) {
        return;
      }
      this.focusItem(parent);
    }
  }
  /**
   * If the item is already collapsed, we expand the item. Otherwise, we will focus the first child.
   */
  _expandCurrentItem() {
    if (!this._activeItem) {
      return;
    }
    if (!this._isCurrentItemExpanded()) {
      this._activeItem.expand();
    } else {
      coerceObservable(this._activeItem.getChildren()).pipe(take(1)).subscribe((children) => {
        const firstChild = children.find((child) => !this._skipPredicateFn(child));
        if (!firstChild) {
          return;
        }
        this.focusItem(firstChild);
      });
    }
  }
  _isCurrentItemExpanded() {
    if (!this._activeItem) {
      return false;
    }
    return typeof this._activeItem.isExpanded === "boolean" ? this._activeItem.isExpanded : this._activeItem.isExpanded();
  }
  _isItemDisabled(item) {
    return typeof item.isDisabled === "boolean" ? item.isDisabled : item.isDisabled?.();
  }
  /** For all items that are the same level as the current item, we expand those items. */
  _expandAllItemsAtCurrentItemLevel() {
    if (!this._activeItem) {
      return;
    }
    const parent = this._activeItem.getParent();
    let itemsToExpand;
    if (!parent) {
      itemsToExpand = of(this._items.filter((item) => item.getParent() === null));
    } else {
      itemsToExpand = coerceObservable(parent.getChildren());
    }
    itemsToExpand.pipe(take(1)).subscribe((items) => {
      for (const item of items) {
        item.expand();
      }
    });
  }
  _activateCurrentItem() {
    this._activeItem?.activate();
  }
};
function TREE_KEY_MANAGER_FACTORY() {
  return (items, options) => new TreeKeyManager(items, options);
}
var TREE_KEY_MANAGER = new InjectionToken("tree-key-manager", {
  providedIn: "root",
  factory: TREE_KEY_MANAGER_FACTORY
});
var InteractivityChecker = class _InteractivityChecker {
  _platform = inject(Platform);
  constructor() {
  }
  /**
   * Gets whether an element is disabled.
   *
   * @param element Element to be checked.
   * @returns Whether the element is disabled.
   */
  isDisabled(element) {
    return element.hasAttribute("disabled");
  }
  /**
   * Gets whether an element is visible for the purposes of interactivity.
   *
   * This will capture states like `display: none` and `visibility: hidden`, but not things like
   * being clipped by an `overflow: hidden` parent or being outside the viewport.
   *
   * @returns Whether the element is visible.
   */
  isVisible(element) {
    return hasGeometry(element) && getComputedStyle(element).visibility === "visible";
  }
  /**
   * Gets whether an element can be reached via Tab key.
   * Assumes that the element has already been checked with isFocusable.
   *
   * @param element Element to be checked.
   * @returns Whether the element is tabbable.
   */
  isTabbable(element) {
    if (!this._platform.isBrowser) {
      return false;
    }
    const frameElement = getFrameElement(getWindow(element));
    if (frameElement) {
      if (getTabIndexValue(frameElement) === -1) {
        return false;
      }
      if (!this.isVisible(frameElement)) {
        return false;
      }
    }
    let nodeName = element.nodeName.toLowerCase();
    let tabIndexValue = getTabIndexValue(element);
    if (element.hasAttribute("contenteditable")) {
      return tabIndexValue !== -1;
    }
    if (nodeName === "iframe" || nodeName === "object") {
      return false;
    }
    if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {
      return false;
    }
    if (nodeName === "audio") {
      if (!element.hasAttribute("controls")) {
        return false;
      }
      return tabIndexValue !== -1;
    }
    if (nodeName === "video") {
      if (tabIndexValue === -1) {
        return false;
      }
      if (tabIndexValue !== null) {
        return true;
      }
      return this._platform.FIREFOX || element.hasAttribute("controls");
    }
    return element.tabIndex >= 0;
  }
  /**
   * Gets whether an element can be focused by the user.
   *
   * @param element Element to be checked.
   * @param config The config object with options to customize this method's behavior
   * @returns Whether the element is focusable.
   */
  isFocusable(element, config) {
    return isPotentiallyFocusable(element) && !this.isDisabled(element) && (config?.ignoreVisibility || this.isVisible(element));
  }
  static ɵfac = function InteractivityChecker_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _InteractivityChecker)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _InteractivityChecker,
    factory: _InteractivityChecker.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InteractivityChecker, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function getFrameElement(window2) {
  try {
    return window2.frameElement;
  } catch {
    return null;
  }
}
function hasGeometry(element) {
  return !!(element.offsetWidth || element.offsetHeight || typeof element.getClientRects === "function" && element.getClientRects().length);
}
function isNativeFormElement(element) {
  let nodeName = element.nodeName.toLowerCase();
  return nodeName === "input" || nodeName === "select" || nodeName === "button" || nodeName === "textarea";
}
function isHiddenInput(element) {
  return isInputElement(element) && element.type == "hidden";
}
function isAnchorWithHref(element) {
  return isAnchorElement(element) && element.hasAttribute("href");
}
function isInputElement(element) {
  return element.nodeName.toLowerCase() == "input";
}
function isAnchorElement(element) {
  return element.nodeName.toLowerCase() == "a";
}
function hasValidTabIndex(element) {
  if (!element.hasAttribute("tabindex") || element.tabIndex === void 0) {
    return false;
  }
  let tabIndex = element.getAttribute("tabindex");
  return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));
}
function getTabIndexValue(element) {
  if (!hasValidTabIndex(element)) {
    return null;
  }
  const tabIndex = parseInt(element.getAttribute("tabindex") || "", 10);
  return isNaN(tabIndex) ? -1 : tabIndex;
}
function isPotentiallyTabbableIOS(element) {
  let nodeName = element.nodeName.toLowerCase();
  let inputType = nodeName === "input" && element.type;
  return inputType === "text" || inputType === "password" || nodeName === "select" || nodeName === "textarea";
}
function isPotentiallyFocusable(element) {
  if (isHiddenInput(element)) {
    return false;
  }
  return isNativeFormElement(element) || isAnchorWithHref(element) || element.hasAttribute("contenteditable") || hasValidTabIndex(element);
}
function getWindow(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || window;
}
var FocusTrap = class {
  _element;
  _checker;
  _ngZone;
  _document;
  _injector;
  _startAnchor;
  _endAnchor;
  _hasAttached = false;
  // Event listeners for the anchors. Need to be regular functions so that we can unbind them later.
  startAnchorListener = () => this.focusLastTabbableElement();
  endAnchorListener = () => this.focusFirstTabbableElement();
  /** Whether the focus trap is active. */
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    if (this._startAnchor && this._endAnchor) {
      this._toggleAnchorTabIndex(value, this._startAnchor);
      this._toggleAnchorTabIndex(value, this._endAnchor);
    }
  }
  _enabled = true;
  constructor(_element, _checker, _ngZone, _document, deferAnchors = false, _injector) {
    this._element = _element;
    this._checker = _checker;
    this._ngZone = _ngZone;
    this._document = _document;
    this._injector = _injector;
    if (!deferAnchors) {
      this.attachAnchors();
    }
  }
  /** Destroys the focus trap by cleaning up the anchors. */
  destroy() {
    const startAnchor = this._startAnchor;
    const endAnchor = this._endAnchor;
    if (startAnchor) {
      startAnchor.removeEventListener("focus", this.startAnchorListener);
      startAnchor.remove();
    }
    if (endAnchor) {
      endAnchor.removeEventListener("focus", this.endAnchorListener);
      endAnchor.remove();
    }
    this._startAnchor = this._endAnchor = null;
    this._hasAttached = false;
  }
  /**
   * Inserts the anchors into the DOM. This is usually done automatically
   * in the constructor, but can be deferred for cases like directives with `*ngIf`.
   * @returns Whether the focus trap managed to attach successfully. This may not be the case
   * if the target element isn't currently in the DOM.
   */
  attachAnchors() {
    if (this._hasAttached) {
      return true;
    }
    this._ngZone.runOutsideAngular(() => {
      if (!this._startAnchor) {
        this._startAnchor = this._createAnchor();
        this._startAnchor.addEventListener("focus", this.startAnchorListener);
      }
      if (!this._endAnchor) {
        this._endAnchor = this._createAnchor();
        this._endAnchor.addEventListener("focus", this.endAnchorListener);
      }
    });
    if (this._element.parentNode) {
      this._element.parentNode.insertBefore(this._startAnchor, this._element);
      this._element.parentNode.insertBefore(this._endAnchor, this._element.nextSibling);
      this._hasAttached = true;
    }
    return this._hasAttached;
  }
  /**
   * Waits for the zone to stabilize, then focuses the first tabbable element.
   * @returns Returns a promise that resolves with a boolean, depending
   * on whether focus was moved successfully.
   */
  focusInitialElementWhenReady(options) {
    return new Promise((resolve) => {
      this._executeOnStable(() => resolve(this.focusInitialElement(options)));
    });
  }
  /**
   * Waits for the zone to stabilize, then focuses
   * the first tabbable element within the focus trap region.
   * @returns Returns a promise that resolves with a boolean, depending
   * on whether focus was moved successfully.
   */
  focusFirstTabbableElementWhenReady(options) {
    return new Promise((resolve) => {
      this._executeOnStable(() => resolve(this.focusFirstTabbableElement(options)));
    });
  }
  /**
   * Waits for the zone to stabilize, then focuses
   * the last tabbable element within the focus trap region.
   * @returns Returns a promise that resolves with a boolean, depending
   * on whether focus was moved successfully.
   */
  focusLastTabbableElementWhenReady(options) {
    return new Promise((resolve) => {
      this._executeOnStable(() => resolve(this.focusLastTabbableElement(options)));
    });
  }
  /**
   * Get the specified boundary element of the trapped region.
   * @param bound The boundary to get (start or end of trapped region).
   * @returns The boundary element.
   */
  _getRegionBoundary(bound) {
    const markers = this._element.querySelectorAll(`[cdk-focus-region-${bound}], [cdkFocusRegion${bound}], [cdk-focus-${bound}]`);
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      for (let i = 0; i < markers.length; i++) {
        if (markers[i].hasAttribute(`cdk-focus-${bound}`)) {
          console.warn(`Found use of deprecated attribute 'cdk-focus-${bound}', use 'cdkFocusRegion${bound}' instead. The deprecated attribute will be removed in 8.0.0.`, markers[i]);
        } else if (markers[i].hasAttribute(`cdk-focus-region-${bound}`)) {
          console.warn(`Found use of deprecated attribute 'cdk-focus-region-${bound}', use 'cdkFocusRegion${bound}' instead. The deprecated attribute will be removed in 8.0.0.`, markers[i]);
        }
      }
    }
    if (bound == "start") {
      return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);
    }
    return markers.length ? markers[markers.length - 1] : this._getLastTabbableElement(this._element);
  }
  /**
   * Focuses the element that should be focused when the focus trap is initialized.
   * @returns Whether focus was moved successfully.
   */
  focusInitialElement(options) {
    const redirectToElement = this._element.querySelector(`[cdk-focus-initial], [cdkFocusInitial]`);
    if (redirectToElement) {
      if ((typeof ngDevMode === "undefined" || ngDevMode) && redirectToElement.hasAttribute(`cdk-focus-initial`)) {
        console.warn(`Found use of deprecated attribute 'cdk-focus-initial', use 'cdkFocusInitial' instead. The deprecated attribute will be removed in 8.0.0`, redirectToElement);
      }
      if ((typeof ngDevMode === "undefined" || ngDevMode) && !this._checker.isFocusable(redirectToElement)) {
        console.warn(`Element matching '[cdkFocusInitial]' is not focusable.`, redirectToElement);
      }
      if (!this._checker.isFocusable(redirectToElement)) {
        const focusableChild = this._getFirstTabbableElement(redirectToElement);
        focusableChild?.focus(options);
        return !!focusableChild;
      }
      redirectToElement.focus(options);
      return true;
    }
    return this.focusFirstTabbableElement(options);
  }
  /**
   * Focuses the first tabbable element within the focus trap region.
   * @returns Whether focus was moved successfully.
   */
  focusFirstTabbableElement(options) {
    const redirectToElement = this._getRegionBoundary("start");
    if (redirectToElement) {
      redirectToElement.focus(options);
    }
    return !!redirectToElement;
  }
  /**
   * Focuses the last tabbable element within the focus trap region.
   * @returns Whether focus was moved successfully.
   */
  focusLastTabbableElement(options) {
    const redirectToElement = this._getRegionBoundary("end");
    if (redirectToElement) {
      redirectToElement.focus(options);
    }
    return !!redirectToElement;
  }
  /**
   * Checks whether the focus trap has successfully been attached.
   */
  hasAttached() {
    return this._hasAttached;
  }
  /** Get the first tabbable element from a DOM subtree (inclusive). */
  _getFirstTabbableElement(root) {
    if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {
      return root;
    }
    const children = root.children;
    for (let i = 0; i < children.length; i++) {
      const tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ? this._getFirstTabbableElement(children[i]) : null;
      if (tabbableChild) {
        return tabbableChild;
      }
    }
    return null;
  }
  /** Get the last tabbable element from a DOM subtree (inclusive). */
  _getLastTabbableElement(root) {
    if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {
      return root;
    }
    const children = root.children;
    for (let i = children.length - 1; i >= 0; i--) {
      const tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ? this._getLastTabbableElement(children[i]) : null;
      if (tabbableChild) {
        return tabbableChild;
      }
    }
    return null;
  }
  /** Creates an anchor element. */
  _createAnchor() {
    const anchor = this._document.createElement("div");
    this._toggleAnchorTabIndex(this._enabled, anchor);
    anchor.classList.add("cdk-visually-hidden");
    anchor.classList.add("cdk-focus-trap-anchor");
    anchor.setAttribute("aria-hidden", "true");
    return anchor;
  }
  /**
   * Toggles the `tabindex` of an anchor, based on the enabled state of the focus trap.
   * @param isEnabled Whether the focus trap is enabled.
   * @param anchor Anchor on which to toggle the tabindex.
   */
  _toggleAnchorTabIndex(isEnabled, anchor) {
    isEnabled ? anchor.setAttribute("tabindex", "0") : anchor.removeAttribute("tabindex");
  }
  /**
   * Toggles the`tabindex` of both anchors to either trap Tab focus or allow it to escape.
   * @param enabled: Whether the anchors should trap Tab.
   */
  toggleAnchors(enabled) {
    if (this._startAnchor && this._endAnchor) {
      this._toggleAnchorTabIndex(enabled, this._startAnchor);
      this._toggleAnchorTabIndex(enabled, this._endAnchor);
    }
  }
  /** Executes a function when the zone is stable. */
  _executeOnStable(fn) {
    if (this._injector) {
      afterNextRender(fn, {
        injector: this._injector
      });
    } else {
      setTimeout(fn);
    }
  }
};
var FocusTrapFactory = class _FocusTrapFactory {
  _checker = inject(InteractivityChecker);
  _ngZone = inject(NgZone);
  _document = inject(DOCUMENT);
  _injector = inject(Injector);
  constructor() {
    inject(_CdkPrivateStyleLoader).load(_VisuallyHiddenLoader);
  }
  /**
   * Creates a focus-trapped region around the given element.
   * @param element The element around which focus will be trapped.
   * @param deferCaptureElements Defers the creation of focus-capturing elements to be done
   *     manually by the user.
   * @returns The created focus trap instance.
   */
  create(element, deferCaptureElements = false) {
    return new FocusTrap(element, this._checker, this._ngZone, this._document, deferCaptureElements, this._injector);
  }
  static ɵfac = function FocusTrapFactory_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FocusTrapFactory)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _FocusTrapFactory,
    factory: _FocusTrapFactory.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusTrapFactory, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var CdkTrapFocus = class _CdkTrapFocus {
  _elementRef = inject(ElementRef);
  _focusTrapFactory = inject(FocusTrapFactory);
  /** Underlying FocusTrap instance. */
  focusTrap;
  /** Previously focused element to restore focus to upon destroy when using autoCapture. */
  _previouslyFocusedElement = null;
  /** Whether the focus trap is active. */
  get enabled() {
    return this.focusTrap?.enabled || false;
  }
  set enabled(value) {
    if (this.focusTrap) {
      this.focusTrap.enabled = value;
    }
  }
  /**
   * Whether the directive should automatically move focus into the trapped region upon
   * initialization and return focus to the previous activeElement upon destruction.
   */
  autoCapture;
  constructor() {
    const platform = inject(Platform);
    if (platform.isBrowser) {
      this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);
    }
  }
  ngOnDestroy() {
    this.focusTrap?.destroy();
    if (this._previouslyFocusedElement) {
      this._previouslyFocusedElement.focus();
      this._previouslyFocusedElement = null;
    }
  }
  ngAfterContentInit() {
    this.focusTrap?.attachAnchors();
    if (this.autoCapture) {
      this._captureFocus();
    }
  }
  ngDoCheck() {
    if (this.focusTrap && !this.focusTrap.hasAttached()) {
      this.focusTrap.attachAnchors();
    }
  }
  ngOnChanges(changes) {
    const autoCaptureChange = changes["autoCapture"];
    if (autoCaptureChange && !autoCaptureChange.firstChange && this.autoCapture && this.focusTrap?.hasAttached()) {
      this._captureFocus();
    }
  }
  _captureFocus() {
    this._previouslyFocusedElement = _getFocusedElementPierceShadowDom();
    this.focusTrap?.focusInitialElementWhenReady();
  }
  static ɵfac = function CdkTrapFocus_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkTrapFocus)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkTrapFocus,
    selectors: [["", "cdkTrapFocus", ""]],
    inputs: {
      enabled: [2, "cdkTrapFocus", "enabled", booleanAttribute],
      autoCapture: [2, "cdkTrapFocusAutoCapture", "autoCapture", booleanAttribute]
    },
    exportAs: ["cdkTrapFocus"],
    features: [ɵɵInputTransformsFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTrapFocus, [{
    type: Directive,
    args: [{
      selector: "[cdkTrapFocus]",
      exportAs: "cdkTrapFocus"
    }]
  }], () => [], {
    enabled: [{
      type: Input,
      args: [{
        alias: "cdkTrapFocus",
        transform: booleanAttribute
      }]
    }],
    autoCapture: [{
      type: Input,
      args: [{
        alias: "cdkTrapFocusAutoCapture",
        transform: booleanAttribute
      }]
    }]
  });
})();
var ConfigurableFocusTrap = class extends FocusTrap {
  _focusTrapManager;
  _inertStrategy;
  /** Whether the FocusTrap is enabled. */
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    if (this._enabled) {
      this._focusTrapManager.register(this);
    } else {
      this._focusTrapManager.deregister(this);
    }
  }
  constructor(_element, _checker, _ngZone, _document, _focusTrapManager, _inertStrategy, config, injector) {
    super(_element, _checker, _ngZone, _document, config.defer, injector);
    this._focusTrapManager = _focusTrapManager;
    this._inertStrategy = _inertStrategy;
    this._focusTrapManager.register(this);
  }
  /** Notifies the FocusTrapManager that this FocusTrap will be destroyed. */
  destroy() {
    this._focusTrapManager.deregister(this);
    super.destroy();
  }
  /** @docs-private Implemented as part of ManagedFocusTrap. */
  _enable() {
    this._inertStrategy.preventFocus(this);
    this.toggleAnchors(true);
  }
  /** @docs-private Implemented as part of ManagedFocusTrap. */
  _disable() {
    this._inertStrategy.allowFocus(this);
    this.toggleAnchors(false);
  }
};
var EventListenerFocusTrapInertStrategy = class {
  /** Focus event handler. */
  _listener = null;
  /** Adds a document event listener that keeps focus inside the FocusTrap. */
  preventFocus(focusTrap) {
    if (this._listener) {
      focusTrap._document.removeEventListener("focus", this._listener, true);
    }
    this._listener = (e5) => this._trapFocus(focusTrap, e5);
    focusTrap._ngZone.runOutsideAngular(() => {
      focusTrap._document.addEventListener("focus", this._listener, true);
    });
  }
  /** Removes the event listener added in preventFocus. */
  allowFocus(focusTrap) {
    if (!this._listener) {
      return;
    }
    focusTrap._document.removeEventListener("focus", this._listener, true);
    this._listener = null;
  }
  /**
   * Refocuses the first element in the FocusTrap if the focus event target was outside
   * the FocusTrap.
   *
   * This is an event listener callback. The event listener is added in runOutsideAngular,
   * so all this code runs outside Angular as well.
   */
  _trapFocus(focusTrap, event) {
    const target = event.target;
    const focusTrapRoot = focusTrap._element;
    if (target && !focusTrapRoot.contains(target) && !target.closest?.("div.cdk-overlay-pane")) {
      setTimeout(() => {
        if (focusTrap.enabled && !focusTrapRoot.contains(focusTrap._document.activeElement)) {
          focusTrap.focusFirstTabbableElement();
        }
      });
    }
  }
};
var FOCUS_TRAP_INERT_STRATEGY = new InjectionToken("FOCUS_TRAP_INERT_STRATEGY");
var FocusTrapManager = class _FocusTrapManager {
  // A stack of the FocusTraps on the page. Only the FocusTrap at the
  // top of the stack is active.
  _focusTrapStack = [];
  /**
   * Disables the FocusTrap at the top of the stack, and then pushes
   * the new FocusTrap onto the stack.
   */
  register(focusTrap) {
    this._focusTrapStack = this._focusTrapStack.filter((ft) => ft !== focusTrap);
    let stack = this._focusTrapStack;
    if (stack.length) {
      stack[stack.length - 1]._disable();
    }
    stack.push(focusTrap);
    focusTrap._enable();
  }
  /**
   * Removes the FocusTrap from the stack, and activates the
   * FocusTrap that is the new top of the stack.
   */
  deregister(focusTrap) {
    focusTrap._disable();
    const stack = this._focusTrapStack;
    const i = stack.indexOf(focusTrap);
    if (i !== -1) {
      stack.splice(i, 1);
      if (stack.length) {
        stack[stack.length - 1]._enable();
      }
    }
  }
  static ɵfac = function FocusTrapManager_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FocusTrapManager)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _FocusTrapManager,
    factory: _FocusTrapManager.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusTrapManager, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var ConfigurableFocusTrapFactory = class _ConfigurableFocusTrapFactory {
  _checker = inject(InteractivityChecker);
  _ngZone = inject(NgZone);
  _focusTrapManager = inject(FocusTrapManager);
  _document = inject(DOCUMENT);
  _inertStrategy;
  _injector = inject(Injector);
  constructor() {
    const inertStrategy = inject(FOCUS_TRAP_INERT_STRATEGY, {
      optional: true
    });
    this._inertStrategy = inertStrategy || new EventListenerFocusTrapInertStrategy();
  }
  create(element, config = {
    defer: false
  }) {
    let configObject;
    if (typeof config === "boolean") {
      configObject = {
        defer: config
      };
    } else {
      configObject = config;
    }
    return new ConfigurableFocusTrap(element, this._checker, this._ngZone, this._document, this._focusTrapManager, this._inertStrategy, configObject, this._injector);
  }
  static ɵfac = function ConfigurableFocusTrapFactory_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ConfigurableFocusTrapFactory)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ConfigurableFocusTrapFactory,
    factory: _ConfigurableFocusTrapFactory.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ConfigurableFocusTrapFactory, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function isFakeMousedownFromScreenReader(event) {
  return event.buttons === 0 || event.detail === 0;
}
function isFakeTouchstartFromScreenReader(event) {
  const touch = event.touches && event.touches[0] || event.changedTouches && event.changedTouches[0];
  return !!touch && touch.identifier === -1 && (touch.radiusX == null || touch.radiusX === 1) && (touch.radiusY == null || touch.radiusY === 1);
}
var INPUT_MODALITY_DETECTOR_OPTIONS = new InjectionToken("cdk-input-modality-detector-options");
var INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS = {
  ignoreKeys: [ALT, CONTROL, MAC_META, META, SHIFT]
};
var TOUCH_BUFFER_MS = 650;
var modalityEventListenerOptions = normalizePassiveListenerOptions({
  passive: true,
  capture: true
});
var InputModalityDetector = class _InputModalityDetector {
  _platform = inject(Platform);
  /** Emits whenever an input modality is detected. */
  modalityDetected;
  /** Emits when the input modality changes. */
  modalityChanged;
  /** The most recently detected input modality. */
  get mostRecentModality() {
    return this._modality.value;
  }
  /**
   * The most recently detected input modality event target. Is null if no input modality has been
   * detected or if the associated event target is null for some unknown reason.
   */
  _mostRecentTarget = null;
  /** The underlying BehaviorSubject that emits whenever an input modality is detected. */
  _modality = new BehaviorSubject(null);
  /** Options for this InputModalityDetector. */
  _options;
  /**
   * The timestamp of the last touch input modality. Used to determine whether mousedown events
   * should be attributed to mouse or touch.
   */
  _lastTouchMs = 0;
  /**
   * Handles keydown events. Must be an arrow function in order to preserve the context when it gets
   * bound.
   */
  _onKeydown = (event) => {
    if (this._options?.ignoreKeys?.some((keyCode) => keyCode === event.keyCode)) {
      return;
    }
    this._modality.next("keyboard");
    this._mostRecentTarget = _getEventTarget(event);
  };
  /**
   * Handles mousedown events. Must be an arrow function in order to preserve the context when it
   * gets bound.
   */
  _onMousedown = (event) => {
    if (Date.now() - this._lastTouchMs < TOUCH_BUFFER_MS) {
      return;
    }
    this._modality.next(isFakeMousedownFromScreenReader(event) ? "keyboard" : "mouse");
    this._mostRecentTarget = _getEventTarget(event);
  };
  /**
   * Handles touchstart events. Must be an arrow function in order to preserve the context when it
   * gets bound.
   */
  _onTouchstart = (event) => {
    if (isFakeTouchstartFromScreenReader(event)) {
      this._modality.next("keyboard");
      return;
    }
    this._lastTouchMs = Date.now();
    this._modality.next("touch");
    this._mostRecentTarget = _getEventTarget(event);
  };
  constructor() {
    const ngZone = inject(NgZone);
    const document2 = inject(DOCUMENT);
    const options = inject(INPUT_MODALITY_DETECTOR_OPTIONS, {
      optional: true
    });
    this._options = __spreadValues(__spreadValues({}, INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS), options);
    this.modalityDetected = this._modality.pipe(skip(1));
    this.modalityChanged = this.modalityDetected.pipe(distinctUntilChanged());
    if (this._platform.isBrowser) {
      ngZone.runOutsideAngular(() => {
        document2.addEventListener("keydown", this._onKeydown, modalityEventListenerOptions);
        document2.addEventListener("mousedown", this._onMousedown, modalityEventListenerOptions);
        document2.addEventListener("touchstart", this._onTouchstart, modalityEventListenerOptions);
      });
    }
  }
  ngOnDestroy() {
    this._modality.complete();
    if (this._platform.isBrowser) {
      document.removeEventListener("keydown", this._onKeydown, modalityEventListenerOptions);
      document.removeEventListener("mousedown", this._onMousedown, modalityEventListenerOptions);
      document.removeEventListener("touchstart", this._onTouchstart, modalityEventListenerOptions);
    }
  }
  static ɵfac = function InputModalityDetector_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _InputModalityDetector)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _InputModalityDetector,
    factory: _InputModalityDetector.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InputModalityDetector, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var LIVE_ANNOUNCER_ELEMENT_TOKEN = new InjectionToken("liveAnnouncerElement", {
  providedIn: "root",
  factory: LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY
});
function LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY() {
  return null;
}
var LIVE_ANNOUNCER_DEFAULT_OPTIONS = new InjectionToken("LIVE_ANNOUNCER_DEFAULT_OPTIONS");
var uniqueIds = 0;
var LiveAnnouncer = class _LiveAnnouncer {
  _ngZone = inject(NgZone);
  _defaultOptions = inject(LIVE_ANNOUNCER_DEFAULT_OPTIONS, {
    optional: true
  });
  _liveElement;
  _document = inject(DOCUMENT);
  _previousTimeout;
  _currentPromise;
  _currentResolve;
  constructor() {
    const elementToken = inject(LIVE_ANNOUNCER_ELEMENT_TOKEN, {
      optional: true
    });
    this._liveElement = elementToken || this._createLiveElement();
  }
  announce(message, ...args) {
    const defaultOptions = this._defaultOptions;
    let politeness;
    let duration;
    if (args.length === 1 && typeof args[0] === "number") {
      duration = args[0];
    } else {
      [politeness, duration] = args;
    }
    this.clear();
    clearTimeout(this._previousTimeout);
    if (!politeness) {
      politeness = defaultOptions && defaultOptions.politeness ? defaultOptions.politeness : "polite";
    }
    if (duration == null && defaultOptions) {
      duration = defaultOptions.duration;
    }
    this._liveElement.setAttribute("aria-live", politeness);
    if (this._liveElement.id) {
      this._exposeAnnouncerToModals(this._liveElement.id);
    }
    return this._ngZone.runOutsideAngular(() => {
      if (!this._currentPromise) {
        this._currentPromise = new Promise((resolve) => this._currentResolve = resolve);
      }
      clearTimeout(this._previousTimeout);
      this._previousTimeout = setTimeout(() => {
        this._liveElement.textContent = message;
        if (typeof duration === "number") {
          this._previousTimeout = setTimeout(() => this.clear(), duration);
        }
        this._currentResolve?.();
        this._currentPromise = this._currentResolve = void 0;
      }, 100);
      return this._currentPromise;
    });
  }
  /**
   * Clears the current text from the announcer element. Can be used to prevent
   * screen readers from reading the text out again while the user is going
   * through the page landmarks.
   */
  clear() {
    if (this._liveElement) {
      this._liveElement.textContent = "";
    }
  }
  ngOnDestroy() {
    clearTimeout(this._previousTimeout);
    this._liveElement?.remove();
    this._liveElement = null;
    this._currentResolve?.();
    this._currentPromise = this._currentResolve = void 0;
  }
  _createLiveElement() {
    const elementClass = "cdk-live-announcer-element";
    const previousElements = this._document.getElementsByClassName(elementClass);
    const liveEl = this._document.createElement("div");
    for (let i = 0; i < previousElements.length; i++) {
      previousElements[i].remove();
    }
    liveEl.classList.add(elementClass);
    liveEl.classList.add("cdk-visually-hidden");
    liveEl.setAttribute("aria-atomic", "true");
    liveEl.setAttribute("aria-live", "polite");
    liveEl.id = `cdk-live-announcer-${uniqueIds++}`;
    this._document.body.appendChild(liveEl);
    return liveEl;
  }
  /**
   * Some browsers won't expose the accessibility node of the live announcer element if there is an
   * `aria-modal` and the live announcer is outside of it. This method works around the issue by
   * pointing the `aria-owns` of all modals to the live announcer element.
   */
  _exposeAnnouncerToModals(id) {
    const modals = this._document.querySelectorAll('body > .cdk-overlay-container [aria-modal="true"]');
    for (let i = 0; i < modals.length; i++) {
      const modal = modals[i];
      const ariaOwns = modal.getAttribute("aria-owns");
      if (!ariaOwns) {
        modal.setAttribute("aria-owns", id);
      } else if (ariaOwns.indexOf(id) === -1) {
        modal.setAttribute("aria-owns", ariaOwns + " " + id);
      }
    }
  }
  static ɵfac = function LiveAnnouncer_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LiveAnnouncer)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _LiveAnnouncer,
    factory: _LiveAnnouncer.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LiveAnnouncer, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var CdkAriaLive = class _CdkAriaLive {
  _elementRef = inject(ElementRef);
  _liveAnnouncer = inject(LiveAnnouncer);
  _contentObserver = inject(ContentObserver);
  _ngZone = inject(NgZone);
  /** The aria-live politeness level to use when announcing messages. */
  get politeness() {
    return this._politeness;
  }
  set politeness(value) {
    this._politeness = value === "off" || value === "assertive" ? value : "polite";
    if (this._politeness === "off") {
      if (this._subscription) {
        this._subscription.unsubscribe();
        this._subscription = null;
      }
    } else if (!this._subscription) {
      this._subscription = this._ngZone.runOutsideAngular(() => {
        return this._contentObserver.observe(this._elementRef).subscribe(() => {
          const elementText = this._elementRef.nativeElement.textContent;
          if (elementText !== this._previousAnnouncedText) {
            this._liveAnnouncer.announce(elementText, this._politeness, this.duration);
            this._previousAnnouncedText = elementText;
          }
        });
      });
    }
  }
  _politeness = "polite";
  /** Time in milliseconds after which to clear out the announcer element. */
  duration;
  _previousAnnouncedText;
  _subscription;
  constructor() {
    inject(_CdkPrivateStyleLoader).load(_VisuallyHiddenLoader);
  }
  ngOnDestroy() {
    if (this._subscription) {
      this._subscription.unsubscribe();
    }
  }
  static ɵfac = function CdkAriaLive_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkAriaLive)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkAriaLive,
    selectors: [["", "cdkAriaLive", ""]],
    inputs: {
      politeness: [0, "cdkAriaLive", "politeness"],
      duration: [0, "cdkAriaLiveDuration", "duration"]
    },
    exportAs: ["cdkAriaLive"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkAriaLive, [{
    type: Directive,
    args: [{
      selector: "[cdkAriaLive]",
      exportAs: "cdkAriaLive"
    }]
  }], () => [], {
    politeness: [{
      type: Input,
      args: ["cdkAriaLive"]
    }],
    duration: [{
      type: Input,
      args: ["cdkAriaLiveDuration"]
    }]
  });
})();
var FocusMonitorDetectionMode;
(function(FocusMonitorDetectionMode2) {
  FocusMonitorDetectionMode2[FocusMonitorDetectionMode2["IMMEDIATE"] = 0] = "IMMEDIATE";
  FocusMonitorDetectionMode2[FocusMonitorDetectionMode2["EVENTUAL"] = 1] = "EVENTUAL";
})(FocusMonitorDetectionMode || (FocusMonitorDetectionMode = {}));
var FOCUS_MONITOR_DEFAULT_OPTIONS = new InjectionToken("cdk-focus-monitor-default-options");
var captureEventListenerOptions = normalizePassiveListenerOptions({
  passive: true,
  capture: true
});
var FocusMonitor = class _FocusMonitor {
  _ngZone = inject(NgZone);
  _platform = inject(Platform);
  _inputModalityDetector = inject(InputModalityDetector);
  /** The focus origin that the next focus event is a result of. */
  _origin = null;
  /** The FocusOrigin of the last focus event tracked by the FocusMonitor. */
  _lastFocusOrigin;
  /** Whether the window has just been focused. */
  _windowFocused = false;
  /** The timeout id of the window focus timeout. */
  _windowFocusTimeoutId;
  /** The timeout id of the origin clearing timeout. */
  _originTimeoutId;
  /**
   * Whether the origin was determined via a touch interaction. Necessary as properly attributing
   * focus events to touch interactions requires special logic.
   */
  _originFromTouchInteraction = false;
  /** Map of elements being monitored to their info. */
  _elementInfo = /* @__PURE__ */ new Map();
  /** The number of elements currently being monitored. */
  _monitoredElementCount = 0;
  /**
   * Keeps track of the root nodes to which we've currently bound a focus/blur handler,
   * as well as the number of monitored elements that they contain. We have to treat focus/blur
   * handlers differently from the rest of the events, because the browser won't emit events
   * to the document when focus moves inside of a shadow root.
   */
  _rootNodeFocusListenerCount = /* @__PURE__ */ new Map();
  /**
   * The specified detection mode, used for attributing the origin of a focus
   * event.
   */
  _detectionMode;
  /**
   * Event listener for `focus` events on the window.
   * Needs to be an arrow function in order to preserve the context when it gets bound.
   */
  _windowFocusListener = () => {
    this._windowFocused = true;
    this._windowFocusTimeoutId = setTimeout(() => this._windowFocused = false);
  };
  /** Used to reference correct document/window */
  _document = inject(DOCUMENT, {
    optional: true
  });
  /** Subject for stopping our InputModalityDetector subscription. */
  _stopInputModalityDetector = new Subject();
  constructor() {
    const options = inject(FOCUS_MONITOR_DEFAULT_OPTIONS, {
      optional: true
    });
    this._detectionMode = options?.detectionMode || FocusMonitorDetectionMode.IMMEDIATE;
  }
  /**
   * Event listener for `focus` and 'blur' events on the document.
   * Needs to be an arrow function in order to preserve the context when it gets bound.
   */
  _rootNodeFocusAndBlurListener = (event) => {
    const target = _getEventTarget(event);
    for (let element = target; element; element = element.parentElement) {
      if (event.type === "focus") {
        this._onFocus(event, element);
      } else {
        this._onBlur(event, element);
      }
    }
  };
  monitor(element, checkChildren = false) {
    const nativeElement = coerceElement(element);
    if (!this._platform.isBrowser || nativeElement.nodeType !== 1) {
      return of();
    }
    const rootNode = _getShadowRoot(nativeElement) || this._getDocument();
    const cachedInfo = this._elementInfo.get(nativeElement);
    if (cachedInfo) {
      if (checkChildren) {
        cachedInfo.checkChildren = true;
      }
      return cachedInfo.subject;
    }
    const info = {
      checkChildren,
      subject: new Subject(),
      rootNode
    };
    this._elementInfo.set(nativeElement, info);
    this._registerGlobalListeners(info);
    return info.subject;
  }
  stopMonitoring(element) {
    const nativeElement = coerceElement(element);
    const elementInfo = this._elementInfo.get(nativeElement);
    if (elementInfo) {
      elementInfo.subject.complete();
      this._setClasses(nativeElement);
      this._elementInfo.delete(nativeElement);
      this._removeGlobalListeners(elementInfo);
    }
  }
  focusVia(element, origin, options) {
    const nativeElement = coerceElement(element);
    const focusedElement = this._getDocument().activeElement;
    if (nativeElement === focusedElement) {
      this._getClosestElementsInfo(nativeElement).forEach(([currentElement, info]) => this._originChanged(currentElement, origin, info));
    } else {
      this._setOrigin(origin);
      if (typeof nativeElement.focus === "function") {
        nativeElement.focus(options);
      }
    }
  }
  ngOnDestroy() {
    this._elementInfo.forEach((_info, element) => this.stopMonitoring(element));
  }
  /** Access injected document if available or fallback to global document reference */
  _getDocument() {
    return this._document || document;
  }
  /** Use defaultView of injected document if available or fallback to global window reference */
  _getWindow() {
    const doc = this._getDocument();
    return doc.defaultView || window;
  }
  _getFocusOrigin(focusEventTarget) {
    if (this._origin) {
      if (this._originFromTouchInteraction) {
        return this._shouldBeAttributedToTouch(focusEventTarget) ? "touch" : "program";
      } else {
        return this._origin;
      }
    }
    if (this._windowFocused && this._lastFocusOrigin) {
      return this._lastFocusOrigin;
    }
    if (focusEventTarget && this._isLastInteractionFromInputLabel(focusEventTarget)) {
      return "mouse";
    }
    return "program";
  }
  /**
   * Returns whether the focus event should be attributed to touch. Recall that in IMMEDIATE mode, a
   * touch origin isn't immediately reset at the next tick (see _setOrigin). This means that when we
   * handle a focus event following a touch interaction, we need to determine whether (1) the focus
   * event was directly caused by the touch interaction or (2) the focus event was caused by a
   * subsequent programmatic focus call triggered by the touch interaction.
   * @param focusEventTarget The target of the focus event under examination.
   */
  _shouldBeAttributedToTouch(focusEventTarget) {
    return this._detectionMode === FocusMonitorDetectionMode.EVENTUAL || !!focusEventTarget?.contains(this._inputModalityDetector._mostRecentTarget);
  }
  /**
   * Sets the focus classes on the element based on the given focus origin.
   * @param element The element to update the classes on.
   * @param origin The focus origin.
   */
  _setClasses(element, origin) {
    element.classList.toggle("cdk-focused", !!origin);
    element.classList.toggle("cdk-touch-focused", origin === "touch");
    element.classList.toggle("cdk-keyboard-focused", origin === "keyboard");
    element.classList.toggle("cdk-mouse-focused", origin === "mouse");
    element.classList.toggle("cdk-program-focused", origin === "program");
  }
  /**
   * Updates the focus origin. If we're using immediate detection mode, we schedule an async
   * function to clear the origin at the end of a timeout. The duration of the timeout depends on
   * the origin being set.
   * @param origin The origin to set.
   * @param isFromInteraction Whether we are setting the origin from an interaction event.
   */
  _setOrigin(origin, isFromInteraction = false) {
    this._ngZone.runOutsideAngular(() => {
      this._origin = origin;
      this._originFromTouchInteraction = origin === "touch" && isFromInteraction;
      if (this._detectionMode === FocusMonitorDetectionMode.IMMEDIATE) {
        clearTimeout(this._originTimeoutId);
        const ms = this._originFromTouchInteraction ? TOUCH_BUFFER_MS : 1;
        this._originTimeoutId = setTimeout(() => this._origin = null, ms);
      }
    });
  }
  /**
   * Handles focus events on a registered element.
   * @param event The focus event.
   * @param element The monitored element.
   */
  _onFocus(event, element) {
    const elementInfo = this._elementInfo.get(element);
    const focusEventTarget = _getEventTarget(event);
    if (!elementInfo || !elementInfo.checkChildren && element !== focusEventTarget) {
      return;
    }
    this._originChanged(element, this._getFocusOrigin(focusEventTarget), elementInfo);
  }
  /**
   * Handles blur events on a registered element.
   * @param event The blur event.
   * @param element The monitored element.
   */
  _onBlur(event, element) {
    const elementInfo = this._elementInfo.get(element);
    if (!elementInfo || elementInfo.checkChildren && event.relatedTarget instanceof Node && element.contains(event.relatedTarget)) {
      return;
    }
    this._setClasses(element);
    this._emitOrigin(elementInfo, null);
  }
  _emitOrigin(info, origin) {
    if (info.subject.observers.length) {
      this._ngZone.run(() => info.subject.next(origin));
    }
  }
  _registerGlobalListeners(elementInfo) {
    if (!this._platform.isBrowser) {
      return;
    }
    const rootNode = elementInfo.rootNode;
    const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode) || 0;
    if (!rootNodeFocusListeners) {
      this._ngZone.runOutsideAngular(() => {
        rootNode.addEventListener("focus", this._rootNodeFocusAndBlurListener, captureEventListenerOptions);
        rootNode.addEventListener("blur", this._rootNodeFocusAndBlurListener, captureEventListenerOptions);
      });
    }
    this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners + 1);
    if (++this._monitoredElementCount === 1) {
      this._ngZone.runOutsideAngular(() => {
        const window2 = this._getWindow();
        window2.addEventListener("focus", this._windowFocusListener);
      });
      this._inputModalityDetector.modalityDetected.pipe(takeUntil(this._stopInputModalityDetector)).subscribe((modality) => {
        this._setOrigin(
          modality,
          true
          /* isFromInteraction */
        );
      });
    }
  }
  _removeGlobalListeners(elementInfo) {
    const rootNode = elementInfo.rootNode;
    if (this._rootNodeFocusListenerCount.has(rootNode)) {
      const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode);
      if (rootNodeFocusListeners > 1) {
        this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners - 1);
      } else {
        rootNode.removeEventListener("focus", this._rootNodeFocusAndBlurListener, captureEventListenerOptions);
        rootNode.removeEventListener("blur", this._rootNodeFocusAndBlurListener, captureEventListenerOptions);
        this._rootNodeFocusListenerCount.delete(rootNode);
      }
    }
    if (!--this._monitoredElementCount) {
      const window2 = this._getWindow();
      window2.removeEventListener("focus", this._windowFocusListener);
      this._stopInputModalityDetector.next();
      clearTimeout(this._windowFocusTimeoutId);
      clearTimeout(this._originTimeoutId);
    }
  }
  /** Updates all the state on an element once its focus origin has changed. */
  _originChanged(element, origin, elementInfo) {
    this._setClasses(element, origin);
    this._emitOrigin(elementInfo, origin);
    this._lastFocusOrigin = origin;
  }
  /**
   * Collects the `MonitoredElementInfo` of a particular element and
   * all of its ancestors that have enabled `checkChildren`.
   * @param element Element from which to start the search.
   */
  _getClosestElementsInfo(element) {
    const results = [];
    this._elementInfo.forEach((info, currentElement) => {
      if (currentElement === element || info.checkChildren && currentElement.contains(element)) {
        results.push([currentElement, info]);
      }
    });
    return results;
  }
  /**
   * Returns whether an interaction is likely to have come from the user clicking the `label` of
   * an `input` or `textarea` in order to focus it.
   * @param focusEventTarget Target currently receiving focus.
   */
  _isLastInteractionFromInputLabel(focusEventTarget) {
    const {
      _mostRecentTarget: mostRecentTarget,
      mostRecentModality
    } = this._inputModalityDetector;
    if (mostRecentModality !== "mouse" || !mostRecentTarget || mostRecentTarget === focusEventTarget || focusEventTarget.nodeName !== "INPUT" && focusEventTarget.nodeName !== "TEXTAREA" || focusEventTarget.disabled) {
      return false;
    }
    const labels = focusEventTarget.labels;
    if (labels) {
      for (let i = 0; i < labels.length; i++) {
        if (labels[i].contains(mostRecentTarget)) {
          return true;
        }
      }
    }
    return false;
  }
  static ɵfac = function FocusMonitor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FocusMonitor)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _FocusMonitor,
    factory: _FocusMonitor.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusMonitor, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var CdkMonitorFocus = class _CdkMonitorFocus {
  _elementRef = inject(ElementRef);
  _focusMonitor = inject(FocusMonitor);
  _monitorSubscription;
  _focusOrigin = null;
  cdkFocusChange = new EventEmitter();
  constructor() {
  }
  get focusOrigin() {
    return this._focusOrigin;
  }
  ngAfterViewInit() {
    const element = this._elementRef.nativeElement;
    this._monitorSubscription = this._focusMonitor.monitor(element, element.nodeType === 1 && element.hasAttribute("cdkMonitorSubtreeFocus")).subscribe((origin) => {
      this._focusOrigin = origin;
      this.cdkFocusChange.emit(origin);
    });
  }
  ngOnDestroy() {
    this._focusMonitor.stopMonitoring(this._elementRef);
    if (this._monitorSubscription) {
      this._monitorSubscription.unsubscribe();
    }
  }
  static ɵfac = function CdkMonitorFocus_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkMonitorFocus)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkMonitorFocus,
    selectors: [["", "cdkMonitorElementFocus", ""], ["", "cdkMonitorSubtreeFocus", ""]],
    outputs: {
      cdkFocusChange: "cdkFocusChange"
    },
    exportAs: ["cdkMonitorFocus"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkMonitorFocus, [{
    type: Directive,
    args: [{
      selector: "[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]",
      exportAs: "cdkMonitorFocus"
    }]
  }], () => [], {
    cdkFocusChange: [{
      type: Output
    }]
  });
})();
var HighContrastMode;
(function(HighContrastMode2) {
  HighContrastMode2[HighContrastMode2["NONE"] = 0] = "NONE";
  HighContrastMode2[HighContrastMode2["BLACK_ON_WHITE"] = 1] = "BLACK_ON_WHITE";
  HighContrastMode2[HighContrastMode2["WHITE_ON_BLACK"] = 2] = "WHITE_ON_BLACK";
})(HighContrastMode || (HighContrastMode = {}));
var BLACK_ON_WHITE_CSS_CLASS = "cdk-high-contrast-black-on-white";
var WHITE_ON_BLACK_CSS_CLASS = "cdk-high-contrast-white-on-black";
var HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS = "cdk-high-contrast-active";
var HighContrastModeDetector = class _HighContrastModeDetector {
  _platform = inject(Platform);
  /**
   * Figuring out the high contrast mode and adding the body classes can cause
   * some expensive layouts. This flag is used to ensure that we only do it once.
   */
  _hasCheckedHighContrastMode;
  _document = inject(DOCUMENT);
  _breakpointSubscription;
  constructor() {
    this._breakpointSubscription = inject(BreakpointObserver).observe("(forced-colors: active)").subscribe(() => {
      if (this._hasCheckedHighContrastMode) {
        this._hasCheckedHighContrastMode = false;
        this._applyBodyHighContrastModeCssClasses();
      }
    });
  }
  /** Gets the current high-contrast-mode for the page. */
  getHighContrastMode() {
    if (!this._platform.isBrowser) {
      return HighContrastMode.NONE;
    }
    const testElement = this._document.createElement("div");
    testElement.style.backgroundColor = "rgb(1,2,3)";
    testElement.style.position = "absolute";
    this._document.body.appendChild(testElement);
    const documentWindow = this._document.defaultView || window;
    const computedStyle = documentWindow && documentWindow.getComputedStyle ? documentWindow.getComputedStyle(testElement) : null;
    const computedColor = (computedStyle && computedStyle.backgroundColor || "").replace(/ /g, "");
    testElement.remove();
    switch (computedColor) {
      // Pre Windows 11 dark theme.
      case "rgb(0,0,0)":
      // Windows 11 dark themes.
      case "rgb(45,50,54)":
      case "rgb(32,32,32)":
        return HighContrastMode.WHITE_ON_BLACK;
      // Pre Windows 11 light theme.
      case "rgb(255,255,255)":
      // Windows 11 light theme.
      case "rgb(255,250,239)":
        return HighContrastMode.BLACK_ON_WHITE;
    }
    return HighContrastMode.NONE;
  }
  ngOnDestroy() {
    this._breakpointSubscription.unsubscribe();
  }
  /** Applies CSS classes indicating high-contrast mode to document body (browser-only). */
  _applyBodyHighContrastModeCssClasses() {
    if (!this._hasCheckedHighContrastMode && this._platform.isBrowser && this._document.body) {
      const bodyClasses = this._document.body.classList;
      bodyClasses.remove(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, BLACK_ON_WHITE_CSS_CLASS, WHITE_ON_BLACK_CSS_CLASS);
      this._hasCheckedHighContrastMode = true;
      const mode = this.getHighContrastMode();
      if (mode === HighContrastMode.BLACK_ON_WHITE) {
        bodyClasses.add(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, BLACK_ON_WHITE_CSS_CLASS);
      } else if (mode === HighContrastMode.WHITE_ON_BLACK) {
        bodyClasses.add(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, WHITE_ON_BLACK_CSS_CLASS);
      }
    }
  }
  static ɵfac = function HighContrastModeDetector_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HighContrastModeDetector)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _HighContrastModeDetector,
    factory: _HighContrastModeDetector.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HighContrastModeDetector, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var A11yModule = class _A11yModule {
  constructor() {
    inject(HighContrastModeDetector)._applyBodyHighContrastModeCssClasses();
  }
  static ɵfac = function A11yModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _A11yModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _A11yModule,
    imports: [ObserversModule, CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],
    exports: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus]
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [ObserversModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(A11yModule, [{
    type: NgModule,
    args: [{
      imports: [ObserversModule, CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],
      exports: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus]
    }]
  }], () => [], null);
})();
var counters = {};
var _IdGenerator = class __IdGenerator {
  _appId = inject(APP_ID);
  /**
   * Generates a unique ID with a specific prefix.
   * @param prefix Prefix to add to the ID.
   */
  getId(prefix) {
    if (this._appId !== "ng") {
      prefix += this._appId;
    }
    if (!counters.hasOwnProperty(prefix)) {
      counters[prefix] = 0;
    }
    return `${prefix}${counters[prefix]++}`;
  }
  static ɵfac = function _IdGenerator_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || __IdGenerator)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: __IdGenerator,
    factory: __IdGenerator.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_IdGenerator, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/bidi.mjs
var DIR_DOCUMENT = new InjectionToken("cdk-dir-doc", {
  providedIn: "root",
  factory: DIR_DOCUMENT_FACTORY
});
function DIR_DOCUMENT_FACTORY() {
  return inject(DOCUMENT);
}
var RTL_LOCALE_PATTERN = /^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;
function _resolveDirectionality(rawValue) {
  const value = rawValue?.toLowerCase() || "";
  if (value === "auto" && typeof navigator !== "undefined" && navigator?.language) {
    return RTL_LOCALE_PATTERN.test(navigator.language) ? "rtl" : "ltr";
  }
  return value === "rtl" ? "rtl" : "ltr";
}
var Directionality = class _Directionality {
  /** The current 'ltr' or 'rtl' value. */
  value = "ltr";
  /** Stream that emits whenever the 'ltr' / 'rtl' state changes. */
  change = new EventEmitter();
  constructor() {
    const _document = inject(DIR_DOCUMENT, {
      optional: true
    });
    if (_document) {
      const bodyDir = _document.body ? _document.body.dir : null;
      const htmlDir = _document.documentElement ? _document.documentElement.dir : null;
      this.value = _resolveDirectionality(bodyDir || htmlDir || "ltr");
    }
  }
  ngOnDestroy() {
    this.change.complete();
  }
  static ɵfac = function Directionality_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _Directionality)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _Directionality,
    factory: _Directionality.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Directionality, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var Dir = class _Dir {
  /** Normalized direction that accounts for invalid/unsupported values. */
  _dir = "ltr";
  /** Whether the `value` has been set to its initial value. */
  _isInitialized = false;
  /** Direction as passed in by the consumer. */
  _rawDir;
  /** Event emitted when the direction changes. */
  change = new EventEmitter();
  /** @docs-private */
  get dir() {
    return this._dir;
  }
  set dir(value) {
    const previousValue = this._dir;
    this._dir = _resolveDirectionality(value);
    this._rawDir = value;
    if (previousValue !== this._dir && this._isInitialized) {
      this.change.emit(this._dir);
    }
  }
  /** Current layout direction of the element. */
  get value() {
    return this.dir;
  }
  /** Initialize once default value has been set. */
  ngAfterContentInit() {
    this._isInitialized = true;
  }
  ngOnDestroy() {
    this.change.complete();
  }
  static ɵfac = function Dir_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _Dir)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _Dir,
    selectors: [["", "dir", ""]],
    hostVars: 1,
    hostBindings: function Dir_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx._rawDir);
      }
    },
    inputs: {
      dir: "dir"
    },
    outputs: {
      change: "dirChange"
    },
    exportAs: ["dir"],
    features: [ɵɵProvidersFeature([{
      provide: Directionality,
      useExisting: _Dir
    }])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Dir, [{
    type: Directive,
    args: [{
      selector: "[dir]",
      providers: [{
        provide: Directionality,
        useExisting: Dir
      }],
      host: {
        "[attr.dir]": "_rawDir"
      },
      exportAs: "dir"
    }]
  }], null, {
    change: [{
      type: Output,
      args: ["dirChange"]
    }],
    dir: [{
      type: Input
    }]
  });
})();
var BidiModule = class _BidiModule {
  static ɵfac = function BidiModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BidiModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _BidiModule,
    imports: [Dir],
    exports: [Dir]
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BidiModule, [{
    type: NgModule,
    args: [{
      imports: [Dir],
      exports: [Dir]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/collections.mjs
var DataSource = class {
};
function isDataSource(value) {
  return value && typeof value.connect === "function" && !(value instanceof ConnectableObservable);
}
var ArrayDataSource = class extends DataSource {
  _data;
  constructor(_data) {
    super();
    this._data = _data;
  }
  connect() {
    return isObservable(this._data) ? this._data : of(this._data);
  }
  disconnect() {
  }
};
var _ViewRepeaterOperation;
(function(_ViewRepeaterOperation2) {
  _ViewRepeaterOperation2[_ViewRepeaterOperation2["REPLACED"] = 0] = "REPLACED";
  _ViewRepeaterOperation2[_ViewRepeaterOperation2["INSERTED"] = 1] = "INSERTED";
  _ViewRepeaterOperation2[_ViewRepeaterOperation2["MOVED"] = 2] = "MOVED";
  _ViewRepeaterOperation2[_ViewRepeaterOperation2["REMOVED"] = 3] = "REMOVED";
})(_ViewRepeaterOperation || (_ViewRepeaterOperation = {}));
var _VIEW_REPEATER_STRATEGY = new InjectionToken("_ViewRepeater");
var _RecycleViewRepeaterStrategy = class {
  /**
   * The size of the cache used to store unused views.
   * Setting the cache size to `0` will disable caching. Defaults to 20 views.
   */
  viewCacheSize = 20;
  /**
   * View cache that stores embedded view instances that have been previously stamped out,
   * but don't are not currently rendered. The view repeater will reuse these views rather than
   * creating brand new ones.
   *
   * TODO(michaeljamesparsons) Investigate whether using a linked list would improve performance.
   */
  _viewCache = [];
  /** Apply changes to the DOM. */
  applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {
    changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {
      let view;
      let operation;
      if (record.previousIndex == null) {
        const viewArgsFactory = () => itemContextFactory(record, adjustedPreviousIndex, currentIndex);
        view = this._insertView(viewArgsFactory, currentIndex, viewContainerRef, itemValueResolver(record));
        operation = view ? _ViewRepeaterOperation.INSERTED : _ViewRepeaterOperation.REPLACED;
      } else if (currentIndex == null) {
        this._detachAndCacheView(adjustedPreviousIndex, viewContainerRef);
        operation = _ViewRepeaterOperation.REMOVED;
      } else {
        view = this._moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, itemValueResolver(record));
        operation = _ViewRepeaterOperation.MOVED;
      }
      if (itemViewChanged) {
        itemViewChanged({
          context: view?.context,
          operation,
          record
        });
      }
    });
  }
  detach() {
    for (const view of this._viewCache) {
      view.destroy();
    }
    this._viewCache = [];
  }
  /**
   * Inserts a view for a new item, either from the cache or by creating a new
   * one. Returns `undefined` if the item was inserted into a cached view.
   */
  _insertView(viewArgsFactory, currentIndex, viewContainerRef, value) {
    const cachedView = this._insertViewFromCache(currentIndex, viewContainerRef);
    if (cachedView) {
      cachedView.context.$implicit = value;
      return void 0;
    }
    const viewArgs = viewArgsFactory();
    return viewContainerRef.createEmbeddedView(viewArgs.templateRef, viewArgs.context, viewArgs.index);
  }
  /** Detaches the view at the given index and inserts into the view cache. */
  _detachAndCacheView(index, viewContainerRef) {
    const detachedView = viewContainerRef.detach(index);
    this._maybeCacheView(detachedView, viewContainerRef);
  }
  /** Moves view at the previous index to the current index. */
  _moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, value) {
    const view = viewContainerRef.get(adjustedPreviousIndex);
    viewContainerRef.move(view, currentIndex);
    view.context.$implicit = value;
    return view;
  }
  /**
   * Cache the given detached view. If the cache is full, the view will be
   * destroyed.
   */
  _maybeCacheView(view, viewContainerRef) {
    if (this._viewCache.length < this.viewCacheSize) {
      this._viewCache.push(view);
    } else {
      const index = viewContainerRef.indexOf(view);
      if (index === -1) {
        view.destroy();
      } else {
        viewContainerRef.remove(index);
      }
    }
  }
  /** Inserts a recycled view from the cache at the given index. */
  _insertViewFromCache(index, viewContainerRef) {
    const cachedView = this._viewCache.pop();
    if (cachedView) {
      viewContainerRef.insert(cachedView, index);
    }
    return cachedView || null;
  }
};
var UniqueSelectionDispatcher = class _UniqueSelectionDispatcher {
  _listeners = [];
  /**
   * Notify other items that selection for the given name has been set.
   * @param id ID of the item.
   * @param name Name of the item.
   */
  notify(id, name) {
    for (let listener of this._listeners) {
      listener(id, name);
    }
  }
  /**
   * Listen for future changes to item selection.
   * @return Function used to deregister listener
   */
  listen(listener) {
    this._listeners.push(listener);
    return () => {
      this._listeners = this._listeners.filter((registered) => {
        return listener !== registered;
      });
    };
  }
  ngOnDestroy() {
    this._listeners = [];
  }
  static ɵfac = function UniqueSelectionDispatcher_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _UniqueSelectionDispatcher)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _UniqueSelectionDispatcher,
    factory: _UniqueSelectionDispatcher.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UniqueSelectionDispatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/scrolling.mjs
var _c0 = ["contentWrapper"];
var _c1 = ["*"];
var VIRTUAL_SCROLL_STRATEGY = new InjectionToken("VIRTUAL_SCROLL_STRATEGY");
var FixedSizeVirtualScrollStrategy = class {
  _scrolledIndexChange = new Subject();
  /** @docs-private Implemented as part of VirtualScrollStrategy. */
  scrolledIndexChange = this._scrolledIndexChange.pipe(distinctUntilChanged());
  /** The attached viewport. */
  _viewport = null;
  /** The size of the items in the virtually scrolling list. */
  _itemSize;
  /** The minimum amount of buffer rendered beyond the viewport (in pixels). */
  _minBufferPx;
  /** The number of buffer items to render beyond the edge of the viewport (in pixels). */
  _maxBufferPx;
  /**
   * @param itemSize The size of the items in the virtually scrolling list.
   * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more
   * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.
   */
  constructor(itemSize, minBufferPx, maxBufferPx) {
    this._itemSize = itemSize;
    this._minBufferPx = minBufferPx;
    this._maxBufferPx = maxBufferPx;
  }
  /**
   * Attaches this scroll strategy to a viewport.
   * @param viewport The viewport to attach this strategy to.
   */
  attach(viewport) {
    this._viewport = viewport;
    this._updateTotalContentSize();
    this._updateRenderedRange();
  }
  /** Detaches this scroll strategy from the currently attached viewport. */
  detach() {
    this._scrolledIndexChange.complete();
    this._viewport = null;
  }
  /**
   * Update the item size and buffer size.
   * @param itemSize The size of the items in the virtually scrolling list.
   * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more
   * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.
   */
  updateItemAndBufferSize(itemSize, minBufferPx, maxBufferPx) {
    if (maxBufferPx < minBufferPx && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error("CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx");
    }
    this._itemSize = itemSize;
    this._minBufferPx = minBufferPx;
    this._maxBufferPx = maxBufferPx;
    this._updateTotalContentSize();
    this._updateRenderedRange();
  }
  /** @docs-private Implemented as part of VirtualScrollStrategy. */
  onContentScrolled() {
    this._updateRenderedRange();
  }
  /** @docs-private Implemented as part of VirtualScrollStrategy. */
  onDataLengthChanged() {
    this._updateTotalContentSize();
    this._updateRenderedRange();
  }
  /** @docs-private Implemented as part of VirtualScrollStrategy. */
  onContentRendered() {
  }
  /** @docs-private Implemented as part of VirtualScrollStrategy. */
  onRenderedOffsetChanged() {
  }
  /**
   * Scroll to the offset for the given index.
   * @param index The index of the element to scroll to.
   * @param behavior The ScrollBehavior to use when scrolling.
   */
  scrollToIndex(index, behavior) {
    if (this._viewport) {
      this._viewport.scrollToOffset(index * this._itemSize, behavior);
    }
  }
  /** Update the viewport's total content size. */
  _updateTotalContentSize() {
    if (!this._viewport) {
      return;
    }
    this._viewport.setTotalContentSize(this._viewport.getDataLength() * this._itemSize);
  }
  /** Update the viewport's rendered range. */
  _updateRenderedRange() {
    if (!this._viewport) {
      return;
    }
    const renderedRange = this._viewport.getRenderedRange();
    const newRange = {
      start: renderedRange.start,
      end: renderedRange.end
    };
    const viewportSize = this._viewport.getViewportSize();
    const dataLength = this._viewport.getDataLength();
    let scrollOffset = this._viewport.measureScrollOffset();
    let firstVisibleIndex = this._itemSize > 0 ? scrollOffset / this._itemSize : 0;
    if (newRange.end > dataLength) {
      const maxVisibleItems = Math.ceil(viewportSize / this._itemSize);
      const newVisibleIndex = Math.max(0, Math.min(firstVisibleIndex, dataLength - maxVisibleItems));
      if (firstVisibleIndex != newVisibleIndex) {
        firstVisibleIndex = newVisibleIndex;
        scrollOffset = newVisibleIndex * this._itemSize;
        newRange.start = Math.floor(firstVisibleIndex);
      }
      newRange.end = Math.max(0, Math.min(dataLength, newRange.start + maxVisibleItems));
    }
    const startBuffer = scrollOffset - newRange.start * this._itemSize;
    if (startBuffer < this._minBufferPx && newRange.start != 0) {
      const expandStart = Math.ceil((this._maxBufferPx - startBuffer) / this._itemSize);
      newRange.start = Math.max(0, newRange.start - expandStart);
      newRange.end = Math.min(dataLength, Math.ceil(firstVisibleIndex + (viewportSize + this._minBufferPx) / this._itemSize));
    } else {
      const endBuffer = newRange.end * this._itemSize - (scrollOffset + viewportSize);
      if (endBuffer < this._minBufferPx && newRange.end != dataLength) {
        const expandEnd = Math.ceil((this._maxBufferPx - endBuffer) / this._itemSize);
        if (expandEnd > 0) {
          newRange.end = Math.min(dataLength, newRange.end + expandEnd);
          newRange.start = Math.max(0, Math.floor(firstVisibleIndex - this._minBufferPx / this._itemSize));
        }
      }
    }
    this._viewport.setRenderedRange(newRange);
    this._viewport.setRenderedContentOffset(this._itemSize * newRange.start);
    this._scrolledIndexChange.next(Math.floor(firstVisibleIndex));
  }
};
function _fixedSizeVirtualScrollStrategyFactory(fixedSizeDir) {
  return fixedSizeDir._scrollStrategy;
}
var CdkFixedSizeVirtualScroll = class _CdkFixedSizeVirtualScroll {
  /** The size of the items in the list (in pixels). */
  get itemSize() {
    return this._itemSize;
  }
  set itemSize(value) {
    this._itemSize = coerceNumberProperty(value);
  }
  _itemSize = 20;
  /**
   * The minimum amount of buffer rendered beyond the viewport (in pixels).
   * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.
   */
  get minBufferPx() {
    return this._minBufferPx;
  }
  set minBufferPx(value) {
    this._minBufferPx = coerceNumberProperty(value);
  }
  _minBufferPx = 100;
  /**
   * The number of pixels worth of buffer to render for when rendering new items. Defaults to 200px.
   */
  get maxBufferPx() {
    return this._maxBufferPx;
  }
  set maxBufferPx(value) {
    this._maxBufferPx = coerceNumberProperty(value);
  }
  _maxBufferPx = 200;
  /** The scroll strategy used by this directive. */
  _scrollStrategy = new FixedSizeVirtualScrollStrategy(this.itemSize, this.minBufferPx, this.maxBufferPx);
  ngOnChanges() {
    this._scrollStrategy.updateItemAndBufferSize(this.itemSize, this.minBufferPx, this.maxBufferPx);
  }
  static ɵfac = function CdkFixedSizeVirtualScroll_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkFixedSizeVirtualScroll)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkFixedSizeVirtualScroll,
    selectors: [["cdk-virtual-scroll-viewport", "itemSize", ""]],
    inputs: {
      itemSize: "itemSize",
      minBufferPx: "minBufferPx",
      maxBufferPx: "maxBufferPx"
    },
    features: [ɵɵProvidersFeature([{
      provide: VIRTUAL_SCROLL_STRATEGY,
      useFactory: _fixedSizeVirtualScrollStrategyFactory,
      deps: [forwardRef(() => _CdkFixedSizeVirtualScroll)]
    }]), ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkFixedSizeVirtualScroll, [{
    type: Directive,
    args: [{
      selector: "cdk-virtual-scroll-viewport[itemSize]",
      providers: [{
        provide: VIRTUAL_SCROLL_STRATEGY,
        useFactory: _fixedSizeVirtualScrollStrategyFactory,
        deps: [forwardRef(() => CdkFixedSizeVirtualScroll)]
      }]
    }]
  }], null, {
    itemSize: [{
      type: Input
    }],
    minBufferPx: [{
      type: Input
    }],
    maxBufferPx: [{
      type: Input
    }]
  });
})();
var DEFAULT_SCROLL_TIME = 20;
var ScrollDispatcher = class _ScrollDispatcher {
  _ngZone = inject(NgZone);
  _platform = inject(Platform);
  _renderer = inject(RendererFactory2).createRenderer(null, null);
  _cleanupGlobalListener;
  constructor() {
  }
  /** Subject for notifying that a registered scrollable reference element has been scrolled. */
  _scrolled = new Subject();
  /** Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards. */
  _scrolledCount = 0;
  /**
   * Map of all the scrollable references that are registered with the service and their
   * scroll event subscriptions.
   */
  scrollContainers = /* @__PURE__ */ new Map();
  /**
   * Registers a scrollable instance with the service and listens for its scrolled events. When the
   * scrollable is scrolled, the service emits the event to its scrolled observable.
   * @param scrollable Scrollable instance to be registered.
   */
  register(scrollable) {
    if (!this.scrollContainers.has(scrollable)) {
      this.scrollContainers.set(scrollable, scrollable.elementScrolled().subscribe(() => this._scrolled.next(scrollable)));
    }
  }
  /**
   * De-registers a Scrollable reference and unsubscribes from its scroll event observable.
   * @param scrollable Scrollable instance to be deregistered.
   */
  deregister(scrollable) {
    const scrollableReference = this.scrollContainers.get(scrollable);
    if (scrollableReference) {
      scrollableReference.unsubscribe();
      this.scrollContainers.delete(scrollable);
    }
  }
  /**
   * Returns an observable that emits an event whenever any of the registered Scrollable
   * references (or window, document, or body) fire a scrolled event. Can provide a time in ms
   * to override the default "throttle" time.
   *
   * **Note:** in order to avoid hitting change detection for every scroll event,
   * all of the events emitted from this stream will be run outside the Angular zone.
   * If you need to update any data bindings as a result of a scroll event, you have
   * to run the callback using `NgZone.run`.
   */
  scrolled(auditTimeInMs = DEFAULT_SCROLL_TIME) {
    if (!this._platform.isBrowser) {
      return of();
    }
    return new Observable((observer) => {
      if (!this._cleanupGlobalListener) {
        this._cleanupGlobalListener = this._ngZone.runOutsideAngular(() => this._renderer.listen("document", "scroll", () => this._scrolled.next()));
      }
      const subscription = auditTimeInMs > 0 ? this._scrolled.pipe(auditTime(auditTimeInMs)).subscribe(observer) : this._scrolled.subscribe(observer);
      this._scrolledCount++;
      return () => {
        subscription.unsubscribe();
        this._scrolledCount--;
        if (!this._scrolledCount) {
          this._cleanupGlobalListener?.();
          this._cleanupGlobalListener = void 0;
        }
      };
    });
  }
  ngOnDestroy() {
    this._cleanupGlobalListener?.();
    this._cleanupGlobalListener = void 0;
    this.scrollContainers.forEach((_, container) => this.deregister(container));
    this._scrolled.complete();
  }
  /**
   * Returns an observable that emits whenever any of the
   * scrollable ancestors of an element are scrolled.
   * @param elementOrElementRef Element whose ancestors to listen for.
   * @param auditTimeInMs Time to throttle the scroll events.
   */
  ancestorScrolled(elementOrElementRef, auditTimeInMs) {
    const ancestors = this.getAncestorScrollContainers(elementOrElementRef);
    return this.scrolled(auditTimeInMs).pipe(filter((target) => !target || ancestors.indexOf(target) > -1));
  }
  /** Returns all registered Scrollables that contain the provided element. */
  getAncestorScrollContainers(elementOrElementRef) {
    const scrollingContainers = [];
    this.scrollContainers.forEach((_subscription, scrollable) => {
      if (this._scrollableContainsElement(scrollable, elementOrElementRef)) {
        scrollingContainers.push(scrollable);
      }
    });
    return scrollingContainers;
  }
  /** Returns true if the element is contained within the provided Scrollable. */
  _scrollableContainsElement(scrollable, elementOrElementRef) {
    let element = coerceElement(elementOrElementRef);
    let scrollableElement = scrollable.getElementRef().nativeElement;
    do {
      if (element == scrollableElement) {
        return true;
      }
    } while (element = element.parentElement);
    return false;
  }
  static ɵfac = function ScrollDispatcher_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ScrollDispatcher)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ScrollDispatcher,
    factory: _ScrollDispatcher.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollDispatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var CdkScrollable = class _CdkScrollable {
  elementRef = inject(ElementRef);
  scrollDispatcher = inject(ScrollDispatcher);
  ngZone = inject(NgZone);
  dir = inject(Directionality, {
    optional: true
  });
  _scrollElement = this.elementRef.nativeElement;
  _destroyed = new Subject();
  _renderer = inject(Renderer2);
  _cleanupScroll;
  _elementScrolled = new Subject();
  constructor() {
  }
  ngOnInit() {
    this._cleanupScroll = this.ngZone.runOutsideAngular(() => this._renderer.listen(this._scrollElement, "scroll", (event) => this._elementScrolled.next(event)));
    this.scrollDispatcher.register(this);
  }
  ngOnDestroy() {
    this._cleanupScroll?.();
    this._elementScrolled.complete();
    this.scrollDispatcher.deregister(this);
    this._destroyed.next();
    this._destroyed.complete();
  }
  /** Returns observable that emits when a scroll event is fired on the host element. */
  elementScrolled() {
    return this._elementScrolled;
  }
  /** Gets the ElementRef for the viewport. */
  getElementRef() {
    return this.elementRef;
  }
  /**
   * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
   * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
   * left and right always refer to the left and right side of the scrolling container irrespective
   * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
   * in an RTL context.
   * @param options specified the offsets to scroll to.
   */
  scrollTo(options) {
    const el = this.elementRef.nativeElement;
    const isRtl = this.dir && this.dir.value == "rtl";
    if (options.left == null) {
      options.left = isRtl ? options.end : options.start;
    }
    if (options.right == null) {
      options.right = isRtl ? options.start : options.end;
    }
    if (options.bottom != null) {
      options.top = el.scrollHeight - el.clientHeight - options.bottom;
    }
    if (isRtl && getRtlScrollAxisType() != RtlScrollAxisType.NORMAL) {
      if (options.left != null) {
        options.right = el.scrollWidth - el.clientWidth - options.left;
      }
      if (getRtlScrollAxisType() == RtlScrollAxisType.INVERTED) {
        options.left = options.right;
      } else if (getRtlScrollAxisType() == RtlScrollAxisType.NEGATED) {
        options.left = options.right ? -options.right : options.right;
      }
    } else {
      if (options.right != null) {
        options.left = el.scrollWidth - el.clientWidth - options.right;
      }
    }
    this._applyScrollToOptions(options);
  }
  _applyScrollToOptions(options) {
    const el = this.elementRef.nativeElement;
    if (supportsScrollBehavior()) {
      el.scrollTo(options);
    } else {
      if (options.top != null) {
        el.scrollTop = options.top;
      }
      if (options.left != null) {
        el.scrollLeft = options.left;
      }
    }
  }
  /**
   * Measures the scroll offset relative to the specified edge of the viewport. This method can be
   * used instead of directly checking scrollLeft or scrollTop, since browsers are not consistent
   * about what scrollLeft means in RTL. The values returned by this method are normalized such that
   * left and right always refer to the left and right side of the scrolling container irrespective
   * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
   * in an RTL context.
   * @param from The edge to measure from.
   */
  measureScrollOffset(from2) {
    const LEFT = "left";
    const RIGHT = "right";
    const el = this.elementRef.nativeElement;
    if (from2 == "top") {
      return el.scrollTop;
    }
    if (from2 == "bottom") {
      return el.scrollHeight - el.clientHeight - el.scrollTop;
    }
    const isRtl = this.dir && this.dir.value == "rtl";
    if (from2 == "start") {
      from2 = isRtl ? RIGHT : LEFT;
    } else if (from2 == "end") {
      from2 = isRtl ? LEFT : RIGHT;
    }
    if (isRtl && getRtlScrollAxisType() == RtlScrollAxisType.INVERTED) {
      if (from2 == LEFT) {
        return el.scrollWidth - el.clientWidth - el.scrollLeft;
      } else {
        return el.scrollLeft;
      }
    } else if (isRtl && getRtlScrollAxisType() == RtlScrollAxisType.NEGATED) {
      if (from2 == LEFT) {
        return el.scrollLeft + el.scrollWidth - el.clientWidth;
      } else {
        return -el.scrollLeft;
      }
    } else {
      if (from2 == LEFT) {
        return el.scrollLeft;
      } else {
        return el.scrollWidth - el.clientWidth - el.scrollLeft;
      }
    }
  }
  static ɵfac = function CdkScrollable_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkScrollable)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkScrollable,
    selectors: [["", "cdk-scrollable", ""], ["", "cdkScrollable", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkScrollable, [{
    type: Directive,
    args: [{
      selector: "[cdk-scrollable], [cdkScrollable]"
    }]
  }], () => [], null);
})();
var DEFAULT_RESIZE_TIME = 20;
var ViewportRuler = class _ViewportRuler {
  _platform = inject(Platform);
  _listeners;
  /** Cached viewport dimensions. */
  _viewportSize;
  /** Stream of viewport change events. */
  _change = new Subject();
  /** Used to reference correct document/window */
  _document = inject(DOCUMENT, {
    optional: true
  });
  constructor() {
    const ngZone = inject(NgZone);
    const renderer = inject(RendererFactory2).createRenderer(null, null);
    ngZone.runOutsideAngular(() => {
      if (this._platform.isBrowser) {
        const changeListener = (event) => this._change.next(event);
        this._listeners = [renderer.listen("window", "resize", changeListener), renderer.listen("window", "orientationchange", changeListener)];
      }
      this.change().subscribe(() => this._viewportSize = null);
    });
  }
  ngOnDestroy() {
    this._listeners?.forEach((cleanup) => cleanup());
    this._change.complete();
  }
  /** Returns the viewport's width and height. */
  getViewportSize() {
    if (!this._viewportSize) {
      this._updateViewportSize();
    }
    const output = {
      width: this._viewportSize.width,
      height: this._viewportSize.height
    };
    if (!this._platform.isBrowser) {
      this._viewportSize = null;
    }
    return output;
  }
  /** Gets a DOMRect for the viewport's bounds. */
  getViewportRect() {
    const scrollPosition = this.getViewportScrollPosition();
    const {
      width,
      height
    } = this.getViewportSize();
    return {
      top: scrollPosition.top,
      left: scrollPosition.left,
      bottom: scrollPosition.top + height,
      right: scrollPosition.left + width,
      height,
      width
    };
  }
  /** Gets the (top, left) scroll position of the viewport. */
  getViewportScrollPosition() {
    if (!this._platform.isBrowser) {
      return {
        top: 0,
        left: 0
      };
    }
    const document2 = this._document;
    const window2 = this._getWindow();
    const documentElement = document2.documentElement;
    const documentRect = documentElement.getBoundingClientRect();
    const top = -documentRect.top || document2.body.scrollTop || window2.scrollY || documentElement.scrollTop || 0;
    const left = -documentRect.left || document2.body.scrollLeft || window2.scrollX || documentElement.scrollLeft || 0;
    return {
      top,
      left
    };
  }
  /**
   * Returns a stream that emits whenever the size of the viewport changes.
   * This stream emits outside of the Angular zone.
   * @param throttleTime Time in milliseconds to throttle the stream.
   */
  change(throttleTime = DEFAULT_RESIZE_TIME) {
    return throttleTime > 0 ? this._change.pipe(auditTime(throttleTime)) : this._change;
  }
  /** Use defaultView of injected document if available or fallback to global window reference */
  _getWindow() {
    return this._document.defaultView || window;
  }
  /** Updates the cached viewport size. */
  _updateViewportSize() {
    const window2 = this._getWindow();
    this._viewportSize = this._platform.isBrowser ? {
      width: window2.innerWidth,
      height: window2.innerHeight
    } : {
      width: 0,
      height: 0
    };
  }
  static ɵfac = function ViewportRuler_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ViewportRuler)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ViewportRuler,
    factory: _ViewportRuler.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ViewportRuler, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var VIRTUAL_SCROLLABLE = new InjectionToken("VIRTUAL_SCROLLABLE");
var CdkVirtualScrollable = class _CdkVirtualScrollable extends CdkScrollable {
  constructor() {
    super();
  }
  /**
   * Measure the viewport size for the provided orientation.
   *
   * @param orientation The orientation to measure the size from.
   */
  measureViewportSize(orientation) {
    const viewportEl = this.elementRef.nativeElement;
    return orientation === "horizontal" ? viewportEl.clientWidth : viewportEl.clientHeight;
  }
  static ɵfac = function CdkVirtualScrollable_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkVirtualScrollable)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkVirtualScrollable,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollable, [{
    type: Directive
  }], () => [], null);
})();
function rangesEqual(r1, r22) {
  return r1.start == r22.start && r1.end == r22.end;
}
var SCROLL_SCHEDULER = typeof requestAnimationFrame !== "undefined" ? animationFrameScheduler : asapScheduler;
var CdkVirtualScrollViewport = class _CdkVirtualScrollViewport extends CdkVirtualScrollable {
  elementRef = inject(ElementRef);
  _changeDetectorRef = inject(ChangeDetectorRef);
  _scrollStrategy = inject(VIRTUAL_SCROLL_STRATEGY, {
    optional: true
  });
  scrollable = inject(VIRTUAL_SCROLLABLE, {
    optional: true
  });
  _platform = inject(Platform);
  /** Emits when the viewport is detached from a CdkVirtualForOf. */
  _detachedSubject = new Subject();
  /** Emits when the rendered range changes. */
  _renderedRangeSubject = new Subject();
  /** The direction the viewport scrolls. */
  get orientation() {
    return this._orientation;
  }
  set orientation(orientation) {
    if (this._orientation !== orientation) {
      this._orientation = orientation;
      this._calculateSpacerSize();
    }
  }
  _orientation = "vertical";
  /**
   * Whether rendered items should persist in the DOM after scrolling out of view. By default, items
   * will be removed.
   */
  appendOnly = false;
  // Note: we don't use the typical EventEmitter here because we need to subscribe to the scroll
  // strategy lazily (i.e. only if the user is actually listening to the events). We do this because
  // depending on how the strategy calculates the scrolled index, it may come at a cost to
  // performance.
  /** Emits when the index of the first element visible in the viewport changes. */
  scrolledIndexChange = new Observable((observer) => this._scrollStrategy.scrolledIndexChange.subscribe((index) => Promise.resolve().then(() => this.ngZone.run(() => observer.next(index)))));
  /** The element that wraps the rendered content. */
  _contentWrapper;
  /** A stream that emits whenever the rendered range changes. */
  renderedRangeStream = this._renderedRangeSubject;
  /**
   * The total size of all content (in pixels), including content that is not currently rendered.
   */
  _totalContentSize = 0;
  /** A string representing the `style.width` property value to be used for the spacer element. */
  _totalContentWidth = "";
  /** A string representing the `style.height` property value to be used for the spacer element. */
  _totalContentHeight = "";
  /**
   * The CSS transform applied to the rendered subset of items so that they appear within the bounds
   * of the visible viewport.
   */
  _renderedContentTransform;
  /** The currently rendered range of indices. */
  _renderedRange = {
    start: 0,
    end: 0
  };
  /** The length of the data bound to this viewport (in number of items). */
  _dataLength = 0;
  /** The size of the viewport (in pixels). */
  _viewportSize = 0;
  /** the currently attached CdkVirtualScrollRepeater. */
  _forOf;
  /** The last rendered content offset that was set. */
  _renderedContentOffset = 0;
  /**
   * Whether the last rendered content offset was to the end of the content (and therefore needs to
   * be rewritten as an offset to the start of the content).
   */
  _renderedContentOffsetNeedsRewrite = false;
  /** Whether there is a pending change detection cycle. */
  _isChangeDetectionPending = false;
  /** A list of functions to run after the next change detection cycle. */
  _runAfterChangeDetection = [];
  /** Subscription to changes in the viewport size. */
  _viewportChanges = Subscription.EMPTY;
  _injector = inject(Injector);
  _isDestroyed = false;
  constructor() {
    super();
    const viewportRuler = inject(ViewportRuler);
    if (!this._scrollStrategy && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error('Error: cdk-virtual-scroll-viewport requires the "itemSize" property to be set.');
    }
    this._viewportChanges = viewportRuler.change().subscribe(() => {
      this.checkViewportSize();
    });
    if (!this.scrollable) {
      this.elementRef.nativeElement.classList.add("cdk-virtual-scrollable");
      this.scrollable = this;
    }
  }
  ngOnInit() {
    if (!this._platform.isBrowser) {
      return;
    }
    if (this.scrollable === this) {
      super.ngOnInit();
    }
    this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {
      this._measureViewportSize();
      this._scrollStrategy.attach(this);
      this.scrollable.elementScrolled().pipe(
        // Start off with a fake scroll event so we properly detect our initial position.
        startWith(null),
        // Collect multiple events into one until the next animation frame. This way if
        // there are multiple scroll events in the same frame we only need to recheck
        // our layout once.
        auditTime(0, SCROLL_SCHEDULER),
        // Usually `elementScrolled` is completed when the scrollable is destroyed, but
        // that may not be the case if a `CdkVirtualScrollableElement` is used so we have
        // to unsubscribe here just in case.
        takeUntil(this._destroyed)
      ).subscribe(() => this._scrollStrategy.onContentScrolled());
      this._markChangeDetectionNeeded();
    }));
  }
  ngOnDestroy() {
    this.detach();
    this._scrollStrategy.detach();
    this._renderedRangeSubject.complete();
    this._detachedSubject.complete();
    this._viewportChanges.unsubscribe();
    this._isDestroyed = true;
    super.ngOnDestroy();
  }
  /** Attaches a `CdkVirtualScrollRepeater` to this viewport. */
  attach(forOf) {
    if (this._forOf && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error("CdkVirtualScrollViewport is already attached.");
    }
    this.ngZone.runOutsideAngular(() => {
      this._forOf = forOf;
      this._forOf.dataStream.pipe(takeUntil(this._detachedSubject)).subscribe((data) => {
        const newLength = data.length;
        if (newLength !== this._dataLength) {
          this._dataLength = newLength;
          this._scrollStrategy.onDataLengthChanged();
        }
        this._doChangeDetection();
      });
    });
  }
  /** Detaches the current `CdkVirtualForOf`. */
  detach() {
    this._forOf = null;
    this._detachedSubject.next();
  }
  /** Gets the length of the data bound to this viewport (in number of items). */
  getDataLength() {
    return this._dataLength;
  }
  /** Gets the size of the viewport (in pixels). */
  getViewportSize() {
    return this._viewportSize;
  }
  // TODO(mmalerba): This is technically out of sync with what's really rendered until a render
  // cycle happens. I'm being careful to only call it after the render cycle is complete and before
  // setting it to something else, but its error prone and should probably be split into
  // `pendingRange` and `renderedRange`, the latter reflecting whats actually in the DOM.
  /** Get the current rendered range of items. */
  getRenderedRange() {
    return this._renderedRange;
  }
  measureBoundingClientRectWithScrollOffset(from2) {
    return this.getElementRef().nativeElement.getBoundingClientRect()[from2];
  }
  /**
   * Sets the total size of all content (in pixels), including content that is not currently
   * rendered.
   */
  setTotalContentSize(size) {
    if (this._totalContentSize !== size) {
      this._totalContentSize = size;
      this._calculateSpacerSize();
      this._markChangeDetectionNeeded();
    }
  }
  /** Sets the currently rendered range of indices. */
  setRenderedRange(range) {
    if (!rangesEqual(this._renderedRange, range)) {
      if (this.appendOnly) {
        range = {
          start: 0,
          end: Math.max(this._renderedRange.end, range.end)
        };
      }
      this._renderedRangeSubject.next(this._renderedRange = range);
      this._markChangeDetectionNeeded(() => this._scrollStrategy.onContentRendered());
    }
  }
  /**
   * Gets the offset from the start of the viewport to the start of the rendered data (in pixels).
   */
  getOffsetToRenderedContentStart() {
    return this._renderedContentOffsetNeedsRewrite ? null : this._renderedContentOffset;
  }
  /**
   * Sets the offset from the start of the viewport to either the start or end of the rendered data
   * (in pixels).
   */
  setRenderedContentOffset(offset, to = "to-start") {
    offset = this.appendOnly && to === "to-start" ? 0 : offset;
    const isRtl = this.dir && this.dir.value == "rtl";
    const isHorizontal = this.orientation == "horizontal";
    const axis = isHorizontal ? "X" : "Y";
    const axisDirection = isHorizontal && isRtl ? -1 : 1;
    let transform = `translate${axis}(${Number(axisDirection * offset)}px)`;
    this._renderedContentOffset = offset;
    if (to === "to-end") {
      transform += ` translate${axis}(-100%)`;
      this._renderedContentOffsetNeedsRewrite = true;
    }
    if (this._renderedContentTransform != transform) {
      this._renderedContentTransform = transform;
      this._markChangeDetectionNeeded(() => {
        if (this._renderedContentOffsetNeedsRewrite) {
          this._renderedContentOffset -= this.measureRenderedContentSize();
          this._renderedContentOffsetNeedsRewrite = false;
          this.setRenderedContentOffset(this._renderedContentOffset);
        } else {
          this._scrollStrategy.onRenderedOffsetChanged();
        }
      });
    }
  }
  /**
   * Scrolls to the given offset from the start of the viewport. Please note that this is not always
   * the same as setting `scrollTop` or `scrollLeft`. In a horizontal viewport with right-to-left
   * direction, this would be the equivalent of setting a fictional `scrollRight` property.
   * @param offset The offset to scroll to.
   * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.
   */
  scrollToOffset(offset, behavior = "auto") {
    const options = {
      behavior
    };
    if (this.orientation === "horizontal") {
      options.start = offset;
    } else {
      options.top = offset;
    }
    this.scrollable.scrollTo(options);
  }
  /**
   * Scrolls to the offset for the given index.
   * @param index The index of the element to scroll to.
   * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.
   */
  scrollToIndex(index, behavior = "auto") {
    this._scrollStrategy.scrollToIndex(index, behavior);
  }
  /**
   * Gets the current scroll offset from the start of the scrollable (in pixels).
   * @param from The edge to measure the offset from. Defaults to 'top' in vertical mode and 'start'
   *     in horizontal mode.
   */
  measureScrollOffset(from2) {
    let measureScrollOffset;
    if (this.scrollable == this) {
      measureScrollOffset = (_from) => super.measureScrollOffset(_from);
    } else {
      measureScrollOffset = (_from) => this.scrollable.measureScrollOffset(_from);
    }
    return Math.max(0, measureScrollOffset(from2 ?? (this.orientation === "horizontal" ? "start" : "top")) - this.measureViewportOffset());
  }
  /**
   * Measures the offset of the viewport from the scrolling container
   * @param from The edge to measure from.
   */
  measureViewportOffset(from2) {
    let fromRect;
    const LEFT = "left";
    const RIGHT = "right";
    const isRtl = this.dir?.value == "rtl";
    if (from2 == "start") {
      fromRect = isRtl ? RIGHT : LEFT;
    } else if (from2 == "end") {
      fromRect = isRtl ? LEFT : RIGHT;
    } else if (from2) {
      fromRect = from2;
    } else {
      fromRect = this.orientation === "horizontal" ? "left" : "top";
    }
    const scrollerClientRect = this.scrollable.measureBoundingClientRectWithScrollOffset(fromRect);
    const viewportClientRect = this.elementRef.nativeElement.getBoundingClientRect()[fromRect];
    return viewportClientRect - scrollerClientRect;
  }
  /** Measure the combined size of all of the rendered items. */
  measureRenderedContentSize() {
    const contentEl = this._contentWrapper.nativeElement;
    return this.orientation === "horizontal" ? contentEl.offsetWidth : contentEl.offsetHeight;
  }
  /**
   * Measure the total combined size of the given range. Throws if the range includes items that are
   * not rendered.
   */
  measureRangeSize(range) {
    if (!this._forOf) {
      return 0;
    }
    return this._forOf.measureRangeSize(range, this.orientation);
  }
  /** Update the viewport dimensions and re-render. */
  checkViewportSize() {
    this._measureViewportSize();
    this._scrollStrategy.onDataLengthChanged();
  }
  /** Measure the viewport size. */
  _measureViewportSize() {
    this._viewportSize = this.scrollable.measureViewportSize(this.orientation);
  }
  /** Queue up change detection to run. */
  _markChangeDetectionNeeded(runAfter) {
    if (runAfter) {
      this._runAfterChangeDetection.push(runAfter);
    }
    if (!this._isChangeDetectionPending) {
      this._isChangeDetectionPending = true;
      this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {
        this._doChangeDetection();
      }));
    }
  }
  /** Run change detection. */
  _doChangeDetection() {
    if (this._isDestroyed) {
      return;
    }
    this.ngZone.run(() => {
      this._changeDetectorRef.markForCheck();
      this._contentWrapper.nativeElement.style.transform = this._renderedContentTransform;
      afterNextRender(() => {
        this._isChangeDetectionPending = false;
        const runAfterChangeDetection = this._runAfterChangeDetection;
        this._runAfterChangeDetection = [];
        for (const fn of runAfterChangeDetection) {
          fn();
        }
      }, {
        injector: this._injector
      });
    });
  }
  /** Calculates the `style.width` and `style.height` for the spacer element. */
  _calculateSpacerSize() {
    this._totalContentHeight = this.orientation === "horizontal" ? "" : `${this._totalContentSize}px`;
    this._totalContentWidth = this.orientation === "horizontal" ? `${this._totalContentSize}px` : "";
  }
  static ɵfac = function CdkVirtualScrollViewport_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkVirtualScrollViewport)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CdkVirtualScrollViewport,
    selectors: [["cdk-virtual-scroll-viewport"]],
    viewQuery: function CdkVirtualScrollViewport_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._contentWrapper = _t.first);
      }
    },
    hostAttrs: [1, "cdk-virtual-scroll-viewport"],
    hostVars: 4,
    hostBindings: function CdkVirtualScrollViewport_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("cdk-virtual-scroll-orientation-horizontal", ctx.orientation === "horizontal")("cdk-virtual-scroll-orientation-vertical", ctx.orientation !== "horizontal");
      }
    },
    inputs: {
      orientation: "orientation",
      appendOnly: [2, "appendOnly", "appendOnly", booleanAttribute]
    },
    outputs: {
      scrolledIndexChange: "scrolledIndexChange"
    },
    features: [ɵɵProvidersFeature([{
      provide: CdkScrollable,
      useFactory: (virtualScrollable, viewport) => virtualScrollable || viewport,
      deps: [[new Optional(), new Inject(VIRTUAL_SCROLLABLE)], _CdkVirtualScrollViewport]
    }]), ɵɵInputTransformsFeature, ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c1,
    decls: 4,
    vars: 4,
    consts: [["contentWrapper", ""], [1, "cdk-virtual-scroll-content-wrapper"], [1, "cdk-virtual-scroll-spacer"]],
    template: function CdkVirtualScrollViewport_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵelementStart(0, "div", 1, 0);
        ɵɵprojection(2);
        ɵɵelementEnd();
        ɵɵelement(3, "div", 2);
      }
      if (rf & 2) {
        ɵɵadvance(3);
        ɵɵstyleProp("width", ctx._totalContentWidth)("height", ctx._totalContentHeight);
      }
    },
    styles: ["cdk-virtual-scroll-viewport{display:block;position:relative;transform:translateZ(0)}.cdk-virtual-scrollable{overflow:auto;will-change:scroll-position;contain:strict}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{height:1px;transform-origin:0 0;flex:0 0 auto}[dir=rtl] .cdk-virtual-scroll-spacer{transform-origin:100% 0}"],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollViewport, [{
    type: Component,
    args: [{
      selector: "cdk-virtual-scroll-viewport",
      host: {
        "class": "cdk-virtual-scroll-viewport",
        "[class.cdk-virtual-scroll-orientation-horizontal]": 'orientation === "horizontal"',
        "[class.cdk-virtual-scroll-orientation-vertical]": 'orientation !== "horizontal"'
      },
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: CdkScrollable,
        useFactory: (virtualScrollable, viewport) => virtualScrollable || viewport,
        deps: [[new Optional(), new Inject(VIRTUAL_SCROLLABLE)], CdkVirtualScrollViewport]
      }],
      template: '<!--\n  Wrap the rendered content in an element that will be used to offset it based on the scroll\n  position.\n-->\n<div #contentWrapper class="cdk-virtual-scroll-content-wrapper">\n  <ng-content></ng-content>\n</div>\n<!--\n  Spacer used to force the scrolling container to the correct size for the *total* number of items\n  so that the scrollbar captures the size of the entire data set.\n-->\n<div class="cdk-virtual-scroll-spacer"\n     [style.width]="_totalContentWidth" [style.height]="_totalContentHeight"></div>\n',
      styles: ["cdk-virtual-scroll-viewport{display:block;position:relative;transform:translateZ(0)}.cdk-virtual-scrollable{overflow:auto;will-change:scroll-position;contain:strict}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{height:1px;transform-origin:0 0;flex:0 0 auto}[dir=rtl] .cdk-virtual-scroll-spacer{transform-origin:100% 0}"]
    }]
  }], () => [], {
    orientation: [{
      type: Input
    }],
    appendOnly: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    scrolledIndexChange: [{
      type: Output
    }],
    _contentWrapper: [{
      type: ViewChild,
      args: ["contentWrapper", {
        static: true
      }]
    }]
  });
})();
function getOffset(orientation, direction, node) {
  const el = node;
  if (!el.getBoundingClientRect) {
    return 0;
  }
  const rect = el.getBoundingClientRect();
  if (orientation === "horizontal") {
    return direction === "start" ? rect.left : rect.right;
  }
  return direction === "start" ? rect.top : rect.bottom;
}
var CdkVirtualForOf = class _CdkVirtualForOf {
  _viewContainerRef = inject(ViewContainerRef);
  _template = inject(TemplateRef);
  _differs = inject(IterableDiffers);
  _viewRepeater = inject(_VIEW_REPEATER_STRATEGY);
  _viewport = inject(CdkVirtualScrollViewport, {
    skipSelf: true
  });
  /** Emits when the rendered view of the data changes. */
  viewChange = new Subject();
  /** Subject that emits when a new DataSource instance is given. */
  _dataSourceChanges = new Subject();
  /** The DataSource to display. */
  get cdkVirtualForOf() {
    return this._cdkVirtualForOf;
  }
  set cdkVirtualForOf(value) {
    this._cdkVirtualForOf = value;
    if (isDataSource(value)) {
      this._dataSourceChanges.next(value);
    } else {
      this._dataSourceChanges.next(new ArrayDataSource(isObservable(value) ? value : Array.from(value || [])));
    }
  }
  _cdkVirtualForOf;
  /**
   * The `TrackByFunction` to use for tracking changes. The `TrackByFunction` takes the index and
   * the item and produces a value to be used as the item's identity when tracking changes.
   */
  get cdkVirtualForTrackBy() {
    return this._cdkVirtualForTrackBy;
  }
  set cdkVirtualForTrackBy(fn) {
    this._needsUpdate = true;
    this._cdkVirtualForTrackBy = fn ? (index, item) => fn(index + (this._renderedRange ? this._renderedRange.start : 0), item) : void 0;
  }
  _cdkVirtualForTrackBy;
  /** The template used to stamp out new elements. */
  set cdkVirtualForTemplate(value) {
    if (value) {
      this._needsUpdate = true;
      this._template = value;
    }
  }
  /**
   * The size of the cache used to store templates that are not being used for re-use later.
   * Setting the cache size to `0` will disable caching. Defaults to 20 templates.
   */
  get cdkVirtualForTemplateCacheSize() {
    return this._viewRepeater.viewCacheSize;
  }
  set cdkVirtualForTemplateCacheSize(size) {
    this._viewRepeater.viewCacheSize = coerceNumberProperty(size);
  }
  /** Emits whenever the data in the current DataSource changes. */
  dataStream = this._dataSourceChanges.pipe(
    // Start off with null `DataSource`.
    startWith(null),
    // Bundle up the previous and current data sources so we can work with both.
    pairwise(),
    // Use `_changeDataSource` to disconnect from the previous data source and connect to the
    // new one, passing back a stream of data changes which we run through `switchMap` to give
    // us a data stream that emits the latest data from whatever the current `DataSource` is.
    switchMap(([prev, cur]) => this._changeDataSource(prev, cur)),
    // Replay the last emitted data when someone subscribes.
    shareReplay(1)
  );
  /** The differ used to calculate changes to the data. */
  _differ = null;
  /** The most recent data emitted from the DataSource. */
  _data;
  /** The currently rendered items. */
  _renderedItems;
  /** The currently rendered range of indices. */
  _renderedRange;
  /** Whether the rendered data should be updated during the next ngDoCheck cycle. */
  _needsUpdate = false;
  _destroyed = new Subject();
  constructor() {
    const ngZone = inject(NgZone);
    this.dataStream.subscribe((data) => {
      this._data = data;
      this._onRenderedDataChange();
    });
    this._viewport.renderedRangeStream.pipe(takeUntil(this._destroyed)).subscribe((range) => {
      this._renderedRange = range;
      if (this.viewChange.observers.length) {
        ngZone.run(() => this.viewChange.next(this._renderedRange));
      }
      this._onRenderedDataChange();
    });
    this._viewport.attach(this);
  }
  /**
   * Measures the combined size (width for horizontal orientation, height for vertical) of all items
   * in the specified range. Throws an error if the range includes items that are not currently
   * rendered.
   */
  measureRangeSize(range, orientation) {
    if (range.start >= range.end) {
      return 0;
    }
    if ((range.start < this._renderedRange.start || range.end > this._renderedRange.end) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error(`Error: attempted to measure an item that isn't rendered.`);
    }
    const renderedStartIndex = range.start - this._renderedRange.start;
    const rangeLen = range.end - range.start;
    let firstNode;
    let lastNode;
    for (let i = 0; i < rangeLen; i++) {
      const view = this._viewContainerRef.get(i + renderedStartIndex);
      if (view && view.rootNodes.length) {
        firstNode = lastNode = view.rootNodes[0];
        break;
      }
    }
    for (let i = rangeLen - 1; i > -1; i--) {
      const view = this._viewContainerRef.get(i + renderedStartIndex);
      if (view && view.rootNodes.length) {
        lastNode = view.rootNodes[view.rootNodes.length - 1];
        break;
      }
    }
    return firstNode && lastNode ? getOffset(orientation, "end", lastNode) - getOffset(orientation, "start", firstNode) : 0;
  }
  ngDoCheck() {
    if (this._differ && this._needsUpdate) {
      const changes = this._differ.diff(this._renderedItems);
      if (!changes) {
        this._updateContext();
      } else {
        this._applyChanges(changes);
      }
      this._needsUpdate = false;
    }
  }
  ngOnDestroy() {
    this._viewport.detach();
    this._dataSourceChanges.next(void 0);
    this._dataSourceChanges.complete();
    this.viewChange.complete();
    this._destroyed.next();
    this._destroyed.complete();
    this._viewRepeater.detach();
  }
  /** React to scroll state changes in the viewport. */
  _onRenderedDataChange() {
    if (!this._renderedRange) {
      return;
    }
    this._renderedItems = this._data.slice(this._renderedRange.start, this._renderedRange.end);
    if (!this._differ) {
      this._differ = this._differs.find(this._renderedItems).create((index, item) => {
        return this.cdkVirtualForTrackBy ? this.cdkVirtualForTrackBy(index, item) : item;
      });
    }
    this._needsUpdate = true;
  }
  /** Swap out one `DataSource` for another. */
  _changeDataSource(oldDs, newDs) {
    if (oldDs) {
      oldDs.disconnect(this);
    }
    this._needsUpdate = true;
    return newDs ? newDs.connect(this) : of();
  }
  /** Update the `CdkVirtualForOfContext` for all views. */
  _updateContext() {
    const count = this._data.length;
    let i = this._viewContainerRef.length;
    while (i--) {
      const view = this._viewContainerRef.get(i);
      view.context.index = this._renderedRange.start + i;
      view.context.count = count;
      this._updateComputedContextProperties(view.context);
      view.detectChanges();
    }
  }
  /** Apply changes to the DOM. */
  _applyChanges(changes) {
    this._viewRepeater.applyChanges(changes, this._viewContainerRef, (record, _adjustedPreviousIndex, currentIndex) => this._getEmbeddedViewArgs(record, currentIndex), (record) => record.item);
    changes.forEachIdentityChange((record) => {
      const view = this._viewContainerRef.get(record.currentIndex);
      view.context.$implicit = record.item;
    });
    const count = this._data.length;
    let i = this._viewContainerRef.length;
    while (i--) {
      const view = this._viewContainerRef.get(i);
      view.context.index = this._renderedRange.start + i;
      view.context.count = count;
      this._updateComputedContextProperties(view.context);
    }
  }
  /** Update the computed properties on the `CdkVirtualForOfContext`. */
  _updateComputedContextProperties(context) {
    context.first = context.index === 0;
    context.last = context.index === context.count - 1;
    context.even = context.index % 2 === 0;
    context.odd = !context.even;
  }
  _getEmbeddedViewArgs(record, index) {
    return {
      templateRef: this._template,
      context: {
        $implicit: record.item,
        // It's guaranteed that the iterable is not "undefined" or "null" because we only
        // generate views for elements if the "cdkVirtualForOf" iterable has elements.
        cdkVirtualForOf: this._cdkVirtualForOf,
        index: -1,
        count: -1,
        first: false,
        last: false,
        odd: false,
        even: false
      },
      index
    };
  }
  static ngTemplateContextGuard(directive, context) {
    return true;
  }
  static ɵfac = function CdkVirtualForOf_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkVirtualForOf)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkVirtualForOf,
    selectors: [["", "cdkVirtualFor", "", "cdkVirtualForOf", ""]],
    inputs: {
      cdkVirtualForOf: "cdkVirtualForOf",
      cdkVirtualForTrackBy: "cdkVirtualForTrackBy",
      cdkVirtualForTemplate: "cdkVirtualForTemplate",
      cdkVirtualForTemplateCacheSize: "cdkVirtualForTemplateCacheSize"
    },
    features: [ɵɵProvidersFeature([{
      provide: _VIEW_REPEATER_STRATEGY,
      useClass: _RecycleViewRepeaterStrategy
    }])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualForOf, [{
    type: Directive,
    args: [{
      selector: "[cdkVirtualFor][cdkVirtualForOf]",
      providers: [{
        provide: _VIEW_REPEATER_STRATEGY,
        useClass: _RecycleViewRepeaterStrategy
      }]
    }]
  }], () => [], {
    cdkVirtualForOf: [{
      type: Input
    }],
    cdkVirtualForTrackBy: [{
      type: Input
    }],
    cdkVirtualForTemplate: [{
      type: Input
    }],
    cdkVirtualForTemplateCacheSize: [{
      type: Input
    }]
  });
})();
var CdkVirtualScrollableElement = class _CdkVirtualScrollableElement extends CdkVirtualScrollable {
  constructor() {
    super();
  }
  measureBoundingClientRectWithScrollOffset(from2) {
    return this.getElementRef().nativeElement.getBoundingClientRect()[from2] - this.measureScrollOffset(from2);
  }
  static ɵfac = function CdkVirtualScrollableElement_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkVirtualScrollableElement)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkVirtualScrollableElement,
    selectors: [["", "cdkVirtualScrollingElement", ""]],
    hostAttrs: [1, "cdk-virtual-scrollable"],
    features: [ɵɵProvidersFeature([{
      provide: VIRTUAL_SCROLLABLE,
      useExisting: _CdkVirtualScrollableElement
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollableElement, [{
    type: Directive,
    args: [{
      selector: "[cdkVirtualScrollingElement]",
      providers: [{
        provide: VIRTUAL_SCROLLABLE,
        useExisting: CdkVirtualScrollableElement
      }],
      host: {
        "class": "cdk-virtual-scrollable"
      }
    }]
  }], () => [], null);
})();
var CdkVirtualScrollableWindow = class _CdkVirtualScrollableWindow extends CdkVirtualScrollable {
  constructor() {
    super();
    const document2 = inject(DOCUMENT);
    this.elementRef = new ElementRef(document2.documentElement);
    this._scrollElement = document2;
  }
  measureBoundingClientRectWithScrollOffset(from2) {
    return this.getElementRef().nativeElement.getBoundingClientRect()[from2];
  }
  static ɵfac = function CdkVirtualScrollableWindow_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkVirtualScrollableWindow)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkVirtualScrollableWindow,
    selectors: [["cdk-virtual-scroll-viewport", "scrollWindow", ""]],
    features: [ɵɵProvidersFeature([{
      provide: VIRTUAL_SCROLLABLE,
      useExisting: _CdkVirtualScrollableWindow
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollableWindow, [{
    type: Directive,
    args: [{
      selector: "cdk-virtual-scroll-viewport[scrollWindow]",
      providers: [{
        provide: VIRTUAL_SCROLLABLE,
        useExisting: CdkVirtualScrollableWindow
      }]
    }]
  }], () => [], null);
})();
var CdkScrollableModule = class _CdkScrollableModule {
  static ɵfac = function CdkScrollableModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkScrollableModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _CdkScrollableModule,
    imports: [CdkScrollable],
    exports: [CdkScrollable]
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkScrollableModule, [{
    type: NgModule,
    args: [{
      exports: [CdkScrollable],
      imports: [CdkScrollable]
    }]
  }], null, null);
})();
var ScrollingModule = class _ScrollingModule {
  static ɵfac = function ScrollingModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ScrollingModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _ScrollingModule,
    imports: [BidiModule, CdkScrollableModule, CdkVirtualScrollViewport, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollableWindow, CdkVirtualScrollableElement],
    exports: [BidiModule, CdkScrollableModule, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport, CdkVirtualScrollableWindow, CdkVirtualScrollableElement]
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [BidiModule, CdkScrollableModule, BidiModule, CdkScrollableModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollingModule, [{
    type: NgModule,
    args: [{
      imports: [BidiModule, CdkScrollableModule, CdkVirtualScrollViewport, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollableWindow, CdkVirtualScrollableElement],
      exports: [BidiModule, CdkScrollableModule, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport, CdkVirtualScrollableWindow, CdkVirtualScrollableElement]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/drag-drop.mjs
function deepCloneNode(node) {
  const clone = node.cloneNode(true);
  const descendantsWithId = clone.querySelectorAll("[id]");
  const nodeName = node.nodeName.toLowerCase();
  clone.removeAttribute("id");
  for (let i = 0; i < descendantsWithId.length; i++) {
    descendantsWithId[i].removeAttribute("id");
  }
  if (nodeName === "canvas") {
    transferCanvasData(node, clone);
  } else if (nodeName === "input" || nodeName === "select" || nodeName === "textarea") {
    transferInputData(node, clone);
  }
  transferData("canvas", node, clone, transferCanvasData);
  transferData("input, textarea, select", node, clone, transferInputData);
  return clone;
}
function transferData(selector, node, clone, callback) {
  const descendantElements = node.querySelectorAll(selector);
  if (descendantElements.length) {
    const cloneElements = clone.querySelectorAll(selector);
    for (let i = 0; i < descendantElements.length; i++) {
      callback(descendantElements[i], cloneElements[i]);
    }
  }
}
var cloneUniqueId = 0;
function transferInputData(source, clone) {
  if (clone.type !== "file") {
    clone.value = source.value;
  }
  if (clone.type === "radio" && clone.name) {
    clone.name = `mat-clone-${clone.name}-${cloneUniqueId++}`;
  }
}
function transferCanvasData(source, clone) {
  const context = clone.getContext("2d");
  if (context) {
    try {
      context.drawImage(source, 0, 0);
    } catch {
    }
  }
}
function getMutableClientRect(element) {
  const rect = element.getBoundingClientRect();
  return {
    top: rect.top,
    right: rect.right,
    bottom: rect.bottom,
    left: rect.left,
    width: rect.width,
    height: rect.height,
    x: rect.x,
    y: rect.y
  };
}
function isInsideClientRect(clientRect, x, y) {
  const {
    top,
    bottom,
    left,
    right
  } = clientRect;
  return y >= top && y <= bottom && x >= left && x <= right;
}
function adjustDomRect(domRect, top, left) {
  domRect.top += top;
  domRect.bottom = domRect.top + domRect.height;
  domRect.left += left;
  domRect.right = domRect.left + domRect.width;
}
function isPointerNearDomRect(rect, threshold, pointerX, pointerY) {
  const {
    top,
    right,
    bottom,
    left,
    width,
    height
  } = rect;
  const xThreshold = width * threshold;
  const yThreshold = height * threshold;
  return pointerY > top - yThreshold && pointerY < bottom + yThreshold && pointerX > left - xThreshold && pointerX < right + xThreshold;
}
var ParentPositionTracker = class {
  _document;
  /** Cached positions of the scrollable parent elements. */
  positions = /* @__PURE__ */ new Map();
  constructor(_document) {
    this._document = _document;
  }
  /** Clears the cached positions. */
  clear() {
    this.positions.clear();
  }
  /** Caches the positions. Should be called at the beginning of a drag sequence. */
  cache(elements) {
    this.clear();
    this.positions.set(this._document, {
      scrollPosition: this.getViewportScrollPosition()
    });
    elements.forEach((element) => {
      this.positions.set(element, {
        scrollPosition: {
          top: element.scrollTop,
          left: element.scrollLeft
        },
        clientRect: getMutableClientRect(element)
      });
    });
  }
  /** Handles scrolling while a drag is taking place. */
  handleScroll(event) {
    const target = _getEventTarget(event);
    const cachedPosition = this.positions.get(target);
    if (!cachedPosition) {
      return null;
    }
    const scrollPosition = cachedPosition.scrollPosition;
    let newTop;
    let newLeft;
    if (target === this._document) {
      const viewportScrollPosition = this.getViewportScrollPosition();
      newTop = viewportScrollPosition.top;
      newLeft = viewportScrollPosition.left;
    } else {
      newTop = target.scrollTop;
      newLeft = target.scrollLeft;
    }
    const topDifference = scrollPosition.top - newTop;
    const leftDifference = scrollPosition.left - newLeft;
    this.positions.forEach((position, node) => {
      if (position.clientRect && target !== node && target.contains(node)) {
        adjustDomRect(position.clientRect, topDifference, leftDifference);
      }
    });
    scrollPosition.top = newTop;
    scrollPosition.left = newLeft;
    return {
      top: topDifference,
      left: leftDifference
    };
  }
  /**
   * Gets the scroll position of the viewport. Note that we use the scrollX and scrollY directly,
   * instead of going through the `ViewportRuler`, because the first value the ruler looks at is
   * the top/left offset of the `document.documentElement` which works for most cases, but breaks
   * if the element is offset by something like the `BlockScrollStrategy`.
   */
  getViewportScrollPosition() {
    return {
      top: window.scrollY,
      left: window.scrollX
    };
  }
};
function getRootNode(viewRef, _document) {
  const rootNodes = viewRef.rootNodes;
  if (rootNodes.length === 1 && rootNodes[0].nodeType === _document.ELEMENT_NODE) {
    return rootNodes[0];
  }
  const wrapper = _document.createElement("div");
  rootNodes.forEach((node) => wrapper.appendChild(node));
  return wrapper;
}
function extendStyles(dest, source, importantProperties2) {
  for (let key in source) {
    if (source.hasOwnProperty(key)) {
      const value = source[key];
      if (value) {
        dest.setProperty(key, value, importantProperties2?.has(key) ? "important" : "");
      } else {
        dest.removeProperty(key);
      }
    }
  }
  return dest;
}
function toggleNativeDragInteractions(element, enable) {
  const userSelect = enable ? "" : "none";
  extendStyles(element.style, {
    "touch-action": enable ? "" : "none",
    "-webkit-user-drag": enable ? "" : "none",
    "-webkit-tap-highlight-color": enable ? "" : "transparent",
    "user-select": userSelect,
    "-ms-user-select": userSelect,
    "-webkit-user-select": userSelect,
    "-moz-user-select": userSelect
  });
}
function toggleVisibility(element, enable, importantProperties2) {
  extendStyles(element.style, {
    position: enable ? "" : "fixed",
    top: enable ? "" : "0",
    opacity: enable ? "" : "0",
    left: enable ? "" : "-999em"
  }, importantProperties2);
}
function combineTransforms(transform, initialTransform) {
  return initialTransform && initialTransform != "none" ? transform + " " + initialTransform : transform;
}
function matchElementSize(target, sourceRect) {
  target.style.width = `${sourceRect.width}px`;
  target.style.height = `${sourceRect.height}px`;
  target.style.transform = getTransform(sourceRect.left, sourceRect.top);
}
function getTransform(x, y) {
  return `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`;
}
function parseCssTimeUnitsToMs(value) {
  const multiplier = value.toLowerCase().indexOf("ms") > -1 ? 1 : 1e3;
  return parseFloat(value) * multiplier;
}
function getTransformTransitionDurationInMs(element) {
  const computedStyle = getComputedStyle(element);
  const transitionedProperties = parseCssPropertyValue(computedStyle, "transition-property");
  const property = transitionedProperties.find((prop) => prop === "transform" || prop === "all");
  if (!property) {
    return 0;
  }
  const propertyIndex = transitionedProperties.indexOf(property);
  const rawDurations = parseCssPropertyValue(computedStyle, "transition-duration");
  const rawDelays = parseCssPropertyValue(computedStyle, "transition-delay");
  return parseCssTimeUnitsToMs(rawDurations[propertyIndex]) + parseCssTimeUnitsToMs(rawDelays[propertyIndex]);
}
function parseCssPropertyValue(computedStyle, name) {
  const value = computedStyle.getPropertyValue(name);
  return value.split(",").map((part) => part.trim());
}
var importantProperties = /* @__PURE__ */ new Set([
  // Needs to be important, because some `mat-table` sets `position: sticky !important`. See #22781.
  "position"
]);
var PreviewRef = class {
  _document;
  _rootElement;
  _direction;
  _initialDomRect;
  _previewTemplate;
  _previewClass;
  _pickupPositionOnPage;
  _initialTransform;
  _zIndex;
  _renderer;
  /** Reference to the view of the preview element. */
  _previewEmbeddedView;
  /** Reference to the preview element. */
  _preview;
  get element() {
    return this._preview;
  }
  constructor(_document, _rootElement, _direction, _initialDomRect, _previewTemplate, _previewClass, _pickupPositionOnPage, _initialTransform, _zIndex, _renderer) {
    this._document = _document;
    this._rootElement = _rootElement;
    this._direction = _direction;
    this._initialDomRect = _initialDomRect;
    this._previewTemplate = _previewTemplate;
    this._previewClass = _previewClass;
    this._pickupPositionOnPage = _pickupPositionOnPage;
    this._initialTransform = _initialTransform;
    this._zIndex = _zIndex;
    this._renderer = _renderer;
  }
  attach(parent) {
    this._preview = this._createPreview();
    parent.appendChild(this._preview);
    if (supportsPopover(this._preview)) {
      this._preview["showPopover"]();
    }
  }
  destroy() {
    this._preview.remove();
    this._previewEmbeddedView?.destroy();
    this._preview = this._previewEmbeddedView = null;
  }
  setTransform(value) {
    this._preview.style.transform = value;
  }
  getBoundingClientRect() {
    return this._preview.getBoundingClientRect();
  }
  addClass(className) {
    this._preview.classList.add(className);
  }
  getTransitionDuration() {
    return getTransformTransitionDurationInMs(this._preview);
  }
  addEventListener(name, handler) {
    return this._renderer.listen(this._preview, name, handler);
  }
  _createPreview() {
    const previewConfig = this._previewTemplate;
    const previewClass = this._previewClass;
    const previewTemplate = previewConfig ? previewConfig.template : null;
    let preview;
    if (previewTemplate && previewConfig) {
      const rootRect = previewConfig.matchSize ? this._initialDomRect : null;
      const viewRef = previewConfig.viewContainer.createEmbeddedView(previewTemplate, previewConfig.context);
      viewRef.detectChanges();
      preview = getRootNode(viewRef, this._document);
      this._previewEmbeddedView = viewRef;
      if (previewConfig.matchSize) {
        matchElementSize(preview, rootRect);
      } else {
        preview.style.transform = getTransform(this._pickupPositionOnPage.x, this._pickupPositionOnPage.y);
      }
    } else {
      preview = deepCloneNode(this._rootElement);
      matchElementSize(preview, this._initialDomRect);
      if (this._initialTransform) {
        preview.style.transform = this._initialTransform;
      }
    }
    extendStyles(preview.style, {
      // It's important that we disable the pointer events on the preview, because
      // it can throw off the `document.elementFromPoint` calls in the `CdkDropList`.
      "pointer-events": "none",
      // If the preview has a margin, it can throw off our positioning so we reset it. The reset
      // value for `margin-right` needs to be `auto` when opened as a popover, because our
      // positioning is always top/left based, but native popover seems to position itself
      // to the top/right if `<html>` or `<body>` have `dir="rtl"` (see #29604). Setting it
      // to `auto` pushed it to the top/left corner in RTL and is a noop in LTR.
      "margin": supportsPopover(preview) ? "0 auto 0 0" : "0",
      "position": "fixed",
      "top": "0",
      "left": "0",
      "z-index": this._zIndex + ""
    }, importantProperties);
    toggleNativeDragInteractions(preview, false);
    preview.classList.add("cdk-drag-preview");
    preview.setAttribute("popover", "manual");
    preview.setAttribute("dir", this._direction);
    if (previewClass) {
      if (Array.isArray(previewClass)) {
        previewClass.forEach((className) => preview.classList.add(className));
      } else {
        preview.classList.add(previewClass);
      }
    }
    return preview;
  }
};
function supportsPopover(element) {
  return "showPopover" in element;
}
var passiveEventListenerOptions = normalizePassiveListenerOptions({
  passive: true
});
var activeEventListenerOptions = normalizePassiveListenerOptions({
  passive: false
});
var activeCapturingEventOptions$1 = normalizePassiveListenerOptions({
  passive: false,
  capture: true
});
var MOUSE_EVENT_IGNORE_TIME = 800;
var dragImportantProperties = /* @__PURE__ */ new Set([
  // Needs to be important, because some `mat-table` sets `position: sticky !important`. See #22781.
  "position"
]);
var DragRef = class {
  _config;
  _document;
  _ngZone;
  _viewportRuler;
  _dragDropRegistry;
  _renderer;
  /** Element displayed next to the user's pointer while the element is dragged. */
  _preview;
  /** Container into which to insert the preview. */
  _previewContainer;
  /** Reference to the view of the placeholder element. */
  _placeholderRef;
  /** Element that is rendered instead of the draggable item while it is being sorted. */
  _placeholder;
  /** Coordinates within the element at which the user picked up the element. */
  _pickupPositionInElement;
  /** Coordinates on the page at which the user picked up the element. */
  _pickupPositionOnPage;
  /**
   * Anchor node used to save the place in the DOM where the element was
   * picked up so that it can be restored at the end of the drag sequence.
   */
  _anchor;
  /**
   * CSS `transform` applied to the element when it isn't being dragged. We need a
   * passive transform in order for the dragged element to retain its new position
   * after the user has stopped dragging and because we need to know the relative
   * position in case they start dragging again. This corresponds to `element.style.transform`.
   */
  _passiveTransform = {
    x: 0,
    y: 0
  };
  /** CSS `transform` that is applied to the element while it's being dragged. */
  _activeTransform = {
    x: 0,
    y: 0
  };
  /** Inline `transform` value that the element had before the first dragging sequence. */
  _initialTransform;
  /**
   * Whether the dragging sequence has been started. Doesn't
   * necessarily mean that the element has been moved.
   */
  _hasStartedDragging = signal(false);
  /** Whether the element has moved since the user started dragging it. */
  _hasMoved;
  /** Drop container in which the DragRef resided when dragging began. */
  _initialContainer;
  /** Index at which the item started in its initial container. */
  _initialIndex;
  /** Cached positions of scrollable parent elements. */
  _parentPositions;
  /** Emits when the item is being moved. */
  _moveEvents = new Subject();
  /** Keeps track of the direction in which the user is dragging along each axis. */
  _pointerDirectionDelta;
  /** Pointer position at which the last change in the delta occurred. */
  _pointerPositionAtLastDirectionChange;
  /** Position of the pointer at the last pointer event. */
  _lastKnownPointerPosition;
  /**
   * Root DOM node of the drag instance. This is the element that will
   * be moved around as the user is dragging.
   */
  _rootElement;
  /**
   * Nearest ancestor SVG, relative to which coordinates are calculated if dragging SVGElement
   */
  _ownerSVGElement;
  /**
   * Inline style value of `-webkit-tap-highlight-color` at the time the
   * dragging was started. Used to restore the value once we're done dragging.
   */
  _rootElementTapHighlight;
  /** Subscription to pointer movement events. */
  _pointerMoveSubscription = Subscription.EMPTY;
  /** Subscription to the event that is dispatched when the user lifts their pointer. */
  _pointerUpSubscription = Subscription.EMPTY;
  /** Subscription to the viewport being scrolled. */
  _scrollSubscription = Subscription.EMPTY;
  /** Subscription to the viewport being resized. */
  _resizeSubscription = Subscription.EMPTY;
  /**
   * Time at which the last touch event occurred. Used to avoid firing the same
   * events multiple times on touch devices where the browser will fire a fake
   * mouse event for each touch event, after a certain time.
   */
  _lastTouchEventTime;
  /** Time at which the last dragging sequence was started. */
  _dragStartTime;
  /** Cached reference to the boundary element. */
  _boundaryElement = null;
  /** Whether the native dragging interactions have been enabled on the root element. */
  _nativeInteractionsEnabled = true;
  /** Client rect of the root element when the dragging sequence has started. */
  _initialDomRect;
  /** Cached dimensions of the preview element. Should be read via `_getPreviewRect`. */
  _previewRect;
  /** Cached dimensions of the boundary element. */
  _boundaryRect;
  /** Element that will be used as a template to create the draggable item's preview. */
  _previewTemplate;
  /** Template for placeholder element rendered to show where a draggable would be dropped. */
  _placeholderTemplate;
  /** Elements that can be used to drag the draggable item. */
  _handles = [];
  /** Registered handles that are currently disabled. */
  _disabledHandles = /* @__PURE__ */ new Set();
  /** Droppable container that the draggable is a part of. */
  _dropContainer;
  /** Layout direction of the item. */
  _direction = "ltr";
  /** Ref that the current drag item is nested in. */
  _parentDragRef;
  /**
   * Cached shadow root that the element is placed in. `null` means that the element isn't in
   * the shadow DOM and `undefined` means that it hasn't been resolved yet. Should be read via
   * `_getShadowRoot`, not directly.
   */
  _cachedShadowRoot;
  /** Axis along which dragging is locked. */
  lockAxis;
  /**
   * Amount of milliseconds to wait after the user has put their
   * pointer down before starting to drag the element.
   */
  dragStartDelay = 0;
  /** Class to be added to the preview element. */
  previewClass;
  /**
   * If the parent of the dragged element has a `scale` transform, it can throw off the
   * positioning when the user starts dragging. Use this input to notify the CDK of the scale.
   */
  scale = 1;
  /** Whether starting to drag this element is disabled. */
  get disabled() {
    return this._disabled || !!(this._dropContainer && this._dropContainer.disabled);
  }
  set disabled(value) {
    if (value !== this._disabled) {
      this._disabled = value;
      this._toggleNativeDragInteractions();
      this._handles.forEach((handle) => toggleNativeDragInteractions(handle, value));
    }
  }
  _disabled = false;
  /** Emits as the drag sequence is being prepared. */
  beforeStarted = new Subject();
  /** Emits when the user starts dragging the item. */
  started = new Subject();
  /** Emits when the user has released a drag item, before any animations have started. */
  released = new Subject();
  /** Emits when the user stops dragging an item in the container. */
  ended = new Subject();
  /** Emits when the user has moved the item into a new container. */
  entered = new Subject();
  /** Emits when the user removes the item its container by dragging it into another container. */
  exited = new Subject();
  /** Emits when the user drops the item inside a container. */
  dropped = new Subject();
  /**
   * Emits as the user is dragging the item. Use with caution,
   * because this event will fire for every pixel that the user has dragged.
   */
  moved = this._moveEvents;
  /** Arbitrary data that can be attached to the drag item. */
  data;
  /**
   * Function that can be used to customize the logic of how the position of the drag item
   * is limited while it's being dragged. Gets called with a point containing the current position
   * of the user's pointer on the page, a reference to the item being dragged and its dimensions.
   * Should return a point describing where the item should be rendered.
   */
  constrainPosition;
  constructor(element, _config, _document, _ngZone, _viewportRuler, _dragDropRegistry, _renderer) {
    this._config = _config;
    this._document = _document;
    this._ngZone = _ngZone;
    this._viewportRuler = _viewportRuler;
    this._dragDropRegistry = _dragDropRegistry;
    this._renderer = _renderer;
    this.withRootElement(element).withParent(_config.parentDragRef || null);
    this._parentPositions = new ParentPositionTracker(_document);
    _dragDropRegistry.registerDragItem(this);
  }
  /**
   * Returns the element that is being used as a placeholder
   * while the current element is being dragged.
   */
  getPlaceholderElement() {
    return this._placeholder;
  }
  /** Returns the root draggable element. */
  getRootElement() {
    return this._rootElement;
  }
  /**
   * Gets the currently-visible element that represents the drag item.
   * While dragging this is the placeholder, otherwise it's the root element.
   */
  getVisibleElement() {
    return this.isDragging() ? this.getPlaceholderElement() : this.getRootElement();
  }
  /** Registers the handles that can be used to drag the element. */
  withHandles(handles) {
    this._handles = handles.map((handle) => coerceElement(handle));
    this._handles.forEach((handle) => toggleNativeDragInteractions(handle, this.disabled));
    this._toggleNativeDragInteractions();
    const disabledHandles = /* @__PURE__ */ new Set();
    this._disabledHandles.forEach((handle) => {
      if (this._handles.indexOf(handle) > -1) {
        disabledHandles.add(handle);
      }
    });
    this._disabledHandles = disabledHandles;
    return this;
  }
  /**
   * Registers the template that should be used for the drag preview.
   * @param template Template that from which to stamp out the preview.
   */
  withPreviewTemplate(template) {
    this._previewTemplate = template;
    return this;
  }
  /**
   * Registers the template that should be used for the drag placeholder.
   * @param template Template that from which to stamp out the placeholder.
   */
  withPlaceholderTemplate(template) {
    this._placeholderTemplate = template;
    return this;
  }
  /**
   * Sets an alternate drag root element. The root element is the element that will be moved as
   * the user is dragging. Passing an alternate root element is useful when trying to enable
   * dragging on an element that you might not have access to.
   */
  withRootElement(rootElement) {
    const element = coerceElement(rootElement);
    if (element !== this._rootElement) {
      if (this._rootElement) {
        this._removeRootElementListeners(this._rootElement);
      }
      this._ngZone.runOutsideAngular(() => {
        element.addEventListener("mousedown", this._pointerDown, activeEventListenerOptions);
        element.addEventListener("touchstart", this._pointerDown, passiveEventListenerOptions);
        element.addEventListener("dragstart", this._nativeDragStart, activeEventListenerOptions);
      });
      this._initialTransform = void 0;
      this._rootElement = element;
    }
    if (typeof SVGElement !== "undefined" && this._rootElement instanceof SVGElement) {
      this._ownerSVGElement = this._rootElement.ownerSVGElement;
    }
    return this;
  }
  /**
   * Element to which the draggable's position will be constrained.
   */
  withBoundaryElement(boundaryElement) {
    this._boundaryElement = boundaryElement ? coerceElement(boundaryElement) : null;
    this._resizeSubscription.unsubscribe();
    if (boundaryElement) {
      this._resizeSubscription = this._viewportRuler.change(10).subscribe(() => this._containInsideBoundaryOnResize());
    }
    return this;
  }
  /** Sets the parent ref that the ref is nested in.  */
  withParent(parent) {
    this._parentDragRef = parent;
    return this;
  }
  /** Removes the dragging functionality from the DOM element. */
  dispose() {
    this._removeRootElementListeners(this._rootElement);
    if (this.isDragging()) {
      this._rootElement?.remove();
    }
    this._anchor?.remove();
    this._destroyPreview();
    this._destroyPlaceholder();
    this._dragDropRegistry.removeDragItem(this);
    this._removeListeners();
    this.beforeStarted.complete();
    this.started.complete();
    this.released.complete();
    this.ended.complete();
    this.entered.complete();
    this.exited.complete();
    this.dropped.complete();
    this._moveEvents.complete();
    this._handles = [];
    this._disabledHandles.clear();
    this._dropContainer = void 0;
    this._resizeSubscription.unsubscribe();
    this._parentPositions.clear();
    this._boundaryElement = this._rootElement = this._ownerSVGElement = this._placeholderTemplate = this._previewTemplate = this._anchor = this._parentDragRef = null;
  }
  /** Checks whether the element is currently being dragged. */
  isDragging() {
    return this._hasStartedDragging() && this._dragDropRegistry.isDragging(this);
  }
  /** Resets a standalone drag item to its initial position. */
  reset() {
    this._rootElement.style.transform = this._initialTransform || "";
    this._activeTransform = {
      x: 0,
      y: 0
    };
    this._passiveTransform = {
      x: 0,
      y: 0
    };
  }
  /**
   * Sets a handle as disabled. While a handle is disabled, it'll capture and interrupt dragging.
   * @param handle Handle element that should be disabled.
   */
  disableHandle(handle) {
    if (!this._disabledHandles.has(handle) && this._handles.indexOf(handle) > -1) {
      this._disabledHandles.add(handle);
      toggleNativeDragInteractions(handle, true);
    }
  }
  /**
   * Enables a handle, if it has been disabled.
   * @param handle Handle element to be enabled.
   */
  enableHandle(handle) {
    if (this._disabledHandles.has(handle)) {
      this._disabledHandles.delete(handle);
      toggleNativeDragInteractions(handle, this.disabled);
    }
  }
  /** Sets the layout direction of the draggable item. */
  withDirection(direction) {
    this._direction = direction;
    return this;
  }
  /** Sets the container that the item is part of. */
  _withDropContainer(container) {
    this._dropContainer = container;
  }
  /**
   * Gets the current position in pixels the draggable outside of a drop container.
   */
  getFreeDragPosition() {
    const position = this.isDragging() ? this._activeTransform : this._passiveTransform;
    return {
      x: position.x,
      y: position.y
    };
  }
  /**
   * Sets the current position in pixels the draggable outside of a drop container.
   * @param value New position to be set.
   */
  setFreeDragPosition(value) {
    this._activeTransform = {
      x: 0,
      y: 0
    };
    this._passiveTransform.x = value.x;
    this._passiveTransform.y = value.y;
    if (!this._dropContainer) {
      this._applyRootElementTransform(value.x, value.y);
    }
    return this;
  }
  /**
   * Sets the container into which to insert the preview element.
   * @param value Container into which to insert the preview.
   */
  withPreviewContainer(value) {
    this._previewContainer = value;
    return this;
  }
  /** Updates the item's sort order based on the last-known pointer position. */
  _sortFromLastPointerPosition() {
    const position = this._lastKnownPointerPosition;
    if (position && this._dropContainer) {
      this._updateActiveDropContainer(this._getConstrainedPointerPosition(position), position);
    }
  }
  /** Unsubscribes from the global subscriptions. */
  _removeListeners() {
    this._pointerMoveSubscription.unsubscribe();
    this._pointerUpSubscription.unsubscribe();
    this._scrollSubscription.unsubscribe();
    this._getShadowRoot()?.removeEventListener("selectstart", shadowDomSelectStart, activeCapturingEventOptions$1);
  }
  /** Destroys the preview element and its ViewRef. */
  _destroyPreview() {
    this._preview?.destroy();
    this._preview = null;
  }
  /** Destroys the placeholder element and its ViewRef. */
  _destroyPlaceholder() {
    this._placeholder?.remove();
    this._placeholderRef?.destroy();
    this._placeholder = this._placeholderRef = null;
  }
  /** Handler for the `mousedown`/`touchstart` events. */
  _pointerDown = (event) => {
    this.beforeStarted.next();
    if (this._handles.length) {
      const targetHandle = this._getTargetHandle(event);
      if (targetHandle && !this._disabledHandles.has(targetHandle) && !this.disabled) {
        this._initializeDragSequence(targetHandle, event);
      }
    } else if (!this.disabled) {
      this._initializeDragSequence(this._rootElement, event);
    }
  };
  /** Handler that is invoked when the user moves their pointer after they've initiated a drag. */
  _pointerMove = (event) => {
    const pointerPosition = this._getPointerPositionOnPage(event);
    if (!this._hasStartedDragging()) {
      const distanceX = Math.abs(pointerPosition.x - this._pickupPositionOnPage.x);
      const distanceY = Math.abs(pointerPosition.y - this._pickupPositionOnPage.y);
      const isOverThreshold = distanceX + distanceY >= this._config.dragStartThreshold;
      if (isOverThreshold) {
        const isDelayElapsed = Date.now() >= this._dragStartTime + this._getDragStartDelay(event);
        const container = this._dropContainer;
        if (!isDelayElapsed) {
          this._endDragSequence(event);
          return;
        }
        if (!container || !container.isDragging() && !container.isReceiving()) {
          if (event.cancelable) {
            event.preventDefault();
          }
          this._hasStartedDragging.set(true);
          this._ngZone.run(() => this._startDragSequence(event));
        }
      }
      return;
    }
    if (event.cancelable) {
      event.preventDefault();
    }
    const constrainedPointerPosition = this._getConstrainedPointerPosition(pointerPosition);
    this._hasMoved = true;
    this._lastKnownPointerPosition = pointerPosition;
    this._updatePointerDirectionDelta(constrainedPointerPosition);
    if (this._dropContainer) {
      this._updateActiveDropContainer(constrainedPointerPosition, pointerPosition);
    } else {
      const offset = this.constrainPosition ? this._initialDomRect : this._pickupPositionOnPage;
      const activeTransform = this._activeTransform;
      activeTransform.x = constrainedPointerPosition.x - offset.x + this._passiveTransform.x;
      activeTransform.y = constrainedPointerPosition.y - offset.y + this._passiveTransform.y;
      this._applyRootElementTransform(activeTransform.x, activeTransform.y);
    }
    if (this._moveEvents.observers.length) {
      this._ngZone.run(() => {
        this._moveEvents.next({
          source: this,
          pointerPosition: constrainedPointerPosition,
          event,
          distance: this._getDragDistance(constrainedPointerPosition),
          delta: this._pointerDirectionDelta
        });
      });
    }
  };
  /** Handler that is invoked when the user lifts their pointer up, after initiating a drag. */
  _pointerUp = (event) => {
    this._endDragSequence(event);
  };
  /**
   * Clears subscriptions and stops the dragging sequence.
   * @param event Browser event object that ended the sequence.
   */
  _endDragSequence(event) {
    if (!this._dragDropRegistry.isDragging(this)) {
      return;
    }
    this._removeListeners();
    this._dragDropRegistry.stopDragging(this);
    this._toggleNativeDragInteractions();
    if (this._handles) {
      this._rootElement.style.webkitTapHighlightColor = this._rootElementTapHighlight;
    }
    if (!this._hasStartedDragging()) {
      return;
    }
    this.released.next({
      source: this,
      event
    });
    if (this._dropContainer) {
      this._dropContainer._stopScrolling();
      this._animatePreviewToPlaceholder().then(() => {
        this._cleanupDragArtifacts(event);
        this._cleanupCachedDimensions();
        this._dragDropRegistry.stopDragging(this);
      });
    } else {
      this._passiveTransform.x = this._activeTransform.x;
      const pointerPosition = this._getPointerPositionOnPage(event);
      this._passiveTransform.y = this._activeTransform.y;
      this._ngZone.run(() => {
        this.ended.next({
          source: this,
          distance: this._getDragDistance(pointerPosition),
          dropPoint: pointerPosition,
          event
        });
      });
      this._cleanupCachedDimensions();
      this._dragDropRegistry.stopDragging(this);
    }
  }
  /** Starts the dragging sequence. */
  _startDragSequence(event) {
    if (isTouchEvent(event)) {
      this._lastTouchEventTime = Date.now();
    }
    this._toggleNativeDragInteractions();
    const shadowRoot = this._getShadowRoot();
    const dropContainer = this._dropContainer;
    if (shadowRoot) {
      this._ngZone.runOutsideAngular(() => {
        shadowRoot.addEventListener("selectstart", shadowDomSelectStart, activeCapturingEventOptions$1);
      });
    }
    if (dropContainer) {
      const element = this._rootElement;
      const parent = element.parentNode;
      const placeholder = this._placeholder = this._createPlaceholderElement();
      const anchor = this._anchor = this._anchor || this._document.createComment(typeof ngDevMode === "undefined" || ngDevMode ? "cdk-drag-anchor" : "");
      parent.insertBefore(anchor, element);
      this._initialTransform = element.style.transform || "";
      this._preview = new PreviewRef(this._document, this._rootElement, this._direction, this._initialDomRect, this._previewTemplate || null, this.previewClass || null, this._pickupPositionOnPage, this._initialTransform, this._config.zIndex || 1e3, this._renderer);
      this._preview.attach(this._getPreviewInsertionPoint(parent, shadowRoot));
      toggleVisibility(element, false, dragImportantProperties);
      this._document.body.appendChild(parent.replaceChild(placeholder, element));
      this.started.next({
        source: this,
        event
      });
      dropContainer.start();
      this._initialContainer = dropContainer;
      this._initialIndex = dropContainer.getItemIndex(this);
    } else {
      this.started.next({
        source: this,
        event
      });
      this._initialContainer = this._initialIndex = void 0;
    }
    this._parentPositions.cache(dropContainer ? dropContainer.getScrollableParents() : []);
  }
  /**
   * Sets up the different variables and subscriptions
   * that will be necessary for the dragging sequence.
   * @param referenceElement Element that started the drag sequence.
   * @param event Browser event object that started the sequence.
   */
  _initializeDragSequence(referenceElement, event) {
    if (this._parentDragRef) {
      event.stopPropagation();
    }
    const isDragging = this.isDragging();
    const isTouchSequence = isTouchEvent(event);
    const isAuxiliaryMouseButton = !isTouchSequence && event.button !== 0;
    const rootElement = this._rootElement;
    const target = _getEventTarget(event);
    const isSyntheticEvent = !isTouchSequence && this._lastTouchEventTime && this._lastTouchEventTime + MOUSE_EVENT_IGNORE_TIME > Date.now();
    const isFakeEvent = isTouchSequence ? isFakeTouchstartFromScreenReader(event) : isFakeMousedownFromScreenReader(event);
    if (target && target.draggable && event.type === "mousedown") {
      event.preventDefault();
    }
    if (isDragging || isAuxiliaryMouseButton || isSyntheticEvent || isFakeEvent) {
      return;
    }
    if (this._handles.length) {
      const rootStyles = rootElement.style;
      this._rootElementTapHighlight = rootStyles.webkitTapHighlightColor || "";
      rootStyles.webkitTapHighlightColor = "transparent";
    }
    this._hasMoved = false;
    this._hasStartedDragging.set(this._hasMoved);
    this._removeListeners();
    this._initialDomRect = this._rootElement.getBoundingClientRect();
    this._pointerMoveSubscription = this._dragDropRegistry.pointerMove.subscribe(this._pointerMove);
    this._pointerUpSubscription = this._dragDropRegistry.pointerUp.subscribe(this._pointerUp);
    this._scrollSubscription = this._dragDropRegistry.scrolled(this._getShadowRoot()).subscribe((scrollEvent) => this._updateOnScroll(scrollEvent));
    if (this._boundaryElement) {
      this._boundaryRect = getMutableClientRect(this._boundaryElement);
    }
    const previewTemplate = this._previewTemplate;
    this._pickupPositionInElement = previewTemplate && previewTemplate.template && !previewTemplate.matchSize ? {
      x: 0,
      y: 0
    } : this._getPointerPositionInElement(this._initialDomRect, referenceElement, event);
    const pointerPosition = this._pickupPositionOnPage = this._lastKnownPointerPosition = this._getPointerPositionOnPage(event);
    this._pointerDirectionDelta = {
      x: 0,
      y: 0
    };
    this._pointerPositionAtLastDirectionChange = {
      x: pointerPosition.x,
      y: pointerPosition.y
    };
    this._dragStartTime = Date.now();
    this._dragDropRegistry.startDragging(this, event);
  }
  /** Cleans up the DOM artifacts that were added to facilitate the element being dragged. */
  _cleanupDragArtifacts(event) {
    toggleVisibility(this._rootElement, true, dragImportantProperties);
    this._anchor.parentNode.replaceChild(this._rootElement, this._anchor);
    this._destroyPreview();
    this._destroyPlaceholder();
    this._initialDomRect = this._boundaryRect = this._previewRect = this._initialTransform = void 0;
    this._ngZone.run(() => {
      const container = this._dropContainer;
      const currentIndex = container.getItemIndex(this);
      const pointerPosition = this._getPointerPositionOnPage(event);
      const distance = this._getDragDistance(pointerPosition);
      const isPointerOverContainer = container._isOverContainer(pointerPosition.x, pointerPosition.y);
      this.ended.next({
        source: this,
        distance,
        dropPoint: pointerPosition,
        event
      });
      this.dropped.next({
        item: this,
        currentIndex,
        previousIndex: this._initialIndex,
        container,
        previousContainer: this._initialContainer,
        isPointerOverContainer,
        distance,
        dropPoint: pointerPosition,
        event
      });
      container.drop(this, currentIndex, this._initialIndex, this._initialContainer, isPointerOverContainer, distance, pointerPosition, event);
      this._dropContainer = this._initialContainer;
    });
  }
  /**
   * Updates the item's position in its drop container, or moves it
   * into a new one, depending on its current drag position.
   */
  _updateActiveDropContainer({
    x,
    y
  }, {
    x: rawX,
    y: rawY
  }) {
    let newContainer = this._initialContainer._getSiblingContainerFromPosition(this, x, y);
    if (!newContainer && this._dropContainer !== this._initialContainer && this._initialContainer._isOverContainer(x, y)) {
      newContainer = this._initialContainer;
    }
    if (newContainer && newContainer !== this._dropContainer) {
      this._ngZone.run(() => {
        this.exited.next({
          item: this,
          container: this._dropContainer
        });
        this._dropContainer.exit(this);
        this._dropContainer = newContainer;
        this._dropContainer.enter(this, x, y, newContainer === this._initialContainer && // If we're re-entering the initial container and sorting is disabled,
        // put item the into its starting index to begin with.
        newContainer.sortingDisabled ? this._initialIndex : void 0);
        this.entered.next({
          item: this,
          container: newContainer,
          currentIndex: newContainer.getItemIndex(this)
        });
      });
    }
    if (this.isDragging()) {
      this._dropContainer._startScrollingIfNecessary(rawX, rawY);
      this._dropContainer._sortItem(this, x, y, this._pointerDirectionDelta);
      if (this.constrainPosition) {
        this._applyPreviewTransform(x, y);
      } else {
        this._applyPreviewTransform(x - this._pickupPositionInElement.x, y - this._pickupPositionInElement.y);
      }
    }
  }
  /**
   * Animates the preview element from its current position to the location of the drop placeholder.
   * @returns Promise that resolves when the animation completes.
   */
  _animatePreviewToPlaceholder() {
    if (!this._hasMoved) {
      return Promise.resolve();
    }
    const placeholderRect = this._placeholder.getBoundingClientRect();
    this._preview.addClass("cdk-drag-animating");
    this._applyPreviewTransform(placeholderRect.left, placeholderRect.top);
    const duration = this._preview.getTransitionDuration();
    if (duration === 0) {
      return Promise.resolve();
    }
    return this._ngZone.runOutsideAngular(() => {
      return new Promise((resolve) => {
        const handler = (event) => {
          if (!event || this._preview && _getEventTarget(event) === this._preview.element && event.propertyName === "transform") {
            cleanupListener();
            resolve();
            clearTimeout(timeout);
          }
        };
        const timeout = setTimeout(handler, duration * 1.5);
        const cleanupListener = this._preview.addEventListener("transitionend", handler);
      });
    });
  }
  /** Creates an element that will be shown instead of the current element while dragging. */
  _createPlaceholderElement() {
    const placeholderConfig = this._placeholderTemplate;
    const placeholderTemplate = placeholderConfig ? placeholderConfig.template : null;
    let placeholder;
    if (placeholderTemplate) {
      this._placeholderRef = placeholderConfig.viewContainer.createEmbeddedView(placeholderTemplate, placeholderConfig.context);
      this._placeholderRef.detectChanges();
      placeholder = getRootNode(this._placeholderRef, this._document);
    } else {
      placeholder = deepCloneNode(this._rootElement);
    }
    placeholder.style.pointerEvents = "none";
    placeholder.classList.add("cdk-drag-placeholder");
    return placeholder;
  }
  /**
   * Figures out the coordinates at which an element was picked up.
   * @param referenceElement Element that initiated the dragging.
   * @param event Event that initiated the dragging.
   */
  _getPointerPositionInElement(elementRect, referenceElement, event) {
    const handleElement = referenceElement === this._rootElement ? null : referenceElement;
    const referenceRect = handleElement ? handleElement.getBoundingClientRect() : elementRect;
    const point = isTouchEvent(event) ? event.targetTouches[0] : event;
    const scrollPosition = this._getViewportScrollPosition();
    const x = point.pageX - referenceRect.left - scrollPosition.left;
    const y = point.pageY - referenceRect.top - scrollPosition.top;
    return {
      x: referenceRect.left - elementRect.left + x,
      y: referenceRect.top - elementRect.top + y
    };
  }
  /** Determines the point of the page that was touched by the user. */
  _getPointerPositionOnPage(event) {
    const scrollPosition = this._getViewportScrollPosition();
    const point = isTouchEvent(event) ? (
      // `touches` will be empty for start/end events so we have to fall back to `changedTouches`.
      // Also note that on real devices we're guaranteed for either `touches` or `changedTouches`
      // to have a value, but Firefox in device emulation mode has a bug where both can be empty
      // for `touchstart` and `touchend` so we fall back to a dummy object in order to avoid
      // throwing an error. The value returned here will be incorrect, but since this only
      // breaks inside a developer tool and the value is only used for secondary information,
      // we can get away with it. See https://bugzilla.mozilla.org/show_bug.cgi?id=1615824.
      event.touches[0] || event.changedTouches[0] || {
        pageX: 0,
        pageY: 0
      }
    ) : event;
    const x = point.pageX - scrollPosition.left;
    const y = point.pageY - scrollPosition.top;
    if (this._ownerSVGElement) {
      const svgMatrix = this._ownerSVGElement.getScreenCTM();
      if (svgMatrix) {
        const svgPoint = this._ownerSVGElement.createSVGPoint();
        svgPoint.x = x;
        svgPoint.y = y;
        return svgPoint.matrixTransform(svgMatrix.inverse());
      }
    }
    return {
      x,
      y
    };
  }
  /** Gets the pointer position on the page, accounting for any position constraints. */
  _getConstrainedPointerPosition(point) {
    const dropContainerLock = this._dropContainer ? this._dropContainer.lockAxis : null;
    let {
      x,
      y
    } = this.constrainPosition ? this.constrainPosition(point, this, this._initialDomRect, this._pickupPositionInElement) : point;
    if (this.lockAxis === "x" || dropContainerLock === "x") {
      y = this._pickupPositionOnPage.y - (this.constrainPosition ? this._pickupPositionInElement.y : 0);
    } else if (this.lockAxis === "y" || dropContainerLock === "y") {
      x = this._pickupPositionOnPage.x - (this.constrainPosition ? this._pickupPositionInElement.x : 0);
    }
    if (this._boundaryRect) {
      const {
        x: pickupX,
        y: pickupY
      } = !this.constrainPosition ? this._pickupPositionInElement : {
        x: 0,
        y: 0
      };
      const boundaryRect = this._boundaryRect;
      const {
        width: previewWidth,
        height: previewHeight
      } = this._getPreviewRect();
      const minY = boundaryRect.top + pickupY;
      const maxY = boundaryRect.bottom - (previewHeight - pickupY);
      const minX = boundaryRect.left + pickupX;
      const maxX = boundaryRect.right - (previewWidth - pickupX);
      x = clamp$1(x, minX, maxX);
      y = clamp$1(y, minY, maxY);
    }
    return {
      x,
      y
    };
  }
  /** Updates the current drag delta, based on the user's current pointer position on the page. */
  _updatePointerDirectionDelta(pointerPositionOnPage) {
    const {
      x,
      y
    } = pointerPositionOnPage;
    const delta = this._pointerDirectionDelta;
    const positionSinceLastChange = this._pointerPositionAtLastDirectionChange;
    const changeX = Math.abs(x - positionSinceLastChange.x);
    const changeY = Math.abs(y - positionSinceLastChange.y);
    if (changeX > this._config.pointerDirectionChangeThreshold) {
      delta.x = x > positionSinceLastChange.x ? 1 : -1;
      positionSinceLastChange.x = x;
    }
    if (changeY > this._config.pointerDirectionChangeThreshold) {
      delta.y = y > positionSinceLastChange.y ? 1 : -1;
      positionSinceLastChange.y = y;
    }
    return delta;
  }
  /** Toggles the native drag interactions, based on how many handles are registered. */
  _toggleNativeDragInteractions() {
    if (!this._rootElement || !this._handles) {
      return;
    }
    const shouldEnable = this._handles.length > 0 || !this.isDragging();
    if (shouldEnable !== this._nativeInteractionsEnabled) {
      this._nativeInteractionsEnabled = shouldEnable;
      toggleNativeDragInteractions(this._rootElement, shouldEnable);
    }
  }
  /** Removes the manually-added event listeners from the root element. */
  _removeRootElementListeners(element) {
    element.removeEventListener("mousedown", this._pointerDown, activeEventListenerOptions);
    element.removeEventListener("touchstart", this._pointerDown, passiveEventListenerOptions);
    element.removeEventListener("dragstart", this._nativeDragStart, activeEventListenerOptions);
  }
  /**
   * Applies a `transform` to the root element, taking into account any existing transforms on it.
   * @param x New transform value along the X axis.
   * @param y New transform value along the Y axis.
   */
  _applyRootElementTransform(x, y) {
    const scale = 1 / this.scale;
    const transform = getTransform(x * scale, y * scale);
    const styles = this._rootElement.style;
    if (this._initialTransform == null) {
      this._initialTransform = styles.transform && styles.transform != "none" ? styles.transform : "";
    }
    styles.transform = combineTransforms(transform, this._initialTransform);
  }
  /**
   * Applies a `transform` to the preview, taking into account any existing transforms on it.
   * @param x New transform value along the X axis.
   * @param y New transform value along the Y axis.
   */
  _applyPreviewTransform(x, y) {
    const initialTransform = this._previewTemplate?.template ? void 0 : this._initialTransform;
    const transform = getTransform(x, y);
    this._preview.setTransform(combineTransforms(transform, initialTransform));
  }
  /**
   * Gets the distance that the user has dragged during the current drag sequence.
   * @param currentPosition Current position of the user's pointer.
   */
  _getDragDistance(currentPosition) {
    const pickupPosition = this._pickupPositionOnPage;
    if (pickupPosition) {
      return {
        x: currentPosition.x - pickupPosition.x,
        y: currentPosition.y - pickupPosition.y
      };
    }
    return {
      x: 0,
      y: 0
    };
  }
  /** Cleans up any cached element dimensions that we don't need after dragging has stopped. */
  _cleanupCachedDimensions() {
    this._boundaryRect = this._previewRect = void 0;
    this._parentPositions.clear();
  }
  /**
   * Checks whether the element is still inside its boundary after the viewport has been resized.
   * If not, the position is adjusted so that the element fits again.
   */
  _containInsideBoundaryOnResize() {
    let {
      x,
      y
    } = this._passiveTransform;
    if (x === 0 && y === 0 || this.isDragging() || !this._boundaryElement) {
      return;
    }
    const elementRect = this._rootElement.getBoundingClientRect();
    const boundaryRect = this._boundaryElement.getBoundingClientRect();
    if (boundaryRect.width === 0 && boundaryRect.height === 0 || elementRect.width === 0 && elementRect.height === 0) {
      return;
    }
    const leftOverflow = boundaryRect.left - elementRect.left;
    const rightOverflow = elementRect.right - boundaryRect.right;
    const topOverflow = boundaryRect.top - elementRect.top;
    const bottomOverflow = elementRect.bottom - boundaryRect.bottom;
    if (boundaryRect.width > elementRect.width) {
      if (leftOverflow > 0) {
        x += leftOverflow;
      }
      if (rightOverflow > 0) {
        x -= rightOverflow;
      }
    } else {
      x = 0;
    }
    if (boundaryRect.height > elementRect.height) {
      if (topOverflow > 0) {
        y += topOverflow;
      }
      if (bottomOverflow > 0) {
        y -= bottomOverflow;
      }
    } else {
      y = 0;
    }
    if (x !== this._passiveTransform.x || y !== this._passiveTransform.y) {
      this.setFreeDragPosition({
        y,
        x
      });
    }
  }
  /** Gets the drag start delay, based on the event type. */
  _getDragStartDelay(event) {
    const value = this.dragStartDelay;
    if (typeof value === "number") {
      return value;
    } else if (isTouchEvent(event)) {
      return value.touch;
    }
    return value ? value.mouse : 0;
  }
  /** Updates the internal state of the draggable element when scrolling has occurred. */
  _updateOnScroll(event) {
    const scrollDifference = this._parentPositions.handleScroll(event);
    if (scrollDifference) {
      const target = _getEventTarget(event);
      if (this._boundaryRect && target !== this._boundaryElement && target.contains(this._boundaryElement)) {
        adjustDomRect(this._boundaryRect, scrollDifference.top, scrollDifference.left);
      }
      this._pickupPositionOnPage.x += scrollDifference.left;
      this._pickupPositionOnPage.y += scrollDifference.top;
      if (!this._dropContainer) {
        this._activeTransform.x -= scrollDifference.left;
        this._activeTransform.y -= scrollDifference.top;
        this._applyRootElementTransform(this._activeTransform.x, this._activeTransform.y);
      }
    }
  }
  /** Gets the scroll position of the viewport. */
  _getViewportScrollPosition() {
    return this._parentPositions.positions.get(this._document)?.scrollPosition || this._parentPositions.getViewportScrollPosition();
  }
  /**
   * Lazily resolves and returns the shadow root of the element. We do this in a function, rather
   * than saving it in property directly on init, because we want to resolve it as late as possible
   * in order to ensure that the element has been moved into the shadow DOM. Doing it inside the
   * constructor might be too early if the element is inside of something like `ngFor` or `ngIf`.
   */
  _getShadowRoot() {
    if (this._cachedShadowRoot === void 0) {
      this._cachedShadowRoot = _getShadowRoot(this._rootElement);
    }
    return this._cachedShadowRoot;
  }
  /** Gets the element into which the drag preview should be inserted. */
  _getPreviewInsertionPoint(initialParent, shadowRoot) {
    const previewContainer = this._previewContainer || "global";
    if (previewContainer === "parent") {
      return initialParent;
    }
    if (previewContainer === "global") {
      const documentRef = this._document;
      return shadowRoot || documentRef.fullscreenElement || documentRef.webkitFullscreenElement || documentRef.mozFullScreenElement || documentRef.msFullscreenElement || documentRef.body;
    }
    return coerceElement(previewContainer);
  }
  /** Lazily resolves and returns the dimensions of the preview. */
  _getPreviewRect() {
    if (!this._previewRect || !this._previewRect.width && !this._previewRect.height) {
      this._previewRect = this._preview ? this._preview.getBoundingClientRect() : this._initialDomRect;
    }
    return this._previewRect;
  }
  /** Handles a native `dragstart` event. */
  _nativeDragStart = (event) => {
    if (this._handles.length) {
      const targetHandle = this._getTargetHandle(event);
      if (targetHandle && !this._disabledHandles.has(targetHandle) && !this.disabled) {
        event.preventDefault();
      }
    } else if (!this.disabled) {
      event.preventDefault();
    }
  };
  /** Gets a handle that is the target of an event. */
  _getTargetHandle(event) {
    return this._handles.find((handle) => {
      return event.target && (event.target === handle || handle.contains(event.target));
    });
  }
};
function clamp$1(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function isTouchEvent(event) {
  return event.type[0] === "t";
}
function shadowDomSelectStart(event) {
  event.preventDefault();
}
function moveItemInArray(array, fromIndex, toIndex) {
  const from2 = clamp(fromIndex, array.length - 1);
  const to = clamp(toIndex, array.length - 1);
  if (from2 === to) {
    return;
  }
  const target = array[from2];
  const delta = to < from2 ? -1 : 1;
  for (let i = from2; i !== to; i += delta) {
    array[i] = array[i + delta];
  }
  array[to] = target;
}
function clamp(value, max) {
  return Math.max(0, Math.min(max, value));
}
var SingleAxisSortStrategy = class {
  _dragDropRegistry;
  /** Root element container of the drop list. */
  _element;
  /** Function used to determine if an item can be sorted into a specific index. */
  _sortPredicate;
  /** Cache of the dimensions of all the items inside the container. */
  _itemPositions = [];
  /**
   * Draggable items that are currently active inside the container. Includes the items
   * that were there at the start of the sequence, as well as any items that have been dragged
   * in, but haven't been dropped yet.
   */
  _activeDraggables;
  /** Direction in which the list is oriented. */
  orientation = "vertical";
  /** Layout direction of the drop list. */
  direction;
  constructor(_dragDropRegistry) {
    this._dragDropRegistry = _dragDropRegistry;
  }
  /**
   * Keeps track of the item that was last swapped with the dragged item, as well as what direction
   * the pointer was moving in when the swap occurred and whether the user's pointer continued to
   * overlap with the swapped item after the swapping occurred.
   */
  _previousSwap = {
    drag: null,
    delta: 0,
    overlaps: false
  };
  /**
   * To be called when the drag sequence starts.
   * @param items Items that are currently in the list.
   */
  start(items) {
    this.withItems(items);
  }
  /**
   * To be called when an item is being sorted.
   * @param item Item to be sorted.
   * @param pointerX Position of the item along the X axis.
   * @param pointerY Position of the item along the Y axis.
   * @param pointerDelta Direction in which the pointer is moving along each axis.
   */
  sort(item, pointerX, pointerY, pointerDelta) {
    const siblings = this._itemPositions;
    const newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY, pointerDelta);
    if (newIndex === -1 && siblings.length > 0) {
      return null;
    }
    const isHorizontal = this.orientation === "horizontal";
    const currentIndex = siblings.findIndex((currentItem) => currentItem.drag === item);
    const siblingAtNewPosition = siblings[newIndex];
    const currentPosition = siblings[currentIndex].clientRect;
    const newPosition = siblingAtNewPosition.clientRect;
    const delta = currentIndex > newIndex ? 1 : -1;
    const itemOffset = this._getItemOffsetPx(currentPosition, newPosition, delta);
    const siblingOffset = this._getSiblingOffsetPx(currentIndex, siblings, delta);
    const oldOrder = siblings.slice();
    moveItemInArray(siblings, currentIndex, newIndex);
    siblings.forEach((sibling, index) => {
      if (oldOrder[index] === sibling) {
        return;
      }
      const isDraggedItem = sibling.drag === item;
      const offset = isDraggedItem ? itemOffset : siblingOffset;
      const elementToOffset = isDraggedItem ? item.getPlaceholderElement() : sibling.drag.getRootElement();
      sibling.offset += offset;
      const transformAmount = Math.round(sibling.offset * (1 / sibling.drag.scale));
      if (isHorizontal) {
        elementToOffset.style.transform = combineTransforms(`translate3d(${transformAmount}px, 0, 0)`, sibling.initialTransform);
        adjustDomRect(sibling.clientRect, 0, offset);
      } else {
        elementToOffset.style.transform = combineTransforms(`translate3d(0, ${transformAmount}px, 0)`, sibling.initialTransform);
        adjustDomRect(sibling.clientRect, offset, 0);
      }
    });
    this._previousSwap.overlaps = isInsideClientRect(newPosition, pointerX, pointerY);
    this._previousSwap.drag = siblingAtNewPosition.drag;
    this._previousSwap.delta = isHorizontal ? pointerDelta.x : pointerDelta.y;
    return {
      previousIndex: currentIndex,
      currentIndex: newIndex
    };
  }
  /**
   * Called when an item is being moved into the container.
   * @param item Item that was moved into the container.
   * @param pointerX Position of the item along the X axis.
   * @param pointerY Position of the item along the Y axis.
   * @param index Index at which the item entered. If omitted, the container will try to figure it
   *   out automatically.
   */
  enter(item, pointerX, pointerY, index) {
    const newIndex = index == null || index < 0 ? (
      // We use the coordinates of where the item entered the drop
      // zone to figure out at which index it should be inserted.
      this._getItemIndexFromPointerPosition(item, pointerX, pointerY)
    ) : index;
    const activeDraggables = this._activeDraggables;
    const currentIndex = activeDraggables.indexOf(item);
    const placeholder = item.getPlaceholderElement();
    let newPositionReference = activeDraggables[newIndex];
    if (newPositionReference === item) {
      newPositionReference = activeDraggables[newIndex + 1];
    }
    if (!newPositionReference && (newIndex == null || newIndex === -1 || newIndex < activeDraggables.length - 1) && this._shouldEnterAsFirstChild(pointerX, pointerY)) {
      newPositionReference = activeDraggables[0];
    }
    if (currentIndex > -1) {
      activeDraggables.splice(currentIndex, 1);
    }
    if (newPositionReference && !this._dragDropRegistry.isDragging(newPositionReference)) {
      const element = newPositionReference.getRootElement();
      element.parentElement.insertBefore(placeholder, element);
      activeDraggables.splice(newIndex, 0, item);
    } else {
      this._element.appendChild(placeholder);
      activeDraggables.push(item);
    }
    placeholder.style.transform = "";
    this._cacheItemPositions();
  }
  /** Sets the items that are currently part of the list. */
  withItems(items) {
    this._activeDraggables = items.slice();
    this._cacheItemPositions();
  }
  /** Assigns a sort predicate to the strategy. */
  withSortPredicate(predicate) {
    this._sortPredicate = predicate;
  }
  /** Resets the strategy to its initial state before dragging was started. */
  reset() {
    this._activeDraggables?.forEach((item) => {
      const rootElement = item.getRootElement();
      if (rootElement) {
        const initialTransform = this._itemPositions.find((p) => p.drag === item)?.initialTransform;
        rootElement.style.transform = initialTransform || "";
      }
    });
    this._itemPositions = [];
    this._activeDraggables = [];
    this._previousSwap.drag = null;
    this._previousSwap.delta = 0;
    this._previousSwap.overlaps = false;
  }
  /**
   * Gets a snapshot of items currently in the list.
   * Can include items that we dragged in from another list.
   */
  getActiveItemsSnapshot() {
    return this._activeDraggables;
  }
  /** Gets the index of a specific item. */
  getItemIndex(item) {
    const items = this.orientation === "horizontal" && this.direction === "rtl" ? this._itemPositions.slice().reverse() : this._itemPositions;
    return items.findIndex((currentItem) => currentItem.drag === item);
  }
  /** Used to notify the strategy that the scroll position has changed. */
  updateOnScroll(topDifference, leftDifference) {
    this._itemPositions.forEach(({
      clientRect
    }) => {
      adjustDomRect(clientRect, topDifference, leftDifference);
    });
    this._itemPositions.forEach(({
      drag
    }) => {
      if (this._dragDropRegistry.isDragging(drag)) {
        drag._sortFromLastPointerPosition();
      }
    });
  }
  withElementContainer(container) {
    this._element = container;
  }
  /** Refreshes the position cache of the items and sibling containers. */
  _cacheItemPositions() {
    const isHorizontal = this.orientation === "horizontal";
    this._itemPositions = this._activeDraggables.map((drag) => {
      const elementToMeasure = drag.getVisibleElement();
      return {
        drag,
        offset: 0,
        initialTransform: elementToMeasure.style.transform || "",
        clientRect: getMutableClientRect(elementToMeasure)
      };
    }).sort((a, b) => {
      return isHorizontal ? a.clientRect.left - b.clientRect.left : a.clientRect.top - b.clientRect.top;
    });
  }
  /**
   * Gets the offset in pixels by which the item that is being dragged should be moved.
   * @param currentPosition Current position of the item.
   * @param newPosition Position of the item where the current item should be moved.
   * @param delta Direction in which the user is moving.
   */
  _getItemOffsetPx(currentPosition, newPosition, delta) {
    const isHorizontal = this.orientation === "horizontal";
    let itemOffset = isHorizontal ? newPosition.left - currentPosition.left : newPosition.top - currentPosition.top;
    if (delta === -1) {
      itemOffset += isHorizontal ? newPosition.width - currentPosition.width : newPosition.height - currentPosition.height;
    }
    return itemOffset;
  }
  /**
   * Gets the offset in pixels by which the items that aren't being dragged should be moved.
   * @param currentIndex Index of the item currently being dragged.
   * @param siblings All of the items in the list.
   * @param delta Direction in which the user is moving.
   */
  _getSiblingOffsetPx(currentIndex, siblings, delta) {
    const isHorizontal = this.orientation === "horizontal";
    const currentPosition = siblings[currentIndex].clientRect;
    const immediateSibling = siblings[currentIndex + delta * -1];
    let siblingOffset = currentPosition[isHorizontal ? "width" : "height"] * delta;
    if (immediateSibling) {
      const start = isHorizontal ? "left" : "top";
      const end = isHorizontal ? "right" : "bottom";
      if (delta === -1) {
        siblingOffset -= immediateSibling.clientRect[start] - currentPosition[end];
      } else {
        siblingOffset += currentPosition[start] - immediateSibling.clientRect[end];
      }
    }
    return siblingOffset;
  }
  /**
   * Checks if pointer is entering in the first position
   * @param pointerX Position of the user's pointer along the X axis.
   * @param pointerY Position of the user's pointer along the Y axis.
   */
  _shouldEnterAsFirstChild(pointerX, pointerY) {
    if (!this._activeDraggables.length) {
      return false;
    }
    const itemPositions = this._itemPositions;
    const isHorizontal = this.orientation === "horizontal";
    const reversed = itemPositions[0].drag !== this._activeDraggables[0];
    if (reversed) {
      const lastItemRect = itemPositions[itemPositions.length - 1].clientRect;
      return isHorizontal ? pointerX >= lastItemRect.right : pointerY >= lastItemRect.bottom;
    } else {
      const firstItemRect = itemPositions[0].clientRect;
      return isHorizontal ? pointerX <= firstItemRect.left : pointerY <= firstItemRect.top;
    }
  }
  /**
   * Gets the index of an item in the drop container, based on the position of the user's pointer.
   * @param item Item that is being sorted.
   * @param pointerX Position of the user's pointer along the X axis.
   * @param pointerY Position of the user's pointer along the Y axis.
   * @param delta Direction in which the user is moving their pointer.
   */
  _getItemIndexFromPointerPosition(item, pointerX, pointerY, delta) {
    const isHorizontal = this.orientation === "horizontal";
    const index = this._itemPositions.findIndex(({
      drag,
      clientRect
    }) => {
      if (drag === item) {
        return false;
      }
      if (delta) {
        const direction = isHorizontal ? delta.x : delta.y;
        if (drag === this._previousSwap.drag && this._previousSwap.overlaps && direction === this._previousSwap.delta) {
          return false;
        }
      }
      return isHorizontal ? (
        // Round these down since most browsers report client rects with
        // sub-pixel precision, whereas the pointer coordinates are rounded to pixels.
        pointerX >= Math.floor(clientRect.left) && pointerX < Math.floor(clientRect.right)
      ) : pointerY >= Math.floor(clientRect.top) && pointerY < Math.floor(clientRect.bottom);
    });
    return index === -1 || !this._sortPredicate(index, item) ? -1 : index;
  }
};
var MixedSortStrategy = class {
  _document;
  _dragDropRegistry;
  /** Root element container of the drop list. */
  _element;
  /** Function used to determine if an item can be sorted into a specific index. */
  _sortPredicate;
  /** Lazily-resolved root node containing the list. Use `_getRootNode` to read this. */
  _rootNode;
  /**
   * Draggable items that are currently active inside the container. Includes the items
   * that were there at the start of the sequence, as well as any items that have been dragged
   * in, but haven't been dropped yet.
   */
  _activeItems;
  /**
   * Keeps track of the item that was last swapped with the dragged item, as well as what direction
   * the pointer was moving in when the swap occurred and whether the user's pointer continued to
   * overlap with the swapped item after the swapping occurred.
   */
  _previousSwap = {
    drag: null,
    deltaX: 0,
    deltaY: 0,
    overlaps: false
  };
  /**
   * Keeps track of the relationship between a node and its next sibling. This information
   * is used to restore the DOM to the order it was in before dragging started.
   */
  _relatedNodes = [];
  constructor(_document, _dragDropRegistry) {
    this._document = _document;
    this._dragDropRegistry = _dragDropRegistry;
  }
  /**
   * To be called when the drag sequence starts.
   * @param items Items that are currently in the list.
   */
  start(items) {
    const childNodes = this._element.childNodes;
    this._relatedNodes = [];
    for (let i = 0; i < childNodes.length; i++) {
      const node = childNodes[i];
      this._relatedNodes.push([node, node.nextSibling]);
    }
    this.withItems(items);
  }
  /**
   * To be called when an item is being sorted.
   * @param item Item to be sorted.
   * @param pointerX Position of the item along the X axis.
   * @param pointerY Position of the item along the Y axis.
   * @param pointerDelta Direction in which the pointer is moving along each axis.
   */
  sort(item, pointerX, pointerY, pointerDelta) {
    const newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY);
    const previousSwap = this._previousSwap;
    if (newIndex === -1 || this._activeItems[newIndex] === item) {
      return null;
    }
    const toSwapWith = this._activeItems[newIndex];
    if (previousSwap.drag === toSwapWith && previousSwap.overlaps && previousSwap.deltaX === pointerDelta.x && previousSwap.deltaY === pointerDelta.y) {
      return null;
    }
    const previousIndex = this.getItemIndex(item);
    const current = item.getPlaceholderElement();
    const overlapElement = toSwapWith.getRootElement();
    if (newIndex > previousIndex) {
      overlapElement.after(current);
    } else {
      overlapElement.before(current);
    }
    moveItemInArray(this._activeItems, previousIndex, newIndex);
    const newOverlapElement = this._getRootNode().elementFromPoint(pointerX, pointerY);
    previousSwap.deltaX = pointerDelta.x;
    previousSwap.deltaY = pointerDelta.y;
    previousSwap.drag = toSwapWith;
    previousSwap.overlaps = overlapElement === newOverlapElement || overlapElement.contains(newOverlapElement);
    return {
      previousIndex,
      currentIndex: newIndex
    };
  }
  /**
   * Called when an item is being moved into the container.
   * @param item Item that was moved into the container.
   * @param pointerX Position of the item along the X axis.
   * @param pointerY Position of the item along the Y axis.
   * @param index Index at which the item entered. If omitted, the container will try to figure it
   *   out automatically.
   */
  enter(item, pointerX, pointerY, index) {
    let enterIndex = index == null || index < 0 ? this._getItemIndexFromPointerPosition(item, pointerX, pointerY) : index;
    if (enterIndex === -1) {
      enterIndex = this._getClosestItemIndexToPointer(item, pointerX, pointerY);
    }
    const targetItem = this._activeItems[enterIndex];
    const currentIndex = this._activeItems.indexOf(item);
    if (currentIndex > -1) {
      this._activeItems.splice(currentIndex, 1);
    }
    if (targetItem && !this._dragDropRegistry.isDragging(targetItem)) {
      this._activeItems.splice(enterIndex, 0, item);
      targetItem.getRootElement().before(item.getPlaceholderElement());
    } else {
      this._activeItems.push(item);
      this._element.appendChild(item.getPlaceholderElement());
    }
  }
  /** Sets the items that are currently part of the list. */
  withItems(items) {
    this._activeItems = items.slice();
  }
  /** Assigns a sort predicate to the strategy. */
  withSortPredicate(predicate) {
    this._sortPredicate = predicate;
  }
  /** Resets the strategy to its initial state before dragging was started. */
  reset() {
    const root = this._element;
    const previousSwap = this._previousSwap;
    for (let i = this._relatedNodes.length - 1; i > -1; i--) {
      const [node, nextSibling] = this._relatedNodes[i];
      if (node.parentNode === root && node.nextSibling !== nextSibling) {
        if (nextSibling === null) {
          root.appendChild(node);
        } else if (nextSibling.parentNode === root) {
          root.insertBefore(node, nextSibling);
        }
      }
    }
    this._relatedNodes = [];
    this._activeItems = [];
    previousSwap.drag = null;
    previousSwap.deltaX = previousSwap.deltaY = 0;
    previousSwap.overlaps = false;
  }
  /**
   * Gets a snapshot of items currently in the list.
   * Can include items that we dragged in from another list.
   */
  getActiveItemsSnapshot() {
    return this._activeItems;
  }
  /** Gets the index of a specific item. */
  getItemIndex(item) {
    return this._activeItems.indexOf(item);
  }
  /** Used to notify the strategy that the scroll position has changed. */
  updateOnScroll() {
    this._activeItems.forEach((item) => {
      if (this._dragDropRegistry.isDragging(item)) {
        item._sortFromLastPointerPosition();
      }
    });
  }
  withElementContainer(container) {
    if (container !== this._element) {
      this._element = container;
      this._rootNode = void 0;
    }
  }
  /**
   * Gets the index of an item in the drop container, based on the position of the user's pointer.
   * @param item Item that is being sorted.
   * @param pointerX Position of the user's pointer along the X axis.
   * @param pointerY Position of the user's pointer along the Y axis.
   * @param delta Direction in which the user is moving their pointer.
   */
  _getItemIndexFromPointerPosition(item, pointerX, pointerY) {
    const elementAtPoint = this._getRootNode().elementFromPoint(Math.floor(pointerX), Math.floor(pointerY));
    const index = elementAtPoint ? this._activeItems.findIndex((item2) => {
      const root = item2.getRootElement();
      return elementAtPoint === root || root.contains(elementAtPoint);
    }) : -1;
    return index === -1 || !this._sortPredicate(index, item) ? -1 : index;
  }
  /** Lazily resolves the list's root node. */
  _getRootNode() {
    if (!this._rootNode) {
      this._rootNode = _getShadowRoot(this._element) || this._document;
    }
    return this._rootNode;
  }
  /**
   * Finds the index of the item that's closest to the item being dragged.
   * @param item Item being dragged.
   * @param pointerX Position of the user's pointer along the X axis.
   * @param pointerY Position of the user's pointer along the Y axis.
   */
  _getClosestItemIndexToPointer(item, pointerX, pointerY) {
    if (this._activeItems.length === 0) {
      return -1;
    }
    if (this._activeItems.length === 1) {
      return 0;
    }
    let minDistance = Infinity;
    let minIndex = -1;
    for (let i = 0; i < this._activeItems.length; i++) {
      const current = this._activeItems[i];
      if (current !== item) {
        const {
          x,
          y
        } = current.getRootElement().getBoundingClientRect();
        const distance = Math.hypot(pointerX - x, pointerY - y);
        if (distance < minDistance) {
          minDistance = distance;
          minIndex = i;
        }
      }
    }
    return minIndex;
  }
};
var DROP_PROXIMITY_THRESHOLD = 0.05;
var SCROLL_PROXIMITY_THRESHOLD = 0.05;
var AutoScrollVerticalDirection;
(function(AutoScrollVerticalDirection2) {
  AutoScrollVerticalDirection2[AutoScrollVerticalDirection2["NONE"] = 0] = "NONE";
  AutoScrollVerticalDirection2[AutoScrollVerticalDirection2["UP"] = 1] = "UP";
  AutoScrollVerticalDirection2[AutoScrollVerticalDirection2["DOWN"] = 2] = "DOWN";
})(AutoScrollVerticalDirection || (AutoScrollVerticalDirection = {}));
var AutoScrollHorizontalDirection;
(function(AutoScrollHorizontalDirection2) {
  AutoScrollHorizontalDirection2[AutoScrollHorizontalDirection2["NONE"] = 0] = "NONE";
  AutoScrollHorizontalDirection2[AutoScrollHorizontalDirection2["LEFT"] = 1] = "LEFT";
  AutoScrollHorizontalDirection2[AutoScrollHorizontalDirection2["RIGHT"] = 2] = "RIGHT";
})(AutoScrollHorizontalDirection || (AutoScrollHorizontalDirection = {}));
var DropListRef = class {
  _dragDropRegistry;
  _ngZone;
  _viewportRuler;
  /** Element that the drop list is attached to. */
  element;
  /** Whether starting a dragging sequence from this container is disabled. */
  disabled = false;
  /** Whether sorting items within the list is disabled. */
  sortingDisabled = false;
  /** Locks the position of the draggable elements inside the container along the specified axis. */
  lockAxis;
  /**
   * Whether auto-scrolling the view when the user
   * moves their pointer close to the edges is disabled.
   */
  autoScrollDisabled = false;
  /** Number of pixels to scroll for each frame when auto-scrolling an element. */
  autoScrollStep = 2;
  /**
   * Function that is used to determine whether an item
   * is allowed to be moved into a drop container.
   */
  enterPredicate = () => true;
  /** Function that is used to determine whether an item can be sorted into a particular index. */
  sortPredicate = () => true;
  /** Emits right before dragging has started. */
  beforeStarted = new Subject();
  /**
   * Emits when the user has moved a new drag item into this container.
   */
  entered = new Subject();
  /**
   * Emits when the user removes an item from the container
   * by dragging it into another container.
   */
  exited = new Subject();
  /** Emits when the user drops an item inside the container. */
  dropped = new Subject();
  /** Emits as the user is swapping items while actively dragging. */
  sorted = new Subject();
  /** Emits when a dragging sequence is started in a list connected to the current one. */
  receivingStarted = new Subject();
  /** Emits when a dragging sequence is stopped from a list connected to the current one. */
  receivingStopped = new Subject();
  /** Arbitrary data that can be attached to the drop list. */
  data;
  /** Element that is the direct parent of the drag items. */
  _container;
  /** Whether an item in the list is being dragged. */
  _isDragging = false;
  /** Keeps track of the positions of any parent scrollable elements. */
  _parentPositions;
  /** Strategy being used to sort items within the list. */
  _sortStrategy;
  /** Cached `DOMRect` of the drop list. */
  _domRect;
  /** Draggable items in the container. */
  _draggables = [];
  /** Drop lists that are connected to the current one. */
  _siblings = [];
  /** Connected siblings that currently have a dragged item. */
  _activeSiblings = /* @__PURE__ */ new Set();
  /** Subscription to the window being scrolled. */
  _viewportScrollSubscription = Subscription.EMPTY;
  /** Vertical direction in which the list is currently scrolling. */
  _verticalScrollDirection = AutoScrollVerticalDirection.NONE;
  /** Horizontal direction in which the list is currently scrolling. */
  _horizontalScrollDirection = AutoScrollHorizontalDirection.NONE;
  /** Node that is being auto-scrolled. */
  _scrollNode;
  /** Used to signal to the current auto-scroll sequence when to stop. */
  _stopScrollTimers = new Subject();
  /** Shadow root of the current element. Necessary for `elementFromPoint` to resolve correctly. */
  _cachedShadowRoot = null;
  /** Reference to the document. */
  _document;
  /** Elements that can be scrolled while the user is dragging. */
  _scrollableElements = [];
  /** Initial value for the element's `scroll-snap-type` style. */
  _initialScrollSnap;
  /** Direction of the list's layout. */
  _direction = "ltr";
  constructor(element, _dragDropRegistry, _document, _ngZone, _viewportRuler) {
    this._dragDropRegistry = _dragDropRegistry;
    this._ngZone = _ngZone;
    this._viewportRuler = _viewportRuler;
    const coercedElement = this.element = coerceElement(element);
    this._document = _document;
    this.withOrientation("vertical").withElementContainer(coercedElement);
    _dragDropRegistry.registerDropContainer(this);
    this._parentPositions = new ParentPositionTracker(_document);
  }
  /** Removes the drop list functionality from the DOM element. */
  dispose() {
    this._stopScrolling();
    this._stopScrollTimers.complete();
    this._viewportScrollSubscription.unsubscribe();
    this.beforeStarted.complete();
    this.entered.complete();
    this.exited.complete();
    this.dropped.complete();
    this.sorted.complete();
    this.receivingStarted.complete();
    this.receivingStopped.complete();
    this._activeSiblings.clear();
    this._scrollNode = null;
    this._parentPositions.clear();
    this._dragDropRegistry.removeDropContainer(this);
  }
  /** Whether an item from this list is currently being dragged. */
  isDragging() {
    return this._isDragging;
  }
  /** Starts dragging an item. */
  start() {
    this._draggingStarted();
    this._notifyReceivingSiblings();
  }
  /**
   * Attempts to move an item into the container.
   * @param item Item that was moved into the container.
   * @param pointerX Position of the item along the X axis.
   * @param pointerY Position of the item along the Y axis.
   * @param index Index at which the item entered. If omitted, the container will try to figure it
   *   out automatically.
   */
  enter(item, pointerX, pointerY, index) {
    this._draggingStarted();
    if (index == null && this.sortingDisabled) {
      index = this._draggables.indexOf(item);
    }
    this._sortStrategy.enter(item, pointerX, pointerY, index);
    this._cacheParentPositions();
    this._notifyReceivingSiblings();
    this.entered.next({
      item,
      container: this,
      currentIndex: this.getItemIndex(item)
    });
  }
  /**
   * Removes an item from the container after it was dragged into another container by the user.
   * @param item Item that was dragged out.
   */
  exit(item) {
    this._reset();
    this.exited.next({
      item,
      container: this
    });
  }
  /**
   * Drops an item into this container.
   * @param item Item being dropped into the container.
   * @param currentIndex Index at which the item should be inserted.
   * @param previousIndex Index of the item when dragging started.
   * @param previousContainer Container from which the item got dragged in.
   * @param isPointerOverContainer Whether the user's pointer was over the
   *    container when the item was dropped.
   * @param distance Distance the user has dragged since the start of the dragging sequence.
   * @param event Event that triggered the dropping sequence.
   *
   * @breaking-change 15.0.0 `previousIndex` and `event` parameters to become required.
   */
  drop(item, currentIndex, previousIndex, previousContainer, isPointerOverContainer, distance, dropPoint, event = {}) {
    this._reset();
    this.dropped.next({
      item,
      currentIndex,
      previousIndex,
      container: this,
      previousContainer,
      isPointerOverContainer,
      distance,
      dropPoint,
      event
    });
  }
  /**
   * Sets the draggable items that are a part of this list.
   * @param items Items that are a part of this list.
   */
  withItems(items) {
    const previousItems = this._draggables;
    this._draggables = items;
    items.forEach((item) => item._withDropContainer(this));
    if (this.isDragging()) {
      const draggedItems = previousItems.filter((item) => item.isDragging());
      if (draggedItems.every((item) => items.indexOf(item) === -1)) {
        this._reset();
      } else {
        this._sortStrategy.withItems(this._draggables);
      }
    }
    return this;
  }
  /** Sets the layout direction of the drop list. */
  withDirection(direction) {
    this._direction = direction;
    if (this._sortStrategy instanceof SingleAxisSortStrategy) {
      this._sortStrategy.direction = direction;
    }
    return this;
  }
  /**
   * Sets the containers that are connected to this one. When two or more containers are
   * connected, the user will be allowed to transfer items between them.
   * @param connectedTo Other containers that the current containers should be connected to.
   */
  connectedTo(connectedTo) {
    this._siblings = connectedTo.slice();
    return this;
  }
  /**
   * Sets the orientation of the container.
   * @param orientation New orientation for the container.
   */
  withOrientation(orientation) {
    if (orientation === "mixed") {
      this._sortStrategy = new MixedSortStrategy(this._document, this._dragDropRegistry);
    } else {
      const strategy = new SingleAxisSortStrategy(this._dragDropRegistry);
      strategy.direction = this._direction;
      strategy.orientation = orientation;
      this._sortStrategy = strategy;
    }
    this._sortStrategy.withElementContainer(this._container);
    this._sortStrategy.withSortPredicate((index, item) => this.sortPredicate(index, item, this));
    return this;
  }
  /**
   * Sets which parent elements are can be scrolled while the user is dragging.
   * @param elements Elements that can be scrolled.
   */
  withScrollableParents(elements) {
    const element = this._container;
    this._scrollableElements = elements.indexOf(element) === -1 ? [element, ...elements] : elements.slice();
    return this;
  }
  /**
   * Configures the drop list so that a different element is used as the container for the
   * dragged items. This is useful for the cases when one might not have control over the
   * full DOM that sets up the dragging.
   * Note that the alternate container needs to be a descendant of the drop list.
   * @param container New element container to be assigned.
   */
  withElementContainer(container) {
    if (container === this._container) {
      return this;
    }
    const element = coerceElement(this.element);
    if ((typeof ngDevMode === "undefined" || ngDevMode) && container !== element && !element.contains(container)) {
      throw new Error("Invalid DOM structure for drop list. Alternate container element must be a descendant of the drop list.");
    }
    const oldContainerIndex = this._scrollableElements.indexOf(this._container);
    const newContainerIndex = this._scrollableElements.indexOf(container);
    if (oldContainerIndex > -1) {
      this._scrollableElements.splice(oldContainerIndex, 1);
    }
    if (newContainerIndex > -1) {
      this._scrollableElements.splice(newContainerIndex, 1);
    }
    if (this._sortStrategy) {
      this._sortStrategy.withElementContainer(container);
    }
    this._cachedShadowRoot = null;
    this._scrollableElements.unshift(container);
    this._container = container;
    return this;
  }
  /** Gets the scrollable parents that are registered with this drop container. */
  getScrollableParents() {
    return this._scrollableElements;
  }
  /**
   * Figures out the index of an item in the container.
   * @param item Item whose index should be determined.
   */
  getItemIndex(item) {
    return this._isDragging ? this._sortStrategy.getItemIndex(item) : this._draggables.indexOf(item);
  }
  /**
   * Whether the list is able to receive the item that
   * is currently being dragged inside a connected drop list.
   */
  isReceiving() {
    return this._activeSiblings.size > 0;
  }
  /**
   * Sorts an item inside the container based on its position.
   * @param item Item to be sorted.
   * @param pointerX Position of the item along the X axis.
   * @param pointerY Position of the item along the Y axis.
   * @param pointerDelta Direction in which the pointer is moving along each axis.
   */
  _sortItem(item, pointerX, pointerY, pointerDelta) {
    if (this.sortingDisabled || !this._domRect || !isPointerNearDomRect(this._domRect, DROP_PROXIMITY_THRESHOLD, pointerX, pointerY)) {
      return;
    }
    const result = this._sortStrategy.sort(item, pointerX, pointerY, pointerDelta);
    if (result) {
      this.sorted.next({
        previousIndex: result.previousIndex,
        currentIndex: result.currentIndex,
        container: this,
        item
      });
    }
  }
  /**
   * Checks whether the user's pointer is close to the edges of either the
   * viewport or the drop list and starts the auto-scroll sequence.
   * @param pointerX User's pointer position along the x axis.
   * @param pointerY User's pointer position along the y axis.
   */
  _startScrollingIfNecessary(pointerX, pointerY) {
    if (this.autoScrollDisabled) {
      return;
    }
    let scrollNode;
    let verticalScrollDirection = AutoScrollVerticalDirection.NONE;
    let horizontalScrollDirection = AutoScrollHorizontalDirection.NONE;
    this._parentPositions.positions.forEach((position, element) => {
      if (element === this._document || !position.clientRect || scrollNode) {
        return;
      }
      if (isPointerNearDomRect(position.clientRect, DROP_PROXIMITY_THRESHOLD, pointerX, pointerY)) {
        [verticalScrollDirection, horizontalScrollDirection] = getElementScrollDirections(element, position.clientRect, this._direction, pointerX, pointerY);
        if (verticalScrollDirection || horizontalScrollDirection) {
          scrollNode = element;
        }
      }
    });
    if (!verticalScrollDirection && !horizontalScrollDirection) {
      const {
        width,
        height
      } = this._viewportRuler.getViewportSize();
      const domRect = {
        width,
        height,
        top: 0,
        right: width,
        bottom: height,
        left: 0
      };
      verticalScrollDirection = getVerticalScrollDirection(domRect, pointerY);
      horizontalScrollDirection = getHorizontalScrollDirection(domRect, pointerX);
      scrollNode = window;
    }
    if (scrollNode && (verticalScrollDirection !== this._verticalScrollDirection || horizontalScrollDirection !== this._horizontalScrollDirection || scrollNode !== this._scrollNode)) {
      this._verticalScrollDirection = verticalScrollDirection;
      this._horizontalScrollDirection = horizontalScrollDirection;
      this._scrollNode = scrollNode;
      if ((verticalScrollDirection || horizontalScrollDirection) && scrollNode) {
        this._ngZone.runOutsideAngular(this._startScrollInterval);
      } else {
        this._stopScrolling();
      }
    }
  }
  /** Stops any currently-running auto-scroll sequences. */
  _stopScrolling() {
    this._stopScrollTimers.next();
  }
  /** Starts the dragging sequence within the list. */
  _draggingStarted() {
    const styles = this._container.style;
    this.beforeStarted.next();
    this._isDragging = true;
    if ((typeof ngDevMode === "undefined" || ngDevMode) && // Prevent the check from running on apps not using an alternate container. Ideally we
    // would always run it, but introducing it at this stage would be a breaking change.
    this._container !== coerceElement(this.element)) {
      for (const drag of this._draggables) {
        if (!drag.isDragging() && drag.getVisibleElement().parentNode !== this._container) {
          throw new Error("Invalid DOM structure for drop list. All items must be placed directly inside of the element container.");
        }
      }
    }
    this._initialScrollSnap = styles.msScrollSnapType || styles.scrollSnapType || "";
    styles.scrollSnapType = styles.msScrollSnapType = "none";
    this._sortStrategy.start(this._draggables);
    this._cacheParentPositions();
    this._viewportScrollSubscription.unsubscribe();
    this._listenToScrollEvents();
  }
  /** Caches the positions of the configured scrollable parents. */
  _cacheParentPositions() {
    this._parentPositions.cache(this._scrollableElements);
    this._domRect = this._parentPositions.positions.get(this._container).clientRect;
  }
  /** Resets the container to its initial state. */
  _reset() {
    this._isDragging = false;
    const styles = this._container.style;
    styles.scrollSnapType = styles.msScrollSnapType = this._initialScrollSnap;
    this._siblings.forEach((sibling) => sibling._stopReceiving(this));
    this._sortStrategy.reset();
    this._stopScrolling();
    this._viewportScrollSubscription.unsubscribe();
    this._parentPositions.clear();
  }
  /** Starts the interval that'll auto-scroll the element. */
  _startScrollInterval = () => {
    this._stopScrolling();
    interval(0, animationFrameScheduler).pipe(takeUntil(this._stopScrollTimers)).subscribe(() => {
      const node = this._scrollNode;
      const scrollStep = this.autoScrollStep;
      if (this._verticalScrollDirection === AutoScrollVerticalDirection.UP) {
        node.scrollBy(0, -scrollStep);
      } else if (this._verticalScrollDirection === AutoScrollVerticalDirection.DOWN) {
        node.scrollBy(0, scrollStep);
      }
      if (this._horizontalScrollDirection === AutoScrollHorizontalDirection.LEFT) {
        node.scrollBy(-scrollStep, 0);
      } else if (this._horizontalScrollDirection === AutoScrollHorizontalDirection.RIGHT) {
        node.scrollBy(scrollStep, 0);
      }
    });
  };
  /**
   * Checks whether the user's pointer is positioned over the container.
   * @param x Pointer position along the X axis.
   * @param y Pointer position along the Y axis.
   */
  _isOverContainer(x, y) {
    return this._domRect != null && isInsideClientRect(this._domRect, x, y);
  }
  /**
   * Figures out whether an item should be moved into a sibling
   * drop container, based on its current position.
   * @param item Drag item that is being moved.
   * @param x Position of the item along the X axis.
   * @param y Position of the item along the Y axis.
   */
  _getSiblingContainerFromPosition(item, x, y) {
    return this._siblings.find((sibling) => sibling._canReceive(item, x, y));
  }
  /**
   * Checks whether the drop list can receive the passed-in item.
   * @param item Item that is being dragged into the list.
   * @param x Position of the item along the X axis.
   * @param y Position of the item along the Y axis.
   */
  _canReceive(item, x, y) {
    if (!this._domRect || !isInsideClientRect(this._domRect, x, y) || !this.enterPredicate(item, this)) {
      return false;
    }
    const elementFromPoint = this._getShadowRoot().elementFromPoint(x, y);
    if (!elementFromPoint) {
      return false;
    }
    return elementFromPoint === this._container || this._container.contains(elementFromPoint);
  }
  /**
   * Called by one of the connected drop lists when a dragging sequence has started.
   * @param sibling Sibling in which dragging has started.
   */
  _startReceiving(sibling, items) {
    const activeSiblings = this._activeSiblings;
    if (!activeSiblings.has(sibling) && items.every((item) => {
      return this.enterPredicate(item, this) || this._draggables.indexOf(item) > -1;
    })) {
      activeSiblings.add(sibling);
      this._cacheParentPositions();
      this._listenToScrollEvents();
      this.receivingStarted.next({
        initiator: sibling,
        receiver: this,
        items
      });
    }
  }
  /**
   * Called by a connected drop list when dragging has stopped.
   * @param sibling Sibling whose dragging has stopped.
   */
  _stopReceiving(sibling) {
    this._activeSiblings.delete(sibling);
    this._viewportScrollSubscription.unsubscribe();
    this.receivingStopped.next({
      initiator: sibling,
      receiver: this
    });
  }
  /**
   * Starts listening to scroll events on the viewport.
   * Used for updating the internal state of the list.
   */
  _listenToScrollEvents() {
    this._viewportScrollSubscription = this._dragDropRegistry.scrolled(this._getShadowRoot()).subscribe((event) => {
      if (this.isDragging()) {
        const scrollDifference = this._parentPositions.handleScroll(event);
        if (scrollDifference) {
          this._sortStrategy.updateOnScroll(scrollDifference.top, scrollDifference.left);
        }
      } else if (this.isReceiving()) {
        this._cacheParentPositions();
      }
    });
  }
  /**
   * Lazily resolves and returns the shadow root of the element. We do this in a function, rather
   * than saving it in property directly on init, because we want to resolve it as late as possible
   * in order to ensure that the element has been moved into the shadow DOM. Doing it inside the
   * constructor might be too early if the element is inside of something like `ngFor` or `ngIf`.
   */
  _getShadowRoot() {
    if (!this._cachedShadowRoot) {
      const shadowRoot = _getShadowRoot(this._container);
      this._cachedShadowRoot = shadowRoot || this._document;
    }
    return this._cachedShadowRoot;
  }
  /** Notifies any siblings that may potentially receive the item. */
  _notifyReceivingSiblings() {
    const draggedItems = this._sortStrategy.getActiveItemsSnapshot().filter((item) => item.isDragging());
    this._siblings.forEach((sibling) => sibling._startReceiving(this, draggedItems));
  }
};
function getVerticalScrollDirection(clientRect, pointerY) {
  const {
    top,
    bottom,
    height
  } = clientRect;
  const yThreshold = height * SCROLL_PROXIMITY_THRESHOLD;
  if (pointerY >= top - yThreshold && pointerY <= top + yThreshold) {
    return AutoScrollVerticalDirection.UP;
  } else if (pointerY >= bottom - yThreshold && pointerY <= bottom + yThreshold) {
    return AutoScrollVerticalDirection.DOWN;
  }
  return AutoScrollVerticalDirection.NONE;
}
function getHorizontalScrollDirection(clientRect, pointerX) {
  const {
    left,
    right,
    width
  } = clientRect;
  const xThreshold = width * SCROLL_PROXIMITY_THRESHOLD;
  if (pointerX >= left - xThreshold && pointerX <= left + xThreshold) {
    return AutoScrollHorizontalDirection.LEFT;
  } else if (pointerX >= right - xThreshold && pointerX <= right + xThreshold) {
    return AutoScrollHorizontalDirection.RIGHT;
  }
  return AutoScrollHorizontalDirection.NONE;
}
function getElementScrollDirections(element, clientRect, direction, pointerX, pointerY) {
  const computedVertical = getVerticalScrollDirection(clientRect, pointerY);
  const computedHorizontal = getHorizontalScrollDirection(clientRect, pointerX);
  let verticalScrollDirection = AutoScrollVerticalDirection.NONE;
  let horizontalScrollDirection = AutoScrollHorizontalDirection.NONE;
  if (computedVertical) {
    const scrollTop = element.scrollTop;
    if (computedVertical === AutoScrollVerticalDirection.UP) {
      if (scrollTop > 0) {
        verticalScrollDirection = AutoScrollVerticalDirection.UP;
      }
    } else if (element.scrollHeight - scrollTop > element.clientHeight) {
      verticalScrollDirection = AutoScrollVerticalDirection.DOWN;
    }
  }
  if (computedHorizontal) {
    const scrollLeft = element.scrollLeft;
    if (direction === "rtl") {
      if (computedHorizontal === AutoScrollHorizontalDirection.RIGHT) {
        if (scrollLeft < 0) {
          horizontalScrollDirection = AutoScrollHorizontalDirection.RIGHT;
        }
      } else if (element.scrollWidth + scrollLeft > element.clientWidth) {
        horizontalScrollDirection = AutoScrollHorizontalDirection.LEFT;
      }
    } else {
      if (computedHorizontal === AutoScrollHorizontalDirection.LEFT) {
        if (scrollLeft > 0) {
          horizontalScrollDirection = AutoScrollHorizontalDirection.LEFT;
        }
      } else if (element.scrollWidth - scrollLeft > element.clientWidth) {
        horizontalScrollDirection = AutoScrollHorizontalDirection.RIGHT;
      }
    }
  }
  return [verticalScrollDirection, horizontalScrollDirection];
}
var activeCapturingEventOptions = normalizePassiveListenerOptions({
  passive: false,
  capture: true
});
var _ResetsLoader = class __ResetsLoader {
  static ɵfac = function _ResetsLoader_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || __ResetsLoader)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: __ResetsLoader,
    selectors: [["ng-component"]],
    hostAttrs: ["cdk-drag-resets-container", ""],
    decls: 0,
    vars: 0,
    template: function _ResetsLoader_Template(rf, ctx) {
    },
    styles: ["@layer cdk-resets{.cdk-drag-preview{background:none;border:none;padding:0;color:inherit;inset:auto}}.cdk-drag-placeholder *,.cdk-drag-preview *{pointer-events:none !important}"],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_ResetsLoader, [{
    type: Component,
    args: [{
      encapsulation: ViewEncapsulation.None,
      template: "",
      changeDetection: ChangeDetectionStrategy.OnPush,
      host: {
        "cdk-drag-resets-container": ""
      },
      styles: ["@layer cdk-resets{.cdk-drag-preview{background:none;border:none;padding:0;color:inherit;inset:auto}}.cdk-drag-placeholder *,.cdk-drag-preview *{pointer-events:none !important}"]
    }]
  }], null, null);
})();
var DragDropRegistry = class _DragDropRegistry {
  _ngZone = inject(NgZone);
  _document = inject(DOCUMENT);
  _styleLoader = inject(_CdkPrivateStyleLoader);
  /** Registered drop container instances. */
  _dropInstances = /* @__PURE__ */ new Set();
  /** Registered drag item instances. */
  _dragInstances = /* @__PURE__ */ new Set();
  /** Drag item instances that are currently being dragged. */
  _activeDragInstances = signal([]);
  /** Keeps track of the event listeners that we've bound to the `document`. */
  _globalListeners = /* @__PURE__ */ new Map();
  /**
   * Predicate function to check if an item is being dragged.  Moved out into a property,
   * because it'll be called a lot and we don't want to create a new function every time.
   */
  _draggingPredicate = (item) => item.isDragging();
  /**
   * Map tracking DOM nodes and their corresponding drag directives. Note that this is different
   * from looking through the `_dragInstances` and getting their root node, because the root node
   * isn't necessarily the node that the directive is set on.
   */
  _domNodesToDirectives = null;
  /**
   * Emits the `touchmove` or `mousemove` events that are dispatched
   * while the user is dragging a drag item instance.
   */
  pointerMove = new Subject();
  /**
   * Emits the `touchend` or `mouseup` events that are dispatched
   * while the user is dragging a drag item instance.
   */
  pointerUp = new Subject();
  /**
   * Emits when the viewport has been scrolled while the user is dragging an item.
   * @deprecated To be turned into a private member. Use the `scrolled` method instead.
   * @breaking-change 13.0.0
   */
  scroll = new Subject();
  constructor() {
  }
  /** Adds a drop container to the registry. */
  registerDropContainer(drop) {
    if (!this._dropInstances.has(drop)) {
      this._dropInstances.add(drop);
    }
  }
  /** Adds a drag item instance to the registry. */
  registerDragItem(drag) {
    this._dragInstances.add(drag);
    if (this._dragInstances.size === 1) {
      this._ngZone.runOutsideAngular(() => {
        this._document.addEventListener("touchmove", this._persistentTouchmoveListener, activeCapturingEventOptions);
      });
    }
  }
  /** Removes a drop container from the registry. */
  removeDropContainer(drop) {
    this._dropInstances.delete(drop);
  }
  /** Removes a drag item instance from the registry. */
  removeDragItem(drag) {
    this._dragInstances.delete(drag);
    this.stopDragging(drag);
    if (this._dragInstances.size === 0) {
      this._document.removeEventListener("touchmove", this._persistentTouchmoveListener, activeCapturingEventOptions);
    }
  }
  /**
   * Starts the dragging sequence for a drag instance.
   * @param drag Drag instance which is being dragged.
   * @param event Event that initiated the dragging.
   */
  startDragging(drag, event) {
    if (this._activeDragInstances().indexOf(drag) > -1) {
      return;
    }
    this._styleLoader.load(_ResetsLoader);
    this._activeDragInstances.update((instances) => [...instances, drag]);
    if (this._activeDragInstances().length === 1) {
      const isTouchEvent2 = event.type.startsWith("touch");
      const endEventHandler = {
        handler: (e5) => this.pointerUp.next(e5),
        options: true
      };
      if (isTouchEvent2) {
        this._globalListeners.set("touchend", endEventHandler);
        this._globalListeners.set("touchcancel", endEventHandler);
      } else {
        this._globalListeners.set("mouseup", endEventHandler);
      }
      this._globalListeners.set("scroll", {
        handler: (e5) => this.scroll.next(e5),
        // Use capturing so that we pick up scroll changes in any scrollable nodes that aren't
        // the document. See https://github.com/angular/components/issues/17144.
        options: true
      }).set("selectstart", {
        handler: this._preventDefaultWhileDragging,
        options: activeCapturingEventOptions
      });
      if (!isTouchEvent2) {
        this._globalListeners.set("mousemove", {
          handler: (e5) => this.pointerMove.next(e5),
          options: activeCapturingEventOptions
        });
      }
      this._ngZone.runOutsideAngular(() => {
        this._globalListeners.forEach((config, name) => {
          this._document.addEventListener(name, config.handler, config.options);
        });
      });
    }
  }
  /** Stops dragging a drag item instance. */
  stopDragging(drag) {
    this._activeDragInstances.update((instances) => {
      const index = instances.indexOf(drag);
      if (index > -1) {
        instances.splice(index, 1);
        return [...instances];
      }
      return instances;
    });
    if (this._activeDragInstances().length === 0) {
      this._clearGlobalListeners();
    }
  }
  /** Gets whether a drag item instance is currently being dragged. */
  isDragging(drag) {
    return this._activeDragInstances().indexOf(drag) > -1;
  }
  /**
   * Gets a stream that will emit when any element on the page is scrolled while an item is being
   * dragged.
   * @param shadowRoot Optional shadow root that the current dragging sequence started from.
   *   Top-level listeners won't pick up events coming from the shadow DOM so this parameter can
   *   be used to include an additional top-level listener at the shadow root level.
   */
  scrolled(shadowRoot) {
    const streams = [this.scroll];
    if (shadowRoot && shadowRoot !== this._document) {
      streams.push(new Observable((observer) => {
        return this._ngZone.runOutsideAngular(() => {
          const eventOptions = true;
          const callback = (event) => {
            if (this._activeDragInstances().length) {
              observer.next(event);
            }
          };
          shadowRoot.addEventListener("scroll", callback, eventOptions);
          return () => {
            shadowRoot.removeEventListener("scroll", callback, eventOptions);
          };
        });
      }));
    }
    return merge(...streams);
  }
  /**
   * Tracks the DOM node which has a draggable directive.
   * @param node Node to track.
   * @param dragRef Drag directive set on the node.
   */
  registerDirectiveNode(node, dragRef) {
    this._domNodesToDirectives ??= /* @__PURE__ */ new WeakMap();
    this._domNodesToDirectives.set(node, dragRef);
  }
  /**
   * Stops tracking a draggable directive node.
   * @param node Node to stop tracking.
   */
  removeDirectiveNode(node) {
    this._domNodesToDirectives?.delete(node);
  }
  /**
   * Gets the drag directive corresponding to a specific DOM node, if any.
   * @param node Node for which to do the lookup.
   */
  getDragDirectiveForNode(node) {
    return this._domNodesToDirectives?.get(node) || null;
  }
  ngOnDestroy() {
    this._dragInstances.forEach((instance) => this.removeDragItem(instance));
    this._dropInstances.forEach((instance) => this.removeDropContainer(instance));
    this._domNodesToDirectives = null;
    this._clearGlobalListeners();
    this.pointerMove.complete();
    this.pointerUp.complete();
  }
  /**
   * Event listener that will prevent the default browser action while the user is dragging.
   * @param event Event whose default action should be prevented.
   */
  _preventDefaultWhileDragging = (event) => {
    if (this._activeDragInstances().length > 0) {
      event.preventDefault();
    }
  };
  /** Event listener for `touchmove` that is bound even if no dragging is happening. */
  _persistentTouchmoveListener = (event) => {
    if (this._activeDragInstances().length > 0) {
      if (this._activeDragInstances().some(this._draggingPredicate)) {
        event.preventDefault();
      }
      this.pointerMove.next(event);
    }
  };
  /** Clears out the global event listeners from the `document`. */
  _clearGlobalListeners() {
    this._globalListeners.forEach((config, name) => {
      this._document.removeEventListener(name, config.handler, config.options);
    });
    this._globalListeners.clear();
  }
  static ɵfac = function DragDropRegistry_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragDropRegistry)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DragDropRegistry,
    factory: _DragDropRegistry.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragDropRegistry, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var DEFAULT_CONFIG = {
  dragStartThreshold: 5,
  pointerDirectionChangeThreshold: 5
};
var DragDrop = class _DragDrop {
  _document = inject(DOCUMENT);
  _ngZone = inject(NgZone);
  _viewportRuler = inject(ViewportRuler);
  _dragDropRegistry = inject(DragDropRegistry);
  _renderer = inject(RendererFactory2).createRenderer(null, null);
  constructor() {
  }
  /**
   * Turns an element into a draggable item.
   * @param element Element to which to attach the dragging functionality.
   * @param config Object used to configure the dragging behavior.
   */
  createDrag(element, config = DEFAULT_CONFIG) {
    return new DragRef(element, config, this._document, this._ngZone, this._viewportRuler, this._dragDropRegistry, this._renderer);
  }
  /**
   * Turns an element into a drop list.
   * @param element Element to which to attach the drop list functionality.
   */
  createDropList(element) {
    return new DropListRef(element, this._dragDropRegistry, this._document, this._ngZone, this._viewportRuler);
  }
  static ɵfac = function DragDrop_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragDrop)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DragDrop,
    factory: _DragDrop.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragDrop, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var CDK_DRAG_PARENT = new InjectionToken("CDK_DRAG_PARENT");
function assertElementNode(node, name) {
  if (node.nodeType !== 1) {
    throw Error(`${name} must be attached to an element node. Currently attached to "${node.nodeName}".`);
  }
}
var CDK_DRAG_HANDLE = new InjectionToken("CdkDragHandle");
var CdkDragHandle = class _CdkDragHandle {
  element = inject(ElementRef);
  _parentDrag = inject(CDK_DRAG_PARENT, {
    optional: true,
    skipSelf: true
  });
  _dragDropRegistry = inject(DragDropRegistry);
  /** Emits when the state of the handle has changed. */
  _stateChanges = new Subject();
  /** Whether starting to drag through this handle is disabled. */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this._stateChanges.next(this);
  }
  _disabled = false;
  constructor() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      assertElementNode(this.element.nativeElement, "cdkDragHandle");
    }
    this._parentDrag?._addHandle(this);
  }
  ngAfterViewInit() {
    if (!this._parentDrag) {
      let parent = this.element.nativeElement.parentElement;
      while (parent) {
        const ref = this._dragDropRegistry.getDragDirectiveForNode(parent);
        if (ref) {
          this._parentDrag = ref;
          ref._addHandle(this);
          break;
        }
        parent = parent.parentElement;
      }
    }
  }
  ngOnDestroy() {
    this._parentDrag?._removeHandle(this);
    this._stateChanges.complete();
  }
  static ɵfac = function CdkDragHandle_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkDragHandle)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkDragHandle,
    selectors: [["", "cdkDragHandle", ""]],
    hostAttrs: [1, "cdk-drag-handle"],
    inputs: {
      disabled: [2, "cdkDragHandleDisabled", "disabled", booleanAttribute]
    },
    features: [ɵɵProvidersFeature([{
      provide: CDK_DRAG_HANDLE,
      useExisting: _CdkDragHandle
    }]), ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDragHandle, [{
    type: Directive,
    args: [{
      selector: "[cdkDragHandle]",
      host: {
        "class": "cdk-drag-handle"
      },
      providers: [{
        provide: CDK_DRAG_HANDLE,
        useExisting: CdkDragHandle
      }]
    }]
  }], () => [], {
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkDragHandleDisabled",
        transform: booleanAttribute
      }]
    }]
  });
})();
var CDK_DRAG_CONFIG = new InjectionToken("CDK_DRAG_CONFIG");
var CDK_DROP_LIST = new InjectionToken("CdkDropList");
var CdkDrag = class _CdkDrag {
  element = inject(ElementRef);
  dropContainer = inject(CDK_DROP_LIST, {
    optional: true,
    skipSelf: true
  });
  _ngZone = inject(NgZone);
  _viewContainerRef = inject(ViewContainerRef);
  _dir = inject(Directionality, {
    optional: true
  });
  _changeDetectorRef = inject(ChangeDetectorRef);
  _selfHandle = inject(CDK_DRAG_HANDLE, {
    optional: true,
    self: true
  });
  _parentDrag = inject(CDK_DRAG_PARENT, {
    optional: true,
    skipSelf: true
  });
  _dragDropRegistry = inject(DragDropRegistry);
  _destroyed = new Subject();
  _handles = new BehaviorSubject([]);
  _previewTemplate;
  _placeholderTemplate;
  /** Reference to the underlying drag instance. */
  _dragRef;
  /** Arbitrary data to attach to this drag instance. */
  data;
  /** Locks the position of the dragged element along the specified axis. */
  lockAxis;
  /**
   * Selector that will be used to determine the root draggable element, starting from
   * the `cdkDrag` element and going up the DOM. Passing an alternate root element is useful
   * when trying to enable dragging on an element that you might not have access to.
   */
  rootElementSelector;
  /**
   * Node or selector that will be used to determine the element to which the draggable's
   * position will be constrained. If a string is passed in, it'll be used as a selector that
   * will be matched starting from the element's parent and going up the DOM until a match
   * has been found.
   */
  boundaryElement;
  /**
   * Amount of milliseconds to wait after the user has put their
   * pointer down before starting to drag the element.
   */
  dragStartDelay;
  /**
   * Sets the position of a `CdkDrag` that is outside of a drop container.
   * Can be used to restore the element's position for a returning user.
   */
  freeDragPosition;
  /** Whether starting to drag this element is disabled. */
  get disabled() {
    return this._disabled || !!(this.dropContainer && this.dropContainer.disabled);
  }
  set disabled(value) {
    this._disabled = value;
    this._dragRef.disabled = this._disabled;
  }
  _disabled;
  /**
   * Function that can be used to customize the logic of how the position of the drag item
   * is limited while it's being dragged. Gets called with a point containing the current position
   * of the user's pointer on the page, a reference to the item being dragged and its dimensions.
   * Should return a point describing where the item should be rendered.
   */
  constrainPosition;
  /** Class to be added to the preview element. */
  previewClass;
  /**
   * Configures the place into which the preview of the item will be inserted. Can be configured
   * globally through `CDK_DROP_LIST`. Possible values:
   * - `global` - Preview will be inserted at the bottom of the `<body>`. The advantage is that
   * you don't have to worry about `overflow: hidden` or `z-index`, but the item won't retain
   * its inherited styles.
   * - `parent` - Preview will be inserted into the parent of the drag item. The advantage is that
   * inherited styles will be preserved, but it may be clipped by `overflow: hidden` or not be
   * visible due to `z-index`. Furthermore, the preview is going to have an effect over selectors
   * like `:nth-child` and some flexbox configurations.
   * - `ElementRef<HTMLElement> | HTMLElement` - Preview will be inserted into a specific element.
   * Same advantages and disadvantages as `parent`.
   */
  previewContainer;
  /**
   * If the parent of the dragged element has a `scale` transform, it can throw off the
   * positioning when the user starts dragging. Use this input to notify the CDK of the scale.
   */
  scale = 1;
  /** Emits when the user starts dragging the item. */
  started = new EventEmitter();
  /** Emits when the user has released a drag item, before any animations have started. */
  released = new EventEmitter();
  /** Emits when the user stops dragging an item in the container. */
  ended = new EventEmitter();
  /** Emits when the user has moved the item into a new container. */
  entered = new EventEmitter();
  /** Emits when the user removes the item its container by dragging it into another container. */
  exited = new EventEmitter();
  /** Emits when the user drops the item inside a container. */
  dropped = new EventEmitter();
  /**
   * Emits as the user is dragging the item. Use with caution,
   * because this event will fire for every pixel that the user has dragged.
   */
  moved = new Observable((observer) => {
    const subscription = this._dragRef.moved.pipe(map((movedEvent) => ({
      source: this,
      pointerPosition: movedEvent.pointerPosition,
      event: movedEvent.event,
      delta: movedEvent.delta,
      distance: movedEvent.distance
    }))).subscribe(observer);
    return () => {
      subscription.unsubscribe();
    };
  });
  _injector = inject(Injector);
  constructor() {
    const dropContainer = this.dropContainer;
    const config = inject(CDK_DRAG_CONFIG, {
      optional: true
    });
    const dragDrop = inject(DragDrop);
    this._dragRef = dragDrop.createDrag(this.element, {
      dragStartThreshold: config && config.dragStartThreshold != null ? config.dragStartThreshold : 5,
      pointerDirectionChangeThreshold: config && config.pointerDirectionChangeThreshold != null ? config.pointerDirectionChangeThreshold : 5,
      zIndex: config?.zIndex
    });
    this._dragRef.data = this;
    this._dragDropRegistry.registerDirectiveNode(this.element.nativeElement, this);
    if (config) {
      this._assignDefaults(config);
    }
    if (dropContainer) {
      this._dragRef._withDropContainer(dropContainer._dropListRef);
      dropContainer.addItem(this);
      dropContainer._dropListRef.beforeStarted.pipe(takeUntil(this._destroyed)).subscribe(() => {
        this._dragRef.scale = this.scale;
      });
    }
    this._syncInputs(this._dragRef);
    this._handleEvents(this._dragRef);
  }
  /**
   * Returns the element that is being used as a placeholder
   * while the current element is being dragged.
   */
  getPlaceholderElement() {
    return this._dragRef.getPlaceholderElement();
  }
  /** Returns the root draggable element. */
  getRootElement() {
    return this._dragRef.getRootElement();
  }
  /** Resets a standalone drag item to its initial position. */
  reset() {
    this._dragRef.reset();
  }
  /**
   * Gets the pixel coordinates of the draggable outside of a drop container.
   */
  getFreeDragPosition() {
    return this._dragRef.getFreeDragPosition();
  }
  /**
   * Sets the current position in pixels the draggable outside of a drop container.
   * @param value New position to be set.
   */
  setFreeDragPosition(value) {
    this._dragRef.setFreeDragPosition(value);
  }
  ngAfterViewInit() {
    afterNextRender(() => {
      this._updateRootElement();
      this._setupHandlesListener();
      this._dragRef.scale = this.scale;
      if (this.freeDragPosition) {
        this._dragRef.setFreeDragPosition(this.freeDragPosition);
      }
    }, {
      injector: this._injector
    });
  }
  ngOnChanges(changes) {
    const rootSelectorChange = changes["rootElementSelector"];
    const positionChange = changes["freeDragPosition"];
    if (rootSelectorChange && !rootSelectorChange.firstChange) {
      this._updateRootElement();
    }
    this._dragRef.scale = this.scale;
    if (positionChange && !positionChange.firstChange && this.freeDragPosition) {
      this._dragRef.setFreeDragPosition(this.freeDragPosition);
    }
  }
  ngOnDestroy() {
    if (this.dropContainer) {
      this.dropContainer.removeItem(this);
    }
    this._dragDropRegistry.removeDirectiveNode(this.element.nativeElement);
    this._ngZone.runOutsideAngular(() => {
      this._handles.complete();
      this._destroyed.next();
      this._destroyed.complete();
      this._dragRef.dispose();
    });
  }
  _addHandle(handle) {
    const handles = this._handles.getValue();
    handles.push(handle);
    this._handles.next(handles);
  }
  _removeHandle(handle) {
    const handles = this._handles.getValue();
    const index = handles.indexOf(handle);
    if (index > -1) {
      handles.splice(index, 1);
      this._handles.next(handles);
    }
  }
  _setPreviewTemplate(preview) {
    this._previewTemplate = preview;
  }
  _resetPreviewTemplate(preview) {
    if (preview === this._previewTemplate) {
      this._previewTemplate = null;
    }
  }
  _setPlaceholderTemplate(placeholder) {
    this._placeholderTemplate = placeholder;
  }
  _resetPlaceholderTemplate(placeholder) {
    if (placeholder === this._placeholderTemplate) {
      this._placeholderTemplate = null;
    }
  }
  /** Syncs the root element with the `DragRef`. */
  _updateRootElement() {
    const element = this.element.nativeElement;
    let rootElement = element;
    if (this.rootElementSelector) {
      rootElement = element.closest !== void 0 ? element.closest(this.rootElementSelector) : (
        // Comment tag doesn't have closest method, so use parent's one.
        element.parentElement?.closest(this.rootElementSelector)
      );
    }
    if (rootElement && (typeof ngDevMode === "undefined" || ngDevMode)) {
      assertElementNode(rootElement, "cdkDrag");
    }
    this._dragRef.withRootElement(rootElement || element);
  }
  /** Gets the boundary element, based on the `boundaryElement` value. */
  _getBoundaryElement() {
    const boundary = this.boundaryElement;
    if (!boundary) {
      return null;
    }
    if (typeof boundary === "string") {
      return this.element.nativeElement.closest(boundary);
    }
    return coerceElement(boundary);
  }
  /** Syncs the inputs of the CdkDrag with the options of the underlying DragRef. */
  _syncInputs(ref) {
    ref.beforeStarted.subscribe(() => {
      if (!ref.isDragging()) {
        const dir = this._dir;
        const dragStartDelay = this.dragStartDelay;
        const placeholder = this._placeholderTemplate ? {
          template: this._placeholderTemplate.templateRef,
          context: this._placeholderTemplate.data,
          viewContainer: this._viewContainerRef
        } : null;
        const preview = this._previewTemplate ? {
          template: this._previewTemplate.templateRef,
          context: this._previewTemplate.data,
          matchSize: this._previewTemplate.matchSize,
          viewContainer: this._viewContainerRef
        } : null;
        ref.disabled = this.disabled;
        ref.lockAxis = this.lockAxis;
        ref.scale = this.scale;
        ref.dragStartDelay = typeof dragStartDelay === "object" && dragStartDelay ? dragStartDelay : coerceNumberProperty(dragStartDelay);
        ref.constrainPosition = this.constrainPosition;
        ref.previewClass = this.previewClass;
        ref.withBoundaryElement(this._getBoundaryElement()).withPlaceholderTemplate(placeholder).withPreviewTemplate(preview).withPreviewContainer(this.previewContainer || "global");
        if (dir) {
          ref.withDirection(dir.value);
        }
      }
    });
    ref.beforeStarted.pipe(take(1)).subscribe(() => {
      if (this._parentDrag) {
        ref.withParent(this._parentDrag._dragRef);
        return;
      }
      let parent = this.element.nativeElement.parentElement;
      while (parent) {
        const parentDrag = this._dragDropRegistry.getDragDirectiveForNode(parent);
        if (parentDrag) {
          ref.withParent(parentDrag._dragRef);
          break;
        }
        parent = parent.parentElement;
      }
    });
  }
  /** Handles the events from the underlying `DragRef`. */
  _handleEvents(ref) {
    ref.started.subscribe((startEvent) => {
      this.started.emit({
        source: this,
        event: startEvent.event
      });
      this._changeDetectorRef.markForCheck();
    });
    ref.released.subscribe((releaseEvent) => {
      this.released.emit({
        source: this,
        event: releaseEvent.event
      });
    });
    ref.ended.subscribe((endEvent) => {
      this.ended.emit({
        source: this,
        distance: endEvent.distance,
        dropPoint: endEvent.dropPoint,
        event: endEvent.event
      });
      this._changeDetectorRef.markForCheck();
    });
    ref.entered.subscribe((enterEvent) => {
      this.entered.emit({
        container: enterEvent.container.data,
        item: this,
        currentIndex: enterEvent.currentIndex
      });
    });
    ref.exited.subscribe((exitEvent) => {
      this.exited.emit({
        container: exitEvent.container.data,
        item: this
      });
    });
    ref.dropped.subscribe((dropEvent) => {
      this.dropped.emit({
        previousIndex: dropEvent.previousIndex,
        currentIndex: dropEvent.currentIndex,
        previousContainer: dropEvent.previousContainer.data,
        container: dropEvent.container.data,
        isPointerOverContainer: dropEvent.isPointerOverContainer,
        item: this,
        distance: dropEvent.distance,
        dropPoint: dropEvent.dropPoint,
        event: dropEvent.event
      });
    });
  }
  /** Assigns the default input values based on a provided config object. */
  _assignDefaults(config) {
    const {
      lockAxis,
      dragStartDelay,
      constrainPosition,
      previewClass,
      boundaryElement,
      draggingDisabled,
      rootElementSelector,
      previewContainer
    } = config;
    this.disabled = draggingDisabled == null ? false : draggingDisabled;
    this.dragStartDelay = dragStartDelay || 0;
    if (lockAxis) {
      this.lockAxis = lockAxis;
    }
    if (constrainPosition) {
      this.constrainPosition = constrainPosition;
    }
    if (previewClass) {
      this.previewClass = previewClass;
    }
    if (boundaryElement) {
      this.boundaryElement = boundaryElement;
    }
    if (rootElementSelector) {
      this.rootElementSelector = rootElementSelector;
    }
    if (previewContainer) {
      this.previewContainer = previewContainer;
    }
  }
  /** Sets up the listener that syncs the handles with the drag ref. */
  _setupHandlesListener() {
    this._handles.pipe(
      // Sync the new handles with the DragRef.
      tap((handles) => {
        const handleElements = handles.map((handle) => handle.element);
        if (this._selfHandle && this.rootElementSelector) {
          handleElements.push(this.element);
        }
        this._dragRef.withHandles(handleElements);
      }),
      // Listen if the state of any of the handles changes.
      switchMap((handles) => {
        return merge(...handles.map((item) => item._stateChanges.pipe(startWith(item))));
      }),
      takeUntil(this._destroyed)
    ).subscribe((handleInstance) => {
      const dragRef = this._dragRef;
      const handle = handleInstance.element.nativeElement;
      handleInstance.disabled ? dragRef.disableHandle(handle) : dragRef.enableHandle(handle);
    });
  }
  static ɵfac = function CdkDrag_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkDrag)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkDrag,
    selectors: [["", "cdkDrag", ""]],
    hostAttrs: [1, "cdk-drag"],
    hostVars: 4,
    hostBindings: function CdkDrag_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("cdk-drag-disabled", ctx.disabled)("cdk-drag-dragging", ctx._dragRef.isDragging());
      }
    },
    inputs: {
      data: [0, "cdkDragData", "data"],
      lockAxis: [0, "cdkDragLockAxis", "lockAxis"],
      rootElementSelector: [0, "cdkDragRootElement", "rootElementSelector"],
      boundaryElement: [0, "cdkDragBoundary", "boundaryElement"],
      dragStartDelay: [0, "cdkDragStartDelay", "dragStartDelay"],
      freeDragPosition: [0, "cdkDragFreeDragPosition", "freeDragPosition"],
      disabled: [2, "cdkDragDisabled", "disabled", booleanAttribute],
      constrainPosition: [0, "cdkDragConstrainPosition", "constrainPosition"],
      previewClass: [0, "cdkDragPreviewClass", "previewClass"],
      previewContainer: [0, "cdkDragPreviewContainer", "previewContainer"],
      scale: [2, "cdkDragScale", "scale", numberAttribute]
    },
    outputs: {
      started: "cdkDragStarted",
      released: "cdkDragReleased",
      ended: "cdkDragEnded",
      entered: "cdkDragEntered",
      exited: "cdkDragExited",
      dropped: "cdkDragDropped",
      moved: "cdkDragMoved"
    },
    exportAs: ["cdkDrag"],
    features: [ɵɵProvidersFeature([{
      provide: CDK_DRAG_PARENT,
      useExisting: _CdkDrag
    }]), ɵɵInputTransformsFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDrag, [{
    type: Directive,
    args: [{
      selector: "[cdkDrag]",
      exportAs: "cdkDrag",
      host: {
        "class": "cdk-drag",
        "[class.cdk-drag-disabled]": "disabled",
        "[class.cdk-drag-dragging]": "_dragRef.isDragging()"
      },
      providers: [{
        provide: CDK_DRAG_PARENT,
        useExisting: CdkDrag
      }]
    }]
  }], () => [], {
    data: [{
      type: Input,
      args: ["cdkDragData"]
    }],
    lockAxis: [{
      type: Input,
      args: ["cdkDragLockAxis"]
    }],
    rootElementSelector: [{
      type: Input,
      args: ["cdkDragRootElement"]
    }],
    boundaryElement: [{
      type: Input,
      args: ["cdkDragBoundary"]
    }],
    dragStartDelay: [{
      type: Input,
      args: ["cdkDragStartDelay"]
    }],
    freeDragPosition: [{
      type: Input,
      args: ["cdkDragFreeDragPosition"]
    }],
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkDragDisabled",
        transform: booleanAttribute
      }]
    }],
    constrainPosition: [{
      type: Input,
      args: ["cdkDragConstrainPosition"]
    }],
    previewClass: [{
      type: Input,
      args: ["cdkDragPreviewClass"]
    }],
    previewContainer: [{
      type: Input,
      args: ["cdkDragPreviewContainer"]
    }],
    scale: [{
      type: Input,
      args: [{
        alias: "cdkDragScale",
        transform: numberAttribute
      }]
    }],
    started: [{
      type: Output,
      args: ["cdkDragStarted"]
    }],
    released: [{
      type: Output,
      args: ["cdkDragReleased"]
    }],
    ended: [{
      type: Output,
      args: ["cdkDragEnded"]
    }],
    entered: [{
      type: Output,
      args: ["cdkDragEntered"]
    }],
    exited: [{
      type: Output,
      args: ["cdkDragExited"]
    }],
    dropped: [{
      type: Output,
      args: ["cdkDragDropped"]
    }],
    moved: [{
      type: Output,
      args: ["cdkDragMoved"]
    }]
  });
})();
var CDK_DROP_LIST_GROUP = new InjectionToken("CdkDropListGroup");
var CdkDropListGroup = class _CdkDropListGroup {
  /** Drop lists registered inside the group. */
  _items = /* @__PURE__ */ new Set();
  /** Whether starting a dragging sequence from inside this group is disabled. */
  disabled = false;
  ngOnDestroy() {
    this._items.clear();
  }
  static ɵfac = function CdkDropListGroup_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkDropListGroup)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkDropListGroup,
    selectors: [["", "cdkDropListGroup", ""]],
    inputs: {
      disabled: [2, "cdkDropListGroupDisabled", "disabled", booleanAttribute]
    },
    exportAs: ["cdkDropListGroup"],
    features: [ɵɵProvidersFeature([{
      provide: CDK_DROP_LIST_GROUP,
      useExisting: _CdkDropListGroup
    }]), ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDropListGroup, [{
    type: Directive,
    args: [{
      selector: "[cdkDropListGroup]",
      exportAs: "cdkDropListGroup",
      providers: [{
        provide: CDK_DROP_LIST_GROUP,
        useExisting: CdkDropListGroup
      }]
    }]
  }], null, {
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkDropListGroupDisabled",
        transform: booleanAttribute
      }]
    }]
  });
})();
var CdkDropList = class _CdkDropList {
  element = inject(ElementRef);
  _changeDetectorRef = inject(ChangeDetectorRef);
  _scrollDispatcher = inject(ScrollDispatcher);
  _dir = inject(Directionality, {
    optional: true
  });
  _group = inject(CDK_DROP_LIST_GROUP, {
    optional: true,
    skipSelf: true
  });
  /** Emits when the list has been destroyed. */
  _destroyed = new Subject();
  /** Whether the element's scrollable parents have been resolved. */
  _scrollableParentsResolved;
  /** Keeps track of the drop lists that are currently on the page. */
  static _dropLists = [];
  /** Reference to the underlying drop list instance. */
  _dropListRef;
  /**
   * Other draggable containers that this container is connected to and into which the
   * container's items can be transferred. Can either be references to other drop containers,
   * or their unique IDs.
   */
  connectedTo = [];
  /** Arbitrary data to attach to this container. */
  data;
  /** Direction in which the list is oriented. */
  orientation;
  /**
   * Unique ID for the drop zone. Can be used as a reference
   * in the `connectedTo` of another `CdkDropList`.
   */
  id = inject(_IdGenerator).getId("cdk-drop-list-");
  /** Locks the position of the draggable elements inside the container along the specified axis. */
  lockAxis;
  /** Whether starting a dragging sequence from this container is disabled. */
  get disabled() {
    return this._disabled || !!this._group && this._group.disabled;
  }
  set disabled(value) {
    this._dropListRef.disabled = this._disabled = value;
  }
  _disabled;
  /** Whether sorting within this drop list is disabled. */
  sortingDisabled;
  /**
   * Function that is used to determine whether an item
   * is allowed to be moved into a drop container.
   */
  enterPredicate = () => true;
  /** Functions that is used to determine whether an item can be sorted into a particular index. */
  sortPredicate = () => true;
  /** Whether to auto-scroll the view when the user moves their pointer close to the edges. */
  autoScrollDisabled;
  /** Number of pixels to scroll for each frame when auto-scrolling an element. */
  autoScrollStep;
  /**
   * Selector that will be used to resolve an alternate element container for the drop list.
   * Passing an alternate container is useful for the cases where one might not have control
   * over the parent node of the draggable items within the list (e.g. due to content projection).
   * This allows for usages like:
   *
   * ```
   * <div cdkDropList cdkDropListElementContainer=".inner">
   *   <div class="inner">
   *     <div cdkDrag></div>
   *   </div>
   * </div>
   * ```
   */
  elementContainerSelector;
  /** Emits when the user drops an item inside the container. */
  dropped = new EventEmitter();
  /**
   * Emits when the user has moved a new drag item into this container.
   */
  entered = new EventEmitter();
  /**
   * Emits when the user removes an item from the container
   * by dragging it into another container.
   */
  exited = new EventEmitter();
  /** Emits as the user is swapping items while actively dragging. */
  sorted = new EventEmitter();
  /**
   * Keeps track of the items that are registered with this container. Historically we used to
   * do this with a `ContentChildren` query, however queries don't handle transplanted views very
   * well which means that we can't handle cases like dragging the headers of a `mat-table`
   * correctly. What we do instead is to have the items register themselves with the container
   * and then we sort them based on their position in the DOM.
   */
  _unsortedItems = /* @__PURE__ */ new Set();
  constructor() {
    const dragDrop = inject(DragDrop);
    const config = inject(CDK_DRAG_CONFIG, {
      optional: true
    });
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      assertElementNode(this.element.nativeElement, "cdkDropList");
    }
    this._dropListRef = dragDrop.createDropList(this.element);
    this._dropListRef.data = this;
    if (config) {
      this._assignDefaults(config);
    }
    this._dropListRef.enterPredicate = (drag, drop) => {
      return this.enterPredicate(drag.data, drop.data);
    };
    this._dropListRef.sortPredicate = (index, drag, drop) => {
      return this.sortPredicate(index, drag.data, drop.data);
    };
    this._setupInputSyncSubscription(this._dropListRef);
    this._handleEvents(this._dropListRef);
    _CdkDropList._dropLists.push(this);
    if (this._group) {
      this._group._items.add(this);
    }
  }
  /** Registers an items with the drop list. */
  addItem(item) {
    this._unsortedItems.add(item);
    if (this._dropListRef.isDragging()) {
      this._syncItemsWithRef();
    }
  }
  /** Removes an item from the drop list. */
  removeItem(item) {
    this._unsortedItems.delete(item);
    if (this._dropListRef.isDragging()) {
      this._syncItemsWithRef();
    }
  }
  /** Gets the registered items in the list, sorted by their position in the DOM. */
  getSortedItems() {
    return Array.from(this._unsortedItems).sort((a, b) => {
      const documentPosition = a._dragRef.getVisibleElement().compareDocumentPosition(b._dragRef.getVisibleElement());
      return documentPosition & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;
    });
  }
  ngOnDestroy() {
    const index = _CdkDropList._dropLists.indexOf(this);
    if (index > -1) {
      _CdkDropList._dropLists.splice(index, 1);
    }
    if (this._group) {
      this._group._items.delete(this);
    }
    this._unsortedItems.clear();
    this._dropListRef.dispose();
    this._destroyed.next();
    this._destroyed.complete();
  }
  /** Syncs the inputs of the CdkDropList with the options of the underlying DropListRef. */
  _setupInputSyncSubscription(ref) {
    if (this._dir) {
      this._dir.change.pipe(startWith(this._dir.value), takeUntil(this._destroyed)).subscribe((value) => ref.withDirection(value));
    }
    ref.beforeStarted.subscribe(() => {
      const siblings = coerceArray(this.connectedTo).map((drop) => {
        if (typeof drop === "string") {
          const correspondingDropList = _CdkDropList._dropLists.find((list) => list.id === drop);
          if (!correspondingDropList && (typeof ngDevMode === "undefined" || ngDevMode)) {
            console.warn(`CdkDropList could not find connected drop list with id "${drop}"`);
          }
          return correspondingDropList;
        }
        return drop;
      });
      if (this._group) {
        this._group._items.forEach((drop) => {
          if (siblings.indexOf(drop) === -1) {
            siblings.push(drop);
          }
        });
      }
      if (!this._scrollableParentsResolved) {
        const scrollableParents = this._scrollDispatcher.getAncestorScrollContainers(this.element).map((scrollable) => scrollable.getElementRef().nativeElement);
        this._dropListRef.withScrollableParents(scrollableParents);
        this._scrollableParentsResolved = true;
      }
      if (this.elementContainerSelector) {
        const container = this.element.nativeElement.querySelector(this.elementContainerSelector);
        if (!container && (typeof ngDevMode === "undefined" || ngDevMode)) {
          throw new Error(`CdkDropList could not find an element container matching the selector "${this.elementContainerSelector}"`);
        }
        ref.withElementContainer(container);
      }
      ref.disabled = this.disabled;
      ref.lockAxis = this.lockAxis;
      ref.sortingDisabled = this.sortingDisabled;
      ref.autoScrollDisabled = this.autoScrollDisabled;
      ref.autoScrollStep = coerceNumberProperty(this.autoScrollStep, 2);
      ref.connectedTo(siblings.filter((drop) => drop && drop !== this).map((list) => list._dropListRef)).withOrientation(this.orientation);
    });
  }
  /** Handles events from the underlying DropListRef. */
  _handleEvents(ref) {
    ref.beforeStarted.subscribe(() => {
      this._syncItemsWithRef();
      this._changeDetectorRef.markForCheck();
    });
    ref.entered.subscribe((event) => {
      this.entered.emit({
        container: this,
        item: event.item.data,
        currentIndex: event.currentIndex
      });
    });
    ref.exited.subscribe((event) => {
      this.exited.emit({
        container: this,
        item: event.item.data
      });
      this._changeDetectorRef.markForCheck();
    });
    ref.sorted.subscribe((event) => {
      this.sorted.emit({
        previousIndex: event.previousIndex,
        currentIndex: event.currentIndex,
        container: this,
        item: event.item.data
      });
    });
    ref.dropped.subscribe((dropEvent) => {
      this.dropped.emit({
        previousIndex: dropEvent.previousIndex,
        currentIndex: dropEvent.currentIndex,
        previousContainer: dropEvent.previousContainer.data,
        container: dropEvent.container.data,
        item: dropEvent.item.data,
        isPointerOverContainer: dropEvent.isPointerOverContainer,
        distance: dropEvent.distance,
        dropPoint: dropEvent.dropPoint,
        event: dropEvent.event
      });
      this._changeDetectorRef.markForCheck();
    });
    merge(ref.receivingStarted, ref.receivingStopped).subscribe(() => this._changeDetectorRef.markForCheck());
  }
  /** Assigns the default input values based on a provided config object. */
  _assignDefaults(config) {
    const {
      lockAxis,
      draggingDisabled,
      sortingDisabled,
      listAutoScrollDisabled,
      listOrientation
    } = config;
    this.disabled = draggingDisabled == null ? false : draggingDisabled;
    this.sortingDisabled = sortingDisabled == null ? false : sortingDisabled;
    this.autoScrollDisabled = listAutoScrollDisabled == null ? false : listAutoScrollDisabled;
    this.orientation = listOrientation || "vertical";
    if (lockAxis) {
      this.lockAxis = lockAxis;
    }
  }
  /** Syncs up the registered drag items with underlying drop list ref. */
  _syncItemsWithRef() {
    this._dropListRef.withItems(this.getSortedItems().map((item) => item._dragRef));
  }
  static ɵfac = function CdkDropList_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkDropList)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkDropList,
    selectors: [["", "cdkDropList", ""], ["cdk-drop-list"]],
    hostAttrs: [1, "cdk-drop-list"],
    hostVars: 7,
    hostBindings: function CdkDropList_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("id", ctx.id);
        ɵɵclassProp("cdk-drop-list-disabled", ctx.disabled)("cdk-drop-list-dragging", ctx._dropListRef.isDragging())("cdk-drop-list-receiving", ctx._dropListRef.isReceiving());
      }
    },
    inputs: {
      connectedTo: [0, "cdkDropListConnectedTo", "connectedTo"],
      data: [0, "cdkDropListData", "data"],
      orientation: [0, "cdkDropListOrientation", "orientation"],
      id: "id",
      lockAxis: [0, "cdkDropListLockAxis", "lockAxis"],
      disabled: [2, "cdkDropListDisabled", "disabled", booleanAttribute],
      sortingDisabled: [2, "cdkDropListSortingDisabled", "sortingDisabled", booleanAttribute],
      enterPredicate: [0, "cdkDropListEnterPredicate", "enterPredicate"],
      sortPredicate: [0, "cdkDropListSortPredicate", "sortPredicate"],
      autoScrollDisabled: [2, "cdkDropListAutoScrollDisabled", "autoScrollDisabled", booleanAttribute],
      autoScrollStep: [0, "cdkDropListAutoScrollStep", "autoScrollStep"],
      elementContainerSelector: [0, "cdkDropListElementContainer", "elementContainerSelector"]
    },
    outputs: {
      dropped: "cdkDropListDropped",
      entered: "cdkDropListEntered",
      exited: "cdkDropListExited",
      sorted: "cdkDropListSorted"
    },
    exportAs: ["cdkDropList"],
    features: [ɵɵProvidersFeature([
      // Prevent child drop lists from picking up the same group as their parent.
      {
        provide: CDK_DROP_LIST_GROUP,
        useValue: void 0
      },
      {
        provide: CDK_DROP_LIST,
        useExisting: _CdkDropList
      }
    ]), ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDropList, [{
    type: Directive,
    args: [{
      selector: "[cdkDropList], cdk-drop-list",
      exportAs: "cdkDropList",
      providers: [
        // Prevent child drop lists from picking up the same group as their parent.
        {
          provide: CDK_DROP_LIST_GROUP,
          useValue: void 0
        },
        {
          provide: CDK_DROP_LIST,
          useExisting: CdkDropList
        }
      ],
      host: {
        "class": "cdk-drop-list",
        "[attr.id]": "id",
        "[class.cdk-drop-list-disabled]": "disabled",
        "[class.cdk-drop-list-dragging]": "_dropListRef.isDragging()",
        "[class.cdk-drop-list-receiving]": "_dropListRef.isReceiving()"
      }
    }]
  }], () => [], {
    connectedTo: [{
      type: Input,
      args: ["cdkDropListConnectedTo"]
    }],
    data: [{
      type: Input,
      args: ["cdkDropListData"]
    }],
    orientation: [{
      type: Input,
      args: ["cdkDropListOrientation"]
    }],
    id: [{
      type: Input
    }],
    lockAxis: [{
      type: Input,
      args: ["cdkDropListLockAxis"]
    }],
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkDropListDisabled",
        transform: booleanAttribute
      }]
    }],
    sortingDisabled: [{
      type: Input,
      args: [{
        alias: "cdkDropListSortingDisabled",
        transform: booleanAttribute
      }]
    }],
    enterPredicate: [{
      type: Input,
      args: ["cdkDropListEnterPredicate"]
    }],
    sortPredicate: [{
      type: Input,
      args: ["cdkDropListSortPredicate"]
    }],
    autoScrollDisabled: [{
      type: Input,
      args: [{
        alias: "cdkDropListAutoScrollDisabled",
        transform: booleanAttribute
      }]
    }],
    autoScrollStep: [{
      type: Input,
      args: ["cdkDropListAutoScrollStep"]
    }],
    elementContainerSelector: [{
      type: Input,
      args: ["cdkDropListElementContainer"]
    }],
    dropped: [{
      type: Output,
      args: ["cdkDropListDropped"]
    }],
    entered: [{
      type: Output,
      args: ["cdkDropListEntered"]
    }],
    exited: [{
      type: Output,
      args: ["cdkDropListExited"]
    }],
    sorted: [{
      type: Output,
      args: ["cdkDropListSorted"]
    }]
  });
})();
var CDK_DRAG_PREVIEW = new InjectionToken("CdkDragPreview");
var CdkDragPreview = class _CdkDragPreview {
  templateRef = inject(TemplateRef);
  _drag = inject(CDK_DRAG_PARENT, {
    optional: true
  });
  /** Context data to be added to the preview template instance. */
  data;
  /** Whether the preview should preserve the same size as the item that is being dragged. */
  matchSize = false;
  constructor() {
    this._drag?._setPreviewTemplate(this);
  }
  ngOnDestroy() {
    this._drag?._resetPreviewTemplate(this);
  }
  static ɵfac = function CdkDragPreview_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkDragPreview)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkDragPreview,
    selectors: [["ng-template", "cdkDragPreview", ""]],
    inputs: {
      data: "data",
      matchSize: [2, "matchSize", "matchSize", booleanAttribute]
    },
    features: [ɵɵProvidersFeature([{
      provide: CDK_DRAG_PREVIEW,
      useExisting: _CdkDragPreview
    }]), ɵɵInputTransformsFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDragPreview, [{
    type: Directive,
    args: [{
      selector: "ng-template[cdkDragPreview]",
      providers: [{
        provide: CDK_DRAG_PREVIEW,
        useExisting: CdkDragPreview
      }]
    }]
  }], () => [], {
    data: [{
      type: Input
    }],
    matchSize: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }]
  });
})();
var CDK_DRAG_PLACEHOLDER = new InjectionToken("CdkDragPlaceholder");
var CdkDragPlaceholder = class _CdkDragPlaceholder {
  templateRef = inject(TemplateRef);
  _drag = inject(CDK_DRAG_PARENT, {
    optional: true
  });
  /** Context data to be added to the placeholder template instance. */
  data;
  constructor() {
    this._drag?._setPlaceholderTemplate(this);
  }
  ngOnDestroy() {
    this._drag?._resetPlaceholderTemplate(this);
  }
  static ɵfac = function CdkDragPlaceholder_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkDragPlaceholder)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CdkDragPlaceholder,
    selectors: [["ng-template", "cdkDragPlaceholder", ""]],
    inputs: {
      data: "data"
    },
    features: [ɵɵProvidersFeature([{
      provide: CDK_DRAG_PLACEHOLDER,
      useExisting: _CdkDragPlaceholder
    }])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDragPlaceholder, [{
    type: Directive,
    args: [{
      selector: "ng-template[cdkDragPlaceholder]",
      providers: [{
        provide: CDK_DRAG_PLACEHOLDER,
        useExisting: CdkDragPlaceholder
      }]
    }]
  }], () => [], {
    data: [{
      type: Input
    }]
  });
})();
var DRAG_DROP_DIRECTIVES = [CdkDropList, CdkDropListGroup, CdkDrag, CdkDragHandle, CdkDragPreview, CdkDragPlaceholder];
var DragDropModule = class _DragDropModule {
  static ɵfac = function DragDropModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragDropModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _DragDropModule,
    imports: [CdkDropList, CdkDropListGroup, CdkDrag, CdkDragHandle, CdkDragPreview, CdkDragPlaceholder],
    exports: [CdkScrollableModule, CdkDropList, CdkDropListGroup, CdkDrag, CdkDragHandle, CdkDragPreview, CdkDragPlaceholder]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [DragDrop],
    imports: [CdkScrollableModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragDropModule, [{
    type: NgModule,
    args: [{
      imports: DRAG_DROP_DIRECTIVES,
      exports: [CdkScrollableModule, ...DRAG_DROP_DIRECTIVES],
      providers: [DragDrop]
    }]
  }], null, null);
})();

// node_modules/@clr/angular/fesm2020/clr-angular.mjs
var _c02 = ["*"];
var _c12 = [[["clr-accordion-title"], ["clr-step-title"]], [["clr-accordion-description"], ["clr-step-description"]], "*"];
var _c2 = ["clr-accordion-title, clr-step-title", "clr-accordion-description, clr-step-description", "*"];
function ClrAccordionPanel_ng_container_0_div_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 9);
    ɵɵlistener("@toggle.done", function ClrAccordionPanel_ng_container_0_div_11_Template_div_animation_toggle_done_0_listener() {
      ɵɵrestoreView(_r3);
      const panel_r4 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.collapsePanelOnAnimationDone(panel_r4));
    });
    ɵɵelementStart(1, "div", 10);
    ɵɵprojection(2, 2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    ɵɵproperty("@toggle", void 0);
  }
}
function ClrAccordionPanel_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 2)(2, "div", 3)(3, "button", 4, 0);
    ɵɵpipe(5, "async");
    ɵɵlistener("click", function ClrAccordionPanel_ng_container_0_Template_button_click_3_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.togglePanel());
    });
    ɵɵelementStart(6, "span", 5);
    ɵɵelement(7, "cds-icon", 6);
    ɵɵelementEnd();
    ɵɵprojection(8);
    ɵɵprojection(9, 1);
    ɵɵelementEnd()();
    ɵɵelementStart(10, "div", 7);
    ɵɵtemplate(11, ClrAccordionPanel_ng_container_0_div_11_Template, 3, 1, "div", 8);
    ɵɵelementEnd()();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    let tmp_6_0;
    const panel_r4 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngClass", ctx_r1.getPanelStateClasses(panel_r4));
    ɵɵadvance();
    ɵɵattribute("role", ctx_r1.headingEnabled || ctx_r1.explicitHeadingLevel ? "heading" : null)("aria-level", ctx_r1.headingEnabled || ctx_r1.explicitHeadingLevel ? ctx_r1.headingLevel : null);
    ɵɵadvance();
    ɵɵclassProp("clr-accordion-header-has-description", ((tmp_6_0 = ɵɵpipeBind1(5, 14, ctx_r1.accordionDescription.changes)) == null ? null : tmp_6_0.length) || ctx_r1.accordionDescription.length);
    ɵɵproperty("id", ctx_r1.getAccordionHeaderId(panel_r4.templateId))("disabled", panel_r4.disabled);
    ɵɵattribute("aria-controls", ctx_r1.getAccordionContentId(panel_r4.templateId))("aria-expanded", panel_r4.open);
    ɵɵadvance(7);
    ɵɵproperty("@skipInitialRender", void 0)("id", ctx_r1.getAccordionContentId(panel_r4.templateId));
    ɵɵattribute("aria-hidden", !panel_r4.open)("aria-labelledby", ctx_r1.getAccordionHeaderId(panel_r4.templateId));
    ɵɵadvance();
    ɵɵproperty("ngIf", panel_r4.open);
  }
}
var _c3 = ["headerButton"];
var _c4 = [[["clr-step-title"]], [["clr-step-description"]], "*"];
var _c5 = ["clr-step-title", "clr-step-description", "*"];
function ClrStepperPanel_ng_container_0_cds_icon_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 14);
  }
}
function ClrStepperPanel_ng_container_0_cds_icon_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 15);
  }
}
function ClrStepperPanel_ng_container_0_ng_container_16_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.stepErrorText(ctx_r1.panelNumber), " ");
  }
}
function ClrStepperPanel_ng_container_0_ng_container_17_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.stepCompleteText(ctx_r1.panelNumber), " ");
  }
}
function ClrStepperPanel_ng_container_0_div_19_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 16);
    ɵɵlistener("@toggle.done", function ClrStepperPanel_ng_container_0_div_19_Template_div_animation_toggle_done_0_listener() {
      ɵɵrestoreView(_r3);
      const panel_r4 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.collapsePanelOnAnimationDone(panel_r4));
    });
    ɵɵelementStart(1, "div", 17);
    ɵɵprojection(2, 2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    ɵɵproperty("@toggle", void 0);
  }
}
function ClrStepperPanel_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 2)(2, "div", 3)(3, "button", 4, 0);
    ɵɵpipe(5, "async");
    ɵɵlistener("click", function ClrStepperPanel_ng_container_0_Template_button_click_3_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.togglePanel());
    });
    ɵɵelementStart(6, "span", 5);
    ɵɵelement(7, "cds-icon", 6);
    ɵɵtemplate(8, ClrStepperPanel_ng_container_0_cds_icon_8_Template, 1, 0, "cds-icon", 7)(9, ClrStepperPanel_ng_container_0_cds_icon_9_Template, 1, 0, "cds-icon", 8);
    ɵɵelementEnd();
    ɵɵelementStart(10, "span", 9)(11, "span", 10);
    ɵɵtext(12);
    ɵɵelementEnd();
    ɵɵprojection(13);
    ɵɵelementEnd();
    ɵɵprojection(14, 1);
    ɵɵelementEnd();
    ɵɵelementStart(15, "div", 11);
    ɵɵtemplate(16, ClrStepperPanel_ng_container_0_ng_container_16_Template, 2, 1, "ng-container", 1)(17, ClrStepperPanel_ng_container_0_ng_container_17_Template, 2, 1, "ng-container", 1);
    ɵɵelementEnd()();
    ɵɵelementStart(18, "div", 12);
    ɵɵtemplate(19, ClrStepperPanel_ng_container_0_div_19_Template, 3, 1, "div", 13);
    ɵɵelementEnd()();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    let tmp_4_0;
    const panel_r4 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngClass", ctx_r1.getPanelStateClasses(panel_r4));
    ɵɵadvance(2);
    ɵɵclassProp("clr-accordion-header-has-description", ((tmp_4_0 = ɵɵpipeBind1(5, 17, ctx_r1.accordionDescription.changes)) == null ? null : tmp_4_0.length) || ctx_r1.accordionDescription.length);
    ɵɵproperty("id", ctx_r1.getAccordionHeaderId(panel_r4.templateId));
    ɵɵattribute("aria-disabled", panel_r4.disabled)("aria-controls", ctx_r1.getAccordionContentId(panel_r4.templateId))("aria-expanded", panel_r4.open);
    ɵɵadvance(5);
    ɵɵproperty("ngIf", panel_r4.status === ctx_r1.AccordionStatus.Error);
    ɵɵadvance();
    ɵɵproperty("ngIf", panel_r4.status === ctx_r1.AccordionStatus.Complete);
    ɵɵadvance(3);
    ɵɵtextInterpolate1("", ctx_r1.panelNumber, ".");
    ɵɵadvance(4);
    ɵɵproperty("ngIf", panel_r4.status === ctx_r1.AccordionStatus.Error);
    ɵɵadvance();
    ɵɵproperty("ngIf", panel_r4.status === ctx_r1.AccordionStatus.Complete);
    ɵɵadvance();
    ɵɵproperty("@skipInitialRender", void 0)("id", ctx_r1.getAccordionContentId(panel_r4.templateId));
    ɵɵattribute("aria-hidden", !panel_r4.open)("aria-labelledby", ctx_r1.getAccordionHeaderId(panel_r4.templateId));
    ɵɵadvance();
    ɵɵproperty("ngIf", panel_r4.open);
  }
}
var _c6 = ["clrStepper", ""];
var _c7 = ["buttonProjectedRef"];
function ClrButton_ng_template_0_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 3);
  }
}
function ClrButton_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 1);
    ɵɵlistener("click", function ClrButton_ng_template_0_Template_button_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.emitClick());
    });
    ɵɵtemplate(1, ClrButton_ng_template_0_span_1_Template, 1, 0, "span", 2);
    ɵɵprojection(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap(ctx_r1.classNames);
    ɵɵattribute("type", ctx_r1.type)("name", ctx_r1.name)("disabled", ctx_r1.disabled)("role", ctx_r1.role)("id", ctx_r1.id);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.loading);
  }
}
var _c8 = ["menuToggle"];
var _c9 = ["menu"];
function ClrButtonGroup_0_ng_template_0_Template(rf, ctx) {
}
function ClrButtonGroup_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ClrButtonGroup_0_ng_template_0_Template, 0, 0, "ng-template", 4);
  }
  if (rf & 2) {
    const inlineButton_r1 = ctx.$implicit;
    ɵɵproperty("ngTemplateOutlet", inlineButton_r1.templateRef);
  }
}
function ClrButtonGroup_div_1_div_4_2_ng_template_0_Template(rf, ctx) {
}
function ClrButtonGroup_div_1_div_4_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ClrButtonGroup_div_1_div_4_2_ng_template_0_Template, 0, 0, "ng-template", 4);
  }
  if (rf & 2) {
    const menuButton_r4 = ctx.$implicit;
    ɵɵproperty("ngTemplateOutlet", menuButton_r4.templateRef);
  }
}
function ClrButtonGroup_div_1_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 9, 1);
    ɵɵtemplate(2, ClrButtonGroup_div_1_div_4_2_Template, 1, 1, null, 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("id", ctx_r2.popoverId);
    ɵɵattribute("id", ctx_r2.popoverId)("aria-hidden", !ctx_r2.open);
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r2.menuButtons);
  }
}
function ClrButtonGroup_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 5)(1, "button", 6, 0);
    ɵɵlistener("keydown.arrowup", function ClrButtonGroup_div_1_Template_button_keydown_arrowup_1_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.openMenu($event, ctx_r2.InitialFocus.LAST_ITEM));
    })("keydown.arrowdown", function ClrButtonGroup_div_1_Template_button_keydown_arrowdown_1_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.openMenu($event, ctx_r2.InitialFocus.FIRST_ITEM));
    });
    ɵɵelement(3, "cds-icon", 7);
    ɵɵelementEnd();
    ɵɵtemplate(4, ClrButtonGroup_div_1_div_4_Template, 3, 4, "div", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r2.menuPosition);
    ɵɵadvance();
    ɵɵattribute("aria-controls", ctx_r2.popoverId)("aria-expanded", ctx_r2.open)("aria-label", ctx_r2.clrToggleButtonAriaLabel);
    ɵɵadvance(2);
    ɵɵattribute("title", ctx_r2.commonStrings.keys.more);
    ɵɵadvance();
    ɵɵproperty("clrPopoverContent", ctx_r2.open)("clrPopoverContentAt", ctx_r2.popoverPosition)("clrPopoverContentOutsideClickToClose", true)("clrPopoverContentScrollToClose", true);
  }
}
var _c10 = ["clrLoading", ""];
function ClrLoadingButton_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "span", 3);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    ɵɵadvance();
    ɵɵproperty("@spinner", void 0);
  }
}
function ClrLoadingButton_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "span", 4);
    ɵɵlistener("@validated.done", function ClrLoadingButton_ng_container_2_Template_span_animation_validated_done_1_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.loadingStateChange(ctx_r1.buttonState.DEFAULT));
    });
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    ɵɵadvance();
    ɵɵproperty("@validated", void 0);
  }
}
function ClrLoadingButton_span_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵprojection(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵproperty("@defaultButton", void 0);
  }
}
function ClrSignpost_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "button", 1);
    ɵɵelement(2, "cds-icon", 2);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵattribute("aria-label", ctx_r0.commonStrings.keys.signpostToggle);
    ɵɵadvance();
    ɵɵattribute("title", ctx_r0.commonStrings.keys.info);
  }
}
var _c11 = [[["clr-signpost-title"]], "*"];
var _c122 = ["clr-signpost-title", "*"];
var _c13 = [[["label"]], "*", [["clr-control-helper"]], [["clr-control-error"]], [["clr-control-success"]]];
var _c14 = ["label", "*", "clr-control-helper", "clr-control-error", "clr-control-success"];
function ClrControlContainer_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "label");
  }
}
function ClrControlContainer_cds_icon_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 5);
  }
}
function ClrControlContainer_cds_icon_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 6);
  }
}
function ClrControlContainer_ng_content_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 2, ["*ngIf", "showHelper"]);
  }
}
function ClrControlContainer_ng_content_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 3, ["*ngIf", "showInvalid"]);
  }
}
function ClrControlContainer_ng_content_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 4, ["*ngIf", "showValid"]);
  }
}
var _c15 = [[["", "clrCheckbox", ""], ["", "clrToggle", ""]], [["label"]]];
var _c16 = ["[clrCheckbox],[clrToggle]", "label"];
function ClrCheckboxWrapper_label_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "label");
  }
}
var _c17 = [[["label"]], [["clr-checkbox-wrapper"], ["clr-toggle-wrapper"]], [["clr-control-helper"]], [["clr-control-error"]], [["clr-control-success"]]];
var _c18 = ["label", "clr-checkbox-wrapper,clr-toggle-wrapper", "clr-control-helper", "clr-control-error", "clr-control-success"];
function ClrCheckboxContainer_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "label");
  }
}
function ClrCheckboxContainer_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3);
    ɵɵprojection(1, 2);
    ɵɵelementEnd();
  }
}
function ClrCheckboxContainer_div_5_cds_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 6);
  }
}
function ClrCheckboxContainer_div_5_cds_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 7);
  }
}
function ClrCheckboxContainer_div_5_ng_content_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 3, ["*ngIf", "showInvalid"]);
  }
}
function ClrCheckboxContainer_div_5_ng_content_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 4, ["*ngIf", "showValid"]);
  }
}
function ClrCheckboxContainer_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3);
    ɵɵtemplate(1, ClrCheckboxContainer_div_5_cds_icon_1_Template, 1, 0, "cds-icon", 4)(2, ClrCheckboxContainer_div_5_cds_icon_2_Template, 1, 0, "cds-icon", 5)(3, ClrCheckboxContainer_div_5_ng_content_3_Template, 1, 0, "ng-content", 0)(4, ClrCheckboxContainer_div_5_ng_content_4_Template, 1, 0, "ng-content", 0);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.showInvalid);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.showValid);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.showInvalid);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.showValid);
  }
}
var _c19 = ["clrKeyFocus", ""];
var _c20 = ["clrRovingTabindex", ""];
var _c21 = ["controlContainer"];
var _c22 = [[["label"]], [["clr-combobox"]], [["clr-control-helper"]], [["clr-control-error"]], [["clr-control-success"]]];
var _c23 = ["label", "clr-combobox", "clr-control-helper", "clr-control-error", "clr-control-success"];
function ClrComboboxContainer_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "label");
  }
}
function ClrComboboxContainer_cds_icon_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 5);
  }
}
function ClrComboboxContainer_cds_icon_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 6);
  }
}
function ClrComboboxContainer_ng_content_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 2, ["*ngIf", "showHelper"]);
  }
}
function ClrComboboxContainer_ng_content_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 3, ["*ngIf", "showInvalid"]);
  }
}
function ClrComboboxContainer_ng_content_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 4, ["*ngIf", "showValid"]);
  }
}
function ClrOption_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 1);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.commonStrings.keys.comboboxSelected);
  }
}
function ClrOptions_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2)(1, "clr-spinner", 3);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementStart(3, "span", 4);
    ɵɵtext(4);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r0.commonStrings.keys.loading, " ");
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r0.searchText(ctx_r0.optionSelectionService.currentInput), " ");
  }
}
function ClrOptions_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 5)(1, "span", 6);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("id", ctx_r0.noResultsElementId);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r0.commonStrings.keys.comboboxNoResults, " ");
  }
}
var _c24 = ["textboxInput"];
var _c25 = ["trigger"];
var _c26 = (a0) => ({
  $implicit: a0
});
function ClrCombobox_span_1_span_1_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 18);
  }
  if (rf & 2) {
    const i_r3 = ɵɵnextContext().index;
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r3.optionSelected.template)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c26, ctx_r3.optionSelectionService.selectionModel.model[i_r3]));
  }
}
function ClrCombobox_span_1_span_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 12)(1, "span", 13)(2, "span", 14);
    ɵɵtemplate(3, ClrCombobox_span_1_span_1_ng_container_3_Template, 1, 4, "ng-container", 15);
    ɵɵelementEnd()();
    ɵɵelementStart(4, "span", 13)(5, "button", 16);
    ɵɵlistener("click", function ClrCombobox_span_1_span_1_Template_button_click_5_listener() {
      const item_r5 = ɵɵrestoreView(_r2).$implicit;
      const ctx_r3 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r3.unselect(item_r5));
    });
    ɵɵelement(6, "cds-icon", 17);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const i_r3 = ctx.index;
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵadvance(3);
    ɵɵproperty("ngIf", ctx_r3.optionSelected);
    ɵɵadvance(2);
    ɵɵproperty("disabled", (ctx_r3.control == null ? null : ctx_r3.control.disabled) ? true : null);
    ɵɵattribute("aria-label", ctx_r3.commonStrings.keys.comboboxDelete + " " + ctx_r3.optionSelectionService.selectionModel.toString(ctx_r3.displayField, i_r3));
  }
}
function ClrCombobox_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 10);
    ɵɵtemplate(1, ClrCombobox_span_1_span_1_Template, 7, 3, "span", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("clrRovingTabindexDisabled", ctx_r3.control == null ? null : ctx_r3.control.disabled);
    ɵɵattribute("aria-label", ctx_r3.getSelectionAriaLabel())("aria-disabled", (ctx_r3.control == null ? null : ctx_r3.control.disabled) ? true : null);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r3.multiSelectModel);
  }
}
function ClrCombobox_div_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 19);
    ɵɵprojection(1);
    ɵɵelementEnd();
  }
}
var _c27 = [[["label"]], [["", "clrInputPrefix", ""]], [["", "clrInput", ""]], [["", "clrInputSuffix", ""]], [["clr-control-helper"]], [["clr-control-error"]], [["clr-control-success"]]];
var _c28 = ["label", "[clrInputPrefix]", "[clrInput]", "[clrInputSuffix]", "clr-control-helper", "clr-control-error", "clr-control-success"];
function ClrInputContainer_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "label");
  }
}
function ClrInputContainer_cds_icon_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 6);
  }
}
function ClrInputContainer_cds_icon_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 7);
  }
}
function ClrInputContainer_ng_content_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 4, ["*ngIf", "showHelper"]);
  }
}
function ClrInputContainer_ng_content_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 5, ["*ngIf", "showInvalid"]);
  }
}
function ClrInputContainer_ng_content_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 6, ["*ngIf", "showValid"]);
  }
}
var _c29 = [[["label"]], [["", "clrDatalistInput", ""]], [["datalist"]], [["clr-control-helper"]], [["clr-control-error"]], [["clr-control-success"]]];
var _c30 = ["label", "[clrDatalistInput]", "datalist", "clr-control-helper", "clr-control-error", "clr-control-success"];
function ClrDatalistContainer_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "label");
  }
}
function ClrDatalistContainer_cds_icon_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 7);
  }
}
function ClrDatalistContainer_cds_icon_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 8);
  }
}
function ClrDatalistContainer_ng_content_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 3, ["*ngIf", "showHelper"]);
  }
}
function ClrDatalistContainer_ng_content_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 4, ["*ngIf", "showInvalid"]);
  }
}
function ClrDatalistContainer_ng_content_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 5, ["*ngIf", "showValid"]);
  }
}
function ClrCalendar_th_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 4)(1, "span");
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const day_r1 = ctx.$implicit;
    ɵɵadvance();
    ɵɵattribute("aria-label", day_r1.day);
    ɵɵadvance();
    ɵɵtextInterpolate(day_r1.narrow);
  }
}
function ClrCalendar_tr_3_td_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 7)(1, "clr-day", 8);
    ɵɵlistener("selectDay", function ClrCalendar_tr_3_td_1_Template_clr_day_selectDay_1_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.setSelectedDay($event));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const dayView_r4 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("clrDayView", dayView_r4);
  }
}
function ClrCalendar_tr_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr", 5);
    ɵɵtemplate(1, ClrCalendar_tr_3_td_1_Template, 2, 1, "td", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r5 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngForOf", row_r5);
  }
}
function ClrMonthpicker_button_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 1);
    ɵɵlistener("click", function ClrMonthpicker_button_0_Template_button_click_0_listener() {
      const monthIndex_r2 = ɵɵrestoreView(_r1).index;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.changeMonth(monthIndex_r2));
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const month_r4 = ctx.$implicit;
    const monthIndex_r2 = ctx.index;
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassProp("is-selected", monthIndex_r2 === ctx_r2.calendarMonthIndex);
    ɵɵattribute("tabindex", ctx_r2.getTabIndex(monthIndex_r2));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", month_r4, " ");
  }
}
function ClrYearpicker_button_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 7);
    ɵɵlistener("click", function ClrYearpicker_button_8_Template_button_click_0_listener() {
      const year_r2 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.changeYear(year_r2));
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const year_r2 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassProp("is-selected", year_r2 === ctx_r2.calendarYear);
    ɵɵattribute("tabindex", ctx_r2.getTabIndex(year_r2));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", year_r2, " ");
  }
}
function ClrDatepickerViewManager_clr_monthpicker_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "clr-monthpicker");
  }
}
function ClrDatepickerViewManager_clr_yearpicker_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "clr-yearpicker");
  }
}
function ClrDatepickerViewManager_clr_daypicker_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "clr-daypicker");
  }
}
function ClrDatepickerViewManager_clr_datepicker_actions_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "clr-datepicker-actions");
  }
}
var _c31 = ["actionButton"];
var _c32 = [[["label"]], [["", "clrDate", ""]], [["clr-control-helper"]], [["clr-control-error"]], [["clr-control-success"]]];
var _c33 = ["label", "[clrDate]", "clr-control-helper", "clr-control-error", "clr-control-success"];
function ClrDateContainer_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "label");
  }
}
function ClrDateContainer_button_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 9, 0);
    ɵɵelement(2, "cds-icon", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("disabled", ctx_r0.isInputDateDisabled);
  }
}
function ClrDateContainer_clr_datepicker_view_manager_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "clr-datepicker-view-manager", 11);
  }
}
function ClrDateContainer_cds_icon_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 12);
  }
}
function ClrDateContainer_cds_icon_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 13);
  }
}
function ClrDateContainer_ng_content_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 2, ["*ngIf", "showHelper"]);
  }
}
function ClrDateContainer_ng_content_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 3, ["*ngIf", "showInvalid"]);
  }
}
function ClrDateContainer_ng_content_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 4, ["*ngIf", "showValid"]);
  }
}
function ClrFileSuccess_ng_content_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 0, ["*ngIf", "context.success"]);
  }
}
var _c34 = (a0, a1) => ({
  "clr-error": a0,
  "clr-success": a1
});
function ClrFileList_ng_container_0_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 2)(1, "div", 3)(2, "span", 4);
    ɵɵtext(3);
    ɵɵelementStart(4, "button", 5);
    ɵɵlistener("click", function ClrFileList_ng_container_0_div_1_Template_button_click_4_listener() {
      ɵɵrestoreView(_r1);
      const file_r2 = ɵɵnextContext().$implicit;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.clearFile(file_r2));
    });
    ɵɵelement(5, "cds-icon", 6);
    ɵɵelementEnd()();
    ɵɵelement(6, "cds-icon", 7);
    ɵɵelementEnd();
    ɵɵelementContainer(7, 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const fileMessagesTemplateContext_r4 = ctx.$implicit;
    const file_r2 = ɵɵnextContext().$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("ngClass", ɵɵpureFunction2(8, _c34, !fileMessagesTemplateContext_r4.success, fileMessagesTemplateContext_r4.success));
    ɵɵadvance(3);
    ɵɵtextInterpolate1(" ", file_r2.name, " ");
    ɵɵadvance();
    ɵɵattribute("aria-label", ctx_r2.getClearFileLabel(file_r2.name));
    ɵɵadvance(2);
    ɵɵattribute("shape", fileMessagesTemplateContext_r4.success ? "check-circle" : "exclamation-circle")("status", fileMessagesTemplateContext_r4.success ? "success" : "danger");
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r2.fileMessagesTemplate.templateRef)("ngTemplateOutletContext", fileMessagesTemplateContext_r4)("ngTemplateOutletInjector", ctx_r2.createFileMessagesTemplateInjector(fileMessagesTemplateContext_r4));
  }
}
function ClrFileList_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, ClrFileList_ng_container_0_div_1_Template, 8, 11, "div", 1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const file_r2 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.createFileMessagesTemplateContext(file_r2));
  }
}
var _c35 = ["browseButton"];
var _c36 = ["fileListFileInput"];
var _c37 = [[["label"]], [["", "clrFileInput", ""]], [["clr-file-list"]], [["clr-control-helper"]], [["clr-control-error"]], [["clr-control-success"]]];
var _c38 = ["label", "[clrFileInput]", "clr-file-list", "clr-control-helper", "clr-control-error", "clr-control-success"];
function ClrFileInputContainer_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "label");
  }
}
function ClrFileInputContainer_input_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "input", 13, 1);
    ɵɵlistener("change", function ClrFileInputContainer_input_5_Template_input_change_0_listener() {
      ɵɵrestoreView(_r2);
      const fileListFileInput_r3 = ɵɵreference(1);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.addFilesToSelection(fileListFileInput_r3.files));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("accept", ctx_r3.accept)("multiple", ctx_r3.multiple)("disabled", ctx_r3.disabled);
  }
}
function ClrFileInputContainer_button_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 14);
    ɵɵlistener("click", function ClrFileInputContainer_button_11_Template_button_click_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.clearSelectedFiles());
    });
    ɵɵelement(1, "cds-icon", 15);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵattribute("aria-label", ctx_r3.fileInput == null ? null : ctx_r3.fileInput.selection == null ? null : ctx_r3.fileInput.selection.clearFilesButtonLabel);
  }
}
function ClrFileInputContainer_cds_icon_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 16);
  }
}
function ClrFileInputContainer_cds_icon_13_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 17);
  }
}
function ClrFileInputContainer_ng_content_14_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 3, ["*ngIf", "showHelper"]);
  }
}
function ClrFileInputContainer_ng_content_15_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 4, ["*ngIf", "showInvalid"]);
  }
}
function ClrFileInputContainer_ng_content_16_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 5, ["*ngIf", "showValid"]);
  }
}
var _c39 = [[["label"]], [["", "clrNumberInput", ""]], [["clr-control-helper"]], [["clr-control-error"]], [["clr-control-success"]]];
var _c40 = ["label", "[clrNumberInput]", "clr-control-helper", "clr-control-error", "clr-control-success"];
function ClrNumberInputContainer_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "label");
  }
}
function ClrNumberInputContainer_cds_icon_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 11);
  }
}
function ClrNumberInputContainer_cds_icon_13_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 12);
  }
}
function ClrNumberInputContainer_ng_content_14_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 2, ["*ngIf", "showHelper"]);
  }
}
function ClrNumberInputContainer_ng_content_15_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 3, ["*ngIf", "showInvalid"]);
  }
}
function ClrNumberInputContainer_ng_content_16_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 4, ["*ngIf", "showValid"]);
  }
}
var _c41 = [[["label"]], [["", "clrPassword", ""]], [["clr-control-helper"]], [["clr-control-error"]], [["clr-control-success"]]];
var _c42 = ["label", "[clrPassword]", "clr-control-helper", "clr-control-error", "clr-control-success"];
function ClrPasswordContainer_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "label");
  }
}
function ClrPasswordContainer_button_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 7);
    ɵɵlistener("click", function ClrPasswordContainer_button_6_Template_button_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.toggle());
    });
    ɵɵelement(1, "cds-icon", 8);
    ɵɵelementStart(2, "span", 9);
    ɵɵtext(3);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("disabled", ctx_r1.control == null ? null : ctx_r1.control.disabled);
    ɵɵadvance();
    ɵɵattribute("shape", ctx_r1.show ? "eye-hide" : "eye");
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r1.show ? ctx_r1.hidePasswordText(ctx_r1.label == null ? null : ctx_r1.label.labelText) : ctx_r1.showPasswordText(ctx_r1.label == null ? null : ctx_r1.label.labelText), " ");
  }
}
function ClrPasswordContainer_cds_icon_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 10);
  }
}
function ClrPasswordContainer_cds_icon_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 11);
  }
}
function ClrPasswordContainer_ng_content_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 2, ["*ngIf", "showHelper"]);
  }
}
function ClrPasswordContainer_ng_content_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 3, ["*ngIf", "showInvalid"]);
  }
}
function ClrPasswordContainer_ng_content_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 4, ["*ngIf", "showValid"]);
  }
}
var _c43 = [[["", "clrRadio", ""]], [["label"]]];
var _c44 = ["[clrRadio]", "label"];
function ClrRadioWrapper_label_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "label");
  }
}
var _c45 = [[["label"]], [["clr-radio-wrapper"]], [["clr-control-helper"]], [["clr-control-error"]], [["clr-control-success"]]];
var _c46 = ["label", "clr-radio-wrapper", "clr-control-helper", "clr-control-error", "clr-control-success"];
function ClrRadioContainer_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "label");
  }
}
function ClrRadioContainer_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3);
    ɵɵprojection(1, 2);
    ɵɵelementEnd();
  }
}
function ClrRadioContainer_div_5_cds_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 6);
  }
}
function ClrRadioContainer_div_5_cds_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 7);
  }
}
function ClrRadioContainer_div_5_ng_content_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 3, ["*ngIf", "showInvalid"]);
  }
}
function ClrRadioContainer_div_5_ng_content_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 4, ["*ngIf", "showValid"]);
  }
}
function ClrRadioContainer_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3);
    ɵɵtemplate(1, ClrRadioContainer_div_5_cds_icon_1_Template, 1, 0, "cds-icon", 4)(2, ClrRadioContainer_div_5_cds_icon_2_Template, 1, 0, "cds-icon", 5)(3, ClrRadioContainer_div_5_ng_content_3_Template, 1, 0, "ng-content", 0)(4, ClrRadioContainer_div_5_ng_content_4_Template, 1, 0, "ng-content", 0);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.showInvalid);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.showValid);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.showInvalid);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.showValid);
  }
}
var _c47 = [[["label"]], [["", "clrRange", ""]], [["clr-control-helper"]], [["clr-control-error"]], [["clr-control-success"]]];
var _c48 = ["label", "[clrRange]", "clr-control-helper", "clr-control-error", "clr-control-success"];
function ClrRangeContainer_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "label");
  }
}
function ClrRangeContainer_span_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 6);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("width", ctx_r0.getRangeProgressFillWidth());
  }
}
function ClrRangeContainer_cds_icon_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 7);
  }
}
function ClrRangeContainer_cds_icon_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 8);
  }
}
function ClrRangeContainer_ng_content_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 2, ["*ngIf", "showHelper"]);
  }
}
function ClrRangeContainer_ng_content_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 3, ["*ngIf", "showInvalid"]);
  }
}
function ClrRangeContainer_ng_content_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 4, ["*ngIf", "showValid"]);
  }
}
var _c49 = [[["label"]], [["", "clrSelect", ""]], [["clr-control-helper"]], [["clr-control-error"]], [["clr-control-success"]]];
var _c50 = ["label", "[clrSelect]", "clr-control-helper", "clr-control-error", "clr-control-success"];
function ClrSelectContainer_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "label");
  }
}
function ClrSelectContainer_cds_icon_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 5);
  }
}
function ClrSelectContainer_cds_icon_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 6);
  }
}
function ClrSelectContainer_ng_content_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 2, ["*ngIf", "showHelper"]);
  }
}
function ClrSelectContainer_ng_content_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 3, ["*ngIf", "showInvalid"]);
  }
}
function ClrSelectContainer_ng_content_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 4, ["*ngIf", "showValid"]);
  }
}
var _c51 = [[["label"]], [["", "clrTextarea", ""]], [["clr-control-helper"]], [["clr-control-error"]], [["clr-control-success"]]];
var _c52 = ["label", "[clrTextarea]", "clr-control-helper", "clr-control-error", "clr-control-success"];
function ClrTextareaContainer_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "label");
  }
}
function ClrTextareaContainer_cds_icon_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 5);
  }
}
function ClrTextareaContainer_cds_icon_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 6);
  }
}
function ClrTextareaContainer_ng_content_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 2, ["*ngIf", "showHelper"]);
  }
}
function ClrTextareaContainer_ng_content_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 3, ["*ngIf", "showInvalid"]);
  }
}
function ClrTextareaContainer_ng_content_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 4, ["*ngIf", "showValid"]);
  }
}
var _c53 = ["anchor"];
function ClrDatagridFilter_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4)(1, "div", 5)(2, "button", 6);
    ɵɵelement(3, "cds-icon", 7);
    ɵɵelementEnd()();
    ɵɵprojection(4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("id", ctx_r0.popoverId);
    ɵɵattribute("aria-label", ctx_r0.commonStrings.keys.datagridFilterDialogAriaLabel);
    ɵɵadvance(3);
    ɵɵattribute("title", ctx_r0.commonStrings.keys.close);
  }
}
var _c54 = ["input_low"];
var _c55 = ["input"];
var _c56 = ["columnPortal"];
function WrappedColumn_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
var _c57 = ["resizeTracker"];
var _c58 = ["columnHandle"];
var _c59 = [[["clr-dg-filter"], ["clr-dg-string-filter"], ["clr-dg-numeric-filter"]], "*"];
var _c60 = ["clr-dg-filter, clr-dg-string-filter, clr-dg-numeric-filter", "*"];
function ClrDatagridColumn_button_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function ClrDatagridColumn_button_1_cds_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 10);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵattribute("direction", ctx_r1.sortDirection);
  }
}
function ClrDatagridColumn_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 7);
    ɵɵlistener("click", function ClrDatagridColumn_button_1_Template_button_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.sort());
    });
    ɵɵtemplate(1, ClrDatagridColumn_button_1_ng_container_1_Template, 1, 0, "ng-container", 8)(2, ClrDatagridColumn_button_1_cds_icon_2_Template, 1, 1, "cds-icon", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const columnTitle_r3 = ɵɵreference(6);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", columnTitle_r3);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.sortDirection);
  }
}
function ClrDatagridColumn_clr_dg_string_filter_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "clr-dg-string-filter", 11);
    ɵɵtwoWayListener("clrFilterValueChange", function ClrDatagridColumn_clr_dg_string_filter_3_Template_clr_dg_string_filter_clrFilterValueChange_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r1.filterValue, $event) || (ctx_r1.filterValue = $event);
      return ɵɵresetView($event);
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("clrFilterPlaceholder", ctx_r1.filterStringPlaceholder)("clrDgStringFilter", ctx_r1.registered);
    ɵɵtwoWayProperty("clrFilterValue", ctx_r1.filterValue);
  }
}
function ClrDatagridColumn_clr_dg_numeric_filter_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "clr-dg-numeric-filter", 12);
    ɵɵtwoWayListener("clrFilterValueChange", function ClrDatagridColumn_clr_dg_numeric_filter_4_Template_clr_dg_numeric_filter_clrFilterValueChange_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r1.filterValue, $event) || (ctx_r1.filterValue = $event);
      return ɵɵresetView($event);
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("clrFilterMaxPlaceholder", ctx_r1.filterNumberMaxPlaceholder)("clrFilterMinPlaceholder", ctx_r1.filterNumberMinPlaceholder)("clrDgNumericFilter", ctx_r1.registered);
    ɵɵtwoWayProperty("clrFilterValue", ctx_r1.filterValue);
  }
}
function ClrDatagridColumn_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 1);
  }
}
function ClrDatagridColumn_span_7_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function ClrDatagridColumn_span_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 13);
    ɵɵtemplate(1, ClrDatagridColumn_span_7_ng_container_1_Template, 1, 0, "ng-container", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵnextContext();
    const columnTitle_r3 = ɵɵreference(6);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", columnTitle_r3);
  }
}
function ClrDatagridColumn_clr_dg_column_separator_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "clr-dg-column-separator");
  }
}
function ClrDatagridPlaceholder_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 4);
  }
}
function ClrDatagridPlaceholder_ng_content_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 0, ["*ngIf", "emptyDatagrid"]);
  }
}
var _c61 = ["cellPortal"];
function WrappedCell_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
var _c62 = ["rowPortal"];
function WrappedRow_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
var _c63 = ["detailButton"];
var _c64 = ["stickyCells"];
var _c65 = ["scrollableCells"];
var _c66 = ["calculatedCells"];
var _c67 = [[["clr-dg-row-detail"]], [["clr-dg-cell"]], [["clr-dg-action-overflow"]]];
var _c68 = ["clr-dg-row-detail", "clr-dg-cell", "clr-dg-action-overflow"];
var _c69 = (a0) => ({
  "is-replaced": a0
});
var _c70 = (a0) => ({
  "clr-form-control-disabled": a0
});
function ClrDatagridRow_div_0_clr_expandable_animation_1_ng_template_1_Template(rf, ctx) {
}
function ClrDatagridRow_div_0_clr_expandable_animation_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "clr-expandable-animation", 10);
    ɵɵtemplate(1, ClrDatagridRow_div_0_clr_expandable_animation_1_ng_template_1_Template, 0, 0, "ng-template", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    const rowContent_r3 = ɵɵreference(6);
    ɵɵproperty("clrExpandTrigger", ctx_r1.expandAnimationTrigger);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", rowContent_r3);
  }
}
function ClrDatagridRow_div_0_2_ng_template_0_Template(rf, ctx) {
}
function ClrDatagridRow_div_0_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ClrDatagridRow_div_0_2_ng_template_0_Template, 0, 0, "ng-template", 11);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const rowContent_r3 = ɵɵreference(6);
    ɵɵproperty("ngTemplateOutlet", rowContent_r3);
  }
}
function ClrDatagridRow_div_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 9);
    ɵɵlistener("mousedown", function ClrDatagridRow_div_0_Template_div_mousedown_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearRanges($event));
    })("click", function ClrDatagridRow_div_0_Template_div_click_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.selectRow(!ctx_r1.selected, $event));
    });
    ɵɵtemplate(1, ClrDatagridRow_div_0_clr_expandable_animation_1_Template, 2, 2, "clr-expandable-animation", 7)(2, ClrDatagridRow_div_0_2_Template, 1, 1, null, 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.expand.expandable);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.expand.expandable);
  }
}
function ClrDatagridRow_clr_expandable_animation_1_ng_template_1_Template(rf, ctx) {
}
function ClrDatagridRow_clr_expandable_animation_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "clr-expandable-animation", 10);
    ɵɵtemplate(1, ClrDatagridRow_clr_expandable_animation_1_ng_template_1_Template, 0, 0, "ng-template", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const rowContent_r3 = ɵɵreference(6);
    ɵɵproperty("clrExpandTrigger", ctx_r1.expandAnimationTrigger);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", rowContent_r3);
  }
}
function ClrDatagridRow_2_ng_template_0_Template(rf, ctx) {
}
function ClrDatagridRow_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ClrDatagridRow_2_ng_template_0_Template, 0, 0, "ng-template", 11);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const rowContent_r3 = ɵɵreference(6);
    ɵɵproperty("ngTemplateOutlet", rowContent_r3);
  }
}
function ClrDatagridRow_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
function ClrDatagridRow_ng_template_5_div_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 20)(1, "div", 21)(2, "input", 22);
    ɵɵlistener("ngModelChange", function ClrDatagridRow_ng_template_5_div_4_Template_input_ngModelChange_2_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.toggle($event));
    });
    ɵɵelementEnd();
    ɵɵelementStart(3, "label", 23);
    ɵɵlistener("click", function ClrDatagridRow_ng_template_5_div_4_Template_label_click_3_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.clearRanges($event));
    });
    ɵɵelementStart(4, "span", 24);
    ɵɵtext(5);
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngClass", ɵɵpureFunction1(7, _c70, !ctx_r1.clrDgSelectable));
    ɵɵadvance(2);
    ɵɵproperty("ngModel", ctx_r1.selected)("id", ctx_r1.checkboxId)("disabled", ctx_r1.clrDgSelectable ? null : true);
    ɵɵattribute("aria-disabled", ctx_r1.clrDgSelectable ? null : true);
    ɵɵadvance();
    ɵɵproperty("for", ctx_r1.checkboxId);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.clrDgRowSelectionLabel || ctx_r1.commonStrings.keys.select);
  }
}
function ClrDatagridRow_ng_template_5_div_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 20)(1, "clr-radio-wrapper")(2, "input", 25);
    ɵɵtwoWayListener("ngModelChange", function ClrDatagridRow_ng_template_5_div_5_Template_input_ngModelChange_2_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r1.selection.currentSingle, $event) || (ctx_r1.selection.currentSingle = $event);
      return ɵɵresetView($event);
    });
    ɵɵelementEnd();
    ɵɵelementStart(3, "label", 26)(4, "span", 24);
    ɵɵtext(5);
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngClass", ɵɵpureFunction1(10, _c70, !ctx_r1.clrDgSelectable));
    ɵɵadvance(2);
    ɵɵproperty("id", ctx_r1.radioId)("name", ctx_r1.selection.id + "-radio")("value", ctx_r1.item);
    ɵɵtwoWayProperty("ngModel", ctx_r1.selection.currentSingle);
    ɵɵproperty("checked", ctx_r1.selection.currentSingle === ctx_r1.item)("disabled", ctx_r1.clrDgSelectable ? null : true);
    ɵɵattribute("aria-disabled", ctx_r1.clrDgSelectable ? null : true);
    ɵɵadvance();
    ɵɵproperty("for", ctx_r1.radioId);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.clrDgRowSelectionLabel || ctx_r1.commonStrings.keys.select);
  }
}
function ClrDatagridRow_ng_template_5_div_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 27);
    ɵɵprojection(1, 2);
    ɵɵelementEnd();
  }
}
function ClrDatagridRow_ng_template_5_div_7_ng_container_1_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 31);
    ɵɵlistener("click", function ClrDatagridRow_ng_template_5_div_7_ng_container_1_button_1_Template_button_click_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r1.toggleExpand());
    });
    ɵɵelement(1, "cds-icon", 32);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵattribute("aria-expanded", ctx_r1.expand.expanded)("aria-label", ctx_r1.expand.expanded ? ctx_r1.clrDgDetailCloseLabel : ctx_r1.clrDgDetailOpenLabel)("aria-controls", ctx_r1.expandableId);
    ɵɵadvance();
    ɵɵattribute("direction", ctx_r1.expand.expanded ? "down" : "right")("title", ctx_r1.expand.expanded ? ctx_r1.commonStrings.keys.collapse : ctx_r1.commonStrings.keys.expand);
  }
}
function ClrDatagridRow_ng_template_5_div_7_ng_container_1_clr_spinner_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "clr-spinner", 33);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.commonStrings.keys.loading);
  }
}
function ClrDatagridRow_ng_template_5_div_7_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, ClrDatagridRow_ng_template_5_div_7_ng_container_1_button_1_Template, 2, 5, "button", 29)(2, ClrDatagridRow_ng_template_5_div_7_ng_container_1_clr_spinner_2_Template, 2, 1, "clr-spinner", 30);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.expand.loading);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.expand.loading);
  }
}
function ClrDatagridRow_ng_template_5_div_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 28);
    ɵɵtemplate(1, ClrDatagridRow_ng_template_5_div_7_ng_container_1_Template, 3, 2, "ng-container", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.expand.expandable);
  }
}
function ClrDatagridRow_ng_template_5_div_8_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 36, 5);
    ɵɵlistener("click", function ClrDatagridRow_ng_template_5_div_8_button_1_Template_button_click_0_listener() {
      ɵɵrestoreView(_r7);
      const detailButton_r8 = ɵɵreference(1);
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.detailService.toggle(ctx_r1.item, detailButton_r8));
    });
    ɵɵelement(2, "cds-icon", 37);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵclassProp("is-open", ctx_r1.detailService.isRowOpen(ctx_r1.item));
    ɵɵproperty("disabled", ctx_r1.detailDisabled);
    ɵɵattribute("aria-label", ctx_r1.detailService.isRowOpen(ctx_r1.item) ? ctx_r1.clrDgDetailCloseLabel : ctx_r1.clrDgDetailOpenLabel)("aria-expanded", ctx_r1.detailService.isRowOpen(ctx_r1.item))("aria-controls", ctx_r1.detailService.id);
    ɵɵadvance(2);
    ɵɵattribute("direction", ctx_r1.detailService.isRowOpen(ctx_r1.item) ? "left" : "right")("title", ctx_r1.detailService.isRowOpen(ctx_r1.item) ? ctx_r1.commonStrings.keys.close : ctx_r1.commonStrings.keys.open);
  }
}
function ClrDatagridRow_ng_template_5_div_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 34);
    ɵɵtemplate(1, ClrDatagridRow_ng_template_5_div_8_button_1_Template, 3, 8, "button", 35);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.detailHidden);
  }
}
function ClrDatagridRow_ng_template_5_14_ng_template_0_Template(rf, ctx) {
}
function ClrDatagridRow_ng_template_5_14_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ClrDatagridRow_ng_template_5_14_ng_template_0_Template, 0, 0, "ng-template", 11);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const detail_r9 = ɵɵreference(4);
    ɵɵproperty("ngTemplateOutlet", detail_r9);
  }
}
function ClrDatagridRow_ng_template_5_15_ng_template_0_Template(rf, ctx) {
}
function ClrDatagridRow_ng_template_5_15_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ClrDatagridRow_ng_template_5_15_ng_template_0_Template, 0, 0, "ng-template", 11);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const detail_r9 = ɵɵreference(4);
    ɵɵproperty("ngTemplateOutlet", detail_r9);
  }
}
function ClrDatagridRow_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 12)(1, "div", 13);
    ɵɵelementContainerStart(2, null, 3);
    ɵɵtemplate(4, ClrDatagridRow_ng_template_5_div_4_Template, 6, 9, "div", 14)(5, ClrDatagridRow_ng_template_5_div_5_Template, 6, 12, "div", 14)(6, ClrDatagridRow_ng_template_5_div_6_Template, 2, 0, "div", 15)(7, ClrDatagridRow_ng_template_5_div_7_Template, 2, 1, "div", 16)(8, ClrDatagridRow_ng_template_5_div_8_Template, 2, 1, "div", 17);
    ɵɵelementContainerEnd();
    ɵɵelementEnd();
    ɵɵelementStart(9, "div", 18)(10, "div", 19);
    ɵɵprojection(11, 1);
    ɵɵelementContainer(12, null, 4);
    ɵɵelementEnd();
    ɵɵtemplate(14, ClrDatagridRow_ng_template_5_14_Template, 1, 1, null, 8)(15, ClrDatagridRow_ng_template_5_15_Template, 1, 1, null, 8);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("datagrid-row-detail-open", ctx_r1.detailService.isRowOpen(ctx_r1.item));
    ɵɵproperty("id", ctx_r1.id);
    ɵɵadvance(4);
    ɵɵproperty("ngIf", ctx_r1.selection.selectionType === ctx_r1.SELECTION_TYPE.Multi);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.selection.selectionType === ctx_r1.SELECTION_TYPE.Single);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.rowActionService.hasActionableRow);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.globalExpandable.hasExpandableRow);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.detailService.enabled);
    ɵɵadvance();
    ɵɵproperty("ngClass", ɵɵpureFunction1(11, _c69, ctx_r1.replaced && ctx_r1.expanded));
    ɵɵadvance(5);
    ɵɵproperty("ngIf", ctx_r1.replaced && !ctx_r1.expand.loading);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.replaced && !ctx_r1.expand.loading);
  }
}
var _c71 = ["datagrid"];
var _c72 = ["datagridTable"];
var _c73 = ["scrollableColumns"];
var _c74 = ["projectedDisplayColumns"];
var _c75 = ["projectedCalculationColumns"];
var _c76 = ["displayedRows"];
var _c77 = ["calculationRows"];
var _c78 = [[["clr-dg-action-bar"]], [["clr-dg-placeholder"]], [["clr-dg-footer"]], [["", "clrIfDetail", ""], ["clr-dg-detail"]]];
var _c79 = ["clr-dg-action-bar", "clr-dg-placeholder", "clr-dg-footer", "[clrIfDetail],clr-dg-detail"];
function ClrDatagrid_div_12_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 29)(1, "input", 30);
    ɵɵtwoWayListener("ngModelChange", function ClrDatagrid_div_12_div_1_Template_input_ngModelChange_1_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r1.allSelected, $event) || (ctx_r1.allSelected = $event);
      return ɵɵresetView($event);
    });
    ɵɵelementEnd();
    ɵɵelementStart(2, "label", 31)(3, "span", 32);
    ɵɵtext(4);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("id", ctx_r1.selectAllId);
    ɵɵtwoWayProperty("ngModel", ctx_r1.allSelected);
    ɵɵattribute("aria-label", ctx_r1.commonStrings.keys.selectAll);
    ɵɵadvance();
    ɵɵproperty("for", ctx_r1.selectAllId);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.commonStrings.keys.selectAll);
  }
}
function ClrDatagrid_div_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 26);
    ɵɵlistener("keydown.space", function ClrDatagrid_div_12_Template_div_keydown_space_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.toggleAllSelected($event));
    });
    ɵɵtemplate(1, ClrDatagrid_div_12_div_1_Template, 5, 5, "div", 27);
    ɵɵelement(2, "div", 28);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.hasVirtualScroller);
  }
}
function ClrDatagrid_div_13_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 33)(1, "div", 32);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelement(3, "div", 28);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.clrDgSingleSelectionAriaLabel);
  }
}
function ClrDatagrid_div_14_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 34)(1, "div", 32);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelement(3, "div", 28);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.clrDgSingleActionableAriaLabel);
  }
}
function ClrDatagrid_div_15_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 35)(1, "div", 32);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelement(3, "div", 28);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.clrDetailExpandableAriaLabel);
  }
}
function ClrDatagrid_clr_dg_row_20_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "clr-dg-row", 36)(1, "clr-dg-cell");
    ɵɵelement(2, "clr-spinner", 37);
    ɵɵelementStart(3, "span");
    ɵɵtext(4);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(4);
    ɵɵtextInterpolate(ctx_r1.commonStrings.keys.loading);
  }
}
function ClrDatagrid_clr_dg_row_23_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "clr-dg-row", 36)(1, "clr-dg-cell");
    ɵɵelement(2, "clr-spinner", 37);
    ɵɵelementStart(3, "span");
    ɵɵtext(4);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(4);
    ɵɵtextInterpolate(ctx_r1.commonStrings.keys.loading);
  }
}
function ClrDatagrid_clr_dg_placeholder_25_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "clr-dg-placeholder");
  }
}
function ClrDatagrid_div_27_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 38)(1, "clr-spinner", 37);
    ɵɵtext(2, "Loading");
    ɵɵelementEnd()();
  }
}
function ClrDatagridActionOverflow_div_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 4);
    ɵɵlistener("click", function ClrDatagridActionOverflow_div_3_Template_div_click_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.closeOverflowContent($event));
    });
    ɵɵprojection(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("id", ctx_r1.popoverId);
    ɵɵattribute("aria-hidden", !ctx_r1.open)("id", ctx_r1.popoverId);
  }
}
var _c80 = ["allSelected"];
function ClrDatagridColumnToggle_div_2_li_12_ng_template_4_Template(rf, ctx) {
}
function ClrDatagridColumnToggle_div_2_li_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li")(1, "clr-checkbox-wrapper")(2, "input", 13);
    ɵɵlistener("ngModelChange", function ClrDatagridColumnToggle_div_2_li_12_Template_input_ngModelChange_2_listener($event) {
      const columnState_r3 = ɵɵrestoreView(_r2).$implicit;
      const ctx_r3 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r3.toggleColumnState(columnState_r3, !$event));
    });
    ɵɵelementEnd();
    ɵɵelementStart(3, "label");
    ɵɵtemplate(4, ClrDatagridColumnToggle_div_2_li_12_ng_template_4_Template, 0, 0, "ng-template", 14);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const columnState_r3 = ctx.$implicit;
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵproperty("disabled", ctx_r3.hasOnlyOneVisibleColumn && !columnState_r3.hidden)("ngModel", !columnState_r3.hidden);
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", columnState_r3.titleTemplateRef);
  }
}
function ClrDatagridColumnToggle_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 3)(1, "div", 4)(2, "div", 5, 0);
    ɵɵtext(4);
    ɵɵelementEnd();
    ɵɵelementStart(5, "h2");
    ɵɵtext(6);
    ɵɵelementEnd();
    ɵɵelementStart(7, "button", 6);
    ɵɵelement(8, "cds-icon", 7);
    ɵɵelementStart(9, "span", 8);
    ɵɵtext(10);
    ɵɵelementEnd()()();
    ɵɵelementStart(11, "ul", 9);
    ɵɵtemplate(12, ClrDatagridColumnToggle_div_2_li_12_Template, 5, 3, "li", 10);
    ɵɵelementEnd();
    ɵɵelementStart(13, "div", 11)(14, "clr-dg-column-toggle-button", 12);
    ɵɵlistener("clrAllSelected", function ClrDatagridColumnToggle_div_2_Template_clr_dg_column_toggle_button_clrAllSelected_14_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.allColumnsSelected());
    });
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("id", ctx_r3.popoverId);
    ɵɵattribute("aria-label", ctx_r3.commonStrings.keys.showColumnsMenuDescription);
    ɵɵadvance(4);
    ɵɵtextInterpolate(ctx_r3.commonStrings.keys.allColumnsSelected);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r3.commonStrings.keys.showColumns);
    ɵɵadvance();
    ɵɵattribute("aria-label", ctx_r3.commonStrings.keys.close);
    ɵɵadvance();
    ɵɵattribute("title", ctx_r3.commonStrings.keys.close);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r3.commonStrings.keys.close);
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r3.hideableColumnStates)("ngForTrackBy", ctx_r3.trackByFn);
  }
}
var _c81 = ["title"];
function ClrDatagridDetail_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 1)(1, "div", 2);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵprojection(3);
    ɵɵelementStart(4, "div", 2);
    ɵɵtext(5);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("cdkTrapFocusAutoCapture", !ctx_r0.header)("id", ctx_r0.detailService.id);
    ɵɵattribute("aria-labelledby", ctx_r0.labelledBy)("aria-label", ctx_r0.label);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.commonStrings.keys.detailPaneStart);
    ɵɵadvance(3);
    ɵɵtextInterpolate(ctx_r0.commonStrings.keys.detailPaneEnd);
  }
}
var _c82 = [[["clr-dg-pagination"]], "*"];
var _c83 = ["clr-dg-pagination", "*"];
function ClrDatagridFooter_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 1)(2, "clr-checkbox-wrapper", 2);
    ɵɵelement(3, "input", 3);
    ɵɵelementStart(4, "label");
    ɵɵtext(5);
    ɵɵelementEnd();
    ɵɵelementStart(6, "span", 4);
    ɵɵtext(7);
    ɵɵelementEnd()()();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(5);
    ɵɵtextInterpolate(ctx_r0.selection.current.length);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.commonStrings.keys.selectedRows);
  }
}
function ClrDatagridFooter_ng_container_1_clr_dg_column_toggle_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "clr-dg-column-toggle");
  }
}
function ClrDatagridFooter_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, ClrDatagridFooter_ng_container_1_clr_dg_column_toggle_1_Template, 1, 0, "clr-dg-column-toggle", 0);
    ɵɵelementStart(2, "div", 5);
    ɵɵprojection(3, 1);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.hasHideableColumns);
  }
}
function ClrDatagridPageSize_option_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "option", 4);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const option_r1 = ctx.$implicit;
    ɵɵproperty("ngValue", option_r1);
    ɵɵadvance();
    ɵɵtextInterpolate(option_r1);
  }
}
var _c84 = ["currentPageInput"];
var _c85 = ["*", [["clr-dg-page-size"]]];
var _c86 = ["*", "clr-dg-page-size"];
function ClrDatagridPagination_ng_container_0_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6);
    ɵɵprojection(1, 1);
    ɵɵelementEnd();
  }
}
function ClrDatagridPagination_ng_container_0_div_4_input_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "input", 18, 1);
    ɵɵlistener("keydown.enter", function ClrDatagridPagination_ng_container_0_div_4_input_9_Template_input_keydown_enter_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.updateCurrentPage($event));
    })("blur", function ClrDatagridPagination_ng_container_0_div_4_input_9_Template_input_blur_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.verifyCurrentPage($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("size", ctx_r1.page.last.toString().length)("value", ctx_r1.page.current);
    ɵɵattribute("aria-label", ctx_r1.commonStrings.keys.currentPage);
  }
}
function ClrDatagridPagination_ng_container_0_div_4_ng_template_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.page.current);
  }
}
function ClrDatagridPagination_ng_container_0_div_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 7)(1, "button", 8);
    ɵɵlistener("click", function ClrDatagridPagination_ng_container_0_div_4_Template_button_click_1_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.page.current = 1);
    });
    ɵɵelementStart(2, "span", 9);
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵelement(4, "cds-icon", 10);
    ɵɵelementEnd();
    ɵɵelementStart(5, "button", 11);
    ɵɵlistener("click", function ClrDatagridPagination_ng_container_0_div_4_Template_button_click_5_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.page.current = ctx_r1.page.current - 1);
    });
    ɵɵelementStart(6, "span", 9);
    ɵɵtext(7);
    ɵɵelementEnd();
    ɵɵelement(8, "cds-icon", 12);
    ɵɵelementEnd();
    ɵɵtemplate(9, ClrDatagridPagination_ng_container_0_div_4_input_9_Template, 2, 3, "input", 13)(10, ClrDatagridPagination_ng_container_0_div_4_ng_template_10_Template, 2, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    ɵɵtext(12, "  / ");
    ɵɵelementStart(13, "span");
    ɵɵtext(14);
    ɵɵelementEnd();
    ɵɵelementStart(15, "button", 14);
    ɵɵlistener("click", function ClrDatagridPagination_ng_container_0_div_4_Template_button_click_15_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.page.current = ctx_r1.page.current + 1);
    });
    ɵɵelementStart(16, "span", 9);
    ɵɵtext(17);
    ɵɵelementEnd();
    ɵɵelement(18, "cds-icon", 15);
    ɵɵelementEnd();
    ɵɵelementStart(19, "button", 16);
    ɵɵlistener("click", function ClrDatagridPagination_ng_container_0_div_4_Template_button_click_19_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.page.current = ctx_r1.page.last);
    });
    ɵɵelementStart(20, "span", 9);
    ɵɵtext(21);
    ɵɵelementEnd();
    ɵɵelement(22, "cds-icon", 17);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const readOnly_r4 = ɵɵreference(11);
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("disabled", ctx_r1.page.current <= 1);
    ɵɵattribute("aria-label", ctx_r1.commonStrings.keys.firstPage);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.commonStrings.keys.firstPage);
    ɵɵadvance(2);
    ɵɵproperty("disabled", ctx_r1.page.current <= 1);
    ɵɵattribute("aria-label", ctx_r1.commonStrings.keys.previousPage);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.commonStrings.keys.previousPage);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", !ctx_r1.disableCurrentPageInput)("ngIfElse", readOnly_r4);
    ɵɵadvance(4);
    ɵɵattribute("aria-label", ctx_r1.commonStrings.keys.totalPages);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.page.last);
    ɵɵadvance();
    ɵɵproperty("disabled", ctx_r1.page.current >= ctx_r1.page.last);
    ɵɵattribute("aria-label", ctx_r1.commonStrings.keys.nextPage);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.commonStrings.keys.nextPage);
    ɵɵadvance(2);
    ɵɵproperty("disabled", ctx_r1.page.current >= ctx_r1.page.last);
    ɵɵattribute("aria-label", ctx_r1.commonStrings.keys.lastPage);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.commonStrings.keys.lastPage);
  }
}
function ClrDatagridPagination_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, ClrDatagridPagination_ng_container_0_div_1_Template, 2, 0, "div", 3);
    ɵɵelementStart(2, "div", 4);
    ɵɵprojection(3);
    ɵɵelementEnd();
    ɵɵtemplate(4, ClrDatagridPagination_ng_container_0_div_4_Template, 23, 16, "div", 5);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1._pageSizeComponent);
    ɵɵadvance(3);
    ɵɵproperty("ngIf", ctx_r1.page.last > 1);
  }
}
function ClrDatagridPagination_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 19);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementStart(3, "div", 7)(4, "button", 11);
    ɵɵlistener("click", function ClrDatagridPagination_ng_container_1_Template_button_click_4_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.page.current = ctx_r1.page.current - 1);
    });
    ɵɵelementStart(5, "span", 9);
    ɵɵtext(6);
    ɵɵelementEnd();
    ɵɵelement(7, "cds-icon", 12);
    ɵɵelementEnd();
    ɵɵelementStart(8, "span");
    ɵɵtext(9);
    ɵɵelementEnd();
    ɵɵelementStart(10, "button", 14);
    ɵɵlistener("click", function ClrDatagridPagination_ng_container_1_Template_button_click_10_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.page.current = ctx_r1.page.current + 1);
    });
    ɵɵelementStart(11, "span", 9);
    ɵɵtext(12);
    ɵɵelementEnd();
    ɵɵelement(13, "cds-icon", 15);
    ɵɵelementEnd()();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate3(" ", ctx_r1.page.firstItem + 1, "-", ctx_r1.page.lastItem + 1, " / ", ctx_r1.page.totalItems, " ");
    ɵɵadvance(2);
    ɵɵproperty("disabled", ctx_r1.page.current <= 1);
    ɵɵattribute("aria-label", ctx_r1.commonStrings.keys.previousPage);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.commonStrings.keys.previousPage);
    ɵɵadvance(3);
    ɵɵtextInterpolate(ctx_r1.page.current);
    ɵɵadvance();
    ɵɵproperty("disabled", ctx_r1.page.current >= ctx_r1.page.last);
    ɵɵattribute("aria-label", ctx_r1.commonStrings.keys.nextPage);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.commonStrings.keys.nextPage);
  }
}
var _c87 = [[["clr-stack-label"]], "*", [["clr-stack-block"]]];
var _c88 = ["clr-stack-label", "*", "clr-stack-block"];
function ClrStackBlock_cds_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵattribute("direction", ctx_r0.caretDirection);
  }
}
function ClrStackBlock_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 8);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.commonStrings.keys.stackViewChanged);
  }
}
function ClrStackBlock_div_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 9);
    ɵɵprojection(1, 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("height", ctx_r0.expanded ? "auto" : 0);
    ɵɵattribute("id", ctx_r0.getStackChildrenId())("aria-labelledby", ctx_r0.labelledById);
  }
}
var _c89 = [[["clr-stack-header"]], "*"];
var _c90 = ["clr-stack-header", "*"];
var _c91 = ["*", [["", 8, "stack-action"]]];
var _c92 = ["*", ".stack-action"];
function RecursiveChildren_ng_container_0_ng_container_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function RecursiveChildren_ng_container_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, RecursiveChildren_ng_container_0_ng_container_1_ng_container_1_Template, 1, 0, "ng-container", 2);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const child_r1 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.featuresService.recursion.template)("ngTemplateOutletContext", ctx_r1.getContext(child_r1));
  }
}
function RecursiveChildren_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, RecursiveChildren_ng_container_0_ng_container_1_Template, 2, 2, "ng-container", 1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", (ctx_r1.parent == null ? null : ctx_r1.parent.children) || ctx_r1.children);
  }
}
var _c93 = ["contentContainer"];
var _c94 = [[["clr-tree-node"]], [["", "clrIfExpanded", ""]], "*"];
var _c95 = ["clr-tree-node", "[clrIfExpanded]", "*"];
function ClrTreeNode_button_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 9);
    ɵɵlistener("click", function ClrTreeNode_button_2_Template_button_click_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.expandService.toggle());
    })("focus", function ClrTreeNode_button_2_Template_button_focus_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.focusTreeNode());
    });
    ɵɵelement(1, "cds-icon", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("disabled", ctx_r2.disabled);
    ɵɵadvance();
    ɵɵattribute("direction", ctx_r2.expandService.expanded ? "down" : "right");
  }
}
function ClrTreeNode_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 11);
    ɵɵelement(1, "span", 12);
    ɵɵelementEnd();
  }
}
function ClrTreeNode_div_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 13)(1, "input", 14);
    ɵɵlistener("change", function ClrTreeNode_div_4_Template_input_change_1_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2._model.toggleSelection(ctx_r2.featuresService.eager));
    })("focus", function ClrTreeNode_div_4_Template_input_focus_1_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.focusTreeNode());
    });
    ɵɵelementEnd();
    ɵɵelementStart(2, "label", 15);
    ɵɵelementContainer(3, 16);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    const treenodeContent_r5 = ɵɵreference(7);
    ɵɵadvance();
    ɵɵpropertyInterpolate1("id", "", ctx_r2.nodeId, "-check");
    ɵɵproperty("disabled", ctx_r2.disabled)("checked", ctx_r2._model.selected.value === ctx_r2.STATES.SELECTED)("indeterminate", ctx_r2._model.selected.value === ctx_r2.STATES.INDETERMINATE);
    ɵɵadvance();
    ɵɵpropertyInterpolate1("for", "", ctx_r2.nodeId, "-check");
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", treenodeContent_r5);
  }
}
function ClrTreeNode_div_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 17);
    ɵɵlistener("mouseup", function ClrTreeNode_div_5_Template_div_mouseup_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.focusTreeNode());
    });
    ɵɵelementContainer(1, 16);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    const treenodeContent_r5 = ɵɵreference(7);
    ɵɵclassProp("clr-treenode-text-only", ctx_r2.treeNodeContentTextOnly);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", treenodeContent_r5);
  }
}
function ClrTreeNode_ng_template_6_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 19)(1, "span");
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r2.ariaSelected ? ctx_r2.commonStrings.keys.selectedTreeNode : ctx_r2.commonStrings.keys.unselectedTreeNode, "");
  }
}
function ClrTreeNode_ng_template_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 2);
    ɵɵtemplate(1, ClrTreeNode_ng_template_6_div_1_Template, 3, 1, "div", 18);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.featuresService.selectable || ctx_r2.ariaSelected);
  }
}
function ClrTree_clr_recursive_children_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "clr-recursive-children", 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("children", ctx_r0.featuresService.recursion.root);
  }
}
function ClrAlert_div_0_button_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 4);
    ɵɵlistener("click", function ClrAlert_div_0_button_3_Template_button_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.close());
    });
    ɵɵelement(1, "cds-icon", 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵattribute("aria-label", ctx_r1.clrCloseButtonAriaLabel);
  }
}
function ClrAlert_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 1)(1, "div", 2);
    ɵɵprojection(2);
    ɵɵelementEnd();
    ɵɵtemplate(3, ClrAlert_div_0_button_3_Template, 2, 1, "button", 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("alert-sm", ctx_r1.isSmall)("alert-lightweight", ctx_r1.isLightweight)("alert-app-level", ctx_r1.isAppLevel);
    ɵɵproperty("ngClass", ctx_r1.alertClass);
    ɵɵadvance(3);
    ɵɵproperty("ngIf", ctx_r1.closable);
  }
}
function ClrAlertItem_clr_spinner_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "clr-spinner", 3);
  }
}
function ClrAlertItem_cds_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵattribute("shape", ctx_r0.iconService.alertIconShape)("aria-label", ctx_r0.iconService.alertIconTitle);
  }
}
var _c96 = [[["clr-alert"]]];
var _c97 = ["clr-alert"];
function ClrAlerts_clr_alerts_pager_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "clr-alerts-pager", 2);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("clrCurrentAlertIndex", ctx_r0.currentAlertIndex);
  }
}
function ClrBreadcrumbs_div_0_clr_breadcrumb_item_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "clr-breadcrumb-item")(1, "button", 5);
    ɵɵlistener("click", function ClrBreadcrumbs_div_0_clr_breadcrumb_item_1_Template_button_click_1_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.expand());
    })("keydown", function ClrBreadcrumbs_div_0_clr_breadcrumb_item_1_Template_button_keydown_1_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.expand());
    });
    ɵɵelement(2, "cds-icon", 6);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵattribute("aria-label", ctx_r1.commonStrings.keys.expandBreadcrumbsLabel);
  }
}
function ClrBreadcrumbs_div_0_clr_breadcrumb_item_2_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 8);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const breadcrumb_r3 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(breadcrumb_r3.label);
  }
}
function ClrBreadcrumbs_div_0_clr_breadcrumb_item_2_ng_template_2_a_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 11);
    ɵɵlistener("click", function ClrBreadcrumbs_div_0_clr_breadcrumb_item_2_ng_template_2_a_0_Template_a_click_0_listener() {
      ɵɵrestoreView(_r4);
      const breadcrumb_r3 = ɵɵnextContext(2).$implicit;
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.handleItemClick(breadcrumb_r3));
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const breadcrumb_r3 = ɵɵnextContext(2).$implicit;
    ɵɵproperty("routerLink", breadcrumb_r3.routerLink)("queryParams", breadcrumb_r3.queryParams)("target", breadcrumb_r3.target);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", breadcrumb_r3.label, " ");
  }
}
function ClrBreadcrumbs_div_0_clr_breadcrumb_item_2_ng_template_2_a_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 12);
    ɵɵlistener("click", function ClrBreadcrumbs_div_0_clr_breadcrumb_item_2_ng_template_2_a_1_Template_a_click_0_listener() {
      ɵɵrestoreView(_r5);
      const breadcrumb_r3 = ɵɵnextContext(2).$implicit;
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.handleItemClick(breadcrumb_r3));
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const breadcrumb_r3 = ɵɵnextContext(2).$implicit;
    ɵɵproperty("href", breadcrumb_r3.href, ɵɵsanitizeUrl)("target", breadcrumb_r3.target);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", breadcrumb_r3.label, " ");
  }
}
function ClrBreadcrumbs_div_0_clr_breadcrumb_item_2_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ClrBreadcrumbs_div_0_clr_breadcrumb_item_2_ng_template_2_a_0_Template, 2, 4, "a", 9)(1, ClrBreadcrumbs_div_0_clr_breadcrumb_item_2_ng_template_2_a_1_Template, 2, 3, "a", 10);
  }
  if (rf & 2) {
    const breadcrumb_r3 = ɵɵnextContext().$implicit;
    ɵɵproperty("ngIf", breadcrumb_r3.routerLink);
    ɵɵadvance();
    ɵɵproperty("ngIf", breadcrumb_r3.href);
  }
}
function ClrBreadcrumbs_div_0_clr_breadcrumb_item_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "clr-breadcrumb-item");
    ɵɵtemplate(1, ClrBreadcrumbs_div_0_clr_breadcrumb_item_2_span_1_Template, 2, 1, "span", 7)(2, ClrBreadcrumbs_div_0_clr_breadcrumb_item_2_ng_template_2_Template, 2, 2, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const isLastItem_r6 = ctx.last;
    const breadcrumbLinks_r7 = ɵɵreference(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", isLastItem_r6)("ngIfElse", breadcrumbLinks_r7);
  }
}
function ClrBreadcrumbs_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2);
    ɵɵtemplate(1, ClrBreadcrumbs_div_0_clr_breadcrumb_item_1_Template, 3, 1, "clr-breadcrumb-item", 3)(2, ClrBreadcrumbs_div_0_clr_breadcrumb_item_2_Template, 4, 2, "clr-breadcrumb-item", 4);
    ɵɵpipe(3, "slice");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.items.length > ctx_r1.max && !ctx_r1.isExpanded);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ɵɵpipeBind3(3, 2, ctx_r1.items, -ctx_r1.limit, ctx_r1.items.length));
  }
}
function ClrHeader_button_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 3);
    ɵɵlistener("click", function ClrHeader_button_0_Template_button_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.openNav(ctx_r1.responsiveNavCodes.NAV_LEVEL_1));
    });
    ɵɵelement(1, "span");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵattribute("aria-label", ctx_r1.responsiveNavCommonString);
  }
}
function ClrHeader_button_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 4);
    ɵɵlistener("click", function ClrHeader_button_2_Template_button_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.openNav(ctx_r1.responsiveNavCodes.NAV_LEVEL_2));
    });
    ɵɵelement(1, "span");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵattribute("aria-label", ctx_r1.responsiveOverflowCommonString);
  }
}
function TemplateRefContainer_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
var _c98 = ["tabContentProjectedRef"];
function ClrTabContent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "section", 1);
    ɵɵprojection(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("active", ctx_r0.active);
    ɵɵproperty("id", ctx_r0.tabContentId)("hidden", !ctx_r0.active);
    ɵɵattribute("aria-labelledby", ctx_r0.ariaLabelledBy)("aria-hidden", !ctx_r0.active);
  }
}
var _c99 = ["tabContentViewContainer"];
var _c100 = [[["clr-tabs-actions"]]];
var _c101 = ["clr-tabs-actions"];
function ClrTabs_ng_container_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "li", 5);
    ɵɵelementContainer(2, 6);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const link_r2 = ɵɵnextContext().$implicit;
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", link_r2.templateRefContainer.template);
  }
}
function ClrTabs_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, ClrTabs_ng_container_1_ng_container_1_Template, 3, 1, "ng-container", 4);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const link_r2 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", link_r2.tabsId === ctx_r2.tabsId && !link_r2.inOverflow);
  }
}
function ClrTabs_ng_container_2_clr_tab_overflow_content_6_ng_container_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 6);
  }
  if (rf & 2) {
    const link_r7 = ɵɵnextContext().$implicit;
    ɵɵproperty("ngTemplateOutlet", link_r7.templateRefContainer.template);
  }
}
function ClrTabs_ng_container_2_clr_tab_overflow_content_6_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, ClrTabs_ng_container_2_clr_tab_overflow_content_6_ng_container_1_ng_container_1_Template, 1, 1, "ng-container", 13);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const link_r7 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", link_r7.tabsId === ctx_r2.tabsId && link_r7.inOverflow);
  }
}
function ClrTabs_ng_container_2_clr_tab_overflow_content_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "clr-tab-overflow-content", 12);
    ɵɵlistener("keydown.escape", function ClrTabs_ng_container_2_clr_tab_overflow_content_6_Template_clr_tab_overflow_content_keydown_escape_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.closeOnEscapeKey());
    }, false, ɵɵresolveDocument)("click", function ClrTabs_ng_container_2_clr_tab_overflow_content_6_Template_clr_tab_overflow_content_click_0_listener($event) {
      ɵɵrestoreView(_r5);
      ɵɵnextContext();
      const tabOverflowTrigger_r6 = ɵɵreference(4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.closeOnOutsideClick($event, tabOverflowTrigger_r6));
    }, false, ɵɵresolveDocument)("focusout", function ClrTabs_ng_container_2_clr_tab_overflow_content_6_Template_clr_tab_overflow_content_focusout_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.closeOnFocusOut($event));
    });
    ɵɵtemplate(1, ClrTabs_ng_container_2_clr_tab_overflow_content_6_ng_container_1_Template, 2, 1, "ng-container", 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2.tabLinkDirectives);
  }
}
function ClrTabs_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 7)(2, "li", 8)(3, "button", 9, 1);
    ɵɵlistener("mousedown", function ClrTabs_ng_container_2_Template_button_mousedown_3_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2._mousedown = true);
    })("focus", function ClrTabs_ng_container_2_Template_button_focus_3_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.openOverflowOnFocus());
    })("click", function ClrTabs_ng_container_2_Template_button_click_3_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.toggleOverflowOnClick());
    });
    ɵɵelement(5, "cds-icon", 10);
    ɵɵelementEnd()();
    ɵɵtemplate(6, ClrTabs_ng_container_2_clr_tab_overflow_content_6_Template, 2, 1, "clr-tab-overflow-content", 11);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵclassProp("open", ctx_r2.toggleService.open);
    ɵɵadvance(2);
    ɵɵclassProp("active", ctx_r2.activeTabInOverflow)("open", ctx_r2.toggleService.open);
    ɵɵattribute("tabindex", ctx_r2.activeTabInOverflow && !ctx_r2.toggleService.open ? 0 : -1)("title", ctx_r2.commonStrings.keys.more);
    ɵɵadvance(2);
    ɵɵattribute("status", ctx_r2.toggleService.open ? "info" : null)("title", ctx_r2.commonStrings.keys.more);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.toggleService.open);
  }
}
function ClrVerticalNav_button_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 3);
    ɵɵlistener("click", function ClrVerticalNav_button_0_Template_button_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.toggleByButton());
    });
    ɵɵelement(1, "cds-icon", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("on-collapse", ctx_r1.collapsed);
    ɵɵattribute("aria-expanded", ctx_r1.ariaExpanded)("aria-label", ctx_r1.commonStrings.keys.verticalNavToggle);
    ɵɵadvance();
    ɵɵattribute("direction", ctx_r1.collapsed ? "right" : "left");
  }
}
function ClrVerticalNav_button_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 5);
    ɵɵlistener("click", function ClrVerticalNav_button_3_Template_button_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.collapsed = false);
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵattribute("aria-label", ctx_r1.commonStrings.keys.verticalNavToggle);
  }
}
var _c102 = [[["", "clrVerticalNavLink", ""]], [["", "clrVerticalNavIcon", ""]], "*", [["", "clrIfExpanded", ""], ["clr-vertical-nav-group-children"]]];
var _c103 = ["[clrVerticalNavLink]", "[clrVerticalNavIcon]", "*", "[clrIfExpanded], clr-vertical-nav-group-children"];
var _c104 = ["clrVerticalNavLink", ""];
var _c105 = [[["", "clrVerticalNavIcon", ""]], "*"];
var _c106 = ["[clrVerticalNavIcon]", "*"];
var _c107 = [[["", 8, "modal-nav"]], [["", 8, "modal-title"]], [["", 8, "modal-body"]], [["", 8, "modal-footer"]]];
var _c108 = [".modal-nav", ".modal-title", ".modal-body", ".modal-footer"];
function ClrModal_div_0_button_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 12);
    ɵɵlistener("click", function ClrModal_div_0_button_11_Template_button_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.close());
    });
    ɵɵelement(1, "cds-icon", 13);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵattribute("aria-label", ctx_r1.closeButtonAriaLabel || ctx_r1.commonStrings.keys.close);
  }
}
function ClrModal_div_0_div_17_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 14);
    ɵɵlistener("click", function ClrModal_div_0_div_17_Template_div_click_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.backdropClick());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵproperty("@fade", void 0);
  }
}
function ClrModal_div_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 2)(1, "div", 3);
    ɵɵlistener("@fadeMove.done", function ClrModal_div_0_Template_div_animation_fadeMove_done_1_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.fadeDone($event));
    });
    ɵɵelementStart(2, "div", 4);
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵelementStart(4, "div", 5);
    ɵɵprojection(5);
    ɵɵelementStart(6, "div", 6)(7, "div", 7)(8, "div", 8, 0);
    ɵɵprojection(10, 1);
    ɵɵelementEnd();
    ɵɵtemplate(11, ClrModal_div_0_button_11_Template, 2, 1, "button", 9);
    ɵɵelementEnd();
    ɵɵelementStart(12, "div", 10);
    ɵɵprojection(13, 2);
    ɵɵelementEnd();
    ɵɵprojection(14, 3);
    ɵɵelementEnd()();
    ɵɵelementStart(15, "div", 4);
    ɵɵtext(16);
    ɵɵelementEnd()();
    ɵɵtemplate(17, ClrModal_div_0_div_17_Template, 1, 1, "div", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("modal-full-screen", ctx_r1.size == "full-screen");
    ɵɵadvance();
    ɵɵclassProp("modal-sm", ctx_r1.size == "sm")("modal-lg", ctx_r1.size == "lg")("modal-xl", ctx_r1.size == "xl");
    ɵɵproperty("cdkTrapFocusAutoCapture", true)("@fadeMove", ctx_r1.fadeMove);
    ɵɵattribute("aria-hidden", !ctx_r1._open)("aria-labelledby", ctx_r1.labelledBy || ctx_r1.modalId);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.commonStrings.keys.modalContentStart);
    ɵɵadvance(5);
    ɵɵpropertyInterpolate("id", ctx_r1.modalId);
    ɵɵadvance(3);
    ɵɵproperty("ngIf", ctx_r1.closable);
    ɵɵadvance(5);
    ɵɵtextInterpolate(ctx_r1.commonStrings.keys.modalContentEnd);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.backdrop);
  }
}
var _c109 = [[["", 8, "side-panel-title"]], [["", 8, "side-panel-body"]], [["", 8, "side-panel-footer"]]];
var _c110 = [".side-panel-title", ".side-panel-body", ".side-panel-footer"];
function ClrProgressBar_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.displayValue);
  }
}
var _c111 = [[["clr-timeline-step-header"]], [["clr-timeline-step-title"]], [["clr-timeline-step-description"]]];
var _c112 = ["clr-timeline-step-header", "clr-timeline-step-title", "clr-timeline-step-description"];
function ClrTimelineStep_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "cds-icon", 4);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵattribute("status", ctx_r0.iconStatus)("shape", ctx_r0.iconShape)("aria-label", ctx_r0.iconAriaLabel);
  }
}
function ClrTimelineStep_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "clr-spinner", 5);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵattribute("aria-label", ctx_r0.iconAriaLabel);
  }
}
var _c113 = ["clr-wizard-stepnav-item", ""];
function ClrWizardStepnavItem_cds_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 8);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵattribute("aria-label", ctx_r0.commonStrings.keys.wizardStepError);
  }
}
function ClrWizardStepnavItem_cds_icon_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 9);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵattribute("aria-label", ctx_r0.commonStrings.keys.wizardStepSuccess);
  }
}
function ClrWizardStepnavItem_ng_template_9_Template(rf, ctx) {
}
function ClrWizardStepnav_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const page_r1 = ctx.$implicit;
    const i_r2 = ctx.index;
    ɵɵproperty("page", page_r1);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", i_r2 + 1, " ");
  }
}
var _c114 = ["pageTitle"];
var _c115 = [[["clr-wizard-title"]], "*", [["clr-wizard-header-action"]], [["clr-wizard-button"]]];
var _c116 = ["clr-wizard-title", "*", "clr-wizard-header-action", "clr-wizard-button"];
function ClrWizard_ng_template_8_Template(rf, ctx) {
}
function ClrWizard_div_9_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵprojection(1, 2);
    ɵɵelementEnd();
  }
}
function ClrWizard_div_9_div_2_ng_template_1_Template(rf, ctx) {
}
function ClrWizard_div_9_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, ClrWizard_div_9_div_2_ng_template_1_Template, 0, 0, "ng-template", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.navService.currentPage.headerActions);
  }
}
function ClrWizard_div_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 13);
    ɵɵtemplate(1, ClrWizard_div_9_div_1_Template, 2, 0, "div", 14)(2, ClrWizard_div_9_div_2_Template, 2, 1, "div", 14);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.headerActionService.showWizardHeaderActions);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.headerActionService.currentPageHasHeaderActions);
  }
}
function ClrWizard_div_15_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 15);
    ɵɵprojection(1, 3);
    ɵɵelementEnd();
  }
}
function ClrWizard_div_16_ng_template_1_Template(rf, ctx) {
}
function ClrWizard_div_16_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 15);
    ɵɵtemplate(1, ClrWizard_div_16_ng_template_1_Template, 0, 0, "ng-template", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.navService.currentPage.buttons);
  }
}
var ClrIconCustomTag = class {
};
ClrIconCustomTag.ɵfac = function ClrIconCustomTag_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrIconCustomTag)();
};
ClrIconCustomTag.ɵdir = ɵɵdefineDirective({
  type: ClrIconCustomTag,
  selectors: [["clr-icon"]],
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrIconCustomTag, [{
    type: Directive,
    args: [{
      selector: "clr-icon"
    }]
  }], null, null);
})();
var CdsIconCustomTag = class {
};
CdsIconCustomTag.ɵfac = function CdsIconCustomTag_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || CdsIconCustomTag)();
};
CdsIconCustomTag.ɵdir = ɵɵdefineDirective({
  type: CdsIconCustomTag,
  selectors: [["cds-icon"]],
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdsIconCustomTag, [{
    type: Directive,
    args: [{
      selector: "cds-icon"
    }]
  }], null, null);
})();
var CLR_ICON_DIRECTIVES = [ClrIconCustomTag, CdsIconCustomTag];
var ClrIconModule = class {
};
ClrIconModule.ɵfac = function ClrIconModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrIconModule)();
};
ClrIconModule.ɵmod = ɵɵdefineNgModule({
  type: ClrIconModule,
  declarations: [ClrIconCustomTag, CdsIconCustomTag],
  imports: [CommonModule],
  exports: [ClrIconCustomTag, CdsIconCustomTag]
});
ClrIconModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrIconModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [CLR_ICON_DIRECTIVES],
      exports: [CLR_ICON_DIRECTIVES]
    }]
  }], null, null);
})();
var LoadingListener = class {
};
var ClrLoadingState;
(function(ClrLoadingState2) {
  ClrLoadingState2[ClrLoadingState2["DEFAULT"] = 0] = "DEFAULT";
  ClrLoadingState2[ClrLoadingState2["LOADING"] = 1] = "LOADING";
  ClrLoadingState2[ClrLoadingState2["SUCCESS"] = 2] = "SUCCESS";
  ClrLoadingState2[ClrLoadingState2["ERROR"] = 3] = "ERROR";
})(ClrLoadingState || (ClrLoadingState = {}));
var ClrLoading = class {
  // We find the first parent that handles something loading
  constructor(listener) {
    this.listener = listener;
    this._loadingState = ClrLoadingState.DEFAULT;
  }
  get loadingState() {
    return this._loadingState;
  }
  set loadingState(value) {
    if (value === true) {
      value = ClrLoadingState.LOADING;
    } else if (!value) {
      value = ClrLoadingState.DEFAULT;
    }
    if (value === this._loadingState) {
      return;
    }
    this._loadingState = value;
    if (this.listener) {
      this.listener.loadingStateChange(value);
    }
  }
  ngOnDestroy() {
    this.loadingState = ClrLoadingState.DEFAULT;
  }
};
ClrLoading.ɵfac = function ClrLoading_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrLoading)(ɵɵdirectiveInject(LoadingListener, 8));
};
ClrLoading.ɵdir = ɵɵdefineDirective({
  type: ClrLoading,
  selectors: [["", "clrLoading", ""]],
  inputs: {
    loadingState: [0, "clrLoading", "loadingState"]
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrLoading, [{
    type: Directive,
    args: [{
      selector: "[clrLoading]"
    }]
  }], function() {
    return [{
      type: LoadingListener,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    loadingState: [{
      type: Input,
      args: ["clrLoading"]
    }]
  });
})();
var IfExpandService = class {
  constructor() {
    this.expandable = 0;
    this._loading = false;
    this._expanded = false;
    this._expandChange = new Subject();
  }
  get loading() {
    return this._loading;
  }
  set loading(value) {
    value = !!value;
    if (value !== this._loading) {
      this._loading = value;
    }
  }
  get expanded() {
    return this._expanded;
  }
  set expanded(value) {
    value = !!value;
    if (value !== this._expanded) {
      this._expanded = value;
      this._expandChange.next(value);
    }
  }
  get expandChange() {
    return this._expandChange.asObservable();
  }
  toggle() {
    this.expanded = !this._expanded;
  }
  loadingStateChange(state2) {
    switch (state2) {
      case ClrLoadingState.LOADING:
        this.loading = true;
        break;
      default:
        this.loading = false;
        break;
    }
  }
};
IfExpandService.ɵfac = function IfExpandService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || IfExpandService)();
};
IfExpandService.ɵprov = ɵɵdefineInjectable({
  token: IfExpandService,
  factory: IfExpandService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IfExpandService, [{
    type: Injectable
  }], null, null);
})();
var NB_INSTANCES = 0;
function uniqueIdFactory() {
  return "clr-id-" + NB_INSTANCES++;
}
var ClrAccordionDescription = class {
};
ClrAccordionDescription.ɵfac = function ClrAccordionDescription_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrAccordionDescription)();
};
ClrAccordionDescription.ɵcmp = ɵɵdefineComponent({
  type: ClrAccordionDescription,
  selectors: [["clr-accordion-description"], ["clr-step-description"]],
  hostVars: 2,
  hostBindings: function ClrAccordionDescription_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-accordion-description", true);
    }
  },
  standalone: false,
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrAccordionDescription_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrAccordionDescription, [{
    type: Component,
    args: [{
      selector: "clr-accordion-description, clr-step-description",
      template: `<ng-content></ng-content>`,
      host: {
        "[class.clr-accordion-description]": "true"
      },
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, null);
})();
var defaultAnimationTiming = "0.2s ease-in-out";
var panelAnimation = [trigger("skipInitialRender", [transition(":enter", [])]), trigger("toggle", [transition("void => *", [style({
  display: "block",
  height: 0
}), animate(defaultAnimationTiming, style({
  height: "*"
}))])])];
var stepAnimation = [trigger("skipInitialRender", [transition(":enter", [])]), trigger("toggle", [transition("void => *", [style({
  display: "block",
  height: 0
}), animate(defaultAnimationTiming, style({
  height: "*"
}))]), transition("* => void", [style({
  display: "block"
}), animate(defaultAnimationTiming, style({
  height: 0,
  display: "none"
}))])])];
var commonStringsDefault = {
  open: "Open",
  close: "Close",
  show: "Show",
  hide: "Hide",
  apply: "Apply",
  cancel: "Cancel",
  expand: "Expand",
  collapse: "Collapse",
  more: "More",
  select: "Select",
  selectAll: "Select All",
  previous: "Previous",
  next: "Next",
  current: "Jump to current",
  info: "Info",
  success: "Success",
  warning: "Warning",
  danger: "Error",
  neutral: "Neutral",
  unknown: "Unknown",
  rowActions: "Available actions",
  pickColumns: "Manage Columns",
  showColumns: "Show Columns",
  sortColumn: "Sort Column",
  firstPage: "First Page",
  lastPage: "Last Page",
  nextPage: "Next Page",
  previousPage: "Previous Page",
  currentPage: "Current Page",
  totalPages: "Total Pages",
  filterItems: "Filter items",
  minValue: "Min value",
  maxValue: "Max value",
  modalContentStart: "Beginning of Modal Content",
  modalContentEnd: "End of Modal Content",
  showColumnsMenuDescription: "Show or hide columns menu",
  allColumnsSelected: "All columns selected",
  signpostToggle: "Signpost Toggle",
  signpostClose: "Close",
  loading: "Loading",
  // Datagrid
  detailPaneStart: "Start of row details",
  detailPaneEnd: "End of row details",
  singleSelectionAriaLabel: "Single selection header",
  singleActionableAriaLabel: "Single actionable header",
  detailExpandableAriaLabel: "Toggle more row content",
  datagridFilterAriaLabel: "{COLUMN} filter",
  datagridFilterLabel: "{COLUMN} filter",
  datagridFilterDialogAriaLabel: "Filter dialog",
  columnSeparatorAriaLabel: "Column resize handle",
  columnSeparatorDescription: "Use left or right key to resize the column",
  fromLabel: "From",
  toLabel: "To",
  // Alert
  alertCloseButtonAriaLabel: "Close alert",
  alertNextAlertAriaLabel: "Next alert message, {CURRENT} of {COUNT}",
  alertPreviousAlertAriaLabel: "Previous alert message, {CURRENT} of {COUNT}",
  // Date Picker
  datepickerDialogLabel: "Choose date",
  datepickerToggleChooseDateLabel: "Choose date",
  datepickerToggleChangeDateLabel: "Change date, {SELECTED_DATE}",
  datepickerPreviousMonth: "Previous month",
  datepickerCurrentMonth: "Current month",
  datepickerNextMonth: "Next month",
  datepickerPreviousDecade: "Previous decade",
  datepickerNextDecade: "Next decade",
  datepickerCurrentDecade: "Current decade",
  datepickerSelectMonthText: "Select month, the current month is {CALENDAR_MONTH}",
  datepickerSelectYearText: "Select year, the current year is {CALENDAR_YEAR}",
  datepickerSelectedLabel: "{FULL_DATE} - Selected",
  // Stack View
  stackViewChanged: "Value changed.",
  // Responsive Nav
  responsiveNavToggleOpen: "Open navigation menu",
  responsiveNavToggleClose: "Close navigation menu",
  responsiveNavOverflowOpen: "Open navigation overflow menu",
  responsiveNavOverflowClose: "Close navigation overflow menu",
  //Vertical Nav
  verticalNavToggle: "Toggle vertical navigation",
  // Timeline steps
  timelineStepNotStarted: "Not started",
  timelineStepCurrent: "Current",
  timelineStepSuccess: "Completed",
  timelineStepError: "Error",
  timelineStepProcessing: "In progress",
  // Combobox
  comboboxDelete: "Delete selected option",
  comboboxSearching: 'Searching for matches for "{INPUT}"',
  comboboxSelection: "Selection",
  comboboxSelected: "Selected",
  comboboxNoResults: "No results",
  comboboxOpen: "Show options",
  // Datagrid expandable rows
  datagridExpandableBeginningOf: "Beginning of",
  datagridExpandableEndOf: "End of",
  datagridExpandableRowContent: "Expandable row content",
  datagridExpandableRowsHelperText: `Screen reader table commands may not work for viewing expanded content, please use your screen reader's browse mode to read the content exposed by this button`,
  // Wizard
  wizardStep: "Step",
  wizardStepSuccess: "Completed",
  wizardStepError: "Error",
  wizardStepnavAriaLabel: "Step navigation",
  /**
   * Password Input
   * Screen-reader text for the hide/show password field button
   */
  passwordHide: "Hide password for {LABEL}",
  passwordShow: "Show password for {LABEL}",
  /**
   * Datagrid footer; sr-only text after the number of selected rows.
   */
  selectedRows: "Selected rows",
  // Accordion/Stepper
  stepComplete: "Step {STEP} complete",
  stepError: "Error in step {STEP}",
  // File input
  browse: "Browse",
  fileCount: "{COUNT} files",
  clearFile: "Clear {FILE}",
  clearFiles: "Clear {COUNT} files",
  // Tree
  selectedTreeNode: "selected",
  unselectedTreeNode: "unselected",
  // Breadcrumbs
  breadcrumbsLabel: "breadcrumbs",
  expandBreadcrumbsLabel: "Expand breadcrumbs"
};
var ClrCommonStringsService = class {
  constructor() {
    this._strings = commonStringsDefault;
  }
  /**
   * Access to all of the keys as strings
   */
  get keys() {
    return this._strings;
  }
  /**
   * Allows you to pass in new overrides for localization
   */
  localize(overrides) {
    this._strings = __spreadValues(__spreadValues({}, this._strings), overrides);
  }
  /**
   * Parse a string with a set of tokens to replace
   */
  parse(source, tokens = {}) {
    const names = Object.keys(tokens);
    let output = source;
    if (names.length) {
      names.forEach((name) => {
        output = output.replace(`{${name}}`, tokens[name]);
      });
    }
    return output;
  }
};
ClrCommonStringsService.ɵfac = function ClrCommonStringsService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrCommonStringsService)();
};
ClrCommonStringsService.ɵprov = ɵɵdefineInjectable({
  token: ClrCommonStringsService,
  factory: ClrCommonStringsService.ɵfac,
  providedIn: "root"
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrCommonStringsService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var AccordionStatus;
(function(AccordionStatus2) {
  AccordionStatus2["Inactive"] = "inactive";
  AccordionStatus2["Error"] = "error";
  AccordionStatus2["Complete"] = "complete";
})(AccordionStatus || (AccordionStatus = {}));
var AccordionStrategy;
(function(AccordionStrategy2) {
  AccordionStrategy2["Default"] = "default";
  AccordionStrategy2["Multi"] = "multi";
})(AccordionStrategy || (AccordionStrategy = {}));
var accordionCount = 0;
var AccordionPanelModel = class {
  constructor(id, accordionId) {
    this.id = id;
    this.accordionId = accordionId;
    this.status = AccordionStatus.Inactive;
    this.index = null;
    this.disabled = false;
    this.open = false;
    this.templateId = `${this.id}-${this.accordionId}`;
  }
};
var AccordionModel = class {
  constructor() {
    this.strategy = AccordionStrategy.Default;
    this.accordionCount = accordionCount++;
    this._panels = {};
  }
  get panels() {
    return Object.keys(this._panels).map((id) => this._panels[id]);
  }
  setStrategy(strategy) {
    this.strategy = strategy;
  }
  updatePanelOrder(ids) {
    ids.forEach((id, index) => this._panels[id].index = index);
    this.removeOldPanels(ids);
  }
  addPanel(id, open = false) {
    this._panels[id] = new AccordionPanelModel(id, this.accordionCount);
    this._panels[id].open = open;
  }
  togglePanel(panelId, open) {
    const panelIsOpen = this._panels[panelId].open;
    const newOpenState = open !== void 0 ? open : !panelIsOpen;
    if (newOpenState && this.strategy === AccordionStrategy.Default) {
      this.closeAllPanels();
    }
    this._panels[panelId].open = newOpenState;
  }
  disablePanel(panelId, disabled) {
    this._panels[panelId].disabled = disabled;
  }
  closeAllPanels() {
    this.panels.forEach((panel) => this._panels[panel.id].open = false);
  }
  removeOldPanels(ids) {
    this.panels.filter((panel) => ids.find((id) => id === panel.id) === void 0).forEach((panel) => delete this._panels[panel.id]);
  }
};
var AccordionService = class {
  constructor() {
    this.accordion = new AccordionModel();
    this._panelsChanges = new BehaviorSubject(this.accordion.panels);
  }
  getPanelChanges(panelId) {
    return this._panelsChanges.pipe(map((panels) => panels.find((s) => s.id === panelId)));
  }
  setStrategy(strategy) {
    this.accordion.setStrategy(strategy);
  }
  addPanel(panelId, open = false) {
    this.accordion.addPanel(panelId, open);
    this.emitUpdatedPanels();
  }
  togglePanel(panelId, open) {
    this.accordion.togglePanel(panelId, open);
    this.emitUpdatedPanels();
  }
  disablePanel(panelId, disabled) {
    this.accordion.disablePanel(panelId, disabled);
    this.emitUpdatedPanels();
  }
  updatePanelOrder(ids) {
    this.accordion.updatePanelOrder(ids);
    this.emitUpdatedPanels();
  }
  emitUpdatedPanels() {
    this._panelsChanges.next(this.accordion.panels);
  }
};
AccordionService.ɵfac = function AccordionService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || AccordionService)();
};
AccordionService.ɵprov = ɵɵdefineInjectable({
  token: AccordionService,
  factory: AccordionService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AccordionService, [{
    type: Injectable
  }], null, null);
})();
var ClrAccordionPanel = class {
  constructor(parent, commonStrings, accordionService, ifExpandService, cdr) {
    this.parent = parent;
    this.commonStrings = commonStrings;
    this.accordionService = accordionService;
    this.ifExpandService = ifExpandService;
    this.cdr = cdr;
    this.disabled = false;
    this.panelOpen = false;
    this.headingEnabled = false;
    this.panelOpenChange = new EventEmitter();
    this._id = uniqueIdFactory();
  }
  get id() {
    return this._id;
  }
  set id(value) {
    this._id = value;
  }
  get panelNumber() {
    return this._panelIndex + 1;
  }
  get headingLevel() {
    if (this.explicitHeadingLevel) {
      return this.explicitHeadingLevel;
    }
    return this.parent ? 4 : 3;
  }
  ngOnInit() {
    this.panel = this.accordionService.getPanelChanges(this.id).pipe(tap((panel) => this.emitPanelChange(panel)));
    this.accordionService.addPanel(this.id, this.panelOpen);
    this.accordionService.togglePanel(this.id, this.panelOpen);
    this.accordionService.disablePanel(this.id, this.disabled);
  }
  ngOnChanges(changes) {
    if (this.panel && changes.panelOpen && changes.panelOpen.currentValue !== changes.panelOpen.previousValue) {
      this.accordionService.togglePanel(this.id, changes.panelOpen.currentValue);
    }
    if (this.panel && changes.disabled && changes.disabled.currentValue !== changes.disabled.previousValue) {
      this.accordionService.disablePanel(this.id, changes.disabled.currentValue);
    }
  }
  togglePanel() {
    this.accordionService.togglePanel(this.id);
  }
  collapsePanelOnAnimationDone(panel) {
    if (!panel.open) {
      this.ifExpandService.expanded = false;
    }
  }
  getPanelStateClasses(panel) {
    return `clr-accordion-panel-${panel.status} ${panel.open ? "clr-accordion-panel-open" : ""}`;
  }
  getAccordionContentId(id) {
    return `clr-accordion-content-${id}'`;
  }
  getAccordionHeaderId(id) {
    return `clr-accordion-header-${id}`;
  }
  stepCompleteText(panelNumber) {
    return this.commonStrings.parse(this.commonStrings.keys.stepComplete, {
      STEP: panelNumber.toString()
    });
  }
  stepErrorText(panelNumber) {
    return this.commonStrings.parse(this.commonStrings.keys.stepError, {
      STEP: panelNumber.toString()
    });
  }
  emitPanelChange(panel) {
    if (panel.index !== this._panelIndex) {
      this._panelIndex = panel.index;
      this.cdr.detectChanges();
    }
    if (panel.open !== this.panelOpen) {
      this.panelOpenChange.emit(panel.open);
      this.panelOpen = panel.open;
    }
    if (panel.open) {
      this.ifExpandService.expanded = true;
    }
  }
};
ClrAccordionPanel.ɵfac = function ClrAccordionPanel_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrAccordionPanel)(ɵɵdirectiveInject(ClrAccordionPanel, 12), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(AccordionService), ɵɵdirectiveInject(IfExpandService), ɵɵdirectiveInject(ChangeDetectorRef));
};
ClrAccordionPanel.ɵcmp = ɵɵdefineComponent({
  type: ClrAccordionPanel,
  selectors: [["clr-accordion-panel"]],
  contentQueries: function ClrAccordionPanel_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrAccordionDescription, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.accordionDescription = _t);
    }
  },
  hostVars: 4,
  hostBindings: function ClrAccordionPanel_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-accordion-panel", true)("clr-accordion-panel-disabled", ctx.disabled);
    }
  },
  inputs: {
    disabled: [0, "clrAccordionPanelDisabled", "disabled"],
    panelOpen: [0, "clrAccordionPanelOpen", "panelOpen"],
    headingEnabled: [0, "clrAccordionPanelHeadingEnabled", "headingEnabled"],
    explicitHeadingLevel: [0, "clrAccordionPanelHeadingLevel", "explicitHeadingLevel"]
  },
  outputs: {
    panelOpenChange: "clrAccordionPanelOpenChange"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([IfExpandService]), ɵɵNgOnChangesFeature],
  ngContentSelectors: _c2,
  decls: 2,
  vars: 3,
  consts: [["headerButton", ""], [4, "ngIf"], [3, "ngClass"], [1, "clr-accordion-header"], ["type", "button", 1, "clr-accordion-header-button", 3, "click", "id", "disabled"], [1, "clr-accordion-status"], ["shape", "angle", "direction", "right", 1, "clr-accordion-angle"], ["role", "region", 1, "clr-accordion-content-region", 3, "id"], ["class", "clr-accordion-content", 4, "ngIf"], [1, "clr-accordion-content"], [1, "clr-accordion-inner-content"]],
  template: function ClrAccordionPanel_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c12);
      ɵɵtemplate(0, ClrAccordionPanel_ng_container_0_Template, 12, 16, "ng-container", 1);
      ɵɵpipe(1, "async");
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ɵɵpipeBind1(1, 1, ctx.panel));
    }
  },
  dependencies: [NgClass, NgIf, CdsIconCustomTag, AsyncPipe],
  encapsulation: 2,
  data: {
    animation: panelAnimation
  },
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrAccordionPanel, [{
    type: Component,
    args: [{
      selector: "clr-accordion-panel",
      host: {
        "[class.clr-accordion-panel]": "true"
      },
      changeDetection: ChangeDetectionStrategy.OnPush,
      animations: panelAnimation,
      providers: [IfExpandService],
      template: `<ng-container *ngIf="panel | async; let panel">
  <div [ngClass]="getPanelStateClasses(panel)">
    <div
      class="clr-accordion-header"
      [attr.role]="headingEnabled || explicitHeadingLevel ? 'heading' : null"
      [attr.aria-level]="headingEnabled || explicitHeadingLevel ? headingLevel : null"
    >
      <button
        type="button"
        class="clr-accordion-header-button"
        (click)="togglePanel()"
        [id]="getAccordionHeaderId(panel.templateId)"
        [disabled]="panel.disabled"
        [attr.aria-controls]="getAccordionContentId(panel.templateId)"
        [attr.aria-expanded]="panel.open"
        [class.clr-accordion-header-has-description]="(accordionDescription.changes | async)?.length || accordionDescription.length"
        #headerButton
      >
        <span class="clr-accordion-status">
          <cds-icon shape="angle" direction="right" class="clr-accordion-angle"></cds-icon>
        </span>
        <ng-content select="clr-accordion-title, clr-step-title"></ng-content>
        <ng-content select="clr-accordion-description, clr-step-description"></ng-content>
      </button>
    </div>
    <div
      @skipInitialRender
      role="region"
      class="clr-accordion-content-region"
      [id]="getAccordionContentId(panel.templateId)"
      [attr.aria-hidden]="!panel.open"
      [attr.aria-labelledby]="getAccordionHeaderId(panel.templateId)"
    >
      <div
        *ngIf="panel.open"
        @toggle
        (@toggle.done)="collapsePanelOnAnimationDone(panel)"
        class="clr-accordion-content"
      >
        <div class="clr-accordion-inner-content">
          <ng-content></ng-content>
        </div>
      </div>
    </div>
  </div>
</ng-container>
`
    }]
  }], function() {
    return [{
      type: ClrAccordionPanel,
      decorators: [{
        type: Optional
      }, {
        type: SkipSelf
      }]
    }, {
      type: ClrCommonStringsService
    }, {
      type: AccordionService
    }, {
      type: IfExpandService
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    disabled: [{
      type: Input,
      args: ["clrAccordionPanelDisabled"]
    }, {
      type: HostBinding,
      args: ["class.clr-accordion-panel-disabled"]
    }],
    panelOpen: [{
      type: Input,
      args: ["clrAccordionPanelOpen"]
    }],
    headingEnabled: [{
      type: Input,
      args: ["clrAccordionPanelHeadingEnabled"]
    }],
    explicitHeadingLevel: [{
      type: Input,
      args: ["clrAccordionPanelHeadingLevel"]
    }],
    panelOpenChange: [{
      type: Output,
      args: ["clrAccordionPanelOpenChange"]
    }],
    accordionDescription: [{
      type: ContentChildren,
      args: [ClrAccordionDescription]
    }]
  });
})();
var ClrAccordion = class {
  constructor(accordionService) {
    this.accordionService = accordionService;
    this.multiPanel = false;
    this.subscriptions = [];
  }
  ngOnInit() {
    this.setAccordionStrategy();
  }
  ngOnChanges(changes) {
    if (changes.multiPanel.currentValue !== changes.multiPanel.previousValue) {
      this.setAccordionStrategy();
    }
  }
  ngAfterViewInit() {
    this.subscriptions.push(this.listenForDOMChanges());
  }
  ngOnDestroy() {
    this.subscriptions.forEach((s) => s.unsubscribe());
  }
  setAccordionStrategy() {
    const strategy = this.multiPanel ? AccordionStrategy.Multi : AccordionStrategy.Default;
    this.accordionService.setStrategy(strategy);
  }
  listenForDOMChanges() {
    return this.panels.changes.pipe(startWith(this.panels)).subscribe((panels) => this.accordionService.updatePanelOrder(panels.toArray().map((p) => p.id)));
  }
};
ClrAccordion.ɵfac = function ClrAccordion_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrAccordion)(ɵɵdirectiveInject(AccordionService));
};
ClrAccordion.ɵcmp = ɵɵdefineComponent({
  type: ClrAccordion,
  selectors: [["clr-accordion"]],
  contentQueries: function ClrAccordion_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrAccordionPanel, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.panels = _t);
    }
  },
  hostVars: 2,
  hostBindings: function ClrAccordion_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-accordion", true);
    }
  },
  inputs: {
    multiPanel: [0, "clrAccordionMultiPanel", "multiPanel"]
  },
  standalone: false,
  features: [ɵɵProvidersFeature([AccordionService]), ɵɵNgOnChangesFeature],
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrAccordion_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrAccordion, [{
    type: Component,
    args: [{
      selector: "clr-accordion",
      template: `<ng-content></ng-content>`,
      host: {
        "[class.clr-accordion]": "true"
      },
      providers: [AccordionService],
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], function() {
    return [{
      type: AccordionService
    }];
  }, {
    multiPanel: [{
      type: Input,
      args: ["clrAccordionMultiPanel"]
    }],
    panels: [{
      type: ContentChildren,
      args: [ClrAccordionPanel]
    }]
  });
})();
var ClrAccordionContent = class {
};
ClrAccordionContent.ɵfac = function ClrAccordionContent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrAccordionContent)();
};
ClrAccordionContent.ɵcmp = ɵɵdefineComponent({
  type: ClrAccordionContent,
  selectors: [["clr-accordion-content"], ["clr-step-content"]],
  standalone: false,
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrAccordionContent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrAccordionContent, [{
    type: Component,
    args: [{
      selector: "clr-accordion-content, clr-step-content",
      template: `<ng-content></ng-content>`,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, null);
})();
var ClrAccordionTitle = class {
};
ClrAccordionTitle.ɵfac = function ClrAccordionTitle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrAccordionTitle)();
};
ClrAccordionTitle.ɵcmp = ɵɵdefineComponent({
  type: ClrAccordionTitle,
  selectors: [["clr-accordion-title"], ["clr-step-title"]],
  hostVars: 2,
  hostBindings: function ClrAccordionTitle_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-accordion-title", true);
    }
  },
  standalone: false,
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrAccordionTitle_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrAccordionTitle, [{
    type: Component,
    args: [{
      selector: "clr-accordion-title, clr-step-title",
      template: `<ng-content></ng-content>`,
      host: {
        "[class.clr-accordion-title]": "true"
      },
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, null);
})();
var WillyWonka = class {
  constructor() {
    this.disableChocolateCheck = false;
    this._chocolate = new Subject();
  }
  get chocolate() {
    return this._chocolate.asObservable();
  }
  ngAfterViewChecked() {
    if (!this.disableChocolateCheck) {
      this._chocolate.next();
    }
  }
};
WillyWonka.ɵfac = function WillyWonka_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || WillyWonka)();
};
WillyWonka.ɵdir = ɵɵdefineDirective({
  type: WillyWonka,
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WillyWonka, [{
    type: Directive
  }], null, null);
})();
var OompaLoompa = class {
  // FIXME: Request Injector once we move to Angular 4.2+, it'll allow easier refactors
  constructor(cdr, willyWonka) {
    this.subscription = willyWonka.chocolate.subscribe(() => {
      if (this.latestFlavor !== this.flavor) {
        willyWonka.disableChocolateCheck = true;
        cdr.detectChanges();
        willyWonka.disableChocolateCheck = false;
      }
    });
  }
  ngAfterContentChecked() {
    this.latestFlavor = this.flavor;
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
};
OompaLoompa.ɵfac = function OompaLoompa_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || OompaLoompa)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(WillyWonka));
};
OompaLoompa.ɵdir = ɵɵdefineDirective({
  type: OompaLoompa,
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OompaLoompa, [{
    type: Directive
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: WillyWonka
    }];
  }, null);
})();
var AccordionWillyWonka = class extends WillyWonka {
};
AccordionWillyWonka.ɵfac = /* @__PURE__ */ (() => {
  let ɵAccordionWillyWonka_BaseFactory;
  return function AccordionWillyWonka_Factory(__ngFactoryType__) {
    return (ɵAccordionWillyWonka_BaseFactory || (ɵAccordionWillyWonka_BaseFactory = ɵɵgetInheritedFactory(AccordionWillyWonka)))(__ngFactoryType__ || AccordionWillyWonka);
  };
})();
AccordionWillyWonka.ɵdir = ɵɵdefineDirective({
  type: AccordionWillyWonka,
  selectors: [["clr-accordion"]],
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AccordionWillyWonka, [{
    type: Directive,
    args: [{
      selector: "clr-accordion"
    }]
  }], null, null);
})();
var AccordionOompaLoompa = class extends OompaLoompa {
  constructor(cdr, willyWonka, ifExpandService) {
    if (!willyWonka) {
      throw new Error("clr-accordion-panel should only be used inside of clr-accordion");
    }
    super(cdr, willyWonka);
    this.expand = ifExpandService;
  }
  get flavor() {
    return this.expand.expanded;
  }
};
AccordionOompaLoompa.ɵfac = function AccordionOompaLoompa_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || AccordionOompaLoompa)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(AccordionWillyWonka, 8), ɵɵdirectiveInject(IfExpandService));
};
AccordionOompaLoompa.ɵdir = ɵɵdefineDirective({
  type: AccordionOompaLoompa,
  selectors: [["clr-accordion-panel"]],
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AccordionOompaLoompa, [{
    type: Directive,
    args: [{
      selector: "clr-accordion-panel"
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: AccordionWillyWonka,
      decorators: [{
        type: Optional
      }]
    }, {
      type: IfExpandService
    }];
  }, null);
})();
var declarations$1 = [ClrAccordion, ClrAccordionPanel, ClrAccordionTitle, ClrAccordionDescription, ClrAccordionContent, AccordionOompaLoompa, AccordionWillyWonka];
var ClrAccordionModule = class {
  constructor() {
    r.addIcons(o, o4, e);
  }
};
ClrAccordionModule.ɵfac = function ClrAccordionModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrAccordionModule)();
};
ClrAccordionModule.ɵmod = ɵɵdefineNgModule({
  type: ClrAccordionModule,
  declarations: [ClrAccordion, ClrAccordionPanel, ClrAccordionTitle, ClrAccordionDescription, ClrAccordionContent, AccordionOompaLoompa, AccordionWillyWonka],
  imports: [CommonModule, ClrIconModule],
  exports: [ClrAccordion, ClrAccordionPanel, ClrAccordionTitle, ClrAccordionDescription, ClrAccordionContent, AccordionOompaLoompa, AccordionWillyWonka]
});
ClrAccordionModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrIconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrAccordionModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ClrIconModule],
      declarations: [...declarations$1],
      exports: [...declarations$1]
    }]
  }], function() {
    return [];
  }, null);
})();
function triggerAllFormControlValidation(formGroup) {
  Object.keys(formGroup.controls).forEach((field) => {
    const control = formGroup.get(field);
    if (control instanceof FormControl) {
      control.markAsTouched();
      control.markAsDirty();
      control.updateValueAndValidity();
    } else if (control instanceof FormGroup) {
      triggerAllFormControlValidation(control);
    }
  });
}
var StepperModel = class extends AccordionModel {
  constructor() {
    super(...arguments);
    this.stepperModelInitialize = false;
  }
  get allPanelsCompleted() {
    return this.panels.length && this.getNumberOfIncompletePanels() === 0 && this.getNumberOfOpenPanels() === 0;
  }
  get shouldOpenFirstPanel() {
    return !this.initialPanel || this._panels && Object.keys(this._panels).length && !this._panels[this.initialPanel];
  }
  addPanel(id, open = false) {
    super.addPanel(id, open);
    this._panels[id].disabled = true;
  }
  updatePanelOrder(ids) {
    super.updatePanelOrder(ids);
    if (this.stepperModelInitialize === false) {
      this.openFirstPanel();
    }
  }
  togglePanel(panelId) {
    if (this._panels[panelId].status === AccordionStatus.Complete) {
      this._panels[panelId].open = !this._panels[panelId].open;
    }
  }
  navigateToPreviousPanel(currentPanelId) {
    this.openPreviousPanel(this._panels[currentPanelId].id);
  }
  navigateToNextPanel(currentPanelId, currentPanelValid = true) {
    if (currentPanelValid) {
      this.completePanel(currentPanelId);
      this.openNextPanel(this._panels[currentPanelId].id);
    } else {
      this.setPanelError(currentPanelId);
    }
  }
  overrideInitialPanel(panelId) {
    this.initialPanel = panelId;
    this.panels.filter(() => this._panels[panelId] !== void 0).forEach((panel) => {
      if (panel.index < this._panels[panelId].index) {
        this.completePanel(panel.id);
      } else if (panel.id === panelId) {
        this._panels[panel.id].open = true;
      } else {
        this._panels[panel.id].open = false;
      }
    });
  }
  setPanelValid(panelId) {
    this._panels[panelId].status = AccordionStatus.Complete;
  }
  setPanelInvalid(panelId) {
    this._panels[panelId].status = AccordionStatus.Error;
  }
  setPanelsWithErrors(ids) {
    ids.forEach((id) => this.setPanelError(id));
  }
  resetPanels() {
    this.stepperModelInitialize = false;
    this.panels.forEach((p) => this.resetPanel(p.id));
    this.openFirstPanel();
  }
  getNextPanel(currentPanelId) {
    return this.panels.find((s) => s.index === this._panels[currentPanelId].index + 1);
  }
  getPreviousPanel(currentPanelId) {
    return this.panels.find((s) => s.index === this._panels[currentPanelId].index - 1);
  }
  resetAllFuturePanels(panelId) {
    this.panels.filter((panel) => panel.index >= this._panels[panelId].index).forEach((panel) => this.resetPanel(panel.id));
  }
  resetPanel(panelId) {
    this._panels[panelId].status = AccordionStatus.Inactive;
    this._panels[panelId].open = false;
    this._panels[panelId].disabled = true;
  }
  openFirstPanel() {
    if (!this.shouldOpenFirstPanel) {
      return;
    }
    const firstPanel = this.getFirstPanel();
    if (!firstPanel) {
      return;
    }
    this._panels[firstPanel.id].open = true;
    this._panels[firstPanel.id].disabled = true;
    this.stepperModelInitialize = true;
  }
  completePanel(panelId) {
    this._panels[panelId].status = AccordionStatus.Complete;
    this._panels[panelId].disabled = false;
    this._panels[panelId].open = false;
  }
  openNextPanel(currentPanelId) {
    const nextPanel = this.getNextPanel(currentPanelId);
    if (nextPanel) {
      this.resetAllFuturePanels(nextPanel.id);
      this._panels[nextPanel.id].open = true;
      this._panels[nextPanel.id].disabled = true;
    }
  }
  openPreviousPanel(currentPanelId) {
    const prevPanel = this.getPreviousPanel(currentPanelId);
    if (prevPanel) {
      this._panels[currentPanelId].open = false;
      this._panels[currentPanelId].disabled = false;
      this._panels[prevPanel.id].open = true;
      this._panels[prevPanel.id].disabled = true;
    }
  }
  setPanelError(panelId) {
    this.resetAllFuturePanels(panelId);
    this._panels[panelId].open = true;
    this._panels[panelId].status = AccordionStatus.Error;
  }
  getFirstPanel() {
    return this.panels.find((panel) => panel.index === 0);
  }
  getNumberOfIncompletePanels() {
    return this.panels.reduce((prev, next) => next.status !== AccordionStatus.Complete ? prev + 1 : prev, 0);
  }
  getNumberOfOpenPanels() {
    return this.panels.reduce((prev, next) => next.open !== false ? prev + 1 : prev, 0);
  }
};
var StepperService = class extends AccordionService {
  constructor() {
    super();
    this.panelsCompleted = this.getAllCompletedPanelChanges();
    this.accordion = new StepperModel();
    this._activeStepChanges = new Subject();
    this.activeStep = this._activeStepChanges.asObservable();
  }
  resetPanels() {
    this.accordion.resetPanels();
    this.emitUpdatedPanels();
  }
  setPanelValid(panelId) {
    this.accordion.setPanelValid(panelId);
    this.emitUpdatedPanels();
  }
  setPanelInvalid(panelId) {
    this.accordion.setPanelInvalid(panelId);
    this.emitUpdatedPanels();
  }
  setPanelsWithErrors(ids) {
    this.accordion.setPanelsWithErrors(ids);
    this.emitUpdatedPanels();
  }
  navigateToPreviousPanel(currentPanelId) {
    this.accordion.navigateToPreviousPanel(currentPanelId);
    this.updatePreviousStep(currentPanelId);
    this.emitUpdatedPanels();
  }
  navigateToNextPanel(currentPanelId, currentPanelValid = true) {
    this.accordion.navigateToNextPanel(currentPanelId, currentPanelValid);
    this.updateNextStep(currentPanelId, currentPanelValid);
    this.emitUpdatedPanels();
  }
  overrideInitialPanel(panelId) {
    this.accordion.overrideInitialPanel(panelId);
    this.emitUpdatedPanels();
  }
  updateNextStep(currentPanelId, currentPanelValid) {
    const nextPanel = this.accordion.getNextPanel(currentPanelId);
    if (currentPanelValid && nextPanel) {
      this._activeStepChanges.next(nextPanel.id);
    } else if (currentPanelValid) {
      this._activeStepChanges.next(currentPanelId);
    }
  }
  updatePreviousStep(currentPanelId) {
    const prevPanel = this.accordion.getPreviousPanel(currentPanelId);
    if (prevPanel) {
      this._activeStepChanges.next(prevPanel.id);
    }
  }
  getAllCompletedPanelChanges() {
    return this._panelsChanges.pipe(map(() => this.accordion.allPanelsCompleted), distinctUntilChanged());
  }
};
StepperService.ɵfac = function StepperService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || StepperService)();
};
StepperService.ɵprov = ɵɵdefineInjectable({
  token: StepperService,
  factory: StepperService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StepperService, [{
    type: Injectable
  }], function() {
    return [];
  }, null);
})();
var ClrStepperPanel = class extends ClrAccordionPanel {
  constructor(platformId, commonStrings, formGroupName, ngModelGroup, stepperService, ifExpandService, cdr) {
    super(null, commonStrings, stepperService, ifExpandService, cdr);
    this.platformId = platformId;
    this.commonStrings = commonStrings;
    this.formGroupName = formGroupName;
    this.ngModelGroup = ngModelGroup;
    this.stepperService = stepperService;
    this.AccordionStatus = AccordionStatus;
    this.subscriptions = [];
  }
  get id() {
    return this.formGroupName ? this.formGroupName.name.toString() : this.ngModelGroup.name;
  }
  set id(_value) {
  }
  get formGroup() {
    return this.formGroupName ? this.formGroupName.control : this.ngModelGroup.control;
  }
  ngOnInit() {
    super.ngOnInit();
    this.panel = this.panel.pipe(tap((panel) => this.triggerAllFormControlValidationIfError(panel)));
    this.stepperService.disablePanel(this.id, true);
    this.listenToFocusChanges();
    if (this.formGroup) {
      const invalidStatusTrigger = this.formGroup.statusChanges.pipe(filter((status) => status === "INVALID"));
      this.subscriptions.push(this.formGroup.statusChanges.pipe(skipUntil(invalidStatusTrigger), distinctUntilChanged()).subscribe((status) => {
        if (!this.formGroup.touched) {
          return;
        }
        if (status === "VALID") {
          this.stepperService.setPanelValid(this.id);
        } else if (status === "INVALID") {
          this.stepperService.setPanelInvalid(this.id);
        }
      }));
    }
  }
  ngOnDestroy() {
    this.subscriptions.forEach((s) => s.unsubscribe());
  }
  listenToFocusChanges() {
    this.subscriptions.push(this.stepperService.activeStep.pipe(filter((panelId) => isPlatformBrowser(this.platformId) && panelId === this.id)).subscribe(() => {
      this.headerButton.nativeElement.focus();
    }));
  }
  triggerAllFormControlValidationIfError(panel) {
    if (panel.status === AccordionStatus.Error) {
      triggerAllFormControlValidation(this.formGroup);
    }
  }
};
ClrStepperPanel.ɵfac = function ClrStepperPanel_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrStepperPanel)(ɵɵdirectiveInject(PLATFORM_ID), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(FormGroupName, 8), ɵɵdirectiveInject(NgModelGroup, 8), ɵɵdirectiveInject(StepperService), ɵɵdirectiveInject(IfExpandService), ɵɵdirectiveInject(ChangeDetectorRef));
};
ClrStepperPanel.ɵcmp = ɵɵdefineComponent({
  type: ClrStepperPanel,
  selectors: [["clr-stepper-panel"]],
  viewQuery: function ClrStepperPanel_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c3, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerButton = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function ClrStepperPanel_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-stepper-panel", true);
    }
  },
  standalone: false,
  features: [ɵɵProvidersFeature([IfExpandService]), ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c5,
  decls: 2,
  vars: 3,
  consts: [["headerButton", ""], [4, "ngIf"], [3, "ngClass"], [1, "clr-accordion-header", "clr-stepper-header"], ["type", "button", 1, "clr-accordion-header-button", 3, "click", "id"], [1, "clr-step-status"], ["shape", "angle", "direction", "right", 1, "clr-accordion-angle", "clr-step-angle"], ["status", "danger", "shape", "exclamation-circle", "class", "clr-step-error-icon", 4, "ngIf"], ["status", "success", "shape", "check-circle", "class", "clr-step-complete-icon", 4, "ngIf"], [1, "clr-step-title-wrapper"], [1, "clr-step-number"], ["role", "status", 1, "clr-sr-only"], ["role", "region", 1, "clr-accordion-content-region", 3, "id"], ["class", "clr-accordion-content", 4, "ngIf"], ["status", "danger", "shape", "exclamation-circle", 1, "clr-step-error-icon"], ["status", "success", "shape", "check-circle", 1, "clr-step-complete-icon"], [1, "clr-accordion-content"], [1, "clr-accordion-inner-content"]],
  template: function ClrStepperPanel_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c4);
      ɵɵtemplate(0, ClrStepperPanel_ng_container_0_Template, 20, 19, "ng-container", 1);
      ɵɵpipe(1, "async");
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ɵɵpipeBind1(1, 1, ctx.panel));
    }
  },
  dependencies: [NgClass, NgIf, CdsIconCustomTag, AsyncPipe],
  encapsulation: 2,
  data: {
    animation: stepAnimation
  },
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrStepperPanel, [{
    type: Component,
    args: [{
      selector: "clr-stepper-panel",
      host: {
        "[class.clr-stepper-panel]": "true"
      },
      changeDetection: ChangeDetectionStrategy.OnPush,
      animations: stepAnimation,
      providers: [IfExpandService],
      template: '<ng-container *ngIf="panel | async; let panel">\n  <div [ngClass]="getPanelStateClasses(panel)">\n    <div class="clr-accordion-header clr-stepper-header">\n      <button\n        type="button"\n        class="clr-accordion-header-button"\n        (click)="togglePanel()"\n        [id]="getAccordionHeaderId(panel.templateId)"\n        [attr.aria-disabled]="panel.disabled"\n        [attr.aria-controls]="getAccordionContentId(panel.templateId)"\n        [attr.aria-expanded]="panel.open"\n        [class.clr-accordion-header-has-description]="(accordionDescription.changes | async)?.length || accordionDescription.length"\n        #headerButton\n      >\n        <span class="clr-step-status">\n          <cds-icon shape="angle" direction="right" class="clr-accordion-angle clr-step-angle"></cds-icon>\n          <cds-icon\n            status="danger"\n            *ngIf="panel.status === AccordionStatus.Error"\n            shape="exclamation-circle"\n            class="clr-step-error-icon"\n          ></cds-icon>\n          <cds-icon\n            status="success"\n            *ngIf="panel.status === AccordionStatus.Complete"\n            shape="check-circle"\n            class="clr-step-complete-icon"\n          ></cds-icon>\n        </span>\n        <span class="clr-step-title-wrapper">\n          <span class="clr-step-number">{{panelNumber}}.</span>\n          <ng-content select="clr-step-title"></ng-content>\n        </span>\n        <ng-content select="clr-step-description"></ng-content>\n      </button>\n      <div class="clr-sr-only" role="status">\n        <ng-container *ngIf="panel.status === AccordionStatus.Error"> {{ stepErrorText(panelNumber)}} </ng-container>\n        <ng-container *ngIf="panel.status === AccordionStatus.Complete">\n          {{ stepCompleteText(panelNumber)}}\n        </ng-container>\n      </div>\n    </div>\n    <div\n      @skipInitialRender\n      role="region"\n      class="clr-accordion-content-region"\n      [id]="getAccordionContentId(panel.templateId)"\n      [attr.aria-hidden]="!panel.open"\n      [attr.aria-labelledby]="getAccordionHeaderId(panel.templateId)"\n    >\n      <div\n        *ngIf="panel.open"\n        @toggle\n        (@toggle.done)="collapsePanelOnAnimationDone(panel)"\n        class="clr-accordion-content"\n      >\n        <div class="clr-accordion-inner-content">\n          <ng-content></ng-content>\n        </div>\n      </div>\n    </div>\n  </div>\n</ng-container>\n'
    }]
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }, {
      type: ClrCommonStringsService
    }, {
      type: FormGroupName,
      decorators: [{
        type: Optional
      }]
    }, {
      type: NgModelGroup,
      decorators: [{
        type: Optional
      }]
    }, {
      type: StepperService
    }, {
      type: IfExpandService
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    headerButton: [{
      type: ViewChild,
      args: ["headerButton"]
    }]
  });
})();
var ClrStepButtonType;
(function(ClrStepButtonType2) {
  ClrStepButtonType2["Next"] = "next";
  ClrStepButtonType2["Previous"] = "previous";
  ClrStepButtonType2["Submit"] = "submit";
})(ClrStepButtonType || (ClrStepButtonType = {}));
var ClrStepButton = class {
  constructor(clrStep, stepperService) {
    this.clrStep = clrStep;
    this.stepperService = stepperService;
    this.type = ClrStepButtonType.Next;
    this.submitButton = false;
    this.previousButton = false;
  }
  ngOnInit() {
    this.submitButton = this.type === ClrStepButtonType.Submit;
    this.previousButton = this.type === ClrStepButtonType.Previous;
  }
  navigateToNextPanel() {
    if (this.previousButton) {
      this.stepperService.navigateToPreviousPanel(this.clrStep.id);
      return;
    }
    this.stepperService.navigateToNextPanel(this.clrStep.id, this.clrStep.formGroup.valid);
  }
};
ClrStepButton.ɵfac = function ClrStepButton_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrStepButton)(ɵɵdirectiveInject(ClrStepperPanel), ɵɵdirectiveInject(StepperService));
};
ClrStepButton.ɵdir = ɵɵdefineDirective({
  type: ClrStepButton,
  selectors: [["", "clrStepButton", ""]],
  hostVars: 9,
  hostBindings: function ClrStepButton_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function ClrStepButton_click_HostBindingHandler() {
        return ctx.navigateToNextPanel();
      });
    }
    if (rf & 2) {
      ɵɵhostProperty("type", "button");
      ɵɵclassProp("clr-step-button", true)("btn", true)("btn-success", ctx.submitButton)("btn-link", ctx.previousButton);
    }
  },
  inputs: {
    type: [0, "clrStepButton", "type"]
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrStepButton, [{
    type: Directive,
    args: [{
      selector: "[clrStepButton]",
      host: {
        "[class.clr-step-button]": "true",
        "[class.btn]": "true",
        "[type]": "'button'"
      }
    }]
  }], function() {
    return [{
      type: ClrStepperPanel
    }, {
      type: StepperService
    }];
  }, {
    type: [{
      type: Input,
      args: ["clrStepButton"]
    }],
    submitButton: [{
      type: HostBinding,
      args: ["class.btn-success"]
    }],
    previousButton: [{
      type: HostBinding,
      args: ["class.btn-link"]
    }],
    navigateToNextPanel: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var ClrStepper = class {
  constructor(formGroup, ngForm, stepperService) {
    this.formGroup = formGroup;
    this.ngForm = ngForm;
    this.stepperService = stepperService;
    this.subscriptions = [];
  }
  ngOnInit() {
    if (!this.formGroup && !this.ngForm) {
      throw new Error("To use stepper a Reactive or Template Form is required.");
    }
    this.form = this.formGroup ? this.formGroup : this.ngForm;
    this.subscriptions.push(this.listenForPanelsCompleted());
    this.subscriptions.push(this.listenForFormResetChanges());
  }
  ngOnChanges(changes) {
    if (changes.initialPanel.currentValue !== changes.initialPanel.previousValue) {
      this.stepperService.overrideInitialPanel(this.initialPanel);
    }
  }
  ngAfterViewInit() {
    this.subscriptions.push(this.listenForDOMChanges());
  }
  ngOnDestroy() {
    this.subscriptions.forEach((s) => s.unsubscribe());
  }
  listenForFormResetChanges() {
    return fromControlReset(this.form.form).subscribe(() => this.stepperService.resetPanels());
  }
  listenForPanelsCompleted() {
    return this.stepperService.panelsCompleted.subscribe((panelsCompleted) => {
      if (panelsCompleted && this.form.valid) {
        this.form.ngSubmit.emit();
      } else if (!this.form.valid && this.form.touched) {
        this.setPanelsWithFormErrors();
      }
    });
  }
  setPanelsWithFormErrors() {
    const panelsWithErrors = this.panels.reduce((panels, p) => p.formGroup.invalid ? [...panels, p.id] : panels, []);
    this.stepperService.setPanelsWithErrors(panelsWithErrors);
  }
  listenForDOMChanges() {
    return this.panels.changes.pipe(startWith(this.panels)).subscribe((panels) => {
      this.stepperService.updatePanelOrder(panels.toArray().map((p) => p.id));
      if (this.initialPanel) {
        this.stepperService.overrideInitialPanel(this.initialPanel);
      }
    });
  }
};
ClrStepper.ɵfac = function ClrStepper_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrStepper)(ɵɵdirectiveInject(FormGroupDirective, 8), ɵɵdirectiveInject(NgForm, 8), ɵɵdirectiveInject(StepperService));
};
ClrStepper.ɵcmp = ɵɵdefineComponent({
  type: ClrStepper,
  selectors: [["form", "clrStepper", ""]],
  contentQueries: function ClrStepper_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrStepperPanel, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.panels = _t);
    }
  },
  hostVars: 4,
  hostBindings: function ClrStepper_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-accordion", true)("clr-stepper-forms", true);
    }
  },
  inputs: {
    initialPanel: [0, "clrInitialStep", "initialPanel"]
  },
  standalone: false,
  features: [ɵɵProvidersFeature([StepperService, {
    provide: AccordionService,
    useExisting: StepperService
  }]), ɵɵNgOnChangesFeature],
  attrs: _c6,
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrStepper_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrStepper, [{
    type: Component,
    args: [{
      selector: "form[clrStepper]",
      template: `<ng-content></ng-content>`,
      host: {
        "[class.clr-accordion]": "true",
        "[class.clr-stepper-forms]": "true"
      },
      providers: [StepperService, {
        provide: AccordionService,
        useExisting: StepperService
      }],
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], function() {
    return [{
      type: FormGroupDirective,
      decorators: [{
        type: Optional
      }]
    }, {
      type: NgForm,
      decorators: [{
        type: Optional
      }]
    }, {
      type: StepperService
    }];
  }, {
    initialPanel: [{
      type: Input,
      args: ["clrInitialStep"]
    }],
    panels: [{
      type: ContentChildren,
      args: [ClrStepperPanel, {
        descendants: true
      }]
    }]
  });
})();
function fromControlReset(control) {
  return new Observable((observer) => {
    const unpatchedControlReset = control.reset;
    control.reset = () => {
      observer.next();
      unpatchedControlReset.apply(control);
    };
    return () => {
      control.reset = unpatchedControlReset;
    };
  });
}
var StepperWillyWonka = class extends WillyWonka {
};
StepperWillyWonka.ɵfac = /* @__PURE__ */ (() => {
  let ɵStepperWillyWonka_BaseFactory;
  return function StepperWillyWonka_Factory(__ngFactoryType__) {
    return (ɵStepperWillyWonka_BaseFactory || (ɵStepperWillyWonka_BaseFactory = ɵɵgetInheritedFactory(StepperWillyWonka)))(__ngFactoryType__ || StepperWillyWonka);
  };
})();
StepperWillyWonka.ɵdir = ɵɵdefineDirective({
  type: StepperWillyWonka,
  selectors: [["form", "clrStepper", ""]],
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StepperWillyWonka, [{
    type: Directive,
    args: [{
      selector: "form[clrStepper]"
    }]
  }], null, null);
})();
var StepperOompaLoompa = class extends OompaLoompa {
  constructor(cdr, willyWonka, ifExpandService) {
    if (!willyWonka) {
      throw new Error("clr-stepper-panel should only be used inside of clrStepper");
    }
    super(cdr, willyWonka);
    this.expand = ifExpandService;
  }
  get flavor() {
    return this.expand.expanded;
  }
};
StepperOompaLoompa.ɵfac = function StepperOompaLoompa_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || StepperOompaLoompa)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(StepperWillyWonka, 8), ɵɵdirectiveInject(IfExpandService));
};
StepperOompaLoompa.ɵdir = ɵɵdefineDirective({
  type: StepperOompaLoompa,
  selectors: [["clr-stepper-panel"], ["", "clrStepButton", ""]],
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StepperOompaLoompa, [{
    type: Directive,
    args: [{
      selector: "clr-stepper-panel, [clrStepButton]"
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: StepperWillyWonka,
      decorators: [{
        type: Optional
      }]
    }, {
      type: IfExpandService
    }];
  }, null);
})();
var declarations = [ClrStepper, ClrStepButton, ClrStepperPanel, StepperOompaLoompa, StepperWillyWonka];
var ClrStepperModule = class {
};
ClrStepperModule.ɵfac = function ClrStepperModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrStepperModule)();
};
ClrStepperModule.ɵmod = ɵɵdefineNgModule({
  type: ClrStepperModule,
  declarations: [ClrStepper, ClrStepButton, ClrStepperPanel, StepperOompaLoompa, StepperWillyWonka],
  imports: [CommonModule, ClrIconModule, ClrAccordionModule],
  exports: [ClrStepper, ClrStepButton, ClrStepperPanel, StepperOompaLoompa, StepperWillyWonka, ClrAccordionModule]
});
ClrStepperModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrIconModule, ClrAccordionModule, ClrAccordionModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrStepperModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ClrIconModule, ClrAccordionModule],
      declarations: [...declarations],
      exports: [...declarations, ClrAccordionModule]
    }]
  }], null, null);
})();
var Keys;
(function(Keys2) {
  Keys2["ArrowLeft"] = "ArrowLeft";
  Keys2["ArrowUp"] = "ArrowUp";
  Keys2["ArrowRight"] = "ArrowRight";
  Keys2["ArrowDown"] = "ArrowDown";
  Keys2["Backspace"] = "Backspace";
  Keys2["Tab"] = "Tab";
  Keys2["Enter"] = "Enter";
  Keys2["Escape"] = "Escape";
  Keys2["Space"] = "Space";
  Keys2["Spacebar"] = " ";
  Keys2["Home"] = "Home";
  Keys2["End"] = "End";
})(Keys || (Keys = {}));
var IEKeys;
(function(IEKeys2) {
  IEKeys2["ArrowUp"] = "Up";
  IEKeys2["ArrowDown"] = "Down";
  IEKeys2["ArrowRight"] = "Right";
  IEKeys2["ArrowLeft"] = "Left";
  IEKeys2["Space"] = "Spacebar";
  IEKeys2["Escape"] = "Esc";
})(IEKeys || (IEKeys = {}));
function normalizeKey(key) {
  if (key === Keys.ArrowUp || key === IEKeys.ArrowUp) {
    return Keys.ArrowUp;
  } else if (key === Keys.ArrowDown || key === IEKeys.ArrowDown) {
    return Keys.ArrowDown;
  } else if (key === Keys.ArrowRight || key === IEKeys.ArrowRight) {
    return Keys.ArrowRight;
  } else if (key === Keys.ArrowLeft || key === IEKeys.ArrowLeft) {
    return Keys.ArrowLeft;
  } else if (key === Keys.Space || key === IEKeys.Space) {
    return Keys.Space;
  } else if (key === Keys.Escape || key === IEKeys.Escape) {
    return Keys.Escape;
  } else {
    return key;
  }
}
function preventArrowKeyScroll(event) {
  const key = normalizeKey(event.key);
  if (key === Keys.ArrowUp || key === Keys.ArrowDown || key === Keys.ArrowLeft || key === Keys.ArrowRight) {
    event.preventDefault();
  }
}
function isKeyEitherLetterOrNumber(event) {
  const char = event.key;
  return char.toLowerCase() !== char.toUpperCase() || char >= "0" && char <= "9";
}
var ClrPopoverToggleService = class {
  constructor() {
    this._open = false;
    this._openChange = new Subject();
    this._openEventChange = new Subject();
    this._popoverAligned = new Subject();
    this._popoverVisible = new Subject();
  }
  get openChange() {
    return this._openChange.asObservable();
  }
  get popoverVisible() {
    return this._popoverVisible.asObservable();
  }
  get openEvent() {
    return this._openEvent;
  }
  set openEvent(event) {
    this._openEvent = event;
    this._openEventChange.next(event);
  }
  get open() {
    return this._open;
  }
  set open(value) {
    value = !!value;
    if (this._open !== value) {
      this._open = value;
      this._openChange.next(value);
    }
  }
  // For compatibility with legacy IfOpenService based implementations
  get originalEvent() {
    return this._openEvent;
  }
  get popoverAligned() {
    return this._popoverAligned.asObservable();
  }
  getEventChange() {
    return this._openEventChange.asObservable();
  }
  /**
   * Sometimes, we need to remember the event that triggered the toggling to avoid loops.
   * This is for instance the case of components that open on a click, but close on a click outside.
   */
  toggleWithEvent(event) {
    preventArrowKeyScroll(event);
    this.openEvent = event;
    this.open = !this.open;
  }
  popoverVisibleEmit(visible) {
    this._popoverVisible.next(visible);
  }
  popoverAlignedEmit(popoverNode) {
    this._popoverAligned.next(popoverNode);
  }
};
ClrPopoverToggleService.ɵfac = function ClrPopoverToggleService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrPopoverToggleService)();
};
ClrPopoverToggleService.ɵprov = ɵɵdefineInjectable({
  token: ClrPopoverToggleService,
  factory: ClrPopoverToggleService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrPopoverToggleService, [{
    type: Injectable
  }], null, null);
})();
var ClrPopoverEventsService = class {
  constructor(renderer, smartOpenService, document2) {
    this.renderer = renderer;
    this.smartOpenService = smartOpenService;
    this.document = document2;
    this.outsideClickClose = true;
    this.scrollToClose = true;
    this.subscriptions = [];
    this.subscriptions.push(smartOpenService.openChange.subscribe((open) => {
      if (open) {
        this.addEscapeListener();
        this.addClickListener();
        this.addScrollListener();
      } else {
        this.removeAllEventListeners();
      }
    }), smartOpenService.getEventChange().subscribe((event) => {
      this.ignoredEvent = event;
    }));
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
    this.removeAllEventListeners();
  }
  addScrollListener() {
    if (this.scrollToClose) {
      this.documentScroller = fromEvent(this.document, "scroll", {
        capture: true
      });
      this.scrollSubscription = this.documentScroller.pipe(filter(this.testForSmartPopoverContentContainer)).subscribe(() => {
        this.smartOpenService.open = false;
        this.setAnchorFocus();
      });
    } else {
      return;
    }
  }
  removeScrollListener() {
    if (this.documentScroller) {
      this.scrollSubscription.unsubscribe();
      delete this.documentScroller;
    }
  }
  addClickListener() {
    if (this.outsideClickClose) {
      this.documentClickListener = this.renderer.listen(this.document, "click", (event) => {
        if (event === this.ignoredEvent) {
          delete this.ignoredEvent;
        } else {
          this.smartOpenService.open = false;
          const clickedElement = event.target;
          clickedElement.focus();
        }
      });
    }
  }
  removeClickListener() {
    if (this.outsideClickClose) {
      delete this.ignoredEvent;
      if (this.documentClickListener) {
        this.documentClickListener();
        delete this.documentClickListener;
      }
    }
  }
  addEscapeListener() {
    this.escapeListener = this.renderer.listen(this.document, "keydown.escape", () => {
      this.smartOpenService.open = false;
      this.setAnchorFocus();
    });
  }
  removeEscapeListener() {
    if (this.escapeListener) {
      this.escapeListener();
      delete this.escapeListener;
    }
  }
  setCloseFocus() {
    this.closeButtonRef.nativeElement.focus();
  }
  setAnchorFocus() {
    this.anchorButtonRef.nativeElement.focus();
  }
  testForSmartPopoverContentContainer(event) {
    let target = event.target;
    while (target.classList && target.parentElement.localName !== "body") {
      target = target.parentElement;
    }
    if (target.classList) {
      return target.classList.contains("clr-popover-content") ? false : true;
    } else {
      return false;
    }
  }
  removeAllEventListeners() {
    this.removeScrollListener();
    this.removeClickListener();
    this.removeEscapeListener();
  }
};
ClrPopoverEventsService.ɵfac = function ClrPopoverEventsService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrPopoverEventsService)(ɵɵinject(Renderer2), ɵɵinject(ClrPopoverToggleService), ɵɵinject(DOCUMENT));
};
ClrPopoverEventsService.ɵprov = ɵɵdefineInjectable({
  token: ClrPopoverEventsService,
  factory: ClrPopoverEventsService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrPopoverEventsService, [{
    type: Injectable
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: ClrPopoverToggleService
    }, {
      type: HTMLDocument,
      decorators: [{
        type: Inject,
        args: [DOCUMENT]
      }]
    }];
  }, null);
})();
var ClrPopoverAnchor = class {
  constructor(smartEventService, element) {
    smartEventService.anchorButtonRef = element;
  }
};
ClrPopoverAnchor.ɵfac = function ClrPopoverAnchor_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrPopoverAnchor)(ɵɵdirectiveInject(ClrPopoverEventsService), ɵɵdirectiveInject(ElementRef));
};
ClrPopoverAnchor.ɵdir = ɵɵdefineDirective({
  type: ClrPopoverAnchor,
  selectors: [["", "clrPopoverAnchor", ""]],
  hostVars: 2,
  hostBindings: function ClrPopoverAnchor_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-anchor", true);
    }
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrPopoverAnchor, [{
    type: Directive,
    args: [{
      selector: "[clrPopoverAnchor]",
      host: {
        "[class.clr-anchor]": "true"
      }
    }]
  }], function() {
    return [{
      type: ClrPopoverEventsService
    }, {
      type: ElementRef
    }];
  }, null);
})();
var ClrPopoverCloseButton = class {
  constructor(elementRef, smartEventsService, smartOpenService) {
    this.elementRef = elementRef;
    this.smartEventsService = smartEventsService;
    this.smartOpenService = smartOpenService;
    this.closeChange = new EventEmitter();
    this.subscriptions = [];
    this.subscriptions.push(smartOpenService.openChange.pipe(filter((value) => !value)).subscribe(() => {
      this.closeChange.next();
    }));
  }
  handleClick(event) {
    this.smartOpenService.toggleWithEvent(event);
    this.smartEventsService.setAnchorFocus();
  }
  ngAfterViewInit() {
    this.smartEventsService.closeButtonRef = this.elementRef;
    this.smartEventsService.setCloseFocus();
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
};
ClrPopoverCloseButton.ɵfac = function ClrPopoverCloseButton_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrPopoverCloseButton)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ClrPopoverEventsService), ɵɵdirectiveInject(ClrPopoverToggleService));
};
ClrPopoverCloseButton.ɵdir = ɵɵdefineDirective({
  type: ClrPopoverCloseButton,
  selectors: [["", "clrPopoverCloseButton", ""]],
  hostVars: 2,
  hostBindings: function ClrPopoverCloseButton_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function ClrPopoverCloseButton_click_HostBindingHandler($event) {
        return ctx.handleClick($event);
      });
    }
    if (rf & 2) {
      ɵɵclassProp("clr-smart-close-button", true);
    }
  },
  outputs: {
    closeChange: "clrPopoverOnCloseChange"
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrPopoverCloseButton, [{
    type: Directive,
    args: [{
      selector: "[clrPopoverCloseButton]",
      host: {
        "[class.clr-smart-close-button]": "true"
      }
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ClrPopoverEventsService
    }, {
      type: ClrPopoverToggleService
    }];
  }, {
    closeChange: [{
      type: Output,
      args: ["clrPopoverOnCloseChange"]
    }],
    handleClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var ClrAxis;
(function(ClrAxis2) {
  ClrAxis2[ClrAxis2["VERTICAL"] = 0] = "VERTICAL";
  ClrAxis2[ClrAxis2["HORIZONTAL"] = 1] = "HORIZONTAL";
})(ClrAxis || (ClrAxis = {}));
var ClrAlignment;
(function(ClrAlignment2) {
  ClrAlignment2[ClrAlignment2["START"] = 0] = "START";
  ClrAlignment2[ClrAlignment2["CENTER"] = 0.5] = "CENTER";
  ClrAlignment2[ClrAlignment2["END"] = 1] = "END";
})(ClrAlignment || (ClrAlignment = {}));
var ClrViewportViolation;
(function(ClrViewportViolation2) {
  ClrViewportViolation2[ClrViewportViolation2["BOTTOM"] = 0] = "BOTTOM";
  ClrViewportViolation2[ClrViewportViolation2["LEFT"] = 1] = "LEFT";
  ClrViewportViolation2[ClrViewportViolation2["RIGHT"] = 2] = "RIGHT";
  ClrViewportViolation2[ClrViewportViolation2["TOP"] = 3] = "TOP";
})(ClrViewportViolation || (ClrViewportViolation = {}));
var flipSides = (position) => {
  return __spreadProps(__spreadValues({}, position), {
    side: -1 * position.side
  });
};
var nudgeContent = (position, forward) => {
  const nextAlignment = position.content + (forward ? 0.5 : -0.5);
  if (nextAlignment < 0 || nextAlignment > 1) {
    return position;
  } else {
    return __spreadProps(__spreadValues({}, position), {
      content: nextAlignment
    });
  }
};
function flipSidesAndNudgeContent(flip, nudge, nudgeBack) {
  return (position) => nudge(flip(position), nudgeBack);
}
function align(position, anchor, content) {
  let xDiff = anchor.left;
  let yDiff = anchor.top;
  switch (position.axis + position.side) {
    case -1: {
      xDiff += alignHorizontal(position, anchor, content);
      yDiff -= content.height;
      break;
    }
    case 1: {
      xDiff += alignHorizontal(position, anchor, content);
      yDiff += anchor.height;
      break;
    }
    case 0: {
      xDiff -= content.width;
      yDiff += alignVertical(position, anchor, content);
      break;
    }
    case 2: {
      xDiff += anchor.width;
      yDiff += alignVertical(position, anchor, content);
      break;
    }
    default: {
      break;
    }
  }
  return {
    xOffset: xDiff,
    yOffset: yDiff
  };
}
function alignHorizontal(position, anchor, content) {
  let horizontalOffset = 0;
  switch (position.anchor) {
    case ClrAlignment.START: {
      break;
    }
    case ClrAlignment.CENTER: {
      horizontalOffset += anchor.width / 2;
      break;
    }
    case ClrAlignment.END: {
      horizontalOffset += anchor.width;
      break;
    }
    default: {
      break;
    }
  }
  switch (position.content) {
    case ClrAlignment.START: {
      break;
    }
    case ClrAlignment.CENTER: {
      horizontalOffset -= content.width / 2;
      break;
    }
    case ClrAlignment.END: {
      horizontalOffset -= content.width;
      break;
    }
    default: {
      break;
    }
  }
  return horizontalOffset;
}
function alignVertical(position, anchor, content) {
  let verticalOffset = 0;
  switch (position.anchor) {
    case ClrAlignment.START: {
      break;
    }
    case ClrAlignment.CENTER: {
      verticalOffset += anchor.height / 2;
      break;
    }
    case ClrAlignment.END: {
      verticalOffset += anchor.height;
      break;
    }
    default: {
      break;
    }
  }
  switch (position.content) {
    case ClrAlignment.START: {
      break;
    }
    case ClrAlignment.CENTER: {
      verticalOffset -= content.height / 2;
      break;
    }
    case ClrAlignment.END: {
      verticalOffset -= content.height;
      break;
    }
    default: {
      break;
    }
  }
  return verticalOffset;
}
function testVisibility(offset, content) {
  const violations = [];
  const mockCoords = {
    bottom: offset.yOffset + content.height,
    left: offset.xOffset,
    right: offset.xOffset + content.width,
    top: offset.yOffset
  };
  if (!(mockCoords.top >= 0)) {
    violations.push(ClrViewportViolation.TOP);
  }
  if (!(mockCoords.left >= 0)) {
    violations.push(ClrViewportViolation.LEFT);
  }
  if (!(mockCoords.bottom <= (window.innerHeight || document.documentElement.clientHeight))) {
    violations.push(ClrViewportViolation.BOTTOM);
  }
  if (!(mockCoords.right <= (window.innerWidth || document.documentElement.clientWidth))) {
    violations.push(ClrViewportViolation.RIGHT);
  }
  return violations;
}
var ClrPopoverPositionService = class {
  constructor(eventService, platformId) {
    this.eventService = eventService;
    this.platformId = platformId;
    this._shouldRealign = new Subject();
    this.shouldRealign = this._shouldRealign.asObservable();
  }
  realign() {
    this._shouldRealign.next();
  }
  alignContent(content) {
    if (!isPlatformBrowser(this.platformId)) {
      return {
        xOffset: 0,
        yOffset: 0
      };
    }
    this.currentAnchorCoords = this.eventService.anchorButtonRef.nativeElement.getBoundingClientRect();
    this.currentContentCoords = content.getBoundingClientRect();
    this.contentOffsets = align(this.position, this.currentAnchorCoords, this.currentContentCoords);
    const visibilityViolations = testVisibility(this.contentOffsets, this.currentContentCoords);
    const errorSum = visibilityViolations.reduce((count, current) => {
      return count + current;
    }, 0);
    if (visibilityViolations.length === 1 && this.position.axis === ClrAxis.VERTICAL) {
      this.handleVerticalAxisOneViolation(errorSum);
    } else if (visibilityViolations.length === 1 && this.position.axis === ClrAxis.HORIZONTAL) {
      this.handleHorizontalAxisOneViolation(errorSum);
    } else if (visibilityViolations.length === 2 && this.position.axis === ClrAxis.VERTICAL) {
      this.handleVerticalAxisTwoViolations(errorSum);
    } else if (visibilityViolations.length === 2 && this.position.axis === ClrAxis.HORIZONTAL) {
      this.handleHorizontalAxisTwoViolations(errorSum);
    }
    if (this.currentContentCoords.top < 0) {
      this.contentOffsets.yOffset += Math.abs(this.currentContentCoords.top);
    }
    if (this.contentOffsets.yOffset + this.currentAnchorCoords.y < 0) {
      this.contentOffsets.yOffset = 0 - this.currentContentCoords.top;
    }
    return this.contentOffsets;
  }
  handleVerticalAxisOneViolation(errorSum) {
    switch (errorSum) {
      case 0:
      case 3: {
        this.contentOffsets = align(flipSides(this.position), this.currentAnchorCoords, this.currentContentCoords);
        break;
      }
      case 1: {
        this.contentOffsets = align(this.position, this.currentAnchorCoords, this.currentContentCoords);
        if (this.contentOffsets.xOffset < 0) {
          this.contentOffsets.xOffset = 10;
        }
        break;
      }
      case 2: {
        this.contentOffsets = align(nudgeContent(this.position, true), this.currentAnchorCoords, this.currentContentCoords);
        break;
      }
      default: {
        break;
      }
    }
  }
  handleVerticalAxisTwoViolations(errorSum) {
    switch (errorSum) {
      // We know there are two violations. We can use the errorSum to determine which combination of sides were
      // violated and handle appropriately.
      case 5: {
        const flipAndNudgeLeft = flipSidesAndNudgeContent(flipSides, nudgeContent, true);
        this.contentOffsets = align(flipAndNudgeLeft(this.position), this.currentAnchorCoords, this.currentContentCoords);
        break;
      }
      case 4: {
        const flipAndNudgeRight = flipSidesAndNudgeContent(flipSides, nudgeContent, false);
        this.contentOffsets = align(flipAndNudgeRight(this.position), this.currentAnchorCoords, this.currentContentCoords);
        break;
      }
      case 3: {
        break;
      }
      case 2: {
        const flipAndNudgeLeft = flipSidesAndNudgeContent(flipSides, nudgeContent, true);
        this.contentOffsets = align(flipAndNudgeLeft(this.position), this.currentAnchorCoords, this.currentContentCoords);
        break;
      }
      case 1: {
        const flipAndNudgeRight = flipSidesAndNudgeContent(flipSides, nudgeContent, false);
        this.contentOffsets = align(flipAndNudgeRight(this.position), this.currentAnchorCoords, this.currentContentCoords);
        break;
      }
      default: {
        break;
      }
    }
  }
  handleHorizontalAxisOneViolation(errorSum) {
    switch (errorSum) {
      case 1:
      case 2: {
        this.contentOffsets = align(flipSides(this.position), this.currentAnchorCoords, this.currentContentCoords);
        break;
      }
      case 0: {
        this.contentOffsets = align(nudgeContent(this.position, true), this.currentAnchorCoords, this.currentContentCoords);
        break;
      }
      case 3: {
        this.contentOffsets = align(nudgeContent(this.position), this.currentAnchorCoords, this.currentContentCoords);
        break;
      }
      default: {
        break;
      }
    }
  }
  handleHorizontalAxisTwoViolations(errorSum) {
    switch (errorSum) {
      case 5:
      case 4: {
        const flipAndNudgeDown = flipSidesAndNudgeContent(flipSides, nudgeContent, false);
        this.contentOffsets = align(flipAndNudgeDown(this.position), this.currentAnchorCoords, this.currentContentCoords);
        break;
      }
      case 3: {
        break;
      }
      case 2:
      case 1: {
        const flipAndNudgeUp = flipSidesAndNudgeContent(flipSides, nudgeContent, true);
        this.contentOffsets = align(flipAndNudgeUp(this.position), this.currentAnchorCoords, this.currentContentCoords);
        break;
      }
      default: {
        break;
      }
    }
  }
};
ClrPopoverPositionService.ɵfac = function ClrPopoverPositionService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrPopoverPositionService)(ɵɵinject(ClrPopoverEventsService), ɵɵinject(PLATFORM_ID));
};
ClrPopoverPositionService.ɵprov = ɵɵdefineInjectable({
  token: ClrPopoverPositionService,
  factory: ClrPopoverPositionService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrPopoverPositionService, [{
    type: Injectable
  }], function() {
    return [{
      type: ClrPopoverEventsService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }];
  }, null);
})();
var ClrPopoverContent = class {
  constructor(document2, container, template, renderer, smartPositionService, smartEventsService, smartOpenService) {
    this.document = document2;
    this.container = container;
    this.template = template;
    this.renderer = renderer;
    this.smartPositionService = smartPositionService;
    this.smartEventsService = smartEventsService;
    this.smartOpenService = smartOpenService;
    this.subscriptions = [];
    this.removeClickListenerFn = null;
    this.shouldRealign = false;
    this.previousContentHeight = null;
    this.checkCollector = new EventEmitter();
  }
  set open(value) {
    this.smartOpenService.open = !!value;
  }
  set contentAt(position) {
    this.smartPositionService.position = position;
  }
  set outsideClickClose(clickToClose) {
    this.smartEventsService.outsideClickClose = !!clickToClose;
  }
  set scrollToClose(scrollToClose) {
    this.smartEventsService.scrollToClose = !!scrollToClose;
  }
  ngAfterContentChecked() {
    if (this.smartOpenService.open && this.view) {
      const rootNodeOffsetHeight = this.view.rootNodes[0].offsetHeight;
      if (this.shouldRealign || this.previousContentHeight !== null && this.previousContentHeight !== rootNodeOffsetHeight) {
        this.previousContentHeight = rootNodeOffsetHeight;
        this.checkCollector.emit();
      }
    }
  }
  ngAfterViewInit() {
    this.subscriptions.push(
      this.smartOpenService.openChange.subscribe((change) => {
        if (change) {
          this.addContent();
        } else {
          this.removeContent();
        }
      }),
      this.smartPositionService.shouldRealign.subscribe(() => {
        this.shouldRealign = true;
      }),
      // Here we collect subsequent synchronously received content-check events and only take action
      // at the end of the cycle. See below for details on the check-collector pattern.
      this.checkCollector.pipe(debounceTime(0)).subscribe(() => {
        this.alignContent();
        this.shouldRealign = false;
        if (this.view) {
          this.renderer.setStyle(this.view.rootNodes[0], "opacity", "1");
          this.smartOpenService.popoverVisibleEmit(true);
        }
      })
    );
  }
  ngOnDestroy() {
    this.removeContent();
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
  /**
   * TODO(matt): investigate why DebugElement retains a reference to the nodes and causes a memory leak.
   * A note about the use of appendChild/removeChild
   * The DebugElement is keeping a reference to the detached node and its unclear why.
   * This does warrant further investigation. But, since it doesn't happen in production mode
   * it is a low priority issue for now.
   */
  addContent() {
    this.view = this.container.createEmbeddedView(this.template);
    const [rootNode] = this.view.rootNodes;
    this.smartEventsService.contentRef = rootNode;
    this.renderer.addClass(rootNode, "clr-popover-content");
    this.renderer.setStyle(rootNode, "top", "0px");
    this.renderer.setStyle(rootNode, "left", "0px");
    this.renderer.setStyle(rootNode, "opacity", "0");
    this.removeClickListenerFn = this.renderer.listen(rootNode, "click", (event) => {
      this.smartOpenService.openEvent = event;
    });
    this.view.rootNodes.forEach((node) => {
      this.renderer.appendChild(this.document.body, node);
    });
    this.shouldRealign = true;
  }
  removeContent() {
    if (!this.view) {
      return;
    }
    if (this.removeClickListenerFn) {
      this.removeClickListenerFn();
      this.removeClickListenerFn = null;
    }
    this.view.rootNodes.forEach((node) => this.renderer.removeChild(this.document.body, node));
    this.container.clear();
    delete this.view;
    this.smartOpenService.popoverVisibleEmit(false);
  }
  alignContent() {
    if (!this.view) {
      return;
    }
    const positionCoords = this.smartPositionService.alignContent(this.view.rootNodes[0]);
    this.renderer.setStyle(this.view.rootNodes[0], "top", `${positionCoords.yOffset}px`);
    this.renderer.setStyle(this.view.rootNodes[0], "left", `${positionCoords.xOffset}px`);
    this.smartOpenService.popoverAlignedEmit(this.view.rootNodes[0]);
  }
};
ClrPopoverContent.ɵfac = function ClrPopoverContent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrPopoverContent)(ɵɵdirectiveInject(DOCUMENT), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ClrPopoverPositionService), ɵɵdirectiveInject(ClrPopoverEventsService), ɵɵdirectiveInject(ClrPopoverToggleService));
};
ClrPopoverContent.ɵdir = ɵɵdefineDirective({
  type: ClrPopoverContent,
  selectors: [["", "clrPopoverContent", ""]],
  inputs: {
    open: [0, "clrPopoverContent", "open"],
    contentAt: [0, "clrPopoverContentAt", "contentAt"],
    outsideClickClose: [0, "clrPopoverContentOutsideClickToClose", "outsideClickClose"],
    scrollToClose: [0, "clrPopoverContentScrollToClose", "scrollToClose"]
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrPopoverContent, [{
    type: Directive,
    args: [{
      selector: "[clrPopoverContent]"
    }]
  }], function() {
    return [{
      type: Document,
      decorators: [{
        type: Inject,
        args: [DOCUMENT]
      }]
    }, {
      type: ViewContainerRef
    }, {
      type: TemplateRef
    }, {
      type: Renderer2
    }, {
      type: ClrPopoverPositionService
    }, {
      type: ClrPopoverEventsService
    }, {
      type: ClrPopoverToggleService
    }];
  }, {
    open: [{
      type: Input,
      args: ["clrPopoverContent"]
    }],
    contentAt: [{
      type: Input,
      args: ["clrPopoverContentAt"]
    }],
    outsideClickClose: [{
      type: Input,
      args: ["clrPopoverContentOutsideClickToClose"]
    }],
    scrollToClose: [{
      type: Input,
      args: ["clrPopoverContentScrollToClose"]
    }]
  });
})();
var ClrPopoverOpenCloseButton = class {
  constructor(smartOpenService) {
    this.smartOpenService = smartOpenService;
    this.openCloseChange = new EventEmitter();
    this.subscriptions = [];
    this.subscriptions.push(smartOpenService.openChange.subscribe((change) => {
      this.openCloseChange.next(change);
    }));
  }
  handleClick(event) {
    this.smartOpenService.toggleWithEvent(event);
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
};
ClrPopoverOpenCloseButton.ɵfac = function ClrPopoverOpenCloseButton_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrPopoverOpenCloseButton)(ɵɵdirectiveInject(ClrPopoverToggleService));
};
ClrPopoverOpenCloseButton.ɵdir = ɵɵdefineDirective({
  type: ClrPopoverOpenCloseButton,
  selectors: [["", "clrPopoverOpenCloseButton", ""]],
  hostVars: 2,
  hostBindings: function ClrPopoverOpenCloseButton_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function ClrPopoverOpenCloseButton_click_HostBindingHandler($event) {
        return ctx.handleClick($event);
      });
    }
    if (rf & 2) {
      ɵɵclassProp("clr-smart-open-close", true);
    }
  },
  outputs: {
    openCloseChange: "clrPopoverOpenCloseChange"
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrPopoverOpenCloseButton, [{
    type: Directive,
    args: [{
      selector: "[clrPopoverOpenCloseButton]",
      host: {
        "[class.clr-smart-open-close]": "true"
      }
    }]
  }], function() {
    return [{
      type: ClrPopoverToggleService
    }];
  }, {
    openCloseChange: [{
      type: Output,
      args: ["clrPopoverOpenCloseChange"]
    }],
    handleClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var ClrPopoverModuleNext = class {
};
ClrPopoverModuleNext.ɵfac = function ClrPopoverModuleNext_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrPopoverModuleNext)();
};
ClrPopoverModuleNext.ɵmod = ɵɵdefineNgModule({
  type: ClrPopoverModuleNext,
  declarations: [ClrPopoverAnchor, ClrPopoverCloseButton, ClrPopoverOpenCloseButton, ClrPopoverContent],
  exports: [ClrPopoverAnchor, ClrPopoverCloseButton, ClrPopoverOpenCloseButton, ClrPopoverContent]
});
ClrPopoverModuleNext.ɵinj = ɵɵdefineInjector({});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrPopoverModuleNext, [{
    type: NgModule,
    args: [{
      imports: [],
      declarations: [ClrPopoverAnchor, ClrPopoverCloseButton, ClrPopoverOpenCloseButton, ClrPopoverContent],
      exports: [ClrPopoverAnchor, ClrPopoverCloseButton, ClrPopoverOpenCloseButton, ClrPopoverContent]
    }]
  }], null, null);
})();
var ButtonInGroupService = class {
  constructor() {
    this._changes = new Subject();
  }
  get changes() {
    return this._changes.asObservable();
  }
  updateButtonGroup(button) {
    this._changes.next(button);
  }
};
ButtonInGroupService.ɵfac = function ButtonInGroupService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ButtonInGroupService)();
};
ButtonInGroupService.ɵprov = ɵɵdefineInjectable({
  token: ButtonInGroupService,
  factory: ButtonInGroupService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ButtonInGroupService, [{
    type: Injectable
  }], null, null);
})();
var ClrButton = class {
  constructor(buttonInGroupService) {
    this.buttonInGroupService = buttonInGroupService;
    this._click = new EventEmitter(false);
    this._inMenu = false;
    this._enableService = false;
    this._classNames = "btn";
    this._name = null;
    this._type = null;
    this._disabled = null;
    this._id = uniqueIdFactory();
  }
  get inMenu() {
    return this._inMenu;
  }
  set inMenu(value) {
    value = !!value;
    if (this._inMenu !== value) {
      this._inMenu = value;
      if (this._enableService && this.buttonInGroupService) {
        this.buttonInGroupService.updateButtonGroup(this);
      }
    }
  }
  get classNames() {
    return this._classNames;
  }
  set classNames(value) {
    if (typeof value === "string") {
      const classNames = value.split(" ");
      if (classNames.indexOf("btn") === -1) {
        classNames.push("btn");
      }
      this._classNames = classNames.join(" ");
    }
  }
  get name() {
    return this._name;
  }
  set name(value) {
    if (typeof value === "string") {
      this._name = value;
    }
  }
  get type() {
    return this._type;
  }
  set type(value) {
    if (typeof value === "string") {
      this._type = value;
    }
  }
  get id() {
    return this._id;
  }
  set id(value) {
    if (typeof value === "string") {
      this._id = value;
    }
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    if (value !== null && value !== false) {
      this._disabled = "";
    } else {
      this._disabled = null;
    }
  }
  get role() {
    return this.inMenu ? "menuitem" : null;
  }
  ngAfterViewInit() {
    this._enableService = true;
  }
  loadingStateChange(state2) {
    this.loading = state2 === ClrLoadingState.LOADING;
  }
  emitClick() {
    this._click.emit(true);
  }
};
ClrButton.ɵfac = function ClrButton_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrButton)(ɵɵdirectiveInject(ButtonInGroupService, 12));
};
ClrButton.ɵcmp = ɵɵdefineComponent({
  type: ClrButton,
  selectors: [["clr-button"]],
  viewQuery: function ClrButton_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c7, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.templateRef = _t.first);
    }
  },
  inputs: {
    inMenu: [0, "clrInMenu", "inMenu"],
    classNames: [0, "class", "classNames"],
    name: "name",
    type: "type",
    id: "id",
    disabled: "disabled"
  },
  outputs: {
    _click: "click"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([{
    provide: LoadingListener,
    useExisting: ClrButton
  }])],
  ngContentSelectors: _c02,
  decls: 2,
  vars: 0,
  consts: [["buttonProjectedRef", ""], [3, "click"], ["class", "spinner spinner-inline", 4, "ngIf"], [1, "spinner", "spinner-inline"]],
  template: function ClrButton_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, ClrButton_ng_template_0_Template, 3, 8, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    }
  },
  dependencies: [NgIf],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrButton, [{
    type: Component,
    args: [{
      selector: "clr-button",
      template: `
    <ng-template #buttonProjectedRef>
      <button
        [class]="classNames"
        (click)="emitClick()"
        [attr.type]="type"
        [attr.name]="name"
        [attr.disabled]="disabled"
        [attr.role]="role"
        [attr.id]="id"
      >
        <span class="spinner spinner-inline" *ngIf="loading"></span>
        <ng-content></ng-content>
      </button>
    </ng-template>
  `,
      providers: [{
        provide: LoadingListener,
        useExisting: ClrButton
      }]
    }]
  }], function() {
    return [{
      type: ButtonInGroupService,
      decorators: [{
        type: SkipSelf
      }, {
        type: Optional
      }]
    }];
  }, {
    _click: [{
      type: Output,
      args: ["click"]
    }],
    templateRef: [{
      type: ViewChild,
      args: ["buttonProjectedRef", {
        static: true
      }]
    }],
    inMenu: [{
      type: Input,
      args: ["clrInMenu"]
    }],
    classNames: [{
      type: Input,
      args: ["class"]
    }],
    name: [{
      type: Input,
      args: ["name"]
    }],
    type: [{
      type: Input,
      args: ["type"]
    }],
    id: [{
      type: Input,
      args: ["id"]
    }],
    disabled: [{
      type: Input,
      args: ["disabled"]
    }]
  });
})();
var ClrDestroyService = class extends Subject {
  ngOnDestroy() {
    this.next();
    this.complete();
  }
};
ClrDestroyService.ɵfac = /* @__PURE__ */ (() => {
  let ɵClrDestroyService_BaseFactory;
  return function ClrDestroyService_Factory(__ngFactoryType__) {
    return (ɵClrDestroyService_BaseFactory || (ɵClrDestroyService_BaseFactory = ɵɵgetInheritedFactory(ClrDestroyService)))(__ngFactoryType__ || ClrDestroyService);
  };
})();
ClrDestroyService.ɵprov = ɵɵdefineInjectable({
  token: ClrDestroyService,
  factory: ClrDestroyService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDestroyService, [{
    type: Injectable
  }], null, null);
})();
var ArrowKeyDirection;
(function(ArrowKeyDirection2) {
  ArrowKeyDirection2["UP"] = "up";
  ArrowKeyDirection2["DOWN"] = "down";
  ArrowKeyDirection2["LEFT"] = "left";
  ArrowKeyDirection2["RIGHT"] = "right";
})(ArrowKeyDirection || (ArrowKeyDirection = {}));
var FocusService$1 = class FocusService {
  constructor(renderer) {
    this.renderer = renderer;
    this._unlistenFuncs = [];
  }
  get current() {
    return this._current;
  }
  reset(first2) {
    this._current = first2;
  }
  listenToArrowKeys(el) {
    this._unlistenFuncs.push(this.renderer.listen(el, "keydown.arrowup", () => !this.move(ArrowKeyDirection.UP)));
    this._unlistenFuncs.push(this.renderer.listen(el, "keydown.arrowdown", () => !this.move(ArrowKeyDirection.DOWN)));
    this._unlistenFuncs.push(this.renderer.listen(el, "keydown.arrowleft", () => !this.move(ArrowKeyDirection.LEFT)));
    this._unlistenFuncs.push(this.renderer.listen(el, "keydown.arrowright", () => !this.move(ArrowKeyDirection.RIGHT)));
  }
  registerContainer(el, tabIndex = "0") {
    this.renderer.setAttribute(el, "tabindex", tabIndex);
    this.listenToArrowKeys(el);
    this._unlistenFuncs.push(this.renderer.listen(el, "keydown.space", () => !this.activateCurrent()));
    this._unlistenFuncs.push(this.renderer.listen(el, "keydown.enter", () => !this.activateCurrent()));
  }
  moveTo(item) {
    if (item === void 0) {
      return;
    }
    if (this.current) {
      this.current.blur();
    }
    item.focus();
    this._current = item;
  }
  move(direction) {
    let moved = false;
    if (this.current) {
      const next = this.current[direction];
      if (next) {
        const nextObs = isObservable(next) ? next : of(next);
        nextObs.subscribe((item) => {
          if (item) {
            this.moveTo(item);
            moved = true;
          }
        });
      }
    }
    return moved;
  }
  activateCurrent() {
    if (this.current && this.current.activate) {
      this.current.activate();
      return true;
    }
    return false;
  }
  detachListeners() {
    this._unlistenFuncs.forEach((unlisten) => unlisten());
  }
};
FocusService$1.ɵfac = function FocusService$1_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || FocusService$1)(ɵɵinject(Renderer2));
};
FocusService$1.ɵprov = ɵɵdefineInjectable({
  token: FocusService$1,
  factory: FocusService$1.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusService$1, [{
    type: Injectable
  }], function() {
    return [{
      type: Renderer2
    }];
  }, null);
})();
function clrFocusServiceFactory(existing, renderer) {
  return existing || new FocusService$1(renderer);
}
var FOCUS_SERVICE_PROVIDER = {
  provide: FocusService$1,
  useFactory: clrFocusServiceFactory,
  deps: [[new Optional(), new SkipSelf(), FocusService$1], Renderer2]
};
var ClrSide;
(function(ClrSide2) {
  ClrSide2[ClrSide2["BEFORE"] = -1] = "BEFORE";
  ClrSide2[ClrSide2["AFTER"] = 1] = "AFTER";
})(ClrSide || (ClrSide = {}));
var ClrPopoverPositions = class {
};
ClrPopoverPositions["top-right"] = {
  axis: ClrAxis.VERTICAL,
  side: ClrSide.BEFORE,
  anchor: ClrAlignment.END,
  content: ClrAlignment.END
};
ClrPopoverPositions["top-left"] = {
  axis: ClrAxis.VERTICAL,
  side: ClrSide.BEFORE,
  anchor: ClrAlignment.START,
  content: ClrAlignment.START
};
ClrPopoverPositions["bottom-right"] = {
  axis: ClrAxis.VERTICAL,
  side: ClrSide.AFTER,
  anchor: ClrAlignment.END,
  content: ClrAlignment.END
};
ClrPopoverPositions["bottom-left"] = {
  axis: ClrAxis.VERTICAL,
  side: ClrSide.AFTER,
  anchor: ClrAlignment.START,
  content: ClrAlignment.START
};
ClrPopoverPositions["right-top"] = {
  axis: ClrAxis.HORIZONTAL,
  side: ClrSide.AFTER,
  anchor: ClrAlignment.CENTER,
  content: ClrAlignment.END
};
ClrPopoverPositions["right-bottom"] = {
  axis: ClrAxis.HORIZONTAL,
  side: ClrSide.AFTER,
  anchor: ClrAlignment.START,
  content: ClrAlignment.START
};
ClrPopoverPositions["left-top"] = {
  axis: ClrAxis.HORIZONTAL,
  side: ClrSide.BEFORE,
  anchor: ClrAlignment.CENTER,
  content: ClrAlignment.END
};
ClrPopoverPositions["left-bottom"] = {
  axis: ClrAxis.HORIZONTAL,
  side: ClrSide.BEFORE,
  anchor: ClrAlignment.START,
  content: ClrAlignment.START
};
var POPOVER_HOST_ANCHOR = new InjectionToken("POPOVER_HOST_ANCHOR");
var ClrStopEscapePropagationDirective = class {
  constructor(toggleService) {
    this.toggleService = toggleService;
    this.lastOpenChange = null;
  }
  ngOnInit() {
    this.subscription = this.toggleService.openChange.subscribe((open) => {
      this.lastOpenChange = open;
    });
  }
  ngOnDestroy() {
    this.subscription?.unsubscribe();
  }
  onEscapeKey(event) {
    if (this.lastOpenChange !== null) {
      if (this.lastOpenChange === false) {
        event.stopPropagation();
      }
      this.lastOpenChange = null;
    }
  }
};
ClrStopEscapePropagationDirective.ɵfac = function ClrStopEscapePropagationDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrStopEscapePropagationDirective)(ɵɵdirectiveInject(ClrPopoverToggleService));
};
ClrStopEscapePropagationDirective.ɵdir = ɵɵdefineDirective({
  type: ClrStopEscapePropagationDirective,
  hostBindings: function ClrStopEscapePropagationDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("keyup.escape", function ClrStopEscapePropagationDirective_keyup_escape_HostBindingHandler($event) {
        return ctx.onEscapeKey($event);
      });
    }
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrStopEscapePropagationDirective, [{
    type: Directive,
    args: [{
      standalone: true
    }]
  }], function() {
    return [{
      type: ClrPopoverToggleService
    }];
  }, {
    onEscapeKey: [{
      type: HostListener,
      args: ["keyup.escape", ["$event"]]
    }]
  });
})();
var ClrPopoverHostDirective = class {
};
ClrPopoverHostDirective.ɵfac = function ClrPopoverHostDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrPopoverHostDirective)();
};
ClrPopoverHostDirective.ɵdir = ɵɵdefineDirective({
  type: ClrPopoverHostDirective,
  features: [ɵɵProvidersFeature([ClrPopoverToggleService, ClrPopoverEventsService, ClrPopoverPositionService, {
    provide: POPOVER_HOST_ANCHOR,
    useExisting: ElementRef
  }]), ɵɵHostDirectivesFeature([ClrStopEscapePropagationDirective])]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrPopoverHostDirective, [{
    type: Directive,
    args: [{
      standalone: true,
      providers: [ClrPopoverToggleService, ClrPopoverEventsService, ClrPopoverPositionService, {
        provide: POPOVER_HOST_ANCHOR,
        useExisting: ElementRef
      }],
      hostDirectives: [ClrStopEscapePropagationDirective]
    }]
  }], null, null);
})();
var Linkers = class {
  /**
   * Links a set of focusable items to a parent along one direction
   */
  static linkParent(items, parent, direction) {
    items.forEach((item) => item[direction] = parent);
  }
  /**
   * Double-links a set of focusable items vertically, possibly looping
   */
  static linkVertical(items, loop = true) {
    items.forEach((item, index) => {
      if (index > 0) {
        item.up = items[index - 1];
      }
      if (index < items.length - 1) {
        item.down = items[index + 1];
      }
    });
    if (loop && items.length > 1) {
      items[0].up = items[items.length - 1];
      items[items.length - 1].down = items[0];
    }
  }
};
var InitialFocus;
(function(InitialFocus2) {
  InitialFocus2["FIRST_ITEM"] = "first";
  InitialFocus2["LAST_ITEM"] = "last";
})(InitialFocus || (InitialFocus = {}));
function collapse() {
  "use strict";
  return [state("true", style({
    height: 0,
    "overflow-y": "hidden"
  })), transition("true => false", [animate(defaultAnimationTiming, style({
    height: "*",
    "overflow-y": "hidden"
  }))]), transition("false => true", [style({
    height: "*",
    "overflow-y": "hidden"
  }), animate(defaultAnimationTiming)])];
}
var DomAdapter = class {
  /*
    We clone the element and take its measurements from outside the grid
    so we don't trigger reflow for the whole datagrid.
  */
  userDefinedWidth(element) {
    const clonedElement = element.cloneNode(true);
    if (clonedElement.id) {
      clonedElement.id = clonedElement.id + "-clone";
    }
    clonedElement.classList.add("datagrid-cell-width-zero");
    document.body.appendChild(clonedElement);
    const userDefinedWidth = this.clientRect(clonedElement).width;
    clonedElement.remove();
    return userDefinedWidth;
  }
  scrollBarWidth(element) {
    return element.offsetWidth - element.clientWidth;
  }
  scrollWidth(element) {
    return element.scrollWidth || 0;
  }
  computedHeight(element) {
    return parseInt(getComputedStyle(element).getPropertyValue("height"), 10);
  }
  clientRect(element) {
    const elementClientRect = element.getBoundingClientRect();
    return {
      top: parseInt(elementClientRect.top, 10),
      bottom: parseInt(elementClientRect.bottom, 10),
      left: parseInt(elementClientRect.left, 10),
      right: parseInt(elementClientRect.right, 10),
      width: parseInt(elementClientRect.width, 10),
      height: parseInt(elementClientRect.height, 10)
    };
  }
  minWidth(element) {
    return parseInt(getComputedStyle(element).getPropertyValue("min-width"), 10);
  }
  focus(element) {
    element.focus();
  }
};
DomAdapter.ɵfac = function DomAdapter_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || DomAdapter)();
};
DomAdapter.ɵprov = ɵɵdefineInjectable({
  token: DomAdapter,
  factory: DomAdapter.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DomAdapter, [{
    type: Injectable
  }], null, null);
})();
var ClrExpandableAnimation = class {
  constructor(element, domAdapter, renderer) {
    this.element = element;
    this.domAdapter = domAdapter;
    this.renderer = renderer;
    this.clrExpandTrigger = false;
    this.startHeight = 0;
  }
  get expandAnimation() {
    return {
      value: this.clrExpandTrigger,
      params: {
        startHeight: this.startHeight
      }
    };
  }
  animationStart(event) {
    if (event.fromState !== "void") {
      this.renderer.setStyle(this.element.nativeElement, "overflow", "hidden");
    }
  }
  animationDone(event) {
    if (event.fromState !== "void") {
      this.renderer.removeStyle(this.element.nativeElement, "overflow");
      this.updateStartHeight();
    }
  }
  updateStartHeight() {
    this.startHeight = this.domAdapter.computedHeight(this.element.nativeElement) || 0;
  }
};
ClrExpandableAnimation.ɵfac = function ClrExpandableAnimation_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrExpandableAnimation)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(DomAdapter), ɵɵdirectiveInject(Renderer2));
};
ClrExpandableAnimation.ɵcmp = ɵɵdefineComponent({
  type: ClrExpandableAnimation,
  selectors: [["clr-expandable-animation"]],
  hostVars: 1,
  hostBindings: function ClrExpandableAnimation_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵsyntheticHostListener("@expandAnimation.start", function ClrExpandableAnimation_animation_expandAnimation_start_HostBindingHandler($event) {
        return ctx.animationStart($event);
      })("@expandAnimation.done", function ClrExpandableAnimation_animation_expandAnimation_done_HostBindingHandler($event) {
        return ctx.animationDone($event);
      });
    }
    if (rf & 2) {
      ɵɵsyntheticHostProperty("@expandAnimation", ctx.expandAnimation);
    }
  },
  inputs: {
    clrExpandTrigger: "clrExpandTrigger"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([DomAdapter])],
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrExpandableAnimation_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  styles: ["[_nghost-%COMP%]{display:block}"],
  data: {
    animation: [trigger("expandAnimation", [transition("true <=> false", [style({
      height: "{{startHeight}}px"
    }), animate("0.2s ease-in-out", style({
      height: "*"
    }))])])]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrExpandableAnimation, [{
    type: Component,
    args: [{
      selector: "clr-expandable-animation",
      template: `<ng-content></ng-content>`,
      animations: [trigger("expandAnimation", [transition("true <=> false", [style({
        height: "{{startHeight}}px"
      }), animate("0.2s ease-in-out", style({
        height: "*"
      }))])])],
      providers: [DomAdapter],
      styles: [":host{display:block}\n"]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: DomAdapter
    }, {
      type: Renderer2
    }];
  }, {
    clrExpandTrigger: [{
      type: Input
    }],
    expandAnimation: [{
      type: HostBinding,
      args: ["@expandAnimation"]
    }],
    animationStart: [{
      type: HostListener,
      args: ["@expandAnimation.start", ["$event"]]
    }],
    animationDone: [{
      type: HostListener,
      args: ["@expandAnimation.done", ["$event"]]
    }]
  });
})();
var EXPANDABLE_ANIMATION_DIRECTIVES = [ClrExpandableAnimation];
function fade(opacity = 1) {
  return [transition("void => *", [style({
    opacity: 0
  }), animate(defaultAnimationTiming, style({
    opacity
  }))]), transition("* => void", [animate(defaultAnimationTiming, style({
    opacity: 0
  }))])];
}
function fadeSlide(direction) {
  let transform = null;
  if (direction === "up") {
    transform = "translate(0, 25%)";
  } else if (direction === "down") {
    transform = "translate(0, -25%)";
  } else if (direction === "left") {
    transform = "translate(25%, 0)";
  } else if (direction === "right") {
    transform = "translate(-25%, 0)";
  } else {
    throw new Error("Unknown direction " + direction + " for slide animation.");
  }
  return [transition("void => *", [style({
    opacity: 0,
    transform
  }), animate(defaultAnimationTiming)]), transition("* => void", [animate(defaultAnimationTiming, style({
    opacity: 0,
    transform
  }))])];
}
function slide(direction) {
  let transform = null;
  if (direction === "up") {
    transform = "translate(0, 25%)";
  } else if (direction === "down") {
    transform = "translate(0, -25%)";
  } else if (direction === "left") {
    transform = "translate(25%, 0)";
  } else if (direction === "right") {
    transform = "translate(-25%, 0)";
  } else {
    throw new Error("Unknown direction " + direction + " for slide animation.");
  }
  return [transition("void => *", [style({
    transform
  }), animate(defaultAnimationTiming)]), transition("* => void", [animate(defaultAnimationTiming, style({
    transform
  }))])];
}
var CLR_LOADING_DIRECTIVES = [ClrLoading];
var ClrLoadingModule = class {
};
ClrLoadingModule.ɵfac = function ClrLoadingModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrLoadingModule)();
};
ClrLoadingModule.ɵmod = ɵɵdefineNgModule({
  type: ClrLoadingModule,
  declarations: [ClrLoading],
  imports: [CommonModule],
  exports: [ClrLoading]
});
ClrLoadingModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrLoadingModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [CLR_LOADING_DIRECTIVES],
      exports: [CLR_LOADING_DIRECTIVES]
    }]
  }], null, null);
})();
var activeCounter = 0;
var IF_ACTIVE_ID = new InjectionToken("IF_ACTIVE_ID");
function tokenFactory$1() {
  return ++activeCounter;
}
var IF_ACTIVE_ID_PROVIDER = {
  provide: IF_ACTIVE_ID,
  useFactory: tokenFactory$1
};
var IfActiveService = class {
  constructor() {
    this._currentChange = new Subject();
  }
  /*********
   *
   * @description
   * A getter function that provides an observable for the _current Subject.
   *
   */
  get currentChange() {
    return this._currentChange.asObservable();
  }
  /*********
   *
   * @description
   * A property that gets/sets the current state of _current for this instance of IfActive structural directive.
   * And, broadcasts the new value to all subscribers.
   *
   */
  get current() {
    return this._current;
  }
  set current(value) {
    if (this._current !== value) {
      this._current = value;
      this._currentChange.next(value);
    }
  }
};
IfActiveService.ɵfac = function IfActiveService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || IfActiveService)();
};
IfActiveService.ɵprov = ɵɵdefineInjectable({
  token: IfActiveService,
  factory: IfActiveService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IfActiveService, [{
    type: Injectable
  }], null, null);
})();
var ClrIfActive = class {
  constructor(ifActiveService, id, template, container) {
    this.ifActiveService = ifActiveService;
    this.id = id;
    this.template = template;
    this.container = container;
    this.activeChange = new EventEmitter(false);
    this.wasActive = false;
    this.checkAndUpdateView(ifActiveService.current);
    this.subscription = ifActiveService.currentChange.subscribe((newCurrentId) => {
      this.checkAndUpdateView(newCurrentId);
    });
  }
  /**
   * @description
   * A property that gets/sets IfActiveService.active with value.
   *
   */
  get active() {
    return this.ifActiveService.current === this.id;
  }
  set active(value) {
    if (value) {
      this.ifActiveService.current = this.id;
    }
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
  /**
   * @description
   * Function that takes a any value and either created an embedded view for the associated ViewContainerRef or,
   * Clears all views from the ViewContainerRef
   */
  updateView(value) {
    if (value) {
      this.container.createEmbeddedView(this.template);
    } else {
      this.container.clear();
    }
  }
  checkAndUpdateView(currentId) {
    const isNowActive = currentId === this.id;
    if (isNowActive !== this.wasActive) {
      this.updateView(isNowActive);
      this.activeChange.emit(isNowActive);
      this.wasActive = isNowActive;
    }
  }
};
ClrIfActive.ɵfac = function ClrIfActive_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrIfActive)(ɵɵdirectiveInject(IfActiveService), ɵɵdirectiveInject(IF_ACTIVE_ID), ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(ViewContainerRef));
};
ClrIfActive.ɵdir = ɵɵdefineDirective({
  type: ClrIfActive,
  selectors: [["", "clrIfActive", ""]],
  inputs: {
    active: [0, "clrIfActive", "active"]
  },
  outputs: {
    activeChange: "clrIfActiveChange"
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrIfActive, [{
    type: Directive,
    args: [{
      selector: "[clrIfActive]"
    }]
  }], function() {
    return [{
      type: IfActiveService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [IF_ACTIVE_ID]
      }]
    }, {
      type: TemplateRef
    }, {
      type: ViewContainerRef
    }];
  }, {
    activeChange: [{
      type: Output,
      args: ["clrIfActiveChange"]
    }],
    active: [{
      type: Input,
      args: ["clrIfActive"]
    }]
  });
})();
var ClrIfOpen = class {
  constructor(toggleService, template, container) {
    this.toggleService = toggleService;
    this.template = template;
    this.container = container;
    this.openChange = new EventEmitter(false);
    this.subscription = toggleService.openChange.subscribe((change) => {
      this.updateView(change);
      this.openChange.emit(change);
    });
  }
  /**
   * @description
   * A property that gets/sets ClrPopoverToggleService.open with value.
   */
  get open() {
    return this.toggleService.open;
  }
  set open(value) {
    this.toggleService.open = value;
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
  /**
   * @description
   * Function that takes a boolean value and either created an embedded view for the associated ViewContainerRef or,
   * Clears all views from the ViewContainerRef
   *
   * @param value
   */
  updateView(value) {
    if (value) {
      this.container.createEmbeddedView(this.template);
    } else {
      this.container.clear();
    }
  }
};
ClrIfOpen.ɵfac = function ClrIfOpen_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrIfOpen)(ɵɵdirectiveInject(ClrPopoverToggleService), ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(ViewContainerRef));
};
ClrIfOpen.ɵdir = ɵɵdefineDirective({
  type: ClrIfOpen,
  selectors: [["", "clrIfOpen", ""]],
  inputs: {
    open: [0, "clrIfOpen", "open"]
  },
  outputs: {
    openChange: "clrIfOpenChange"
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrIfOpen, [{
    type: Directive,
    args: [{
      selector: "[clrIfOpen]"
    }]
  }], function() {
    return [{
      type: ClrPopoverToggleService
    }, {
      type: TemplateRef
    }, {
      type: ViewContainerRef
    }];
  }, {
    openChange: [{
      type: Output,
      args: ["clrIfOpenChange"]
    }],
    open: [{
      type: Input,
      args: ["clrIfOpen"]
    }]
  });
})();
var ClrIfExpanded = class {
  constructor(template, container, el, renderer, expand) {
    this.template = template;
    this.container = container;
    this.el = el;
    this.renderer = renderer;
    this.expand = expand;
    this.expandedChange = new EventEmitter(true);
    this._expanded = false;
    this._subscriptions = [];
    this._subscriptions.push(expand.expandChange.subscribe(() => {
      this.updateView();
      this.expandedChange.emit(expand.expanded);
    }));
  }
  get expanded() {
    return this._expanded;
  }
  set expanded(value) {
    if (typeof value === "boolean") {
      this.expand.expanded = value;
      this._expanded = value;
    }
  }
  ngOnInit() {
    this.expand.expandable++;
    this.updateView();
  }
  ngOnDestroy() {
    this.expand.expandable--;
    this._subscriptions.forEach((sub) => sub.unsubscribe());
  }
  updateView() {
    if (this.expand.expanded && this.container.length !== 0) {
      return;
    }
    if (this.template) {
      if (this.expand.expanded) {
        this.container.createEmbeddedView(this.template);
      } else {
        this.container.clear();
      }
    } else {
      try {
        if (this.expand.expanded) {
          this.renderer.setStyle(this.el.nativeElement, "display", null);
        } else {
          this.renderer.setStyle(this.el.nativeElement, "display", "none");
        }
      } catch (e5) {
      }
    }
  }
};
ClrIfExpanded.ɵfac = function ClrIfExpanded_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrIfExpanded)(ɵɵdirectiveInject(TemplateRef, 8), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(IfExpandService));
};
ClrIfExpanded.ɵdir = ɵɵdefineDirective({
  type: ClrIfExpanded,
  selectors: [["", "clrIfExpanded", ""]],
  inputs: {
    expanded: [0, "clrIfExpanded", "expanded"]
  },
  outputs: {
    expandedChange: "clrIfExpandedChange"
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrIfExpanded, [{
    type: Directive,
    args: [{
      selector: "[clrIfExpanded]"
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ViewContainerRef
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: IfExpandService
    }];
  }, {
    expandedChange: [{
      type: Output,
      args: ["clrIfExpandedChange"]
    }],
    expanded: [{
      type: Input,
      args: ["clrIfExpanded"]
    }]
  });
})();
var CONDITIONAL_DIRECTIVES = [ClrIfActive, ClrIfOpen, ClrIfExpanded];
var ClrConditionalModule = class {
};
ClrConditionalModule.ɵfac = function ClrConditionalModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrConditionalModule)();
};
ClrConditionalModule.ɵmod = ɵɵdefineNgModule({
  type: ClrConditionalModule,
  declarations: [ClrIfActive, ClrIfOpen, ClrIfExpanded],
  imports: [CommonModule],
  exports: [ClrIfActive, ClrIfOpen, ClrIfExpanded]
});
ClrConditionalModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrConditionalModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [CONDITIONAL_DIRECTIVES],
      exports: [CONDITIONAL_DIRECTIVES]
    }]
  }], null, null);
})();
var FOCUS_ON_VIEW_INIT = new InjectionToken("FOCUS_ON_VIEW_INIT");
var FOCUS_ON_VIEW_INIT_PROVIDER = {
  provide: FOCUS_ON_VIEW_INIT,
  useValue: true
};
var ClrFocusOnViewInit = class {
  constructor(el, platformId, focusOnViewInit, document2, renderer, ngZone) {
    this.el = el;
    this.platformId = platformId;
    this.focusOnViewInit = focusOnViewInit;
    this.renderer = renderer;
    this.directFocus = true;
    this.destroy$ = new Subject();
    this._isEnabled = focusOnViewInit;
    this.document = document2;
    ngZone.runOutsideAngular(() => fromEvent(el.nativeElement, "focusout").pipe(takeUntil(this.destroy$)).subscribe(() => {
      if (!this.directFocus) {
        renderer.removeAttribute(el.nativeElement, "tabindex");
        renderer.setStyle(el.nativeElement, "outline", null);
      }
    }));
  }
  set isEnabled(value) {
    if (this.focusOnViewInit && typeof value === "boolean") {
      this._isEnabled = value;
    }
  }
  ngAfterViewInit() {
    this.focus();
  }
  ngOnDestroy() {
    this.destroy$.next();
  }
  focus() {
    if (!isPlatformBrowser(this.platformId)) {
      return;
    }
    if (!this._isEnabled) {
      return;
    }
    if (this.document && this.document.activeElement !== this.el.nativeElement) {
      this.el.nativeElement.focus();
      if (this.document.activeElement !== this.el.nativeElement) {
        this.directFocus = false;
        this.renderer.setAttribute(this.el.nativeElement, "tabindex", "-1");
        this.renderer.setStyle(this.el.nativeElement, "outline", "none");
        this.el.nativeElement.focus();
      }
    }
  }
};
ClrFocusOnViewInit.ɵfac = function ClrFocusOnViewInit_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrFocusOnViewInit)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(PLATFORM_ID), ɵɵdirectiveInject(FOCUS_ON_VIEW_INIT), ɵɵdirectiveInject(DOCUMENT), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone));
};
ClrFocusOnViewInit.ɵdir = ɵɵdefineDirective({
  type: ClrFocusOnViewInit,
  selectors: [["", "clrFocusOnViewInit", ""]],
  inputs: {
    isEnabled: [0, "clrFocusOnViewInit", "isEnabled"]
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrFocusOnViewInit, [{
    type: Directive,
    args: [{
      selector: "[clrFocusOnViewInit]"
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [FOCUS_ON_VIEW_INIT]
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [DOCUMENT]
      }]
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }];
  }, {
    isEnabled: [{
      type: Input,
      args: ["clrFocusOnViewInit"]
    }]
  });
})();
var FOCUS_ON_VIEW_INIT_DIRECTIVES = [ClrFocusOnViewInit];
var ClrFocusOnViewInitModule = class {
};
ClrFocusOnViewInitModule.ɵfac = function ClrFocusOnViewInitModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrFocusOnViewInitModule)();
};
ClrFocusOnViewInitModule.ɵmod = ɵɵdefineNgModule({
  type: ClrFocusOnViewInitModule,
  declarations: [ClrFocusOnViewInit],
  imports: [CommonModule],
  exports: [ClrFocusOnViewInit]
});
ClrFocusOnViewInitModule.ɵinj = ɵɵdefineInjector({
  providers: [FOCUS_ON_VIEW_INIT_PROVIDER],
  imports: [CommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrFocusOnViewInitModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [FOCUS_ON_VIEW_INIT_DIRECTIVES],
      providers: [FOCUS_ON_VIEW_INIT_PROVIDER],
      exports: [FOCUS_ON_VIEW_INIT_DIRECTIVES]
    }]
  }], null, null);
})();
var ClrStandaloneCdkTrapFocus = class extends CdkTrapFocus {
  /**
   * Include the constructor to forward all the dependencies to the base class
   * as a workaround to fix Angular "ɵɵinvalidFactoryDep" error after upgrading storybook
   * https://github.com/storybookjs/storybook/issues/23534
   */
  constructor(elementRef, focusTrapFactory, document2) {
    super(elementRef, focusTrapFactory, document2);
  }
};
ClrStandaloneCdkTrapFocus.ɵfac = function ClrStandaloneCdkTrapFocus_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrStandaloneCdkTrapFocus)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(FocusTrapFactory), ɵɵdirectiveInject(DOCUMENT, 8));
};
ClrStandaloneCdkTrapFocus.ɵdir = ɵɵdefineDirective({
  type: ClrStandaloneCdkTrapFocus,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrStandaloneCdkTrapFocus, [{
    type: Directive,
    args: [{
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: FocusTrapFactory
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [DOCUMENT]
      }]
    }];
  }, null);
})();
var ButtonGroupFocusHandler = class {
  constructor(focusService, toggleService, renderer) {
    this.focusService = focusService;
    this.toggleService = toggleService;
    this.renderer = renderer;
    this.initialFocus = InitialFocus.FIRST_ITEM;
    this._unlistenFuncs = [];
  }
  ngOnDestroy() {
    this._unlistenFuncs.forEach((unlisten) => unlisten());
    this.focusService.detachListeners();
  }
  initialize({
    menu,
    menuToggle
  }) {
    this.menu = menu;
    this.menuToggle = menuToggle;
    this.focusService.registerContainer(this.menu, "-1");
    this.listenToKeys();
    this.linkButtons();
    switch (this.initialFocus) {
      case InitialFocus.LAST_ITEM:
        this.focusLastItem();
        break;
      default:
        this.focusFirstItem();
        break;
    }
  }
  resetButtonsFocus() {
    this.buttons.forEach((button) => {
      button.blur();
    });
  }
  listenToKeys() {
    this._unlistenFuncs.push(this.renderer.listen(this.menu, "keydown.shift.tab", (event) => this.closeMenu(event, false)));
    this._unlistenFuncs.push(this.renderer.listen(this.menu, "keydown.tab", (event) => this.closeMenu(event, true)));
  }
  closeMenu(event, focusBackOnToggle) {
    this.toggleService.toggleWithEvent(event);
    if (focusBackOnToggle) {
      this.menuToggle.focus();
    }
    this.resetButtonsFocus();
  }
  linkButtons() {
    const buttonElements = Array.from(this.menu.children);
    this.buttons = buttonElements.map((buttonElement) => {
      this._unlistenFuncs.push(this.renderer.listen(buttonElement, "click", (event) => this.closeMenu(event, true)));
      return {
        id: buttonElement.id,
        value: buttonElement,
        focus: () => {
          buttonElement.setAttribute("tabindex", "0");
          buttonElement.focus();
        },
        blur: () => {
          buttonElement.setAttribute("tabindex", "-1");
          buttonElement.blur();
        }
      };
    });
    this.resetButtonsFocus();
    Linkers.linkVertical(this.buttons);
  }
  focusFirstItem() {
    if (this.buttons.length) {
      this.focusService.moveTo(this.buttons[0]);
    }
    this.initialFocus = InitialFocus.FIRST_ITEM;
  }
  focusLastItem() {
    if (this.buttons.length) {
      this.focusService.moveTo(this.buttons[this.buttons.length - 1]);
    }
    this.initialFocus = InitialFocus.FIRST_ITEM;
  }
};
ButtonGroupFocusHandler.ɵfac = function ButtonGroupFocusHandler_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ButtonGroupFocusHandler)(ɵɵinject(FocusService$1), ɵɵinject(ClrPopoverToggleService), ɵɵinject(Renderer2));
};
ButtonGroupFocusHandler.ɵprov = ɵɵdefineInjectable({
  token: ButtonGroupFocusHandler,
  factory: ButtonGroupFocusHandler.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ButtonGroupFocusHandler, [{
    type: Injectable
  }], function() {
    return [{
      type: FocusService$1
    }, {
      type: ClrPopoverToggleService
    }, {
      type: Renderer2
    }];
  }, null);
})();
var BUTTON_GROUP_FOCUS_HANDLER_PROVIDER = {
  provide: ButtonGroupFocusHandler
};
var ClrButtonGroup = class {
  constructor(buttonGroupNewService, toggleService, commonStrings, destroy$, focusHandler) {
    this.buttonGroupNewService = buttonGroupNewService;
    this.toggleService = toggleService;
    this.commonStrings = commonStrings;
    this.destroy$ = destroy$;
    this.focusHandler = focusHandler;
    this.clrToggleButtonAriaLabel = this.commonStrings.keys.rowActions;
    this.popoverId = uniqueIdFactory();
    this.InitialFocus = InitialFocus;
    this.popoverPosition = ClrPopoverPositions["bottom-left"];
    this.inlineButtons = [];
    this.menuButtons = [];
  }
  get menuPosition() {
    return this._menuPosition;
  }
  set menuPosition(pos) {
    if (pos && ClrPopoverPositions[pos]) {
      this._menuPosition = pos;
    } else {
      this._menuPosition = "bottom-left";
    }
    this.popoverPosition = ClrPopoverPositions[this._menuPosition];
  }
  get open() {
    return this.toggleService.open;
  }
  /**
   * 1. Initializes the initial Button Group View
   * 2. Subscribes to changes on the ContentChildren
   *    in case the user content projection changes
   */
  ngAfterContentInit() {
    this.initializeButtons();
    this.buttonGroupNewService.changes.pipe(takeUntil(this.destroy$)).subscribe((button) => this.rearrangeButton(button));
    this.buttons.changes.subscribe(() => {
      this.initializeButtons();
    });
  }
  ngAfterViewInit() {
    this.handleFocusOnMenuOpen();
  }
  /**
   * Moves the button into the other ViewContainer
   * when an update is received.
   *
   * @param button
   */
  rearrangeButton(button) {
    let fromView;
    let toView;
    if (button.inMenu) {
      fromView = this.inlineButtons;
      toView = this.menuButtons;
    } else {
      fromView = this.menuButtons;
      toView = this.inlineButtons;
    }
    const index = fromView.indexOf(button);
    if (index > -1) {
      fromView.splice(index, 1);
      const moveIndex = this.getMoveIndex(button);
      if (moveIndex <= toView.length) {
        toView.splice(moveIndex, 0, button);
      }
    }
  }
  openMenu(event, initialFocus) {
    this.focusHandler.initialFocus = initialFocus;
    if (!this.toggleService.open) {
      this.toggleService.toggleWithEvent(event);
    }
  }
  /**
   * Author: Eudes
   *
   * Finds the order of a button w.r.t other buttons
   *
   * @param buttonToMove
   * @returns
   */
  getMoveIndex(buttonToMove) {
    const tempArr = this.buttons.filter((button) => button.inMenu === buttonToMove.inMenu);
    return tempArr.indexOf(buttonToMove);
  }
  initializeButtons() {
    const tempInlineButtons = [];
    const tempInMenuButtons = [];
    this.buttons.forEach((button) => {
      if (button.inMenu) {
        tempInMenuButtons.push(button);
      } else {
        tempInlineButtons.push(button);
      }
    });
    this.inlineButtons = tempInlineButtons;
    this.menuButtons = tempInMenuButtons;
  }
  handleFocusOnMenuOpen() {
    this.toggleService.popoverVisible.pipe(takeUntil(this.destroy$)).subscribe((visible) => {
      if (visible) {
        this.focusHandler.initialize({
          menu: this.menu.nativeElement,
          menuToggle: this.menuToggle.nativeElement
        });
      }
    });
  }
};
ClrButtonGroup.ɵfac = function ClrButtonGroup_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrButtonGroup)(ɵɵdirectiveInject(ButtonInGroupService), ɵɵdirectiveInject(ClrPopoverToggleService), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(ClrDestroyService), ɵɵdirectiveInject(ButtonGroupFocusHandler));
};
ClrButtonGroup.ɵcmp = ɵɵdefineComponent({
  type: ClrButtonGroup,
  selectors: [["clr-button-group"]],
  contentQueries: function ClrButtonGroup_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrButton, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.buttons = _t);
    }
  },
  viewQuery: function ClrButtonGroup_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c8, 5);
      ɵɵviewQuery(_c9, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.menuToggle = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.menu = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function ClrButtonGroup_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("btn-group", true);
    }
  },
  inputs: {
    clrToggleButtonAriaLabel: "clrToggleButtonAriaLabel",
    menuPosition: [0, "clrMenuPosition", "menuPosition"]
  },
  standalone: false,
  features: [ɵɵProvidersFeature([ButtonInGroupService, ClrDestroyService, BUTTON_GROUP_FOCUS_HANDLER_PROVIDER, FOCUS_SERVICE_PROVIDER]), ɵɵHostDirectivesFeature([ClrPopoverHostDirective])],
  decls: 2,
  vars: 2,
  consts: [["menuToggle", ""], ["menu", ""], [4, "ngFor", "ngForOf"], ["class", "btn-group-overflow open", 3, "ngClass", 4, "ngIf"], [3, "ngTemplateOutlet"], [1, "btn-group-overflow", "open", 3, "ngClass"], ["clrPopoverAnchor", "", "clrPopoverOpenCloseButton", "", 1, "btn", "dropdown-toggle", 3, "keydown.arrowup", "keydown.arrowdown"], ["shape", "ellipsis-horizontal"], ["role", "menu", "class", "dropdown-menu clr-button-group-menu", 3, "id", 4, "clrPopoverContent", "clrPopoverContentAt", "clrPopoverContentOutsideClickToClose", "clrPopoverContentScrollToClose"], ["role", "menu", 1, "dropdown-menu", "clr-button-group-menu", 3, "id"]],
  template: function ClrButtonGroup_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, ClrButtonGroup_0_Template, 1, 1, null, 2)(1, ClrButtonGroup_div_1_Template, 5, 9, "div", 3);
    }
    if (rf & 2) {
      ɵɵproperty("ngForOf", ctx.inlineButtons);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.menuButtons.length > 0);
    }
  },
  dependencies: [NgClass, NgForOf, NgIf, NgTemplateOutlet, CdsIconCustomTag, ClrPopoverAnchor, ClrPopoverOpenCloseButton, ClrPopoverContent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrButtonGroup, [{
    type: Component,
    args: [{
      selector: "clr-button-group",
      providers: [ButtonInGroupService, ClrDestroyService, BUTTON_GROUP_FOCUS_HANDLER_PROVIDER, FOCUS_SERVICE_PROVIDER],
      hostDirectives: [ClrPopoverHostDirective],
      host: {
        "[class.btn-group]": "true"
      },
      template: '<!--\n  ~ Copyright (c) 2016-2024 Broadcom. All Rights Reserved.\n  ~ The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<ng-template *ngFor="let inlineButton of inlineButtons" [ngTemplateOutlet]="inlineButton.templateRef"></ng-template>\n\n<div *ngIf="menuButtons.length > 0" class="btn-group-overflow open" [ngClass]="menuPosition">\n  <button\n    #menuToggle\n    class="btn dropdown-toggle"\n    clrPopoverAnchor\n    clrPopoverOpenCloseButton\n    (keydown.arrowup)="openMenu($event, InitialFocus.LAST_ITEM)"\n    (keydown.arrowdown)="openMenu($event, InitialFocus.FIRST_ITEM)"\n    [attr.aria-controls]="popoverId"\n    [attr.aria-expanded]="open"\n    [attr.aria-label]="clrToggleButtonAriaLabel"\n  >\n    <cds-icon shape="ellipsis-horizontal" [attr.title]="commonStrings.keys.more"></cds-icon>\n  </button>\n  <div\n    #menu\n    role="menu"\n    class="dropdown-menu clr-button-group-menu"\n    [id]="popoverId"\n    [attr.id]="popoverId"\n    [attr.aria-hidden]="!open"\n    *clrPopoverContent="open at popoverPosition; outsideClickToClose: true; scrollToClose: true"\n  >\n    <ng-template *ngFor="let menuButton of menuButtons" [ngTemplateOutlet]="menuButton.templateRef"></ng-template>\n  </div>\n</div>\n'
    }]
  }], function() {
    return [{
      type: ButtonInGroupService
    }, {
      type: ClrPopoverToggleService
    }, {
      type: ClrCommonStringsService
    }, {
      type: ClrDestroyService
    }, {
      type: ButtonGroupFocusHandler
    }];
  }, {
    clrToggleButtonAriaLabel: [{
      type: Input,
      args: ["clrToggleButtonAriaLabel"]
    }],
    menuToggle: [{
      type: ViewChild,
      args: ["menuToggle"]
    }],
    menu: [{
      type: ViewChild,
      args: ["menu"]
    }],
    buttons: [{
      type: ContentChildren,
      args: [ClrButton]
    }],
    menuPosition: [{
      type: Input,
      args: ["clrMenuPosition"]
    }]
  });
})();
var CLR_BUTTON_GROUP_DIRECTIVES = [ClrButton, ClrButtonGroup];
var ClrButtonGroupModule = class {
};
ClrButtonGroupModule.ɵfac = function ClrButtonGroupModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrButtonGroupModule)();
};
ClrButtonGroupModule.ɵmod = ɵɵdefineNgModule({
  type: ClrButtonGroupModule,
  declarations: [ClrButton, ClrButtonGroup],
  imports: [CommonModule, ClrIconModule, ClrPopoverModuleNext],
  exports: [ClrButton, ClrButtonGroup]
});
ClrButtonGroupModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrIconModule, ClrPopoverModuleNext]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrButtonGroupModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ClrIconModule, ClrPopoverModuleNext],
      declarations: [CLR_BUTTON_GROUP_DIRECTIVES],
      exports: [CLR_BUTTON_GROUP_DIRECTIVES]
    }]
  }], null, null);
})();
var MIN_BUTTON_WIDTH = 42;
var ClrLoadingButton = class {
  constructor(el, renderer) {
    this.el = el;
    this.renderer = renderer;
    this.clrLoadingChange = new EventEmitter(false);
    this.buttonState = ClrLoadingState;
    this.state = ClrLoadingState.DEFAULT;
  }
  loadingStateChange(state2) {
    if (state2 === this.state) {
      return;
    }
    this.state = state2;
    switch (state2) {
      case ClrLoadingState.DEFAULT:
        this.renderer.removeStyle(this.el.nativeElement, "width");
        this.renderer.removeStyle(this.el.nativeElement, "transform");
        if (!this.disabled) {
          this.renderer.removeAttribute(this.el.nativeElement, "disabled");
        }
        break;
      case ClrLoadingState.LOADING:
        this.setExplicitButtonWidth();
        this.renderer.setStyle(this.el.nativeElement, "transform", "translatez(0)");
        this.renderer.setAttribute(this.el.nativeElement, "disabled", "");
        break;
      case ClrLoadingState.SUCCESS:
        this.setExplicitButtonWidth();
        break;
      case ClrLoadingState.ERROR:
        this.loadingStateChange(ClrLoadingState.DEFAULT);
        break;
      default:
        break;
    }
    this.clrLoadingChange.emit(state2);
  }
  setExplicitButtonWidth() {
    if (this.el.nativeElement && this.el.nativeElement.getBoundingClientRect) {
      const boundingClientRect = this.el.nativeElement.getBoundingClientRect();
      const width = Math.max(MIN_BUTTON_WIDTH, boundingClientRect.width);
      this.renderer.setStyle(this.el.nativeElement, "width", `${width}px`);
    }
  }
};
ClrLoadingButton.ɵfac = function ClrLoadingButton_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrLoadingButton)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
};
ClrLoadingButton.ɵcmp = ɵɵdefineComponent({
  type: ClrLoadingButton,
  selectors: [["button", "clrLoading", ""]],
  hostVars: 1,
  hostBindings: function ClrLoadingButton_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("disabled", ctx.disabled ? "" : null);
    }
  },
  inputs: {
    disabled: "disabled"
  },
  outputs: {
    clrLoadingChange: "clrLoadingChange"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([{
    provide: LoadingListener,
    useExisting: ClrLoadingButton
  }])],
  attrs: _c10,
  ngContentSelectors: _c02,
  decls: 4,
  vars: 5,
  consts: [[3, "ngSwitch"], [4, "ngSwitchCase"], ["class", "clr-loading-btn-content", 4, "ngSwitchCase"], [1, "spinner", "spinner-inline"], [1, "spinner", "spinner-inline", "spinner-check"], [1, "clr-loading-btn-content"]],
  template: function ClrLoadingButton_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "span", 0);
      ɵɵtemplate(1, ClrLoadingButton_ng_container_1_Template, 2, 1, "ng-container", 1)(2, ClrLoadingButton_ng_container_2_Template, 2, 1, "ng-container", 1)(3, ClrLoadingButton_span_3_Template, 2, 1, "span", 2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("@parent", void 0)("ngSwitch", ctx.state);
      ɵɵadvance();
      ɵɵproperty("ngSwitchCase", ctx.buttonState.LOADING);
      ɵɵadvance();
      ɵɵproperty("ngSwitchCase", ctx.buttonState.SUCCESS);
      ɵɵadvance();
      ɵɵproperty("ngSwitchCase", ctx.buttonState.DEFAULT);
    }
  },
  dependencies: [NgSwitch, NgSwitchCase],
  encapsulation: 2,
  data: {
    animation: [trigger("parent", [
      // Skip :enter animation on first render.
      // The button text/content should only be faded when transitioning to or from a non-default state.
      transition(":enter", [])
    ]), trigger("defaultButton", [
      transition(":enter", [style({
        opacity: 0
      }), animate("200ms 100ms ease-in", style({
        opacity: 1
      }))]),
      // TODO: see if we can get leave animation to work before spinner's enter animation
      transition(":leave", [style({
        opacity: 0
      })])
    ]), trigger("spinner", [transition(":enter", [style({
      opacity: 0
    }), animate("200ms 100ms ease-in", style({
      opacity: 1
    }))]), transition(":leave", [style({
      opacity: 1
    }), animate("100ms ease-out", style({
      opacity: 0
    }))])]), trigger("validated", [transition(":enter", [animate("600ms", keyframes([style({
      transform: "scale(0,0)",
      offset: 0
    }), style({
      opacity: 1,
      offset: 0.2
    }), style({
      transform: "scale(1.2,1.2)",
      offset: 0.4
    }), style({
      transform: "scale(.9,.9)",
      offset: 0.6
    }), style({
      transform: "scale(1,1)",
      offset: 1
    })]))]), transition(":leave", [style({
      opacity: 1
    }), animate("100ms ease-out", style({
      opacity: 0
    }))])])]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrLoadingButton, [{
    type: Component,
    args: [{
      selector: "button[clrLoading]",
      template: `
    <span @parent [ngSwitch]="state">
      <ng-container *ngSwitchCase="buttonState.LOADING">
        <span @spinner class="spinner spinner-inline"></span>
      </ng-container>
      <ng-container *ngSwitchCase="buttonState.SUCCESS">
        <span
          @validated
          (@validated.done)="this.loadingStateChange(this.buttonState.DEFAULT)"
          class="spinner spinner-inline spinner-check"
        ></span>
      </ng-container>
      <span *ngSwitchCase="buttonState.DEFAULT" @defaultButton class="clr-loading-btn-content">
        <ng-content></ng-content>
      </span>
    </span>
  `,
      providers: [{
        provide: LoadingListener,
        useExisting: ClrLoadingButton
      }],
      animations: [trigger("parent", [
        // Skip :enter animation on first render.
        // The button text/content should only be faded when transitioning to or from a non-default state.
        transition(":enter", [])
      ]), trigger("defaultButton", [
        transition(":enter", [style({
          opacity: 0
        }), animate("200ms 100ms ease-in", style({
          opacity: 1
        }))]),
        // TODO: see if we can get leave animation to work before spinner's enter animation
        transition(":leave", [style({
          opacity: 0
        })])
      ]), trigger("spinner", [transition(":enter", [style({
        opacity: 0
      }), animate("200ms 100ms ease-in", style({
        opacity: 1
      }))]), transition(":leave", [style({
        opacity: 1
      }), animate("100ms ease-out", style({
        opacity: 0
      }))])]), trigger("validated", [transition(":enter", [animate("600ms", keyframes([style({
        transform: "scale(0,0)",
        offset: 0
      }), style({
        opacity: 1,
        offset: 0.2
      }), style({
        transform: "scale(1.2,1.2)",
        offset: 0.4
      }), style({
        transform: "scale(.9,.9)",
        offset: 0.6
      }), style({
        transform: "scale(1,1)",
        offset: 1
      })]))]), transition(":leave", [style({
        opacity: 1
      }), animate("100ms ease-out", style({
        opacity: 0
      }))])])],
      host: {
        "[attr.disabled]": "disabled? '' : null"
      }
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }];
  }, {
    disabled: [{
      type: Input,
      args: ["disabled"]
    }],
    clrLoadingChange: [{
      type: Output,
      args: ["clrLoadingChange"]
    }]
  });
})();
var CLR_LOADING_BUTTON_DIRECTIVES = [ClrLoadingButton];
var ClrLoadingButtonModule = class {
};
ClrLoadingButtonModule.ɵfac = function ClrLoadingButtonModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrLoadingButtonModule)();
};
ClrLoadingButtonModule.ɵmod = ɵɵdefineNgModule({
  type: ClrLoadingButtonModule,
  declarations: [ClrLoadingButton],
  imports: [CommonModule],
  exports: [ClrLoadingButton]
});
ClrLoadingButtonModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrLoadingButtonModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [CLR_LOADING_BUTTON_DIRECTIVES],
      exports: [CLR_LOADING_BUTTON_DIRECTIVES]
    }]
  }], null, null);
})();
var ClrButtonModule = class {
  constructor() {
    r.addIcons(o3);
  }
};
ClrButtonModule.ɵfac = function ClrButtonModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrButtonModule)();
};
ClrButtonModule.ɵmod = ɵɵdefineNgModule({
  type: ClrButtonModule,
  exports: [ClrLoadingButtonModule, ClrButtonGroupModule]
});
ClrButtonModule.ɵinj = ɵɵdefineInjector({
  imports: [ClrLoadingButtonModule, ClrButtonGroupModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrButtonModule, [{
    type: NgModule,
    args: [{
      exports: [ClrLoadingButtonModule, ClrButtonGroupModule]
    }]
  }], function() {
    return [];
  }, null);
})();
var EmptyAnchor = class {
};
EmptyAnchor.ɵfac = function EmptyAnchor_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || EmptyAnchor)();
};
EmptyAnchor.ɵcmp = ɵɵdefineComponent({
  type: EmptyAnchor,
  selectors: [["ng-component"]],
  standalone: false,
  decls: 0,
  vars: 0,
  template: function EmptyAnchor_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EmptyAnchor, [{
    type: Component,
    args: [{
      template: ""
    }]
  }], null, null);
})();
var ClrHostWrappingModule = class {
};
ClrHostWrappingModule.ɵfac = function ClrHostWrappingModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrHostWrappingModule)();
};
ClrHostWrappingModule.ɵmod = ɵɵdefineNgModule({
  type: ClrHostWrappingModule,
  declarations: [EmptyAnchor],
  exports: [EmptyAnchor]
});
ClrHostWrappingModule.ɵinj = ɵɵdefineInjector({});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrHostWrappingModule, [{
    type: NgModule,
    args: [{
      declarations: [EmptyAnchor],
      exports: [EmptyAnchor]
    }]
  }], null, null);
})();
var counter$2 = 0;
var ControlIdService = class {
  constructor() {
    this._id = "clr-form-control-" + ++counter$2;
    this._idChange = new BehaviorSubject(this._id);
  }
  get id() {
    return this._id;
  }
  set id(value) {
    this._id = value;
    this._idChange.next(value);
  }
  get idChange() {
    return this._idChange.asObservable();
  }
};
ControlIdService.ɵfac = function ControlIdService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ControlIdService)();
};
ControlIdService.ɵprov = ɵɵdefineInjectable({
  token: ControlIdService,
  factory: ControlIdService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ControlIdService, [{
    type: Injectable
  }], null, null);
})();
var counter$1 = 0;
var ContainerIdService = class {
  constructor() {
    this._id = `clr-form-container-${++counter$1}`;
    this._idChange = new BehaviorSubject(this._id);
  }
  get id() {
    return this._id;
  }
  set id(value) {
    this._id = value;
    this._idChange.next(value);
  }
  get idChange() {
    return this._idChange.asObservable();
  }
};
ContainerIdService.ɵfac = function ContainerIdService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ContainerIdService)();
};
ContainerIdService.ɵprov = ɵɵdefineInjectable({
  token: ContainerIdService,
  factory: ContainerIdService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContainerIdService, [{
    type: Injectable
  }], null, null);
})();
var CONTROL_SUFFIX = {
  HELPER: "helper",
  ERROR: "error",
  SUCCESS: "success",
  NONE: null
};
var ClrAbstractControl = class {
  constructor(controlIdService, containerIdService) {
    this.controlIdService = controlIdService;
    this.containerIdService = containerIdService;
    this.controlIdSuffix = "abstract";
  }
  get id() {
    if (this.containerIdService) {
      return `${this.containerIdService.id}-${this.controlIdSuffix}`;
    }
    if (this.controlIdService) {
      return `${this.controlIdService.id}-${this.controlIdSuffix}`;
    }
    return null;
  }
};
ClrAbstractControl.ɵfac = function ClrAbstractControl_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrAbstractControl)(ɵɵdirectiveInject(ControlIdService, 8), ɵɵdirectiveInject(ContainerIdService, 8));
};
ClrAbstractControl.ɵdir = ɵɵdefineDirective({
  type: ClrAbstractControl,
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrAbstractControl, [{
    type: Directive
  }], function() {
    return [{
      type: ControlIdService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ContainerIdService,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var ClrControlError = class extends ClrAbstractControl {
  constructor(controlIdService, containerIdService) {
    super(controlIdService, containerIdService);
    this.controlIdService = controlIdService;
    this.containerIdService = containerIdService;
    this.controlIdSuffix = CONTROL_SUFFIX.ERROR;
  }
};
ClrControlError.ɵfac = function ClrControlError_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrControlError)(ɵɵdirectiveInject(ControlIdService, 8), ɵɵdirectiveInject(ContainerIdService, 8));
};
ClrControlError.ɵcmp = ɵɵdefineComponent({
  type: ClrControlError,
  selectors: [["clr-control-error"]],
  hostVars: 5,
  hostBindings: function ClrControlError_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("id", ctx.id);
      ɵɵclassProp("clr-subtext", true)("error", true);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrControlError_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrControlError, [{
    type: Component,
    args: [{
      selector: "clr-control-error",
      template: `<ng-content></ng-content>`,
      host: {
        "[class.clr-subtext]": "true",
        "[class.error]": "true",
        "[attr.id]": "id"
      }
    }]
  }], function() {
    return [{
      type: ControlIdService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ContainerIdService,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var ClrControlHelper = class extends ClrAbstractControl {
  constructor(controlIdService, containerIdService) {
    super(controlIdService, containerIdService);
    this.controlIdService = controlIdService;
    this.containerIdService = containerIdService;
    this.controlIdSuffix = CONTROL_SUFFIX.HELPER;
  }
};
ClrControlHelper.ɵfac = function ClrControlHelper_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrControlHelper)(ɵɵdirectiveInject(ControlIdService, 8), ɵɵdirectiveInject(ContainerIdService, 8));
};
ClrControlHelper.ɵcmp = ɵɵdefineComponent({
  type: ClrControlHelper,
  selectors: [["clr-control-helper"]],
  hostVars: 3,
  hostBindings: function ClrControlHelper_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("id", ctx.id);
      ɵɵclassProp("clr-subtext", true);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrControlHelper_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrControlHelper, [{
    type: Component,
    args: [{
      selector: "clr-control-helper",
      template: `<ng-content></ng-content>`,
      host: {
        "[class.clr-subtext]": "true",
        "[attr.id]": "id"
      }
    }]
  }], function() {
    return [{
      type: ControlIdService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ContainerIdService,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var NgControlService = class {
  constructor() {
    this._controlChanges = new Subject();
    this._helpers = new Subject();
  }
  get control() {
    return this._control;
  }
  get controlChanges() {
    return this._controlChanges.asObservable();
  }
  get helpersChange() {
    return this._helpers.asObservable();
  }
  setControl(control) {
    this._control = control;
    this._controlChanges.next(control);
  }
  setHelpers(state2) {
    this._helpers.next(state2);
  }
};
NgControlService.ɵfac = function NgControlService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || NgControlService)();
};
NgControlService.ɵprov = ɵɵdefineInjectable({
  token: NgControlService,
  factory: NgControlService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgControlService, [{
    type: Injectable
  }], null, null);
})();
var CONTROL_STATE;
(function(CONTROL_STATE2) {
  CONTROL_STATE2["NONE"] = "NONE";
  CONTROL_STATE2["VALID"] = "VALID";
  CONTROL_STATE2["INVALID"] = "INVALID";
})(CONTROL_STATE || (CONTROL_STATE = {}));
var IfControlStateService = class {
  constructor(ngControlService) {
    this.triggerStatusChangeSubject = new Subject();
    this.statusChanges = this.getStatusChanges(ngControlService).pipe(shareReplay(1));
  }
  triggerStatusChange() {
    this.triggerStatusChangeSubject.next();
  }
  getStatusChanges(ngControlService) {
    return ngControlService.controlChanges.pipe(switchMap((control) => control ? merge(control.statusChanges, this.triggerStatusChangeSubject.pipe(map(() => control.status))) : EMPTY), map((controlStatus) => {
      const status = CONTROL_STATE[controlStatus];
      return [CONTROL_STATE.VALID, CONTROL_STATE.INVALID].includes(status) ? status : CONTROL_STATE.NONE;
    }), startWith(CONTROL_STATE.NONE));
  }
};
IfControlStateService.ɵfac = function IfControlStateService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || IfControlStateService)(ɵɵinject(NgControlService));
};
IfControlStateService.ɵprov = ɵɵdefineInjectable({
  token: IfControlStateService,
  factory: IfControlStateService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IfControlStateService, [{
    type: Injectable
  }], function() {
    return [{
      type: NgControlService
    }];
  }, null);
})();
var FocusableItem = class {
};
function customFocusableItemProvider(implementation) {
  return [implementation, {
    provide: FocusableItem,
    useExisting: implementation
  }];
}
function wrapObservable(observable, onSubscribe, onUnsubscribe) {
  return Observable.create((observer) => {
    onSubscribe(observer);
    const subscription = observable.subscribe(observer);
    return () => {
      subscription.unsubscribe();
      if (onUnsubscribe) {
        onUnsubscribe(observer);
      }
    };
  });
}
var DropdownFocusHandler = class {
  constructor(renderer, parent, toggleService, focusService, platformId) {
    this.renderer = renderer;
    this.parent = parent;
    this.toggleService = toggleService;
    this.focusService = focusService;
    this.platformId = platformId;
    this.id = uniqueIdFactory();
    this.focusBackOnTriggerWhenClosed = false;
    this._unlistenFuncs = [];
    this.resetChildren();
    this.moveToFirstItemWhenOpen();
    if (!parent) {
      this.handleRootFocus();
    }
  }
  get trigger() {
    return this._trigger;
  }
  set trigger(el) {
    this._trigger = el;
    if (this.parent) {
      this._unlistenFuncs.push(this.renderer.listen(el, "keydown.arrowright", (event) => this.toggleService.toggleWithEvent(event)));
    } else {
      this._unlistenFuncs.push(this.renderer.listen(el, "keydown.arrowup", (event) => this.toggleService.toggleWithEvent(event)));
      this._unlistenFuncs.push(this.renderer.listen(el, "keydown.arrowdown", (event) => this.toggleService.toggleWithEvent(event)));
      this.focusService.listenToArrowKeys(el);
    }
  }
  get container() {
    return this._container;
  }
  set container(el) {
    this._container = el;
    this._unlistenFuncs.push(this.renderer.listen(el, "keydown.tab", (event) => this.toggleService.toggleWithEvent(event)));
    if (this.parent) {
      this._unlistenFuncs.push(this.renderer.listen(el, "keydown.escape", (event) => {
        this.focusService.move(ArrowKeyDirection.LEFT);
        event.stopPropagation();
      }));
    } else {
      this.focusService.registerContainer(el);
      this._unlistenFuncs.push(this.renderer.listen(el, "keydown.escape", (event) => this.toggleService.toggleWithEvent(event)));
      this._unlistenFuncs.push(this.renderer.listen(el, "blur", (event) => {
        this.children.pipe(take(1)).subscribe((items) => items.forEach((item) => item.blur()));
        const target = event.relatedTarget || document.activeElement;
        if (target && isPlatformBrowser(this.platformId)) {
          if (el.contains(target) || target === this.trigger) {
            return;
          }
        }
        this.focusBackOnTriggerWhenClosed = false;
        this.toggleService.open = false;
      }));
    }
  }
  ngOnDestroy() {
    this._unlistenFuncs.forEach((unlisten) => unlisten());
    this.focusService.detachListeners();
  }
  /**
   * If the dropdown was opened by clicking on the trigger, we automatically move to the first item
   */
  moveToFirstItemWhenOpen() {
    const subscription = this.toggleService.openChange.subscribe((open) => {
      if (open && this.toggleService.originalEvent) {
        setTimeout(() => {
          this.focusService.moveTo(this);
          if (this.parent) {
            this.focusService.move(ArrowKeyDirection.RIGHT);
          } else {
            this.focusService.move(ArrowKeyDirection.DOWN);
          }
        });
      }
    });
    this._unlistenFuncs.push(() => subscription.unsubscribe());
  }
  /**
   * Focus on the menu when it opens, and focus back on the root trigger when the whole dropdown becomes closed
   */
  handleRootFocus() {
    const subscription = this.toggleService.openChange.subscribe((open) => {
      if (!open) {
        this.focusService.reset(this);
        if (this.focusBackOnTriggerWhenClosed) {
          this.focus();
        }
      }
      this.focusBackOnTriggerWhenClosed = open;
    });
    this._unlistenFuncs.push(() => subscription.unsubscribe());
  }
  focus() {
    if (this.trigger && isPlatformBrowser(this.platformId)) {
      this.trigger.focus();
    }
  }
  blur() {
    if (this.trigger && isPlatformBrowser(this.platformId)) {
      this.trigger.blur();
    }
  }
  activate() {
    if (isPlatformBrowser(this.platformId)) {
      this.trigger.click();
    }
  }
  resetChildren() {
    this.children = new ReplaySubject(1);
    if (this.parent) {
      this.right = this.openAndGetChildren().pipe(map((all) => all[0]));
    } else {
      this.down = this.openAndGetChildren().pipe(map((all) => all[0]));
      this.up = this.openAndGetChildren().pipe(map((all) => all[all.length - 1]));
    }
  }
  addChildren(children) {
    Linkers.linkVertical(children);
    if (this.parent) {
      Linkers.linkParent(children, this.closeAndGetThis(), ArrowKeyDirection.LEFT);
    }
    this.children.next(children);
  }
  openAndGetChildren() {
    return wrapObservable(this.children, () => this.toggleService.open = true);
  }
  closeAndGetThis() {
    return wrapObservable(of(this), () => this.toggleService.open = false);
  }
};
DropdownFocusHandler.ɵfac = function DropdownFocusHandler_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || DropdownFocusHandler)(ɵɵinject(Renderer2), ɵɵinject(DropdownFocusHandler, 12), ɵɵinject(ClrPopoverToggleService), ɵɵinject(FocusService$1), ɵɵinject(PLATFORM_ID));
};
DropdownFocusHandler.ɵprov = ɵɵdefineInjectable({
  token: DropdownFocusHandler,
  factory: DropdownFocusHandler.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropdownFocusHandler, [{
    type: Injectable
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: DropdownFocusHandler,
      decorators: [{
        type: SkipSelf
      }, {
        type: Optional
      }]
    }, {
      type: ClrPopoverToggleService
    }, {
      type: FocusService$1
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }];
  }, null);
})();
var DROPDOWN_FOCUS_HANDLER_PROVIDER = customFocusableItemProvider(DropdownFocusHandler);
var RootDropdownService = class {
  constructor() {
    this._changes = new Subject();
  }
  get changes() {
    return this._changes.asObservable();
  }
  closeMenus() {
    this._changes.next(false);
  }
};
RootDropdownService.ɵfac = function RootDropdownService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RootDropdownService)();
};
RootDropdownService.ɵprov = ɵɵdefineInjectable({
  token: RootDropdownService,
  factory: RootDropdownService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RootDropdownService, [{
    type: Injectable
  }], null, null);
})();
function clrRootDropdownFactory(existing) {
  return existing || new RootDropdownService();
}
var ROOT_DROPDOWN_PROVIDER = {
  provide: RootDropdownService,
  useFactory: clrRootDropdownFactory,
  deps: [[new Optional(), new SkipSelf(), RootDropdownService]]
};
var ClrDropdown = class {
  constructor(parent, toggleService, focusHandler, cdr, dropdownService) {
    this.parent = parent;
    this.toggleService = toggleService;
    this.focusHandler = focusHandler;
    this.isMenuClosable = true;
    this.subscriptions = [];
    this.subscriptions.push(dropdownService.changes.subscribe((value) => toggleService.open = value));
    this.subscriptions.push(toggleService.openChange.subscribe(() => cdr.markForCheck()));
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
};
ClrDropdown.ɵfac = function ClrDropdown_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDropdown)(ɵɵdirectiveInject(ClrDropdown, 12), ɵɵdirectiveInject(ClrPopoverToggleService), ɵɵdirectiveInject(DropdownFocusHandler), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(RootDropdownService));
};
ClrDropdown.ɵcmp = ɵɵdefineComponent({
  type: ClrDropdown,
  selectors: [["clr-dropdown"]],
  hostVars: 4,
  hostBindings: function ClrDropdown_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("dropdown", true)("open", ctx.toggleService.open);
    }
  },
  inputs: {
    isMenuClosable: [0, "clrCloseMenuOnItemClick", "isMenuClosable"]
  },
  standalone: false,
  features: [ɵɵProvidersFeature([ROOT_DROPDOWN_PROVIDER, FOCUS_SERVICE_PROVIDER, DROPDOWN_FOCUS_HANDLER_PROVIDER]), ɵɵHostDirectivesFeature([ClrPopoverHostDirective])],
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrDropdown_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDropdown, [{
    type: Component,
    args: [{
      selector: "clr-dropdown",
      template: "<ng-content></ng-content>",
      host: {
        "[class.dropdown]": "true",
        "[class.open]": "toggleService.open"
      },
      providers: [ROOT_DROPDOWN_PROVIDER, FOCUS_SERVICE_PROVIDER, DROPDOWN_FOCUS_HANDLER_PROVIDER],
      hostDirectives: [ClrPopoverHostDirective]
    }]
  }], function() {
    return [{
      type: ClrDropdown,
      decorators: [{
        type: SkipSelf
      }, {
        type: Optional
      }]
    }, {
      type: ClrPopoverToggleService
    }, {
      type: DropdownFocusHandler
    }, {
      type: ChangeDetectorRef
    }, {
      type: RootDropdownService
    }];
  }, {
    isMenuClosable: [{
      type: Input,
      args: ["clrCloseMenuOnItemClick"]
    }]
  });
})();
var Point;
(function(Point2) {
  Point2[Point2["RIGHT_CENTER"] = 0] = "RIGHT_CENTER";
  Point2[Point2["RIGHT_TOP"] = 1] = "RIGHT_TOP";
  Point2[Point2["RIGHT_BOTTOM"] = 2] = "RIGHT_BOTTOM";
  Point2[Point2["TOP_CENTER"] = 3] = "TOP_CENTER";
  Point2[Point2["TOP_RIGHT"] = 4] = "TOP_RIGHT";
  Point2[Point2["TOP_LEFT"] = 5] = "TOP_LEFT";
  Point2[Point2["BOTTOM_CENTER"] = 6] = "BOTTOM_CENTER";
  Point2[Point2["BOTTOM_RIGHT"] = 7] = "BOTTOM_RIGHT";
  Point2[Point2["BOTTOM_LEFT"] = 8] = "BOTTOM_LEFT";
  Point2[Point2["LEFT_CENTER"] = 9] = "LEFT_CENTER";
  Point2[Point2["LEFT_TOP"] = 10] = "LEFT_TOP";
  Point2[Point2["LEFT_BOTTOM"] = 11] = "LEFT_BOTTOM";
})(Point || (Point = {}));
var POSITION_RELATIVE = "relative";
var POSITION_ABSOLUTE = "absolute";
var POSITION_FIXED = "fixed";
var OVERFLOW_SCROLL = "scroll";
var OVERFLOW_AUTO = "auto";
var Popover = class {
  constructor(element) {
    this.element = element;
    this.boundOnScrollListener = this.emitScrollEvent.bind(this);
    this.scrollableElements = [];
    element.style.position = POSITION_ABSOLUTE;
    element.style.top = 0;
    element.style.bottom = "auto";
    element.style.left = 0;
    element.style.right = "auto";
  }
  // TODO: need a way to account for parameters that change dynamically (positioning).
  anchor(anchor, anchorAlign, popoverAlign, {
    offsetX = 0,
    offsetY = 0,
    useAnchorParent = false
  } = {}) {
    this.addScrollEventListeners(anchor);
    if (useAnchorParent) {
      anchor = anchor.parentNode;
    }
    anchor.style.position = "static";
    const anchorRect = anchor.getBoundingClientRect();
    const popoverRect = this.element.getBoundingClientRect();
    let leftDiff = anchorRect.left - popoverRect.left + offsetX;
    let topDiff = anchorRect.top - popoverRect.top + offsetY;
    switch (anchorAlign) {
      case Point.LEFT_TOP:
      case Point.TOP_LEFT:
        break;
      case Point.TOP_CENTER:
        leftDiff += anchorRect.width / 2;
        break;
      case Point.TOP_RIGHT:
        leftDiff += anchorRect.width;
        break;
      case Point.RIGHT_TOP:
        leftDiff += anchorRect.width;
        break;
      case Point.LEFT_BOTTOM:
        topDiff += anchorRect.height;
        break;
      case Point.BOTTOM_LEFT:
        topDiff += anchorRect.height;
        break;
      case Point.BOTTOM_CENTER:
        topDiff += anchorRect.height;
        leftDiff += anchorRect.width / 2;
        break;
      case Point.BOTTOM_RIGHT:
        topDiff += anchorRect.height;
        leftDiff += anchorRect.width;
        break;
      case Point.RIGHT_BOTTOM:
        topDiff += anchorRect.height;
        leftDiff += anchorRect.width;
        break;
      case Point.LEFT_CENTER:
        topDiff += anchorRect.height / 2;
        break;
      case Point.RIGHT_CENTER:
        topDiff += anchorRect.height / 2;
        leftDiff += anchorRect.width;
        break;
      default:
    }
    switch (popoverAlign) {
      case Point.LEFT_TOP:
      case Point.TOP_LEFT:
        break;
      case Point.TOP_CENTER:
        leftDiff -= popoverRect.width / 2;
        break;
      case Point.TOP_RIGHT:
        leftDiff -= popoverRect.width;
        break;
      case Point.RIGHT_TOP:
        leftDiff -= popoverRect.width;
        break;
      case Point.LEFT_BOTTOM:
        topDiff -= popoverRect.height;
        break;
      case Point.BOTTOM_LEFT:
        topDiff -= popoverRect.height;
        break;
      case Point.BOTTOM_CENTER:
        topDiff -= popoverRect.height;
        leftDiff -= popoverRect.width / 2;
        break;
      case Point.BOTTOM_RIGHT:
        topDiff -= popoverRect.height;
        leftDiff -= popoverRect.width;
        break;
      case Point.RIGHT_BOTTOM:
        topDiff -= popoverRect.height;
        leftDiff -= popoverRect.width;
        break;
      case Point.LEFT_CENTER:
        topDiff -= popoverRect.height / 2;
        break;
      case Point.RIGHT_CENTER:
        topDiff -= popoverRect.height / 2;
        leftDiff -= popoverRect.width;
        break;
      default:
    }
    const popoverComputedStyle = getComputedStyle(this.element);
    const marginLeft = parseInt(popoverComputedStyle.marginLeft, 10);
    const marginRight = parseInt(popoverComputedStyle.marginRight, 10);
    const marginTop = parseInt(popoverComputedStyle.marginTop, 10);
    const marginBottom = parseInt(popoverComputedStyle.marginBottom, 10);
    switch (anchorAlign) {
      case Point.LEFT_TOP:
      case Point.TOP_LEFT:
      case Point.TOP_RIGHT:
      case Point.RIGHT_TOP:
        if (popoverAlign === Point.BOTTOM_RIGHT || popoverAlign === Point.RIGHT_BOTTOM) {
          topDiff -= marginBottom;
          leftDiff -= marginRight;
        }
        if (popoverAlign === Point.BOTTOM_LEFT || popoverAlign === Point.LEFT_BOTTOM) {
          topDiff -= marginTop;
          leftDiff += marginLeft;
        }
        if (popoverAlign === Point.TOP_LEFT || popoverAlign === Point.LEFT_TOP) {
          topDiff += marginTop;
          leftDiff += marginLeft;
        }
        if (popoverAlign === Point.TOP_RIGHT || popoverAlign === Point.RIGHT_TOP) {
          topDiff += marginTop;
          leftDiff -= marginRight;
        }
        break;
      case Point.LEFT_BOTTOM:
      case Point.BOTTOM_LEFT:
      case Point.BOTTOM_RIGHT:
      case Point.RIGHT_BOTTOM:
        if (popoverAlign === Point.BOTTOM_LEFT || popoverAlign === Point.LEFT_BOTTOM) {
          topDiff -= marginBottom;
          leftDiff += marginLeft;
        }
        if (popoverAlign === Point.BOTTOM_RIGHT || popoverAlign === Point.RIGHT_BOTTOM) {
          topDiff -= marginBottom;
          leftDiff -= marginRight;
        }
        if (popoverAlign === Point.TOP_LEFT || popoverAlign === Point.LEFT_TOP) {
          topDiff += marginTop;
          leftDiff += marginLeft;
        }
        if (popoverAlign === Point.TOP_RIGHT || popoverAlign === Point.RIGHT_TOP) {
          topDiff += marginTop;
          leftDiff -= marginRight;
        }
        break;
      case Point.TOP_CENTER:
        topDiff -= marginBottom;
        leftDiff += marginLeft;
        leftDiff -= marginRight;
        break;
      case Point.BOTTOM_CENTER:
        topDiff += marginTop;
        leftDiff += marginLeft;
        leftDiff -= marginRight;
        break;
      case Point.LEFT_CENTER:
        topDiff += marginTop;
        topDiff -= marginBottom;
        leftDiff -= marginRight;
        break;
      case Point.RIGHT_CENTER:
        topDiff += marginTop;
        topDiff -= marginBottom;
        leftDiff += marginLeft;
        break;
      default:
    }
    this.element.style.transform = `translateX(${Math.round(leftDiff)}px) translateY(${Math.round(topDiff)}px)`;
    return this._scroll.asObservable();
  }
  release() {
    this.element.style.transform = "";
    this.removeScrollEventListeners();
  }
  isPositioned(container) {
    const position = getComputedStyle(container).position;
    return position === POSITION_RELATIVE || position === POSITION_ABSOLUTE || position === POSITION_FIXED;
  }
  emitScrollEvent() {
    this._scroll.next();
  }
  addScrollEventListeners(e5) {
    this._scroll = new Subject();
    const anchor = e5;
    let current = e5;
    while (current && current !== document) {
      if (this.scrolls(current)) {
        current.addEventListener("scroll", this.boundOnScrollListener);
        this.scrollableElements.push(current);
      }
      if (current !== anchor && this.isPositioned(current)) {
        break;
      }
      current = current.parentNode;
    }
  }
  removeScrollEventListeners() {
    for (const elem of this.scrollableElements) {
      elem.removeEventListener("scroll", this.boundOnScrollListener);
    }
    this.scrollableElements.length = 0;
    if (this._scroll) {
      this._scroll.complete();
      delete this._scroll;
    }
  }
  scrolls(container) {
    const computedStyles = getComputedStyle(container);
    return computedStyles.overflowX === OVERFLOW_SCROLL || computedStyles.overflowX === OVERFLOW_AUTO || computedStyles.overflowY === OVERFLOW_SCROLL || computedStyles.overflowY === OVERFLOW_AUTO;
  }
};
var AbstractPopover = class {
  constructor(injector, parentHost) {
    this.parentHost = parentHost;
    this.closeOnOutsideClick = false;
    this.popoverOptions = {};
    this.updateAnchor = false;
    this.documentESCListener = null;
    this.closeOnOutsideClickCallback = (event) => {
      if (this.anchorElem.contains(event.target)) {
        return;
      }
      this.toggleService.open = false;
    };
    this.el = injector.get(ElementRef);
    this.toggleService = injector.get(ClrPopoverToggleService);
    this.renderer = injector.get(Renderer2);
    this.ngZone = injector.get(NgZone);
    this.ref = injector.get(ChangeDetectorRef);
    this.anchorElem = parentHost.nativeElement;
    this.popoverInstance = new Popover(this.el.nativeElement);
    this.subscription = this.toggleService.openChange.subscribe((change) => {
      if (change) {
        this.anchor();
        this.attachESCListener();
      } else {
        this.release();
        this.detachESCListener();
      }
    });
    if (this.toggleService.open) {
      this.anchor();
      this.attachESCListener();
    }
  }
  /*
   * Fallback to hide when *clrIfOpen is not being used
   */
  get isOffScreen() {
    return this.toggleService.open ? false : true;
  }
  ngAfterViewChecked() {
    if (this.updateAnchor) {
      this.updateAnchor = false;
      this.popoverInstance.anchor(this.anchorElem, this.anchorPoint, this.popoverPoint, this.popoverOptions).subscribe(() => {
        this.toggleService.open = false;
      });
      this.attachOutsideClickListener();
    }
  }
  ngOnDestroy() {
    this.release();
    this.detachESCListener();
    this.subscription.unsubscribe();
  }
  anchor() {
    this.updateAnchor = true;
  }
  release() {
    this.detachOutsideClickListener();
    this.popoverInstance.release();
  }
  attachESCListener() {
    if (this.popoverOptions.ignoreGlobalESCListener) {
      return;
    }
    this.ngZone.runOutsideAngular(() => {
      this.documentESCListener = this.renderer.listen("document", "keydown", (event) => {
        if (event && event.key) {
          if (normalizeKey(event.key) === Keys.Escape) {
            this.ngZone.run(() => {
              this.toggleService.open = false;
              this.ref.markForCheck();
            });
          }
        }
      });
    });
  }
  detachESCListener() {
    if (this.documentESCListener) {
      this.documentESCListener();
      this.documentESCListener = null;
    }
  }
  attachOutsideClickListener() {
    if (this.closeOnOutsideClick && this.toggleService.open) {
      if (document && document.addEventListener) {
        document.addEventListener("click", this.closeOnOutsideClickCallback, true);
      }
    }
  }
  detachOutsideClickListener() {
    if (this.closeOnOutsideClick) {
      if (document && document.removeEventListener) {
        document.removeEventListener("click", this.closeOnOutsideClickCallback, true);
      }
    }
  }
};
AbstractPopover.ɵfac = function AbstractPopover_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || AbstractPopover)(ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(ElementRef, 4));
};
AbstractPopover.ɵdir = ɵɵdefineDirective({
  type: AbstractPopover,
  hostVars: 2,
  hostBindings: function AbstractPopover_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("is-off-screen", ctx.isOffScreen);
    }
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AbstractPopover, [{
    type: Directive
  }], function() {
    return [{
      type: Injector
    }, {
      type: ElementRef,
      decorators: [{
        type: SkipSelf
      }]
    }];
  }, {
    isOffScreen: [{
      type: HostBinding,
      args: ["class.is-off-screen"]
    }]
  });
})();
var ClrDropdownMenu = class extends AbstractPopover {
  constructor(injector, parentHost, nested, focusHandler) {
    if (!parentHost) {
      throw new Error("clr-dropdown-menu should only be used inside of a clr-dropdown");
    }
    super(injector, parentHost);
    if (!nested) {
      this.anchorPoint = Point.BOTTOM_LEFT;
      this.popoverPoint = Point.LEFT_TOP;
    } else {
      this.anchorPoint = Point.RIGHT_TOP;
      this.popoverPoint = Point.LEFT_TOP;
    }
    this.popoverOptions.allowMultipleOpen = true;
    this.popoverOptions.ignoreGlobalESCListener = true;
    this.closeOnOutsideClick = true;
    this.focusHandler = focusHandler;
  }
  set position(position) {
    switch (position) {
      case "top-right":
        this.anchorPoint = Point.TOP_RIGHT;
        this.popoverPoint = Point.RIGHT_BOTTOM;
        break;
      case "top-left":
        this.anchorPoint = Point.TOP_LEFT;
        this.popoverPoint = Point.LEFT_BOTTOM;
        break;
      case "bottom-right":
        this.anchorPoint = Point.BOTTOM_RIGHT;
        this.popoverPoint = Point.RIGHT_TOP;
        break;
      case "bottom-left":
        this.anchorPoint = Point.BOTTOM_LEFT;
        this.popoverPoint = Point.LEFT_TOP;
        break;
      case "right-top":
        this.anchorPoint = Point.RIGHT_TOP;
        this.popoverPoint = Point.LEFT_TOP;
        break;
      case "right-bottom":
        this.anchorPoint = Point.RIGHT_BOTTOM;
        this.popoverPoint = Point.LEFT_BOTTOM;
        break;
      case "left-top":
        this.anchorPoint = Point.LEFT_TOP;
        this.popoverPoint = Point.RIGHT_TOP;
        break;
      case "left-bottom":
        this.anchorPoint = Point.LEFT_BOTTOM;
        this.popoverPoint = Point.RIGHT_BOTTOM;
        break;
      default:
        this.anchorPoint = Point.BOTTOM_LEFT;
        this.popoverPoint = Point.LEFT_TOP;
        break;
    }
  }
  ngAfterContentInit() {
    this.focusHandler.container = this.el.nativeElement;
    this.items.changes.subscribe(() => this.focusHandler.addChildren(this.items.toArray()));
    this.items.notifyOnChanges();
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    this.focusHandler.resetChildren();
  }
};
ClrDropdownMenu.ɵfac = function ClrDropdownMenu_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDropdownMenu)(ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(POPOVER_HOST_ANCHOR, 8), ɵɵdirectiveInject(ClrDropdownMenu, 12), ɵɵdirectiveInject(DropdownFocusHandler));
};
ClrDropdownMenu.ɵcmp = ɵɵdefineComponent({
  type: ClrDropdownMenu,
  selectors: [["clr-dropdown-menu"]],
  contentQueries: function ClrDropdownMenu_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, FocusableItem, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.items = _t);
    }
  },
  hostVars: 3,
  hostBindings: function ClrDropdownMenu_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", "menu");
      ɵɵclassProp("dropdown-menu", true);
    }
  },
  inputs: {
    position: [0, "clrPosition", "position"]
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrDropdownMenu_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDropdownMenu, [{
    type: Component,
    args: [{
      selector: "clr-dropdown-menu",
      template: `<ng-content></ng-content>`,
      host: {
        "[class.dropdown-menu]": "true",
        "[attr.role]": '"menu"'
      }
    }]
  }], function() {
    return [{
      type: Injector
    }, {
      type: ElementRef,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [POPOVER_HOST_ANCHOR]
      }]
    }, {
      type: ClrDropdownMenu,
      decorators: [{
        type: Optional
      }, {
        type: SkipSelf
      }]
    }, {
      type: DropdownFocusHandler
    }];
  }, {
    items: [{
      type: ContentChildren,
      args: [FocusableItem]
    }],
    position: [{
      type: Input,
      args: ["clrPosition"]
    }]
  });
})();
var ClrDropdownTrigger = class {
  constructor(dropdown, toggleService, el, focusHandler) {
    this.toggleService = toggleService;
    this.isRootLevelToggle = true;
    if (dropdown.parent) {
      this.isRootLevelToggle = false;
    }
    focusHandler.trigger = el.nativeElement;
  }
  get active() {
    return this.toggleService.open;
  }
  onDropdownTriggerClick(event) {
    this.toggleService.toggleWithEvent(event);
  }
};
ClrDropdownTrigger.ɵfac = function ClrDropdownTrigger_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDropdownTrigger)(ɵɵdirectiveInject(ClrDropdown), ɵɵdirectiveInject(ClrPopoverToggleService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(DropdownFocusHandler));
};
ClrDropdownTrigger.ɵdir = ɵɵdefineDirective({
  type: ClrDropdownTrigger,
  selectors: [["", "clrDropdownTrigger", ""], ["", "clrDropdownToggle", ""]],
  hostVars: 10,
  hostBindings: function ClrDropdownTrigger_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function ClrDropdownTrigger_click_HostBindingHandler($event) {
        return ctx.onDropdownTriggerClick($event);
      });
    }
    if (rf & 2) {
      ɵɵattribute("aria-haspopup", "menu")("aria-expanded", ctx.active);
      ɵɵclassProp("dropdown-toggle", ctx.isRootLevelToggle)("dropdown-item", !ctx.isRootLevelToggle)("expandable", !ctx.isRootLevelToggle)("active", ctx.active);
    }
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDropdownTrigger, [{
    type: Directive,
    args: [{
      // We support both selectors for legacy reasons
      selector: "[clrDropdownTrigger],[clrDropdownToggle]",
      host: {
        "[class.dropdown-toggle]": "isRootLevelToggle",
        "[class.dropdown-item]": "!isRootLevelToggle",
        "[class.expandable]": "!isRootLevelToggle",
        "[class.active]": "active",
        "[attr.aria-haspopup]": '"menu"',
        "[attr.aria-expanded]": "active"
      }
    }]
  }], function() {
    return [{
      type: ClrDropdown
    }, {
      type: ClrPopoverToggleService
    }, {
      type: ElementRef
    }, {
      type: DropdownFocusHandler
    }];
  }, {
    onDropdownTriggerClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var BasicFocusableItem = class {
  constructor(el, renderer, platformId) {
    this.el = el;
    this.renderer = renderer;
    this.platformId = platformId;
    this.id = uniqueIdFactory();
    this.disabled = false;
    renderer.setAttribute(el.nativeElement, "id", this.id);
    renderer.setAttribute(el.nativeElement, "tabindex", "-1");
  }
  focus() {
    if (isPlatformBrowser(this.platformId)) {
      this.renderer.setAttribute(this.el.nativeElement, "tabindex", "0");
      this.el.nativeElement.focus();
      this.el.nativeElement.scrollIntoView({
        behavior: "smooth",
        block: "center",
        inline: "nearest"
      });
    }
  }
  blur() {
    if (isPlatformBrowser(this.platformId)) {
      this.renderer.setAttribute(this.el.nativeElement, "tabindex", "-1");
      this.el.nativeElement.blur();
    }
  }
  activate() {
    if (isPlatformBrowser(this.platformId)) {
      this.el.nativeElement.click();
    }
  }
};
BasicFocusableItem.ɵfac = function BasicFocusableItem_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || BasicFocusableItem)(ɵɵinject(ElementRef), ɵɵinject(Renderer2), ɵɵinject(PLATFORM_ID));
};
BasicFocusableItem.ɵprov = ɵɵdefineInjectable({
  token: BasicFocusableItem,
  factory: BasicFocusableItem.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BasicFocusableItem, [{
    type: Injectable
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }];
  }, null);
})();
var BASIC_FOCUSABLE_ITEM_PROVIDER = [{
  provide: FocusableItem,
  useClass: BasicFocusableItem
}];
var ClrDropdownItem = class {
  constructor(dropdown, _dropdownService, focusableItem) {
    this.dropdown = dropdown;
    this._dropdownService = _dropdownService;
    this.focusableItem = focusableItem;
  }
  get disabled() {
    return this.focusableItem.disabled;
  }
  set disabled(value) {
    this.focusableItem.disabled = !!value || value === "";
  }
  /**
   * Let you overwrite the focusable auto increment id.
   */
  get dropdownItemId() {
    return this.focusableItem.id;
  }
  set dropdownItemId(value) {
    this.focusableItem.id = value;
  }
  onDropdownItemClick() {
    if (this.dropdown.isMenuClosable && !this.disabled && this.dropdown.toggleService.open) {
      const rootDropdown = this.findRootDropdown();
      rootDropdown.focusHandler.focus();
      rootDropdown.focusHandler.focusBackOnTriggerWhenClosed = false;
    }
    setTimeout(() => {
      if (this.dropdown.isMenuClosable && !this.disabled) {
        this._dropdownService.closeMenus();
      }
    });
  }
  onSpaceKeydown($event) {
    this.stopImmediatePropagationIfDisabled($event);
  }
  onEnterKeydown($event) {
    this.stopImmediatePropagationIfDisabled($event);
  }
  stopImmediatePropagationIfDisabled($event) {
    if (this.disabled) {
      $event.preventDefault();
      $event.stopImmediatePropagation();
    }
  }
  findRootDropdown() {
    let rootDropdown = this.dropdown;
    while (rootDropdown.parent) {
      rootDropdown = rootDropdown.parent;
    }
    return rootDropdown;
  }
};
ClrDropdownItem.ɵfac = function ClrDropdownItem_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDropdownItem)(ɵɵdirectiveInject(ClrDropdown), ɵɵdirectiveInject(RootDropdownService), ɵɵdirectiveInject(FocusableItem));
};
ClrDropdownItem.ɵdir = ɵɵdefineDirective({
  type: ClrDropdownItem,
  selectors: [["", "clrDropdownItem", ""]],
  hostVars: 7,
  hostBindings: function ClrDropdownItem_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function ClrDropdownItem_click_HostBindingHandler() {
        return ctx.onDropdownItemClick();
      })("keydown.space", function ClrDropdownItem_keydown_space_HostBindingHandler($event) {
        return ctx.onSpaceKeydown($event);
      })("keydown.enter", function ClrDropdownItem_keydown_enter_HostBindingHandler($event) {
        return ctx.onEnterKeydown($event);
      });
    }
    if (rf & 2) {
      ɵɵattribute("role", "menuitem")("aria-disabled", ctx.disabled)("id", ctx.dropdownItemId);
      ɵɵclassProp("disabled", ctx.disabled)("dropdown-item", true);
    }
  },
  inputs: {
    disabled: [0, "clrDisabled", "disabled"],
    dropdownItemId: [0, "id", "dropdownItemId"]
  },
  standalone: false,
  features: [ɵɵProvidersFeature([BASIC_FOCUSABLE_ITEM_PROVIDER])]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDropdownItem, [{
    type: Directive,
    args: [{
      selector: "[clrDropdownItem]",
      host: {
        "[class.disabled]": "disabled",
        "[class.dropdown-item]": "true",
        "[attr.role]": '"menuitem"',
        "[attr.aria-disabled]": "disabled",
        "[attr.id]": "dropdownItemId"
      },
      providers: [BASIC_FOCUSABLE_ITEM_PROVIDER]
    }]
  }], function() {
    return [{
      type: ClrDropdown
    }, {
      type: RootDropdownService
    }, {
      type: FocusableItem
    }];
  }, {
    disabled: [{
      type: Input,
      args: ["clrDisabled"]
    }],
    dropdownItemId: [{
      type: Input,
      args: ["id"]
    }],
    onDropdownItemClick: [{
      type: HostListener,
      args: ["click"]
    }],
    onSpaceKeydown: [{
      type: HostListener,
      args: ["keydown.space", ["$event"]]
    }],
    onEnterKeydown: [{
      type: HostListener,
      args: ["keydown.enter", ["$event"]]
    }]
  });
})();
var CLR_MENU_POSITIONS = ["bottom-left", "bottom-right", "top-left", "top-right", "left-bottom", "left-top", "right-bottom", "right-top"];
var CLR_DROPDOWN_DIRECTIVES = [ClrDropdown, ClrDropdownMenu, ClrDropdownTrigger, ClrDropdownItem];
var ClrDropdownModule = class {
};
ClrDropdownModule.ɵfac = function ClrDropdownModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDropdownModule)();
};
ClrDropdownModule.ɵmod = ɵɵdefineNgModule({
  type: ClrDropdownModule,
  declarations: [ClrDropdown, ClrDropdownMenu, ClrDropdownTrigger, ClrDropdownItem],
  imports: [CommonModule],
  exports: [ClrDropdown, ClrDropdownMenu, ClrDropdownTrigger, ClrDropdownItem, ClrConditionalModule, ClrIconModule]
});
ClrDropdownModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrConditionalModule, ClrIconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDropdownModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [CLR_DROPDOWN_DIRECTIVES],
      exports: [CLR_DROPDOWN_DIRECTIVES, ClrConditionalModule, ClrIconModule]
    }]
  }], null, null);
})();
var SignpostFocusManager = class {
  set triggerEl(value) {
    this._triggerEl = value;
  }
  focusTrigger() {
    if (this._triggerEl) {
      this._triggerEl.focus();
    }
  }
};
SignpostFocusManager.ɵfac = function SignpostFocusManager_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || SignpostFocusManager)();
};
SignpostFocusManager.ɵprov = ɵɵdefineInjectable({
  token: SignpostFocusManager,
  factory: SignpostFocusManager.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SignpostFocusManager, [{
    type: Injectable
  }], null, null);
})();
var SignpostIdService = class {
  constructor() {
    this._id = new Subject();
  }
  get id() {
    return this._id.asObservable();
  }
  setId(id) {
    this._id.next(id);
  }
};
SignpostIdService.ɵfac = function SignpostIdService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || SignpostIdService)();
};
SignpostIdService.ɵprov = ɵɵdefineInjectable({
  token: SignpostIdService,
  factory: SignpostIdService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SignpostIdService, [{
    type: Injectable
  }], null, null);
})();
var ClrSignpostTrigger = class {
  constructor(toggleService, el, signpostIdService, signpostFocusManager, document2, platformId) {
    this.toggleService = toggleService;
    this.el = el;
    this.signpostIdService = signpostIdService;
    this.signpostFocusManager = signpostFocusManager;
    this.platformId = platformId;
    this.ariaExpanded = false;
    this.subscriptions = [];
    this.document = document2;
  }
  ngOnInit() {
    this.signpostFocusManager.triggerEl = this.el.nativeElement;
    this.subscriptions.push(this.toggleService.openChange.subscribe((isOpen) => {
      this.ariaExpanded = isOpen;
      const prevIsOpen = this.isOpen;
      this.isOpen = isOpen;
      if (!this.isOpen && prevIsOpen) {
        this.focusOnClose();
      }
    }), this.signpostIdService.id.subscribe((idChange) => this.ariaControl = idChange));
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
  /**********
   *
   * @description
   * click handler for the ClrSignpost trigger button used to hide/show ClrSignpostContent.
   */
  onSignpostTriggerClick(event) {
    this.toggleService.toggleWithEvent(event);
  }
  focusOnClose() {
    if (!isPlatformBrowser(this.platformId)) {
      return;
    }
    if (!this.isOpen && this.document.activeElement === this.document.body) {
      this.signpostFocusManager.focusTrigger();
    }
  }
};
ClrSignpostTrigger.ɵfac = function ClrSignpostTrigger_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrSignpostTrigger)(ɵɵdirectiveInject(ClrPopoverToggleService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(SignpostIdService), ɵɵdirectiveInject(SignpostFocusManager), ɵɵdirectiveInject(DOCUMENT), ɵɵdirectiveInject(PLATFORM_ID));
};
ClrSignpostTrigger.ɵdir = ɵɵdefineDirective({
  type: ClrSignpostTrigger,
  selectors: [["", "clrSignpostTrigger", ""]],
  hostAttrs: [1, "signpost-trigger"],
  hostVars: 4,
  hostBindings: function ClrSignpostTrigger_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function ClrSignpostTrigger_click_HostBindingHandler($event) {
        return ctx.onSignpostTriggerClick($event);
      });
    }
    if (rf & 2) {
      ɵɵattribute("aria-expanded", ctx.ariaExpanded)("aria-controls", ctx.ariaControl);
      ɵɵclassProp("active", ctx.isOpen);
    }
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrSignpostTrigger, [{
    type: Directive,
    args: [{
      selector: "[clrSignpostTrigger]",
      host: {
        class: "signpost-trigger",
        "[attr.aria-expanded]": "ariaExpanded",
        "[attr.aria-controls]": "ariaControl",
        "[class.active]": "isOpen"
      }
    }]
  }], function() {
    return [{
      type: ClrPopoverToggleService
    }, {
      type: ElementRef
    }, {
      type: SignpostIdService
    }, {
      type: SignpostFocusManager
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [DOCUMENT]
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }];
  }, {
    onSignpostTriggerClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var ClrSignpost = class {
  constructor(commonStrings) {
    this.commonStrings = commonStrings;
    this.useCustomTrigger = false;
  }
  /**********
   * @property signPostTrigger
   *
   * @description
   * Uses ContentChild to check for a user supplied element with the ClrSignpostTrigger on it.
   *
   */
  set customTrigger(trigger2) {
    this.useCustomTrigger = !!trigger2;
  }
};
ClrSignpost.ɵfac = function ClrSignpost_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrSignpost)(ɵɵdirectiveInject(ClrCommonStringsService));
};
ClrSignpost.ɵcmp = ɵɵdefineComponent({
  type: ClrSignpost,
  selectors: [["clr-signpost"]],
  contentQueries: function ClrSignpost_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrSignpostTrigger, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.customTrigger = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function ClrSignpost_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("signpost", true);
    }
  },
  standalone: false,
  features: [ɵɵProvidersFeature([SignpostFocusManager, SignpostIdService]), ɵɵHostDirectivesFeature([ClrPopoverHostDirective])],
  ngContentSelectors: _c02,
  decls: 2,
  vars: 1,
  consts: [[4, "ngIf"], ["type", "button", "clrSignpostTrigger", "", 1, "signpost-action", "btn", "btn-sm", "btn-icon", "btn-link"], ["shape", "info-circle"]],
  template: function ClrSignpost_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, ClrSignpost_ng_container_0_Template, 3, 2, "ng-container", 0);
      ɵɵprojection(1);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", !ctx.useCustomTrigger);
    }
  },
  dependencies: [NgIf, CdsIconCustomTag, ClrSignpostTrigger],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrSignpost, [{
    type: Component,
    args: [{
      selector: "clr-signpost",
      template: `
    <ng-container *ngIf="!useCustomTrigger">
      <button
        type="button"
        class="signpost-action btn btn-sm btn-icon btn-link"
        clrSignpostTrigger
        [attr.aria-label]="commonStrings.keys.signpostToggle"
      >
        <cds-icon shape="info-circle" [attr.title]="commonStrings.keys.info"></cds-icon>
      </button>
    </ng-container>

    <ng-content></ng-content>
  `,
      host: {
        "[class.signpost]": "true"
      },
      providers: [SignpostFocusManager, SignpostIdService],
      hostDirectives: [ClrPopoverHostDirective]
    }]
  }], function() {
    return [{
      type: ClrCommonStringsService
    }];
  }, {
    customTrigger: [{
      type: ContentChild,
      args: [ClrSignpostTrigger]
    }]
  });
})();
var SIGNPOST_POSITIONS = {
  "top-left": {
    anchorPoint: Point.TOP_CENTER,
    popoverPoint: Point.BOTTOM_RIGHT,
    offsetY: -16,
    offsetX: 0
  },
  "top-middle": {
    anchorPoint: Point.TOP_CENTER,
    popoverPoint: Point.BOTTOM_CENTER,
    offsetY: -16,
    offsetX: 0
  },
  "top-right": {
    anchorPoint: Point.TOP_CENTER,
    popoverPoint: Point.BOTTOM_LEFT,
    offsetY: -16,
    offsetX: 0
  },
  "right-top": {
    anchorPoint: Point.RIGHT_CENTER,
    popoverPoint: Point.LEFT_BOTTOM,
    offsetY: 0,
    offsetX: 16
  },
  "right-middle": {
    anchorPoint: Point.RIGHT_CENTER,
    popoverPoint: Point.LEFT_CENTER,
    offsetY: 0,
    offsetX: 16
  },
  "right-bottom": {
    anchorPoint: Point.RIGHT_CENTER,
    popoverPoint: Point.LEFT_TOP,
    offsetY: 0,
    offsetX: 16
  },
  "bottom-right": {
    anchorPoint: Point.BOTTOM_CENTER,
    popoverPoint: Point.TOP_LEFT,
    offsetY: 16,
    offsetX: 0
  },
  "bottom-middle": {
    anchorPoint: Point.BOTTOM_CENTER,
    popoverPoint: Point.TOP_CENTER,
    offsetY: 16,
    offsetX: 0
  },
  "bottom-left": {
    anchorPoint: Point.BOTTOM_CENTER,
    popoverPoint: Point.TOP_RIGHT,
    offsetY: 16,
    offsetX: 0
  },
  "left-bottom": {
    anchorPoint: Point.LEFT_CENTER,
    popoverPoint: Point.RIGHT_TOP,
    offsetY: 0,
    offsetX: -16
  },
  "left-middle": {
    anchorPoint: Point.LEFT_CENTER,
    popoverPoint: Point.RIGHT_CENTER,
    offsetY: 0,
    offsetX: -16
  },
  "left-top": {
    anchorPoint: Point.LEFT_CENTER,
    popoverPoint: Point.RIGHT_BOTTOM,
    offsetY: 0,
    offsetX: -16
  },
  default: {
    anchorPoint: Point.RIGHT_CENTER,
    popoverPoint: Point.LEFT_CENTER,
    offsetY: 0,
    offsetX: 16
  }
};
var POSITIONS$1 = ["top-left", "top-middle", "top-right", "right-top", "right-middle", "right-bottom", "bottom-right", "bottom-middle", "bottom-left", "left-bottom", "left-middle", "left-top"];
var ClrSignpostContent = class extends AbstractPopover {
  constructor(injector, parentHost, commonStrings, signpostIdService, signpostFocusManager, platformId, document2) {
    super(injector, parentHost);
    this.commonStrings = commonStrings;
    this.signpostFocusManager = signpostFocusManager;
    this.platformId = platformId;
    this.signpostContentId = uniqueIdFactory();
    if (!parentHost) {
      throw new Error("clr-signpost-content should only be used inside of a clr-signpost");
    }
    this.position = "right-middle";
    this.closeOnOutsideClick = true;
    signpostIdService.setId(this.signpostContentId);
    this.document = document2;
  }
  /*********
   *
   * @description
   * A setter for the position of the ClrSignpostContent popover. This is a combination of the following:
   * - anchorPoint - where on the trigger to anchor the ClrSignpostContent
   * - popoverPoint - where on the ClrSignpostContent container to align with the anchorPoint
   * - offsetY - where on the Y axis to align the ClrSignpostContent so it meets specs
   * - offsetX - where on the X axis to align the ClrSignpostContent so it meets specs
   * There are 12 possible positions to place a ClrSignpostContent container:
   * - top-left
   * - top-middle
   * - top-right
   * - right-top
   * - right-middle
   * - right-bottom
   * - bottom-right
   * - bottom-middle
   * - bottom-left
   * - left-bottom
   * - left-middle
   * - left-top
   *
   * I think of it as follows for 'top-left' -> CONTAINER_SIDE-SIDE_POSITION. In this case CONTAINER_SIDE is 'top'
   * meaning the top of the trigger icon (above the icon that hides/shows) the ClrSignpostContent. And, SIDE_POSITION
   * is 'left' meaning two things: 1) the ClrSignpostContent container extends to the left and 2) the 'arrow/pointer'
   * linking the SingpostContent to the trigger points down at the horizontal center of the trigger icon.
   *
   * @param newPosition
   */
  get position() {
    return this._position;
  }
  set position(position) {
    this.renderer.removeClass(this.el.nativeElement, this.position);
    if (position && POSITIONS$1.indexOf(position) > -1) {
      this._position = position;
    } else {
      this._position = "right-middle";
    }
    this.renderer.addClass(this.el.nativeElement, this.position);
    const setPosition = SIGNPOST_POSITIONS[this.position];
    this.anchorPoint = setPosition.anchorPoint;
    this.popoverPoint = setPosition.popoverPoint;
    this.popoverOptions.offsetY = setPosition.offsetY;
    this.popoverOptions.offsetX = setPosition.offsetX;
  }
  /**********
   *
   * @description
   * Close function that uses the signpost instance to toggle the state of the content popover.
   *
   */
  close() {
    this.toggleService.open = false;
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    if (isPlatformBrowser(this.platformId) && this.el.nativeElement.contains(this.document.activeElement)) {
      this.signpostFocusManager.focusTrigger();
    }
  }
};
ClrSignpostContent.ɵfac = function ClrSignpostContent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrSignpostContent)(ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(POPOVER_HOST_ANCHOR, 8), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(SignpostIdService), ɵɵdirectiveInject(SignpostFocusManager), ɵɵdirectiveInject(PLATFORM_ID), ɵɵdirectiveInject(DOCUMENT));
};
ClrSignpostContent.ɵcmp = ɵɵdefineComponent({
  type: ClrSignpostContent,
  selectors: [["clr-signpost-content"]],
  hostVars: 3,
  hostBindings: function ClrSignpostContent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵhostProperty("id", ctx.signpostContentId);
      ɵɵclassProp("signpost-content", true);
    }
  },
  inputs: {
    signpostCloseAriaLabel: [0, "clrSignpostCloseAriaLabel", "signpostCloseAriaLabel"],
    position: [0, "clrPosition", "position"]
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c122,
  decls: 8,
  vars: 3,
  consts: [[1, "signpost-wrap"], [1, "popover-pointer"], [1, "signpost-content-header"], ["type", "button", 1, "signpost-action", "close", 3, "click"], ["shape", "window-close"], ["tabindex", "0", 1, "signpost-content-body"]],
  template: function ClrSignpostContent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c11);
      ɵɵelementStart(0, "div", 0);
      ɵɵelement(1, "div", 1);
      ɵɵelementStart(2, "div", 2);
      ɵɵprojection(3);
      ɵɵelementStart(4, "button", 3);
      ɵɵlistener("click", function ClrSignpostContent_Template_button_click_4_listener() {
        return ctx.close();
      });
      ɵɵelement(5, "cds-icon", 4);
      ɵɵelementEnd()();
      ɵɵelementStart(6, "div", 5);
      ɵɵprojection(7, 1);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance(4);
      ɵɵattribute("aria-label", ctx.signpostCloseAriaLabel || ctx.commonStrings.keys.signpostClose)("aria-controls", ctx.signpostContentId);
      ɵɵadvance();
      ɵɵattribute("title", ctx.commonStrings.keys.close);
    }
  },
  dependencies: [CdsIconCustomTag],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrSignpostContent, [{
    type: Component,
    args: [{
      selector: "clr-signpost-content",
      template: `
    <div class="signpost-wrap">
      <div class="popover-pointer"></div>
      <div class="signpost-content-header">
        <ng-content select="clr-signpost-title"></ng-content>
        <button
          type="button"
          [attr.aria-label]="signpostCloseAriaLabel || commonStrings.keys.signpostClose"
          class="signpost-action close"
          (click)="close()"
          [attr.aria-controls]="signpostContentId"
        >
          <cds-icon shape="window-close" [attr.title]="commonStrings.keys.close"></cds-icon>
        </button>
      </div>
      <div class="signpost-content-body" tabindex="0">
        <ng-content></ng-content>
      </div>
    </div>
  `,
      host: {
        "[class.signpost-content]": "true",
        "[id]": "signpostContentId"
      }
    }]
  }], function() {
    return [{
      type: Injector
    }, {
      type: ElementRef,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [POPOVER_HOST_ANCHOR]
      }]
    }, {
      type: ClrCommonStringsService
    }, {
      type: SignpostIdService
    }, {
      type: SignpostFocusManager
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [DOCUMENT]
      }]
    }];
  }, {
    signpostCloseAriaLabel: [{
      type: Input,
      args: ["clrSignpostCloseAriaLabel"]
    }],
    position: [{
      type: Input,
      args: ["clrPosition"]
    }]
  });
})();
var ClrSignpostTitle = class {
};
ClrSignpostTitle.ɵfac = function ClrSignpostTitle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrSignpostTitle)();
};
ClrSignpostTitle.ɵcmp = ɵɵdefineComponent({
  type: ClrSignpostTitle,
  selectors: [["clr-signpost-title"]],
  hostVars: 2,
  hostBindings: function ClrSignpostTitle_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("signpost-title", true);
    }
  },
  standalone: false,
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrSignpostTitle_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrSignpostTitle, [{
    type: Component,
    args: [{
      selector: "clr-signpost-title",
      template: `<ng-content></ng-content>`,
      host: {
        "[class.signpost-title]": "true"
      }
    }]
  }], null, null);
})();
var CLR_SIGNPOST_DIRECTIVES = [ClrSignpost, ClrSignpostContent, ClrSignpostTrigger, ClrSignpostTitle];
var ClrSignpostModule = class {
  constructor() {
    r.addIcons(L3, o6);
  }
};
ClrSignpostModule.ɵfac = function ClrSignpostModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrSignpostModule)();
};
ClrSignpostModule.ɵmod = ɵɵdefineNgModule({
  type: ClrSignpostModule,
  declarations: [ClrSignpost, ClrSignpostContent, ClrSignpostTrigger, ClrSignpostTitle],
  imports: [CommonModule, ClrIconModule, ClrFocusOnViewInitModule],
  exports: [ClrSignpost, ClrSignpostContent, ClrSignpostTrigger, ClrSignpostTitle, ClrConditionalModule]
});
ClrSignpostModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrIconModule, ClrFocusOnViewInitModule, ClrConditionalModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrSignpostModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ClrIconModule, ClrFocusOnViewInitModule],
      declarations: [CLR_SIGNPOST_DIRECTIVES],
      exports: [CLR_SIGNPOST_DIRECTIVES, ClrConditionalModule]
    }]
  }], function() {
    return [];
  }, null);
})();
var TooltipIdService = class {
  constructor() {
    this._id = new Subject();
  }
  get id() {
    return this._id.asObservable();
  }
  updateId(id) {
    this._id.next(id);
  }
};
TooltipIdService.ɵfac = function TooltipIdService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TooltipIdService)();
};
TooltipIdService.ɵprov = ɵɵdefineInjectable({
  token: TooltipIdService,
  factory: TooltipIdService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TooltipIdService, [{
    type: Injectable
  }], null, null);
})();
var TooltipMouseService = class {
  constructor(toggleService) {
    this.toggleService = toggleService;
  }
  onMouseEnterTrigger() {
    this.mouseOverTrigger = true;
    this.toggleService.open = true;
  }
  onMouseLeaveTrigger() {
    this.mouseOverTrigger = false;
    this.hideIfMouseOut();
  }
  onMouseEnterContent() {
    this.mouseOverContent = true;
  }
  onMouseLeaveContent() {
    this.mouseOverContent = false;
    this.hideIfMouseOut();
  }
  hideIfMouseOut() {
    setTimeout(() => {
      if (!this.mouseOverTrigger && !this.mouseOverContent) {
        this.toggleService.open = false;
      }
    }, 0);
  }
};
TooltipMouseService.ɵfac = function TooltipMouseService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TooltipMouseService)(ɵɵinject(ClrPopoverToggleService));
};
TooltipMouseService.ɵprov = ɵɵdefineInjectable({
  token: TooltipMouseService,
  factory: TooltipMouseService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TooltipMouseService, [{
    type: Injectable
  }], function() {
    return [{
      type: ClrPopoverToggleService
    }];
  }, null);
})();
var ClrTooltip = class {
};
ClrTooltip.ɵfac = function ClrTooltip_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrTooltip)();
};
ClrTooltip.ɵcmp = ɵɵdefineComponent({
  type: ClrTooltip,
  selectors: [["clr-tooltip"]],
  hostVars: 2,
  hostBindings: function ClrTooltip_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("tooltip", true);
    }
  },
  standalone: false,
  features: [ɵɵProvidersFeature([TooltipIdService, TooltipMouseService]), ɵɵHostDirectivesFeature([ClrPopoverHostDirective])],
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrTooltip_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTooltip, [{
    type: Component,
    args: [{
      selector: "clr-tooltip",
      template: `<ng-content></ng-content>`,
      host: {
        "[class.tooltip]": "true"
      },
      providers: [TooltipIdService, TooltipMouseService],
      hostDirectives: [ClrPopoverHostDirective]
    }]
  }], null, null);
})();
function assertNever(value) {
  throw new Error(`Unhandled value: ${value}`);
}
var POSITIONS = ["bottom-left", "bottom-right", "top-left", "top-right", "right", "left"];
var SIZES = ["xs", "sm", "md", "lg"];
var defaultPosition = "right";
var defaultSize = "sm";
var ClrTooltipContent = class extends AbstractPopover {
  constructor(injector, parentHost, tooltipIdService, tooltipMouseService) {
    super(injector, parentHost);
    this.tooltipIdService = tooltipIdService;
    this.tooltipMouseService = tooltipMouseService;
    if (!parentHost) {
      throw new Error("clr-tooltip-content should only be used inside of a clr-tooltip");
    }
    this.id = uniqueIdFactory();
  }
  get id() {
    return this._id;
  }
  set id(value) {
    const id = value || "";
    this._id = id;
    this.tooltipIdService.updateId(id);
  }
  get position() {
    return this._position;
  }
  set position(value) {
    const oldPosition = this._position;
    const newPosition = POSITIONS.includes(value) ? value : defaultPosition;
    this._position = newPosition;
    this.updateCssClass({
      oldClass: `tooltip-${oldPosition}`,
      newClass: `tooltip-${newPosition}`
    });
    switch (newPosition) {
      case "top-right":
        this.anchorPoint = Point.TOP_CENTER;
        this.popoverPoint = Point.LEFT_BOTTOM;
        break;
      case "top-left":
        this.anchorPoint = Point.TOP_CENTER;
        this.popoverPoint = Point.RIGHT_BOTTOM;
        break;
      case "bottom-right":
        this.anchorPoint = Point.BOTTOM_CENTER;
        this.popoverPoint = Point.LEFT_TOP;
        break;
      case "bottom-left":
        this.anchorPoint = Point.BOTTOM_CENTER;
        this.popoverPoint = Point.RIGHT_TOP;
        break;
      case "right":
        this.anchorPoint = Point.RIGHT_CENTER;
        this.popoverPoint = Point.LEFT_TOP;
        break;
      case "left":
        this.anchorPoint = Point.LEFT_CENTER;
        this.popoverPoint = Point.RIGHT_TOP;
        break;
      default:
        assertNever(newPosition);
    }
  }
  get size() {
    return this._size;
  }
  set size(value) {
    const oldSize = this._size;
    const newSize = SIZES.includes(value) ? value : defaultSize;
    this._size = newSize;
    this.updateCssClass({
      oldClass: `tooltip-${oldSize}`,
      newClass: `tooltip-${newSize}`
    });
  }
  ngOnInit() {
    this.size = this.size || defaultSize;
    this.position = this.position || defaultPosition;
  }
  onMouseEnter() {
    this.tooltipMouseService.onMouseEnterContent();
  }
  onMouseLeave() {
    this.tooltipMouseService.onMouseLeaveContent();
  }
  updateCssClass({
    oldClass,
    newClass
  }) {
    this.renderer.removeClass(this.el.nativeElement, oldClass);
    this.renderer.addClass(this.el.nativeElement, newClass);
  }
};
ClrTooltipContent.ɵfac = function ClrTooltipContent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrTooltipContent)(ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(POPOVER_HOST_ANCHOR, 8), ɵɵdirectiveInject(TooltipIdService), ɵɵdirectiveInject(TooltipMouseService));
};
ClrTooltipContent.ɵcmp = ɵɵdefineComponent({
  type: ClrTooltipContent,
  selectors: [["clr-tooltip-content"]],
  hostVars: 6,
  hostBindings: function ClrTooltipContent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("mouseenter", function ClrTooltipContent_mouseenter_HostBindingHandler() {
        return ctx.onMouseEnter();
      })("mouseleave", function ClrTooltipContent_mouseleave_HostBindingHandler() {
        return ctx.onMouseLeave();
      });
    }
    if (rf & 2) {
      ɵɵhostProperty("id", ctx.id);
      ɵɵattribute("role", "tooltip");
      ɵɵstyleProp("opacity", 1);
      ɵɵclassProp("tooltip-content", true);
    }
  },
  inputs: {
    id: "id",
    position: [0, "clrPosition", "position"],
    size: [0, "clrSize", "size"]
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrTooltipContent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTooltipContent, [{
    type: Component,
    args: [{
      selector: "clr-tooltip-content",
      template: `<ng-content></ng-content>`,
      host: {
        "[class.tooltip-content]": "true",
        "[style.opacity]": "1",
        "[attr.role]": '"tooltip"',
        "[id]": "id"
      }
    }]
  }], function() {
    return [{
      type: Injector
    }, {
      type: ElementRef,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [POPOVER_HOST_ANCHOR]
      }]
    }, {
      type: TooltipIdService
    }, {
      type: TooltipMouseService
    }];
  }, {
    id: [{
      type: Input
    }],
    position: [{
      type: Input,
      args: ["clrPosition"]
    }],
    size: [{
      type: Input,
      args: ["clrSize"]
    }],
    onMouseEnter: [{
      type: HostListener,
      args: ["mouseenter"]
    }],
    onMouseLeave: [{
      type: HostListener,
      args: ["mouseleave"]
    }]
  });
})();
var ClrTooltipTrigger = class {
  constructor(toggleService, tooltipIdService, tooltipMouseService) {
    this.toggleService = toggleService;
    this.tooltipMouseService = tooltipMouseService;
    this.subs = [];
    this.subs.push(tooltipIdService.id.subscribe((tooltipId) => this.ariaDescribedBy = tooltipId));
  }
  ngOnDestroy() {
    this.subs.forEach((sub) => sub.unsubscribe());
  }
  showTooltip() {
    this.toggleService.open = true;
  }
  hideTooltip() {
    this.toggleService.open = false;
  }
  onMouseEnter() {
    this.tooltipMouseService.onMouseEnterTrigger();
  }
  onMouseLeave() {
    this.tooltipMouseService.onMouseLeaveTrigger();
  }
};
ClrTooltipTrigger.ɵfac = function ClrTooltipTrigger_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrTooltipTrigger)(ɵɵdirectiveInject(ClrPopoverToggleService), ɵɵdirectiveInject(TooltipIdService), ɵɵdirectiveInject(TooltipMouseService));
};
ClrTooltipTrigger.ɵdir = ɵɵdefineDirective({
  type: ClrTooltipTrigger,
  selectors: [["", "clrTooltipTrigger", ""]],
  hostAttrs: ["tabindex", "0"],
  hostVars: 4,
  hostBindings: function ClrTooltipTrigger_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("focus", function ClrTooltipTrigger_focus_HostBindingHandler() {
        return ctx.showTooltip();
      })("blur", function ClrTooltipTrigger_blur_HostBindingHandler() {
        return ctx.hideTooltip();
      })("mouseenter", function ClrTooltipTrigger_mouseenter_HostBindingHandler() {
        return ctx.onMouseEnter();
      })("mouseleave", function ClrTooltipTrigger_mouseleave_HostBindingHandler() {
        return ctx.onMouseLeave();
      });
    }
    if (rf & 2) {
      ɵɵattribute("aria-describedby", ctx.ariaDescribedBy)("role", "button");
      ɵɵclassProp("tooltip-trigger", true);
    }
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTooltipTrigger, [{
    type: Directive,
    args: [{
      selector: "[clrTooltipTrigger]",
      host: {
        tabindex: "0",
        "[class.tooltip-trigger]": "true",
        "[attr.aria-describedby]": "ariaDescribedBy",
        "[attr.role]": '"button"'
      }
    }]
  }], function() {
    return [{
      type: ClrPopoverToggleService
    }, {
      type: TooltipIdService
    }, {
      type: TooltipMouseService
    }];
  }, {
    showTooltip: [{
      type: HostListener,
      args: ["focus"]
    }],
    hideTooltip: [{
      type: HostListener,
      args: ["blur"]
    }],
    onMouseEnter: [{
      type: HostListener,
      args: ["mouseenter"]
    }],
    onMouseLeave: [{
      type: HostListener,
      args: ["mouseleave"]
    }]
  });
})();
var CLR_TOOLTIP_DIRECTIVES = [ClrTooltip, ClrTooltipTrigger, ClrTooltipContent];
var ClrTooltipModule = class {
};
ClrTooltipModule.ɵfac = function ClrTooltipModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrTooltipModule)();
};
ClrTooltipModule.ɵmod = ɵɵdefineNgModule({
  type: ClrTooltipModule,
  declarations: [ClrTooltip, ClrTooltipTrigger, ClrTooltipContent],
  imports: [CommonModule],
  exports: [ClrTooltip, ClrTooltipTrigger, ClrTooltipContent, ClrConditionalModule, ClrIconModule]
});
ClrTooltipModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrConditionalModule, ClrIconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTooltipModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [CLR_TOOLTIP_DIRECTIVES],
      exports: [CLR_TOOLTIP_DIRECTIVES, ClrConditionalModule, ClrIconModule]
    }]
  }], null, null);
})();
var ClrPopoverModule = class {
};
ClrPopoverModule.ɵfac = function ClrPopoverModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrPopoverModule)();
};
ClrPopoverModule.ɵmod = ɵɵdefineNgModule({
  type: ClrPopoverModule,
  exports: [ClrDropdownModule, ClrSignpostModule, ClrTooltipModule]
});
ClrPopoverModule.ɵinj = ɵɵdefineInjector({
  imports: [ClrDropdownModule, ClrSignpostModule, ClrTooltipModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrPopoverModule, [{
    type: NgModule,
    args: [{
      exports: [ClrDropdownModule, ClrSignpostModule, ClrTooltipModule]
    }]
  }], null, null);
})();
var ClrFormLayout;
(function(ClrFormLayout2) {
  ClrFormLayout2["VERTICAL"] = "vertical";
  ClrFormLayout2["HORIZONTAL"] = "horizontal";
  ClrFormLayout2["COMPACT"] = "compact";
})(ClrFormLayout || (ClrFormLayout = {}));
var LayoutService = class {
  constructor() {
    this.minLabelSize = 1;
    this.maxLabelSize = 12;
    this.layout = ClrFormLayout.HORIZONTAL;
    this.layoutValues = Object.keys(ClrFormLayout).map((key) => ClrFormLayout[key]);
    this._labelSize = 2;
  }
  get labelSize() {
    return this._labelSize;
  }
  set labelSize(size) {
    if (this.labelSizeIsValid(size)) {
      this._labelSize = size;
    }
  }
  get layoutClass() {
    return `clr-form-${this.layout}`;
  }
  isVertical() {
    return this.layout === ClrFormLayout.VERTICAL;
  }
  isHorizontal() {
    return this.layout === ClrFormLayout.HORIZONTAL;
  }
  isCompact() {
    return this.layout === ClrFormLayout.COMPACT;
  }
  isValid(layout) {
    return this.layoutValues.indexOf(layout) > -1;
  }
  labelSizeIsValid(labelSize) {
    return Number.isInteger(labelSize) && labelSize >= this.minLabelSize && labelSize <= this.maxLabelSize;
  }
};
LayoutService.ɵfac = function LayoutService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || LayoutService)();
};
LayoutService.ɵprov = ɵɵdefineInjectable({
  token: LayoutService,
  factory: LayoutService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LayoutService, [{
    type: Injectable
  }], null, null);
})();
var ClrLabel = class {
  constructor(controlIdService, layoutService, ngControlService, renderer, el) {
    this.controlIdService = controlIdService;
    this.layoutService = layoutService;
    this.ngControlService = ngControlService;
    this.renderer = renderer;
    this.el = el;
    this.enableGrid = true;
    this.subscriptions = [];
  }
  get labelText() {
    return this.el.nativeElement && this.el.nativeElement.textContent;
  }
  ngOnInit() {
    this.idAttr = this.idInput;
    if (this.controlIdService || this.ngControlService) {
      this.renderer.addClass(this.el.nativeElement, "clr-control-label");
    }
    if (this.enableGrid && this.layoutService && !this.layoutService.isVertical() && this.el.nativeElement && this.el.nativeElement.className.indexOf("clr-col") < 0) {
      this.renderer.addClass(this.el.nativeElement, "clr-col-12");
      this.renderer.addClass(this.el.nativeElement, `clr-col-md-${this.layoutService.labelSize}`);
    }
    if (this.controlIdService && !this.forAttr) {
      this.subscriptions.push(this.controlIdService.idChange.subscribe((id) => {
        this.forAttr = id;
        this.idAttr = this.idInput || `${id}-label`;
      }));
    }
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
  disableGrid() {
    this.enableGrid = false;
  }
  /**
   * Allowing signposts inside labels to work without disabling default behavior. <label> is spreading a click event to its children so signposts get
   * automatically closed once clicked inside a <label>.
   * @param event
   */
  onClick(event) {
    this.preventDefaultOnSignpostTarget(event);
  }
  preventDefaultOnSignpostTarget(event) {
    if (this.signpost && this.signpost.nativeElement && this.signpost.nativeElement.contains(event.target)) {
      event.preventDefault();
    }
  }
};
ClrLabel.ɵfac = function ClrLabel_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrLabel)(ɵɵdirectiveInject(ControlIdService, 8), ɵɵdirectiveInject(LayoutService, 8), ɵɵdirectiveInject(NgControlService, 8), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
};
ClrLabel.ɵdir = ɵɵdefineDirective({
  type: ClrLabel,
  selectors: [["label"]],
  contentQueries: function ClrLabel_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrSignpost, 5, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.signpost = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function ClrLabel_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function ClrLabel_click_HostBindingHandler($event) {
        return ctx.onClick($event);
      });
    }
    if (rf & 2) {
      ɵɵattribute("id", ctx.idAttr)("for", ctx.forAttr);
    }
  },
  inputs: {
    idInput: [0, "id", "idInput"],
    forAttr: [0, "for", "forAttr"]
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrLabel, [{
    type: Directive,
    args: [{
      selector: "label"
    }]
  }], function() {
    return [{
      type: ControlIdService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: LayoutService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: NgControlService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }];
  }, {
    idInput: [{
      type: Input,
      args: ["id"]
    }],
    idAttr: [{
      type: HostBinding,
      args: ["attr.id"]
    }],
    forAttr: [{
      type: Input,
      args: ["for"]
    }, {
      type: HostBinding,
      args: ["attr.for"]
    }],
    signpost: [{
      type: ContentChild,
      args: [ClrSignpost, {
        read: ElementRef
      }]
    }],
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var ClrControlSuccess = class extends ClrAbstractControl {
  constructor(controlIdService, containerIdService) {
    super(controlIdService, containerIdService);
    this.controlIdService = controlIdService;
    this.containerIdService = containerIdService;
    this.controlIdSuffix = CONTROL_SUFFIX.SUCCESS;
  }
};
ClrControlSuccess.ɵfac = function ClrControlSuccess_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrControlSuccess)(ɵɵdirectiveInject(ControlIdService, 8), ɵɵdirectiveInject(ContainerIdService, 8));
};
ClrControlSuccess.ɵcmp = ɵɵdefineComponent({
  type: ClrControlSuccess,
  selectors: [["clr-control-success"]],
  hostVars: 5,
  hostBindings: function ClrControlSuccess_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("id", ctx.id);
      ɵɵclassProp("clr-subtext", true)("success", true);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrControlSuccess_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrControlSuccess, [{
    type: Component,
    args: [{
      selector: "clr-control-success",
      template: `<ng-content></ng-content>`,
      host: {
        "[class.clr-subtext]": "true",
        "[class.success]": "true",
        "[attr.id]": "id"
      }
    }]
  }], function() {
    return [{
      type: ControlIdService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ContainerIdService,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var CLASS_ERROR = "clr-error";
var CLASS_SUCCESS = "clr-success";
var ControlClassService = class {
  constructor(layoutService) {
    this.layoutService = layoutService;
    this.className = "";
  }
  controlClass(state2 = CONTROL_STATE.NONE, grid = false, additional = "") {
    const controlClasses = [this.className, additional];
    switch (state2) {
      case CONTROL_STATE.VALID:
        controlClasses.push(CLASS_SUCCESS);
        break;
      case CONTROL_STATE.INVALID:
        controlClasses.push(CLASS_ERROR);
        break;
    }
    if (grid && this.layoutService && this.className.indexOf("clr-col") === -1) {
      controlClasses.push(`clr-col-md-${this.layoutService.maxLabelSize - this.layoutService.labelSize} clr-col-12`);
    }
    return controlClasses.join(" ").trim();
  }
  // We want to remove the column classes from the input up to the container
  initControlClass(renderer, element) {
    if (element && element.className) {
      this.className = element.className;
      const klasses = element.className.split(" ");
      klasses.forEach((klass) => {
        if (klass.startsWith("clr-col")) {
          renderer.removeClass(element, klass);
        }
      });
    }
  }
};
ControlClassService.ɵfac = function ControlClassService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ControlClassService)(ɵɵinject(LayoutService, 8));
};
ControlClassService.ɵprov = ɵɵdefineInjectable({
  token: ControlClassService,
  factory: ControlClassService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ControlClassService, [{
    type: Injectable
  }], function() {
    return [{
      type: LayoutService,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var ClrAbstractContainer = class {
  constructor(ifControlStateService, layoutService, controlClassService, ngControlService) {
    this.ifControlStateService = ifControlStateService;
    this.layoutService = layoutService;
    this.controlClassService = controlClassService;
    this.ngControlService = ngControlService;
    this._dynamic = false;
    this.subscriptions = [];
    this.subscriptions.push(ifControlStateService.statusChanges.subscribe((state2) => {
      this.state = state2;
      setTimeout(() => {
        this.updateHelpers();
      });
    }));
    this.subscriptions.push(ngControlService.controlChanges.subscribe((control) => {
      this.control = control;
    }));
  }
  /**
   * @NOTE
   * Helper control is a bit different than the others, it must be always visible:
   *   -  Labels and instructions must always accompany forms and are persistent.
   *   -  The recommendation here is to always have helper text or anything instructions visible.
   *   -  The expectation is to have error text + helper text in the errored state. this way all users will have the helper text information always available.
   */
  get showHelper() {
    return Boolean(this.controlHelperComponent);
  }
  get showValid() {
    return this.touched && this.state === CONTROL_STATE.VALID && this.successMessagePresent;
  }
  get showInvalid() {
    return this.touched && this.state === CONTROL_STATE.INVALID && this.errorMessagePresent;
  }
  get successMessagePresent() {
    return !!this.controlSuccessComponent;
  }
  get errorMessagePresent() {
    return !!this.controlErrorComponent;
  }
  get touched() {
    return this.control?.touched;
  }
  ngAfterContentInit() {
    this.updateHelpers();
  }
  ngOnDestroy() {
    this.subscriptions.forEach((subscription) => subscription.unsubscribe());
  }
  controlClass() {
    if (!this.controlSuccessComponent && this.state === CONTROL_STATE.VALID || !this.touched) {
      return this.controlClassService.controlClass(CONTROL_STATE.NONE, this.addGrid());
    }
    return this.controlClassService.controlClass(this.state, this.addGrid());
  }
  addGrid() {
    return this.layoutService && !this.layoutService.isVertical();
  }
  updateHelpers() {
    if (this.ngControlService) {
      this.ngControlService.setHelpers({
        show: this.showInvalid || this.showHelper || this.showValid,
        showInvalid: this.showInvalid,
        showHelper: this.showHelper,
        showValid: this.showValid
      });
    }
  }
};
ClrAbstractContainer.ɵfac = function ClrAbstractContainer_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrAbstractContainer)(ɵɵdirectiveInject(IfControlStateService), ɵɵdirectiveInject(LayoutService, 8), ɵɵdirectiveInject(ControlClassService), ɵɵdirectiveInject(NgControlService));
};
ClrAbstractContainer.ɵdir = ɵɵdefineDirective({
  type: ClrAbstractContainer,
  contentQueries: function ClrAbstractContainer_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrLabel, 5);
      ɵɵcontentQuery(dirIndex, ClrControlSuccess, 5);
      ɵɵcontentQuery(dirIndex, ClrControlError, 5);
      ɵɵcontentQuery(dirIndex, ClrControlHelper, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.label = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.controlSuccessComponent = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.controlErrorComponent = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.controlHelperComponent = _t.first);
    }
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrAbstractContainer, [{
    type: Directive
  }], function() {
    return [{
      type: IfControlStateService
    }, {
      type: LayoutService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ControlClassService
    }, {
      type: NgControlService
    }];
  }, {
    label: [{
      type: ContentChild,
      args: [ClrLabel, {
        static: false
      }]
    }],
    controlSuccessComponent: [{
      type: ContentChild,
      args: [ClrControlSuccess]
    }],
    controlErrorComponent: [{
      type: ContentChild,
      args: [ClrControlError]
    }],
    controlHelperComponent: [{
      type: ContentChild,
      args: [ClrControlHelper]
    }]
  });
})();
var ClrControlContainer = class extends ClrAbstractContainer {
};
ClrControlContainer.ɵfac = /* @__PURE__ */ (() => {
  let ɵClrControlContainer_BaseFactory;
  return function ClrControlContainer_Factory(__ngFactoryType__) {
    return (ɵClrControlContainer_BaseFactory || (ɵClrControlContainer_BaseFactory = ɵɵgetInheritedFactory(ClrControlContainer)))(__ngFactoryType__ || ClrControlContainer);
  };
})();
ClrControlContainer.ɵcmp = ɵɵdefineComponent({
  type: ClrControlContainer,
  selectors: [["clr-control-container"]],
  hostVars: 6,
  hostBindings: function ClrControlContainer_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-form-control", true)("clr-form-control-disabled", ctx.control == null ? null : ctx.control.disabled)("clr-row", ctx.addGrid());
    }
  },
  standalone: false,
  features: [ɵɵProvidersFeature([IfControlStateService, NgControlService, ControlIdService, ControlClassService]), ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c14,
  decls: 10,
  vars: 7,
  consts: [[4, "ngIf"], [1, "clr-control-container", 3, "ngClass"], [1, "clr-input-wrapper"], ["class", "clr-validate-icon", "shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 4, "ngIf"], ["class", "clr-validate-icon", "shape", "check-circle", "status", "success", "aria-hidden", "true", 4, "ngIf"], ["shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 1, "clr-validate-icon"], ["shape", "check-circle", "status", "success", "aria-hidden", "true", 1, "clr-validate-icon"]],
  template: function ClrControlContainer_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c13);
      ɵɵprojection(0);
      ɵɵtemplate(1, ClrControlContainer_label_1_Template, 1, 0, "label", 0);
      ɵɵelementStart(2, "div", 1)(3, "div", 2);
      ɵɵprojection(4, 1);
      ɵɵtemplate(5, ClrControlContainer_cds_icon_5_Template, 1, 0, "cds-icon", 3)(6, ClrControlContainer_cds_icon_6_Template, 1, 0, "cds-icon", 4);
      ɵɵelementEnd();
      ɵɵtemplate(7, ClrControlContainer_ng_content_7_Template, 1, 0, "ng-content", 0)(8, ClrControlContainer_ng_content_8_Template, 1, 0, "ng-content", 0)(9, ClrControlContainer_ng_content_9_Template, 1, 0, "ng-content", 0);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.label && ctx.addGrid());
      ɵɵadvance();
      ɵɵproperty("ngClass", ctx.controlClass());
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showHelper);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
    }
  },
  dependencies: [NgClass, NgIf, CdsIconCustomTag, ClrLabel],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrControlContainer, [{
    type: Component,
    args: [{
      selector: "clr-control-container",
      template: `
    <ng-content select="label"></ng-content>
    <label *ngIf="!label && addGrid()"></label>
    <div class="clr-control-container" [ngClass]="controlClass()">
      <div class="clr-input-wrapper">
        <ng-content></ng-content>
        <cds-icon
          *ngIf="showInvalid"
          class="clr-validate-icon"
          shape="exclamation-circle"
          status="danger"
          aria-hidden="true"
        ></cds-icon>
        <cds-icon
          *ngIf="showValid"
          class="clr-validate-icon"
          shape="check-circle"
          status="success"
          aria-hidden="true"
        ></cds-icon>
      </div>
      <ng-content select="clr-control-helper" *ngIf="showHelper"></ng-content>
      <ng-content select="clr-control-error" *ngIf="showInvalid"></ng-content>
      <ng-content select="clr-control-success" *ngIf="showValid"></ng-content>
    </div>
  `,
      host: {
        "[class.clr-form-control]": "true",
        "[class.clr-form-control-disabled]": "control?.disabled",
        "[class.clr-row]": "addGrid()"
      },
      providers: [IfControlStateService, NgControlService, ControlIdService, ControlClassService]
    }]
  }], null, null);
})();
var HostWrapper = class {
  constructor(containerType, vcr, index = 0) {
    this.injector = vcr.injector;
    if (!this.injector.get(containerType, null)) {
      const cfr = this.injector.get(ComponentFactoryResolver$1);
      const el = this.injector.get(ElementRef);
      vcr.createComponent(cfr.resolveComponentFactory(EmptyAnchor));
      const factory = cfr.resolveComponentFactory(containerType);
      const element = [];
      element[index] = [el.nativeElement];
      const containerRef = vcr.createComponent(factory, void 0, void 0, element);
      vcr.remove(0);
      containerRef.instance._dynamic = true;
      this.injector = containerRef.injector;
    }
  }
  get(token, notFoundValue) {
    return this.injector.get(token, notFoundValue);
  }
};
var MarkControlService = class {
  constructor() {
    this._touched = new Subject();
  }
  get touchedChange() {
    return this._touched.asObservable();
  }
  markAsTouched() {
    this._touched.next();
  }
};
MarkControlService.ɵfac = function MarkControlService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || MarkControlService)();
};
MarkControlService.ɵprov = ɵɵdefineInjectable({
  token: MarkControlService,
  factory: MarkControlService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MarkControlService, [{
    type: Injectable
  }], null, null);
})();
var CHANGE_KEYS;
(function(CHANGE_KEYS2) {
  CHANGE_KEYS2["FORM"] = "form";
  CHANGE_KEYS2["MODEL"] = "model";
})(CHANGE_KEYS || (CHANGE_KEYS = {}));
var WrappedFormControl = class {
  // I lost way too much time trying to make this work without injecting the ViewContainerRef and the Injector,
  // I'm giving up. So we have to inject these two manually for now.
  constructor(vcr, wrapperType, injector, ngControl, renderer, el) {
    this.vcr = vcr;
    this.wrapperType = wrapperType;
    this.ngControl = ngControl;
    this.renderer = renderer;
    this.el = el;
    this.index = 0;
    this.subscriptions = [];
    if (injector) {
      this.ngControlService = injector.get(NgControlService, null);
      this.ifControlStateService = injector.get(IfControlStateService, null);
      this.controlClassService = injector.get(ControlClassService, null);
      this.markControlService = injector.get(MarkControlService, null);
      this.differs = injector.get(KeyValueDiffers, null);
    }
    if (this.controlClassService) {
      this.controlClassService.initControlClass(renderer, el.nativeElement);
    }
    if (this.markControlService) {
      this.subscriptions.push(this.markControlService.touchedChange.subscribe(() => {
        this.markAsTouched();
      }));
    }
    if (this.ngControlService) {
      this.subscriptions.push(this.ngControlService.helpersChange.subscribe((state2) => {
        this.setAriaDescribedBy(state2);
      }));
    }
    if (ngControl) {
      this.differ = this.differs.find(ngControl).create();
    }
  }
  get id() {
    return this._id;
  }
  set id(value) {
    this._id = value;
    if (this.controlIdService) {
      this.controlIdService.id = value;
    }
  }
  ngOnInit() {
    this._containerInjector = new HostWrapper(this.wrapperType, this.vcr, this.index);
    this.controlIdService = this._containerInjector.get(ControlIdService);
    this.containerIdService = this._containerInjector.get(ContainerIdService, null);
    if (this._id) {
      this.controlIdService.id = this._id;
    } else {
      this._id = this.controlIdService.id;
    }
    if (this.ngControlService && this.ngControl) {
      this.ngControlService.setControl(this.ngControl);
    }
  }
  ngDoCheck() {
    if (this.differ) {
      const changes = this.differ.diff(this.ngControl);
      if (changes) {
        changes.forEachChangedItem((change) => {
          if ((change.key === CHANGE_KEYS.FORM || change.key === CHANGE_KEYS.MODEL) && change.currentValue !== change.previousValue) {
            this.triggerValidation();
          }
        });
      }
    }
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
  triggerValidation() {
    if (this.ifControlStateService) {
      this.ifControlStateService.triggerStatusChange();
    }
  }
  // @TODO This method has a try/catch due to an unknown issue that came when building the clrToggle feature
  // We need to figure out why this fails for the ClrToggle scenario but works for Date picker...
  // To see the error, remove the try/catch here and run the ClrToggle suite to see issues getting the container
  // injector in time, and this ONLY HAPPENS in tests and not in dev/prod mode.
  getProviderFromContainer(token, notFoundValue) {
    try {
      return this._containerInjector.get(token, notFoundValue);
    } catch (e5) {
      return notFoundValue;
    }
  }
  markAsTouched() {
    if (this.ngControl) {
      this.ngControl.control.markAsTouched();
      this.ngControl.control.updateValueAndValidity();
    }
  }
  setAriaDescribedBy(helpers) {
    if (helpers.show) {
      const ariaDescribedBy = this.getAriaDescribedById(helpers);
      if (ariaDescribedBy !== null) {
        this.renderer.setAttribute(this.el.nativeElement, "aria-describedby", ariaDescribedBy);
        return;
      }
    }
    this.renderer.removeAttribute(this.el.nativeElement, "aria-describedby");
  }
  getAriaDescribedById(helpers) {
    const elementId = this.containerIdService?.id || this.controlIdService?.id;
    if (!elementId) {
      return null;
    }
    const describedByIds = [`${elementId}-${CONTROL_SUFFIX.HELPER}`];
    if (helpers.showInvalid) {
      describedByIds.push(`${elementId}-${CONTROL_SUFFIX.ERROR}`);
    } else if (helpers.showValid) {
      describedByIds.push(`${elementId}-${CONTROL_SUFFIX.SUCCESS}`);
    }
    return describedByIds.join(" ");
  }
};
WrappedFormControl.ɵfac = function WrappedFormControl_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || WrappedFormControl)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Type), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(NgControl), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
};
WrappedFormControl.ɵdir = ɵɵdefineDirective({
  type: WrappedFormControl,
  hostVars: 1,
  hostBindings: function WrappedFormControl_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("blur", function WrappedFormControl_blur_HostBindingHandler() {
        return ctx.triggerValidation();
      });
    }
    if (rf & 2) {
      ɵɵhostProperty("id", ctx.id);
    }
  },
  inputs: {
    id: "id"
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WrappedFormControl, [{
    type: Directive
  }], function() {
    return [{
      type: ViewContainerRef
    }, {
      type: Type
    }, {
      type: Injector
    }, {
      type: NgControl
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }];
  }, {
    id: [{
      type: Input
    }, {
      type: HostBinding
    }],
    triggerValidation: [{
      type: HostListener,
      args: ["blur"]
    }]
  });
})();
var ClrControl = class extends WrappedFormControl {
  constructor(vcr, injector, control, renderer, el) {
    super(vcr, ClrControlContainer, injector, control, renderer, el);
    this.index = 1;
  }
};
ClrControl.ɵfac = function ClrControl_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrControl)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(NgControl, 10), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
};
ClrControl.ɵdir = ɵɵdefineDirective({
  type: ClrControl,
  selectors: [["", "clrControl", ""]],
  hostVars: 2,
  hostBindings: function ClrControl_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-input", true);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrControl, [{
    type: Directive,
    args: [{
      selector: "[clrControl]",
      host: {
        "[class.clr-input]": "true"
      }
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }, {
      type: Injector
    }, {
      type: NgControl,
      decorators: [{
        type: Self
      }, {
        type: Optional
      }]
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }];
  }, null);
})();
var ClrForm = class {
  constructor(layoutService, markControlService) {
    this.layoutService = layoutService;
    this.markControlService = markControlService;
  }
  set labelSize(size) {
    const sizeNumber = parseInt(size, 10) || 2;
    this.layoutService.labelSize = sizeNumber;
  }
  onFormSubmit() {
    this.markAsTouched();
  }
  // Trying to avoid adding an input and keep this backwards compatible at the same time
  markAsTouched() {
    this.markControlService.markAsTouched();
  }
};
ClrForm.ɵfac = function ClrForm_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrForm)(ɵɵdirectiveInject(LayoutService), ɵɵdirectiveInject(MarkControlService));
};
ClrForm.ɵdir = ɵɵdefineDirective({
  type: ClrForm,
  selectors: [["", "clrForm", ""]],
  contentQueries: function ClrForm_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrLabel, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.labels = _t);
    }
  },
  hostVars: 6,
  hostBindings: function ClrForm_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("submit", function ClrForm_submit_HostBindingHandler() {
        return ctx.onFormSubmit();
      });
    }
    if (rf & 2) {
      ɵɵclassProp("clr-form", true)("clr-form-horizontal", ctx.layoutService.isHorizontal())("clr-form-compact", ctx.layoutService.isCompact());
    }
  },
  inputs: {
    labelSize: [0, "clrLabelSize", "labelSize"]
  },
  standalone: false,
  features: [ɵɵProvidersFeature([LayoutService, MarkControlService])]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrForm, [{
    type: Directive,
    args: [{
      selector: "[clrForm]",
      providers: [LayoutService, MarkControlService],
      host: {
        "[class.clr-form]": "true",
        "[class.clr-form-horizontal]": "layoutService.isHorizontal()",
        "[class.clr-form-compact]": "layoutService.isCompact()"
      }
    }]
  }], function() {
    return [{
      type: LayoutService
    }, {
      type: MarkControlService
    }];
  }, {
    labels: [{
      type: ContentChildren,
      args: [ClrLabel, {
        descendants: true
      }]
    }],
    labelSize: [{
      type: Input,
      args: ["clrLabelSize"]
    }],
    onFormSubmit: [{
      type: HostListener,
      args: ["submit"]
    }]
  });
})();
var AbstractIfState = class {
  constructor(ifControlStateService, ngControlService) {
    this.ifControlStateService = ifControlStateService;
    this.ngControlService = ngControlService;
    this.subscriptions = [];
    this.displayedContent = false;
    if (ngControlService) {
      this.subscriptions.push(ngControlService.controlChanges.subscribe((control) => {
        this.control = control;
      }));
    }
    if (ifControlStateService) {
      this.subscriptions.push(ifControlStateService.statusChanges.subscribe((state2) => {
        this.handleState(state2);
      }));
    }
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
  handleState(_state) {
  }
};
AbstractIfState.ɵfac = function AbstractIfState_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || AbstractIfState)(ɵɵdirectiveInject(IfControlStateService, 8), ɵɵdirectiveInject(NgControlService, 8));
};
AbstractIfState.ɵdir = ɵɵdefineDirective({
  type: AbstractIfState,
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AbstractIfState, [{
    type: Directive
  }], function() {
    return [{
      type: IfControlStateService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: NgControlService,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var ClrIfError = class extends AbstractIfState {
  constructor(ifControlStateService, ngControlService, template, container) {
    super(ifControlStateService, ngControlService);
    this.template = template;
    this.container = container;
    if (!this.ifControlStateService) {
      throw new Error("clrIfError can only be used within a form control container element like clr-input-container");
    }
  }
  /**
   * @param state CONTROL_STATE
   */
  handleState(state2) {
    if (this.error && this.control) {
      this.displayError(this.control.hasError(this.error));
    } else {
      this.displayError(CONTROL_STATE.INVALID === state2);
    }
  }
  displayError(invalid) {
    if (!this.container) {
      return;
    }
    if (invalid) {
      if (this.displayedContent === false) {
        this.embeddedViewRef = this.container.createEmbeddedView(this.template, {
          error: this.control.getError(this.error)
        });
        this.displayedContent = true;
      } else if (this.embeddedViewRef && this.embeddedViewRef.context) {
        this.embeddedViewRef.context.error = this.control.getError(this.error);
      }
    } else {
      this.container.clear();
      this.displayedContent = false;
    }
  }
};
ClrIfError.ɵfac = function ClrIfError_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrIfError)(ɵɵdirectiveInject(IfControlStateService, 8), ɵɵdirectiveInject(NgControlService, 8), ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(ViewContainerRef));
};
ClrIfError.ɵdir = ɵɵdefineDirective({
  type: ClrIfError,
  selectors: [["", "clrIfError", ""]],
  inputs: {
    error: [0, "clrIfError", "error"]
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrIfError, [{
    type: Directive,
    args: [{
      selector: "[clrIfError]"
    }]
  }], function() {
    return [{
      type: IfControlStateService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: NgControlService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: TemplateRef
    }, {
      type: ViewContainerRef
    }];
  }, {
    error: [{
      type: Input,
      args: ["clrIfError"]
    }]
  });
})();
var ClrIfSuccess = class extends AbstractIfState {
  constructor(ifControlStateService, ngControlService, template, container) {
    super(ifControlStateService, ngControlService);
    this.template = template;
    this.container = container;
    if (!ifControlStateService) {
      throw new Error("ClrIfSuccess can only be used within a form control container element like clr-input-container");
    }
  }
  /**
   * @param state CONTROL_STATE
   */
  handleState(state2) {
    const isValid = CONTROL_STATE.VALID === state2;
    if (isValid && !this.displayedContent) {
      this.container.createEmbeddedView(this.template);
    } else if (!isValid && this.container) {
      this.container.clear();
    }
    this.displayedContent = isValid;
  }
};
ClrIfSuccess.ɵfac = function ClrIfSuccess_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrIfSuccess)(ɵɵdirectiveInject(IfControlStateService, 8), ɵɵdirectiveInject(NgControlService, 8), ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(ViewContainerRef));
};
ClrIfSuccess.ɵdir = ɵɵdefineDirective({
  type: ClrIfSuccess,
  selectors: [["", "clrIfSuccess", ""]],
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrIfSuccess, [{
    type: Directive,
    args: [{
      selector: "[clrIfSuccess]"
    }]
  }], function() {
    return [{
      type: IfControlStateService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: NgControlService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: TemplateRef
    }, {
      type: ViewContainerRef
    }];
  }, null);
})();
var ClrLayout = class {
  constructor(layoutService) {
    this.layoutService = layoutService;
  }
  ngOnInit() {
    if (this.layout && this.layoutService.isValid(this.layout)) {
      this.layoutService.layout = this.layout;
    }
  }
};
ClrLayout.ɵfac = function ClrLayout_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrLayout)(ɵɵdirectiveInject(LayoutService));
};
ClrLayout.ɵdir = ɵɵdefineDirective({
  type: ClrLayout,
  selectors: [["", "clrForm", "", "clrLayout", ""]],
  inputs: {
    layout: [0, "clrLayout", "layout"]
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrLayout, [{
    type: Directive,
    args: [{
      selector: "[clrForm][clrLayout]"
    }]
  }], function() {
    return [{
      type: LayoutService
    }];
  }, {
    layout: [{
      type: Input,
      args: ["clrLayout"]
    }]
  });
})();
var ClrCommonFormsModule = class {
  constructor() {
    r.addIcons(o4, e);
  }
};
ClrCommonFormsModule.ɵfac = function ClrCommonFormsModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrCommonFormsModule)();
};
ClrCommonFormsModule.ɵmod = ɵɵdefineNgModule({
  type: ClrCommonFormsModule,
  declarations: [ClrLabel, ClrControlError, ClrControlSuccess, ClrControlHelper, ClrIfError, ClrIfSuccess, ClrForm, ClrLayout, ClrControlContainer, ClrControl],
  imports: [CommonModule, ClrIconModule],
  exports: [ClrLabel, ClrControlError, ClrControlSuccess, ClrControlHelper, ClrIfError, ClrIfSuccess, ClrForm, ClrLayout, ClrControlContainer, ClrControl]
});
ClrCommonFormsModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrIconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrCommonFormsModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ClrIconModule],
      declarations: [ClrLabel, ClrControlError, ClrControlSuccess, ClrControlHelper, ClrIfError, ClrIfSuccess, ClrForm, ClrLayout, ClrControlContainer, ClrControl],
      exports: [ClrLabel, ClrControlError, ClrControlSuccess, ClrControlHelper, ClrIfError, ClrIfSuccess, ClrForm, ClrLayout, ClrControlContainer, ClrControl]
    }]
  }], function() {
    return [];
  }, null);
})();
var IS_TOGGLE = new InjectionToken("IS_TOGGLE");
function isToggleFactory() {
  return new BehaviorSubject(false);
}
var IS_TOGGLE_PROVIDER = {
  provide: IS_TOGGLE,
  useFactory: isToggleFactory
};
var ClrCheckboxWrapper = class {
  constructor(toggleService) {
    this._dynamic = false;
    this.toggle = false;
    this.subscriptions = [];
    this.subscriptions.push(toggleService.subscribe((state2) => {
      this.toggle = state2;
    }));
  }
  ngOnInit() {
    if (this.label) {
      this.label.disableGrid();
    }
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
};
ClrCheckboxWrapper.ɵfac = function ClrCheckboxWrapper_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrCheckboxWrapper)(ɵɵdirectiveInject(IS_TOGGLE));
};
ClrCheckboxWrapper.ɵcmp = ɵɵdefineComponent({
  type: ClrCheckboxWrapper,
  selectors: [["clr-checkbox-wrapper"], ["clr-toggle-wrapper"]],
  contentQueries: function ClrCheckboxWrapper_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrLabel, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.label = _t.first);
    }
  },
  hostVars: 4,
  hostBindings: function ClrCheckboxWrapper_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-checkbox-wrapper", !ctx.toggle)("clr-toggle-wrapper", ctx.toggle);
    }
  },
  standalone: false,
  features: [ɵɵProvidersFeature([ControlIdService, IS_TOGGLE_PROVIDER])],
  ngContentSelectors: _c16,
  decls: 3,
  vars: 1,
  consts: [[4, "ngIf"]],
  template: function ClrCheckboxWrapper_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c15);
      ɵɵprojection(0);
      ɵɵprojection(1, 1);
      ɵɵtemplate(2, ClrCheckboxWrapper_label_2_Template, 1, 0, "label", 0);
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵproperty("ngIf", !ctx.label);
    }
  },
  dependencies: [NgIf, ClrLabel],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrCheckboxWrapper, [{
    type: Component,
    args: [{
      selector: "clr-checkbox-wrapper,clr-toggle-wrapper",
      template: `
    <ng-content select="[clrCheckbox],[clrToggle]"></ng-content>
    <ng-content select="label"></ng-content>
    <label *ngIf="!label"></label>
  `,
      host: {
        "[class.clr-checkbox-wrapper]": "!toggle",
        "[class.clr-toggle-wrapper]": "toggle"
      },
      providers: [ControlIdService, IS_TOGGLE_PROVIDER]
    }]
  }], function() {
    return [{
      type: BehaviorSubject,
      decorators: [{
        type: Inject,
        args: [IS_TOGGLE]
      }]
    }];
  }, {
    label: [{
      type: ContentChild,
      args: [ClrLabel, {
        static: true
      }]
    }]
  });
})();
var ClrCheckbox = class extends WrappedFormControl {
  constructor(vcr, injector, control, renderer, el, toggle) {
    super(vcr, ClrCheckboxWrapper, injector, control, renderer, el);
    this.toggle = toggle;
  }
  ngOnInit() {
    super.ngOnInit();
    const toggleService = this.getProviderFromContainer(IS_TOGGLE, null);
    if (toggleService && this.toggle !== null) {
      toggleService.next(true);
    }
  }
};
ClrCheckbox.ɵfac = function ClrCheckbox_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrCheckbox)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(NgControl, 10), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵinjectAttribute("clrToggle"));
};
ClrCheckbox.ɵdir = ɵɵdefineDirective({
  type: ClrCheckbox,
  selectors: [["", "clrCheckbox", ""], ["", "clrToggle", ""]],
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrCheckbox, [{
    type: Directive,
    args: [{
      selector: "[clrCheckbox],[clrToggle]"
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }, {
      type: Injector
    }, {
      type: NgControl,
      decorators: [{
        type: Self
      }, {
        type: Optional
      }]
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: void 0,
      decorators: [{
        type: Attribute,
        args: ["clrToggle"]
      }]
    }];
  }, null);
})();
var ClrCheckboxContainer = class extends ClrAbstractContainer {
  constructor(layoutService, controlClassService, ngControlService, ifControlStateService) {
    super(ifControlStateService, layoutService, controlClassService, ngControlService);
    this.layoutService = layoutService;
    this.controlClassService = controlClassService;
    this.ngControlService = ngControlService;
    this.ifControlStateService = ifControlStateService;
    this.inline = false;
  }
  /*
   * Here we want to support the following cases
   * clrInline - true by presence
   * clrInline="true|false" - unless it is explicitly false, strings are considered true
   * [clrInline]="true|false" - expect a boolean
   */
  get clrInline() {
    return this.inline;
  }
  set clrInline(value) {
    if (typeof value === "string") {
      this.inline = value === "false" ? false : true;
    } else {
      this.inline = !!value;
    }
  }
  ngAfterContentInit() {
    this.setAriaRoles();
  }
  setAriaRoles() {
    this.role = this.checkboxes.length ? "group" : null;
  }
};
ClrCheckboxContainer.ɵfac = function ClrCheckboxContainer_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrCheckboxContainer)(ɵɵdirectiveInject(LayoutService, 8), ɵɵdirectiveInject(ControlClassService), ɵɵdirectiveInject(NgControlService), ɵɵdirectiveInject(IfControlStateService));
};
ClrCheckboxContainer.ɵcmp = ɵɵdefineComponent({
  type: ClrCheckboxContainer,
  selectors: [["clr-checkbox-container"], ["clr-toggle-container"]],
  contentQueries: function ClrCheckboxContainer_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrCheckbox, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.checkboxes = _t);
    }
  },
  hostVars: 7,
  hostBindings: function ClrCheckboxContainer_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", ctx.role);
      ɵɵclassProp("clr-form-control", true)("clr-form-control-disabled", ctx.control == null ? null : ctx.control.disabled)("clr-row", ctx.addGrid());
    }
  },
  inputs: {
    clrInline: "clrInline"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([IfControlStateService, NgControlService, ControlClassService, ContainerIdService]), ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c18,
  decls: 6,
  vars: 6,
  consts: [[4, "ngIf"], [1, "clr-control-container", 3, "ngClass"], ["class", "clr-subtext-wrapper", 4, "ngIf"], [1, "clr-subtext-wrapper"], ["class", "clr-validate-icon", "shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 4, "ngIf"], ["class", "clr-validate-icon", "shape", "check-circle", "status", "success", "aria-hidden", "true", 4, "ngIf"], ["shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 1, "clr-validate-icon"], ["shape", "check-circle", "status", "success", "aria-hidden", "true", 1, "clr-validate-icon"]],
  template: function ClrCheckboxContainer_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c17);
      ɵɵprojection(0);
      ɵɵtemplate(1, ClrCheckboxContainer_label_1_Template, 1, 0, "label", 0);
      ɵɵelementStart(2, "div", 1);
      ɵɵprojection(3, 1);
      ɵɵtemplate(4, ClrCheckboxContainer_div_4_Template, 2, 0, "div", 2)(5, ClrCheckboxContainer_div_5_Template, 5, 4, "div", 2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.label && ctx.addGrid());
      ɵɵadvance();
      ɵɵclassProp("clr-control-inline", ctx.clrInline);
      ɵɵproperty("ngClass", ctx.controlClass());
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.showHelper);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showInvalid || ctx.showValid);
    }
  },
  dependencies: [NgClass, NgIf, CdsIconCustomTag, ClrLabel],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrCheckboxContainer, [{
    type: Component,
    args: [{
      selector: "clr-checkbox-container,clr-toggle-container",
      template: `
    <ng-content select="label"></ng-content>
    <label *ngIf="!label && addGrid()"></label>
    <div class="clr-control-container" [class.clr-control-inline]="clrInline" [ngClass]="controlClass()">
      <ng-content select="clr-checkbox-wrapper,clr-toggle-wrapper"></ng-content>
      <div *ngIf="showHelper" class="clr-subtext-wrapper">
        <ng-content select="clr-control-helper"></ng-content>
      </div>
      <div *ngIf="showInvalid || showValid" class="clr-subtext-wrapper">
        <cds-icon
          *ngIf="showInvalid"
          class="clr-validate-icon"
          shape="exclamation-circle"
          status="danger"
          aria-hidden="true"
        ></cds-icon>
        <cds-icon
          *ngIf="showValid"
          class="clr-validate-icon"
          shape="check-circle"
          status="success"
          aria-hidden="true"
        ></cds-icon>
        <ng-content select="clr-control-error" *ngIf="showInvalid"></ng-content>
        <ng-content select="clr-control-success" *ngIf="showValid"></ng-content>
      </div>
    </div>
  `,
      host: {
        "[class.clr-form-control]": "true",
        "[class.clr-form-control-disabled]": "control?.disabled",
        "[class.clr-row]": "addGrid()",
        "[attr.role]": "role"
      },
      providers: [IfControlStateService, NgControlService, ControlClassService, ContainerIdService]
    }]
  }], function() {
    return [{
      type: LayoutService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ControlClassService
    }, {
      type: NgControlService
    }, {
      type: IfControlStateService
    }];
  }, {
    checkboxes: [{
      type: ContentChildren,
      args: [ClrCheckbox, {
        descendants: true
      }]
    }],
    clrInline: [{
      type: Input
    }]
  });
})();
var ClrCheckboxModule = class {
  constructor() {
    r.addIcons(o4, e);
  }
};
ClrCheckboxModule.ɵfac = function ClrCheckboxModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrCheckboxModule)();
};
ClrCheckboxModule.ɵmod = ɵɵdefineNgModule({
  type: ClrCheckboxModule,
  declarations: [ClrCheckbox, ClrCheckboxContainer, ClrCheckboxWrapper],
  imports: [CommonModule, ClrIconModule, ClrCommonFormsModule, ClrHostWrappingModule],
  exports: [ClrCommonFormsModule, ClrCheckbox, ClrCheckboxContainer, ClrCheckboxWrapper]
});
ClrCheckboxModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrIconModule, ClrCommonFormsModule, ClrHostWrappingModule, ClrCommonFormsModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrCheckboxModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ClrIconModule, ClrCommonFormsModule, ClrHostWrappingModule],
      declarations: [ClrCheckbox, ClrCheckboxContainer, ClrCheckboxWrapper],
      exports: [ClrCommonFormsModule, ClrCheckbox, ClrCheckboxContainer, ClrCheckboxWrapper]
    }]
  }], function() {
    return [];
  }, null);
})();
function isBooleanAttributeSet(value) {
  if (value === null) {
    return false;
  }
  if (typeof value === "string") {
    return value.length >= 0;
  }
  return typeof value === "boolean" ? value : false;
}
var ClrSpinner = class {
  /**
   * Default class for all spinners. This class is always true
   */
  get spinnerClass() {
    return true;
  }
  get inlineClass() {
    return this._inline;
  }
  set clrInline(value) {
    this._inline = isBooleanAttributeSet(value);
  }
  get inverseClass() {
    return this._inverse;
  }
  set clrInverse(value) {
    this._inverse = isBooleanAttributeSet(value);
  }
  get smallClass() {
    return this._small;
  }
  set clrSmall(value) {
    this._small = isBooleanAttributeSet(value);
  }
  /**
   * When clrSmall & clrMedium are set both to true.
   * The CSS with high priority will be small - so medium size will be ignored.
   *
   * For this reason if clrSmall is set we won't add clrMedium class.
   *
   * NOTE: This is dictated by the CSS rules.
   * DON'T USE clrSmall & clrMedium to toggle classes. This could change without notice.
   *
   * Also there is no logical need to have both of them set to TRUE or FALSE.
   */
  get mediumClass() {
    if (this._small) {
      return false;
    }
    return this._medium;
  }
  set clrMedium(value) {
    this._medium = isBooleanAttributeSet(value);
  }
};
ClrSpinner.ɵfac = function ClrSpinner_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrSpinner)();
};
ClrSpinner.ɵcmp = ɵɵdefineComponent({
  type: ClrSpinner,
  selectors: [["clr-spinner"]],
  hostVars: 11,
  hostBindings: function ClrSpinner_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("aria-busy", true);
      ɵɵclassProp("spinner", ctx.spinnerClass)("spinner-inline", ctx.inlineClass)("spinner-inverse", ctx.inverseClass)("spinner-sm", ctx.smallClass)("spinner-md", ctx.mediumClass);
    }
  },
  inputs: {
    clrInline: "clrInline",
    clrInverse: "clrInverse",
    clrSmall: "clrSmall",
    clrMedium: "clrMedium"
  },
  standalone: false,
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrSpinner_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrSpinner, [{
    type: Component,
    args: [{
      selector: "clr-spinner",
      template: `<ng-content></ng-content>`,
      host: {
        "[attr.aria-busy]": "true"
      }
    }]
  }], null, {
    spinnerClass: [{
      type: HostBinding,
      args: ["class.spinner"]
    }],
    inlineClass: [{
      type: HostBinding,
      args: ["class.spinner-inline"]
    }],
    clrInline: [{
      type: Input,
      args: ["clrInline"]
    }],
    inverseClass: [{
      type: HostBinding,
      args: ["class.spinner-inverse"]
    }],
    clrInverse: [{
      type: Input,
      args: ["clrInverse"]
    }],
    smallClass: [{
      type: HostBinding,
      args: ["class.spinner-sm"]
    }],
    clrSmall: [{
      type: Input,
      args: ["clrSmall"]
    }],
    mediumClass: [{
      type: HostBinding,
      args: ["class.spinner-md"]
    }],
    clrMedium: [{
      type: Input,
      args: ["clrMedium"]
    }]
  });
})();
var CLR_SPINNER_DIRECTIVES = [ClrSpinner];
var ClrSpinnerModule = class {
};
ClrSpinnerModule.ɵfac = function ClrSpinnerModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrSpinnerModule)();
};
ClrSpinnerModule.ɵmod = ɵɵdefineNgModule({
  type: ClrSpinnerModule,
  declarations: [ClrSpinner],
  imports: [CommonModule],
  exports: [ClrSpinner]
});
ClrSpinnerModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrSpinnerModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [CLR_SPINNER_DIRECTIVES],
      exports: [CLR_SPINNER_DIRECTIVES]
    }]
  }], null, null);
})();
var ClrFocusDirection;
(function(ClrFocusDirection2) {
  ClrFocusDirection2["VERTICAL"] = "vertical";
  ClrFocusDirection2["HORIZONTAL"] = "horizontal";
  ClrFocusDirection2["BOTH"] = "both";
})(ClrFocusDirection || (ClrFocusDirection = {}));
var ClrKeyFocusItem = class {
  constructor(elementRef, platformId) {
    this.elementRef = elementRef;
    this.platformId = platformId;
  }
  get nativeElement() {
    return this.elementRef.nativeElement;
  }
  focus() {
    if (isPlatformBrowser(this.platformId)) {
      this.elementRef.nativeElement.focus();
    }
  }
};
ClrKeyFocusItem.ɵfac = function ClrKeyFocusItem_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrKeyFocusItem)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(PLATFORM_ID));
};
ClrKeyFocusItem.ɵdir = ɵɵdefineDirective({
  type: ClrKeyFocusItem,
  selectors: [["", "clrKeyFocusItem", ""]],
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrKeyFocusItem, [{
    type: Directive,
    args: [{
      selector: "[clrKeyFocusItem]"
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }];
  }, null);
})();
var ClrKeyFocus = class {
  constructor(elementRef) {
    this.elementRef = elementRef;
    this.direction = ClrFocusDirection.VERTICAL;
    this.focusOnLoad = false;
    this.subscriptions = [];
    this.focusChange = new EventEmitter();
    this._current = 0;
  }
  /**
   * Here we use `any` cause any other type require reworking all methods below and a lot of more ifs.
   * this method will only work with array with FocusableItems anyway so any other value will be ignored.
   */
  get focusableItems() {
    if (this._focusableItems) {
      return this._focusableItems;
    } else if (this.clrKeyFocusItems) {
      return this.clrKeyFocusItems.toArray();
    }
    return [];
  }
  set focusableItems(elements) {
    if (Array.isArray(elements) && elements.length) {
      this._focusableItems = elements;
      this.initializeFocus();
    }
  }
  get nativeElement() {
    return this.elementRef.nativeElement;
  }
  get current() {
    return this._current;
  }
  set current(value) {
    if (this._current !== value) {
      this._current = value;
    }
  }
  get currentItem() {
    return this.focusableItems[this._current];
  }
  get currentItemElement() {
    return this.currentItem.nativeElement ? this.currentItem.nativeElement : this.currentItem;
  }
  ngAfterContentInit() {
    this.subscriptions.push(this.listenForItemUpdates());
    this.initializeFocus();
  }
  ngOnDestroy() {
    this.subscriptions.forEach((s) => s.unsubscribe());
  }
  handleKeyboardEvent(event) {
    if (this.currentItemElement !== event.target) {
      const position = this.getItemPosition(event.target);
      if (this.positionInRange(position)) {
        this.current = position;
      }
    }
    if (this.prevKeyPressed(event) && this.currentFocusIsNotFirstItem()) {
      this.moveTo(this.current - 1);
    } else if (this.nextKeyPressed(event) && this.currentFocusIsNotLastItem()) {
      this.moveTo(this.current + 1);
    } else if (event.code === Keys.Home) {
      this.moveTo(0);
    } else if (event.code === Keys.End) {
      this.moveTo(this.focusableItems.length - 1);
    }
    preventArrowKeyScroll(event);
  }
  setClickedItemCurrent(event) {
    const position = this.getItemPosition(event.target);
    if (position > -1) {
      this.moveTo(position);
    }
  }
  focusCurrent() {
    this.currentItem.focus();
    this.focusChange.next(this._current);
  }
  moveTo(position) {
    if (this.positionInRange(position)) {
      this.current = position;
      this.focusCurrent();
    }
  }
  positionInRange(position) {
    return position >= 0 && position < this.focusableItems.length;
  }
  currentFocusIsNotFirstItem() {
    return this._current - 1 >= 0;
  }
  currentFocusIsNotLastItem() {
    return this._current + 1 < this.focusableItems.length;
  }
  initializeFocus() {
    if (this.focusableItems && this.focusableItems.length) {
      if (this._current >= this.focusableItems.length) {
        this._current = this.focusableItems.length - 1;
      }
      if (this.focusOnLoad) {
        this.currentItem.focus();
        this.focusChange.emit();
      }
    }
  }
  nextKeyPressed(event) {
    const key = normalizeKey(event.key);
    switch (this.direction) {
      case ClrFocusDirection.VERTICAL:
        return key === Keys.ArrowDown;
      case ClrFocusDirection.HORIZONTAL:
        return key === Keys.ArrowRight;
      case ClrFocusDirection.BOTH:
        return key === Keys.ArrowDown || key === Keys.ArrowRight;
      default:
        return false;
    }
  }
  prevKeyPressed(event) {
    const key = normalizeKey(event.key);
    switch (this.direction) {
      case ClrFocusDirection.VERTICAL:
        return key === Keys.ArrowUp;
      case ClrFocusDirection.HORIZONTAL:
        return key === Keys.ArrowLeft;
      case ClrFocusDirection.BOTH:
        return key === Keys.ArrowUp || key === Keys.ArrowLeft;
      default:
        return false;
    }
  }
  getItemPosition(item) {
    if (this._focusableItems) {
      return this.focusableItems.indexOf(item);
    } else {
      return this.focusableItems.map((_item) => _item.nativeElement).indexOf(item);
    }
  }
  listenForItemUpdates() {
    return this.clrKeyFocusItems.changes.subscribe(() => {
      this.initializeFocus();
    });
  }
};
ClrKeyFocus.ɵfac = function ClrKeyFocus_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrKeyFocus)(ɵɵdirectiveInject(ElementRef));
};
ClrKeyFocus.ɵcmp = ɵɵdefineComponent({
  type: ClrKeyFocus,
  selectors: [["", "clrKeyFocus", ""]],
  contentQueries: function ClrKeyFocus_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrKeyFocusItem, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.clrKeyFocusItems = _t);
    }
  },
  hostBindings: function ClrKeyFocus_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("keydown", function ClrKeyFocus_keydown_HostBindingHandler($event) {
        return ctx.handleKeyboardEvent($event);
      })("click", function ClrKeyFocus_click_HostBindingHandler($event) {
        return ctx.setClickedItemCurrent($event);
      });
    }
  },
  inputs: {
    direction: [0, "clrDirection", "direction"],
    focusOnLoad: [0, "clrFocusOnLoad", "focusOnLoad"],
    focusableItems: [0, "clrKeyFocus", "focusableItems"]
  },
  outputs: {
    focusChange: "clrFocusChange"
  },
  standalone: false,
  attrs: _c19,
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrKeyFocus_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrKeyFocus, [{
    type: Component,
    args: [{
      selector: "[clrKeyFocus]",
      template: "<ng-content></ng-content>"
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, {
    direction: [{
      type: Input,
      args: ["clrDirection"]
    }],
    focusOnLoad: [{
      type: Input,
      args: ["clrFocusOnLoad"]
    }],
    clrKeyFocusItems: [{
      type: ContentChildren,
      args: [ClrKeyFocusItem, {
        descendants: true
      }]
    }],
    focusChange: [{
      type: Output,
      args: ["clrFocusChange"]
    }],
    focusableItems: [{
      type: Input,
      args: ["clrKeyFocus"]
    }],
    handleKeyboardEvent: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }],
    setClickedItemCurrent: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var ClrRovingTabindex = class extends ClrKeyFocus {
  constructor(elementRef, renderer) {
    super(elementRef);
    this.renderer = renderer;
    this.disabled = false;
  }
  // Proxy the input, as the selector name from parent class will still be "clrKeyFocus".
  get rovingIndexItems() {
    return this.focusableItems;
  }
  set rovingIndexItems(elements) {
    this.focusableItems = elements;
  }
  set rovingTabindexDisabled(disabled) {
    this.disabled = disabled;
    if (this.currentItem) {
      this.setTabindex(this.currentItem, disabled ? -1 : 0);
    }
  }
  handleKeyboardEvent(event) {
    if (this.prevKeyPressed(event) && this.currentFocusIsNotFirstItem()) {
      this.updateTabindex(this.current - 1);
    } else if (this.nextKeyPressed(event) && this.currentFocusIsNotLastItem()) {
      this.updateTabindex(this.current + 1);
    } else if (event.code === Keys.Home) {
      this.updateTabindex(0);
    } else if (event.code === Keys.End) {
      this.updateTabindex(this.focusableItems.length - 1);
    }
    super.handleKeyboardEvent(event);
  }
  setClickedItemCurrent(event) {
    let position;
    if (this.focusableItems[0].nativeElement) {
      position = this.focusableItems.map((item) => item.nativeElement).indexOf(event.target);
    } else {
      position = this.focusableItems.indexOf(event.target);
    }
    if (position > -1) {
      this.updateTabindex(position);
    }
    super.setClickedItemCurrent(event);
  }
  initializeFocus() {
    if (this.focusableItems && this.focusableItems.length) {
      this.focusableItems.forEach((item) => {
        this.setTabindex(item, -1);
      });
      if (this.current >= this.focusableItems.length) {
        this.current = this.focusableItems.length - 1;
      }
      if (!this.disabled && this.currentItem) {
        this.setTabindex(this.currentItem, 0);
      }
    }
    super.initializeFocus();
  }
  updateTabindex(newIndex) {
    this.setTabindex(this.currentItem, -1);
    this.setTabindex(this.focusableItems[newIndex], 0);
  }
  setTabindex(item, value) {
    if (item instanceof HTMLElement) {
      this.renderer.setAttribute(item, "tabindex", value.toString());
    } else {
      this.renderer.setAttribute(item.nativeElement, "tabindex", value.toString());
    }
  }
};
ClrRovingTabindex.ɵfac = function ClrRovingTabindex_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrRovingTabindex)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
};
ClrRovingTabindex.ɵcmp = ɵɵdefineComponent({
  type: ClrRovingTabindex,
  selectors: [["", "clrRovingTabindex", ""]],
  inputs: {
    rovingIndexItems: [0, "clrRovingTabindex", "rovingIndexItems"],
    rovingTabindexDisabled: [0, "clrRovingTabindexDisabled", "rovingTabindexDisabled"]
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature],
  attrs: _c20,
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrRovingTabindex_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrRovingTabindex, [{
    type: Component,
    args: [{
      selector: "[clrRovingTabindex]",
      template: "<ng-content></ng-content>"
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }];
  }, {
    rovingIndexItems: [{
      type: Input,
      args: ["clrRovingTabindex"]
    }],
    rovingTabindexDisabled: [{
      type: Input,
      args: ["clrRovingTabindexDisabled"]
    }]
  });
})();
var KEY_FOCUS_DIRECTIVES = [ClrKeyFocus, ClrRovingTabindex, ClrKeyFocusItem];
var ClrKeyFocusModule = class {
};
ClrKeyFocusModule.ɵfac = function ClrKeyFocusModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrKeyFocusModule)();
};
ClrKeyFocusModule.ɵmod = ɵɵdefineNgModule({
  type: ClrKeyFocusModule,
  declarations: [ClrKeyFocus, ClrRovingTabindex, ClrKeyFocusItem],
  imports: [CommonModule],
  exports: [ClrKeyFocus, ClrRovingTabindex, ClrKeyFocusItem]
});
ClrKeyFocusModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrKeyFocusModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [KEY_FOCUS_DIRECTIVES],
      exports: [KEY_FOCUS_DIRECTIVES]
    }]
  }], null, null);
})();
var ComboboxContainerService = class {
  constructor() {
    this.labelOffset = 0;
  }
};
ComboboxContainerService.ɵfac = function ComboboxContainerService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ComboboxContainerService)();
};
ComboboxContainerService.ɵprov = ɵɵdefineInjectable({
  token: ComboboxContainerService,
  factory: ComboboxContainerService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ComboboxContainerService, [{
    type: Injectable
  }], null, null);
})();
var ClrComboboxContainer = class extends ClrAbstractContainer {
  constructor(ifControlStateService, layoutService, controlClassService, ngControlService, containerService, el) {
    super(ifControlStateService, layoutService, controlClassService, ngControlService);
    this.containerService = containerService;
    this.el = el;
  }
  ngAfterContentInit() {
    if (this.label) {
      this.containerService.labelText = this.label.labelText;
    }
  }
  ngAfterViewInit() {
    this.containerService.labelOffset = this.controlContainer.nativeElement.offsetHeight - this.el.nativeElement.offsetHeight;
  }
};
ClrComboboxContainer.ɵfac = function ClrComboboxContainer_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrComboboxContainer)(ɵɵdirectiveInject(IfControlStateService), ɵɵdirectiveInject(LayoutService, 8), ɵɵdirectiveInject(ControlClassService), ɵɵdirectiveInject(NgControlService), ɵɵdirectiveInject(ComboboxContainerService), ɵɵdirectiveInject(ElementRef));
};
ClrComboboxContainer.ɵcmp = ɵɵdefineComponent({
  type: ClrComboboxContainer,
  selectors: [["clr-combobox-container"]],
  viewQuery: function ClrComboboxContainer_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c21, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.controlContainer = _t.first);
    }
  },
  hostVars: 8,
  hostBindings: function ClrComboboxContainer_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-form-control", true)("clr-combobox-form-control", true)("clr-form-control-disabled", ctx.control == null ? null : ctx.control.disabled)("clr-row", ctx.addGrid());
    }
  },
  standalone: false,
  features: [ɵɵProvidersFeature([IfControlStateService, NgControlService, ControlIdService, ControlClassService, ComboboxContainerService]), ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c23,
  decls: 10,
  vars: 7,
  consts: [["controlContainer", ""], [4, "ngIf"], [1, "clr-control-container", 3, "ngClass"], ["class", "clr-validate-icon", "shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 4, "ngIf"], ["class", "clr-validate-icon", "shape", "check-circle", "status", "success", "aria-hidden", "true", 4, "ngIf"], ["shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 1, "clr-validate-icon"], ["shape", "check-circle", "status", "success", "aria-hidden", "true", 1, "clr-validate-icon"]],
  template: function ClrComboboxContainer_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c22);
      ɵɵprojection(0);
      ɵɵtemplate(1, ClrComboboxContainer_label_1_Template, 1, 0, "label", 1);
      ɵɵelementStart(2, "div", 2, 0);
      ɵɵprojection(4, 1);
      ɵɵtemplate(5, ClrComboboxContainer_cds_icon_5_Template, 1, 0, "cds-icon", 3)(6, ClrComboboxContainer_cds_icon_6_Template, 1, 0, "cds-icon", 4)(7, ClrComboboxContainer_ng_content_7_Template, 1, 0, "ng-content", 1)(8, ClrComboboxContainer_ng_content_8_Template, 1, 0, "ng-content", 1)(9, ClrComboboxContainer_ng_content_9_Template, 1, 0, "ng-content", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.label && ctx.addGrid());
      ɵɵadvance();
      ɵɵproperty("ngClass", ctx.controlClass());
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showHelper);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
    }
  },
  dependencies: [NgClass, NgIf, CdsIconCustomTag, ClrLabel],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrComboboxContainer, [{
    type: Component,
    args: [{
      selector: "clr-combobox-container",
      template: `
    <ng-content select="label"></ng-content>
    <label *ngIf="!label && addGrid()"></label>
    <div class="clr-control-container" [ngClass]="controlClass()" #controlContainer>
      <ng-content select="clr-combobox"></ng-content>
      <cds-icon
        *ngIf="showInvalid"
        class="clr-validate-icon"
        shape="exclamation-circle"
        status="danger"
        aria-hidden="true"
      ></cds-icon>
      <cds-icon
        *ngIf="showValid"
        class="clr-validate-icon"
        shape="check-circle"
        status="success"
        aria-hidden="true"
      ></cds-icon>
      <ng-content select="clr-control-helper" *ngIf="showHelper"></ng-content>
      <ng-content select="clr-control-error" *ngIf="showInvalid"></ng-content>
      <ng-content select="clr-control-success" *ngIf="showValid"></ng-content>
    </div>
  `,
      host: {
        "[class.clr-form-control]": "true",
        "[class.clr-combobox-form-control]": "true",
        "[class.clr-form-control-disabled]": "control?.disabled",
        "[class.clr-row]": "addGrid()"
      },
      providers: [IfControlStateService, NgControlService, ControlIdService, ControlClassService, ComboboxContainerService]
    }]
  }], function() {
    return [{
      type: IfControlStateService
    }, {
      type: LayoutService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ControlClassService
    }, {
      type: NgControlService
    }, {
      type: ComboboxContainerService
    }, {
      type: ElementRef
    }];
  }, {
    controlContainer: [{
      type: ViewChild,
      args: ["controlContainer"]
    }]
  });
})();
var MultiSelectComboboxModel = class {
  containsItem(item) {
    return this.model ? this.model.includes(item) : false;
  }
  select(item) {
    this.addItem(item);
  }
  unselect(item) {
    this.removeItem(item);
  }
  isEmpty() {
    return !(this.model && this.model.length > 0);
  }
  pop() {
    let item;
    if (this.model && this.model.length > 0) {
      item = this.model[this.model.length - 1];
      this.removeItem(item);
    }
    return item;
  }
  toString(displayField, index = -1) {
    let displayString = "";
    if (this.model) {
      if (index > -1) {
        if (this.model[index]) {
          if (displayField && this.model[index][displayField]) {
            displayString += this.model[index][displayField];
          } else {
            displayString += this.model[index].toString();
          }
        }
      } else {
        this.model.forEach((model) => {
          if (displayField && model[displayField]) {
            displayString += model[displayField];
          } else {
            displayString += model.toString();
          }
          displayString += " ";
        });
      }
    }
    return displayString.trim();
  }
  addItem(item) {
    if (!this.containsItem(item)) {
      this.model = this.model || [];
      this.model.push(item);
    }
  }
  removeItem(item) {
    if (this.model === null || this.model === void 0) {
      return;
    }
    const index = this.model.indexOf(item);
    if (index > -1) {
      this.model.splice(index, 1);
    }
    if (this.model.length === 0) {
      this.model = null;
    }
  }
};
var SingleSelectComboboxModel = class {
  containsItem(item) {
    return this.model === item;
  }
  select(item) {
    this.model = item;
  }
  unselect(item) {
    if (this.containsItem(item)) {
      this.model = null;
    }
  }
  isEmpty() {
    return !this.model;
  }
  pop() {
    const item = this.model;
    this.model = null;
    return item;
  }
  toString(displayField) {
    if (!this.model) {
      return "";
    }
    if (displayField && this.model[displayField]) {
      return this.model[displayField];
    } else {
      return this.model.toString();
    }
  }
};
var ClrOptionSelected = class {
  constructor(template) {
    this.template = template;
  }
};
ClrOptionSelected.ɵfac = function ClrOptionSelected_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrOptionSelected)(ɵɵdirectiveInject(TemplateRef));
};
ClrOptionSelected.ɵdir = ɵɵdefineDirective({
  type: ClrOptionSelected,
  selectors: [["", "clrOptionSelected", ""]],
  inputs: {
    selected: [0, "clrOptionSelected", "selected"]
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrOptionSelected, [{
    type: Directive,
    args: [{
      selector: "[clrOptionSelected]"
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, {
    selected: [{
      type: Input,
      args: ["clrOptionSelected"]
    }]
  });
})();
var PseudoFocusModel = class extends SingleSelectComboboxModel {
  constructor() {
    super(...arguments);
    this._focusChanged = new BehaviorSubject(null);
  }
  get focusChanged() {
    return this._focusChanged.asObservable();
  }
  select(item) {
    if (this.model !== item) {
      this.model = item;
      this._focusChanged.next(item);
    }
  }
};
var OptionSelectionService = class {
  constructor() {
    this.loading = false;
    this.showAllOptions = true;
    this._currentInput = "";
    this._inputChanged = new BehaviorSubject("");
    this._selectionChanged = new ReplaySubject(1);
    this.inputChanged = this._inputChanged.asObservable();
  }
  get currentInput() {
    return this._currentInput;
  }
  set currentInput(input) {
    if (input === "" && !this.multiselectable) {
      this.setSelectionValue(null);
    }
    this._currentInput = input;
    this._inputChanged.next(input);
  }
  // This observable is for notifying the ClrOption to update its
  // selection by comparing the value
  get selectionChanged() {
    return this._selectionChanged.asObservable();
  }
  get multiselectable() {
    return this.selectionModel instanceof MultiSelectComboboxModel;
  }
  select(item) {
    if (item === null || item === void 0 || this.selectionModel.containsItem(item)) {
      return;
    }
    this.selectionModel.select(item);
    this._selectionChanged.next(this.selectionModel);
  }
  toggle(item) {
    if (item === null || item === void 0) {
      return;
    }
    if (this.selectionModel.containsItem(item)) {
      this.selectionModel.unselect(item);
    } else {
      this.selectionModel.select(item);
    }
    this._selectionChanged.next(this.selectionModel);
  }
  unselect(item) {
    if (item === null || item === void 0 || !this.selectionModel.containsItem(item)) {
      return;
    }
    this.selectionModel.unselect(item);
    this._selectionChanged.next(this.selectionModel);
  }
  // TODO: Add support for trackBy and compareFn
  setSelectionValue(value) {
    if (!this.selectionModel || this.selectionModel.model === value || !this.selectionModel.model && !value) {
      return;
    }
    this.selectionModel.model = value;
    this._selectionChanged.next(this.selectionModel);
  }
};
OptionSelectionService.ɵfac = function OptionSelectionService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || OptionSelectionService)();
};
OptionSelectionService.ɵprov = ɵɵdefineInjectable({
  token: OptionSelectionService,
  factory: OptionSelectionService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OptionSelectionService, [{
    type: Injectable
  }], function() {
    return [];
  }, null);
})();
var ComboboxFocusHandler = class {
  constructor(rendererFactory, toggleService, selectionService, platformId) {
    this.toggleService = toggleService;
    this.selectionService = selectionService;
    this.platformId = platformId;
    this.pseudoFocus = new PseudoFocusModel();
    this.optionData = [];
    this.handleFocusSubscription();
    this.renderer = rendererFactory.createRenderer(null, null);
  }
  get trigger() {
    return this._trigger;
  }
  set trigger(el) {
    this._trigger = el;
    this.addFocusOnBlurListener(el);
  }
  get listbox() {
    return this._listbox;
  }
  set listbox(el) {
    this._listbox = el;
    this.addFocusOnBlurListener(el);
  }
  get textInput() {
    return this._textInput;
  }
  set textInput(el) {
    this._textInput = el;
    this.renderer.listen(el, "keydown", (event) => !this.handleTextInput(event));
    this.addFocusOnBlurListener(el);
  }
  focusInput() {
    if (this.textInput && isPlatformBrowser(this.platformId)) {
      this.textInput.focus();
    }
  }
  focusFirstActive() {
    if (this.optionData.length > 0) {
      if (this.selectionService.selectionModel.isEmpty()) {
        this.pseudoFocus.select(this.optionData[0]);
      } else {
        let firstActive;
        if (this.selectionService.multiselectable) {
          firstActive = this.selectionService.selectionModel.model[0];
        } else {
          firstActive = this.selectionService.selectionModel.model;
        }
        const activeProxy = this.optionData.find((option) => option.value === firstActive);
        if (activeProxy) {
          this.pseudoFocus.select(activeProxy);
        } else {
          this.pseudoFocus.select(this.optionData[0]);
        }
        this.scrollIntoSelectedModel("auto");
      }
    }
  }
  addOptionValues(options) {
    this.optionData = options;
  }
  handleFocusSubscription() {
    this.toggleService.openChange.subscribe((open) => {
      if (!open) {
        this.pseudoFocus.model = null;
      }
    });
  }
  moveFocusTo(direction) {
    let index = this.optionData.findIndex((option) => option.equals(this.pseudoFocus.model));
    if (direction === ArrowKeyDirection.UP) {
      if (index === -1 || index === 0) {
        index = this.optionData.length - 1;
      } else {
        index--;
      }
    } else if (direction === ArrowKeyDirection.DOWN) {
      if (index === -1 || index === this.optionData.length - 1) {
        index = 0;
      } else {
        index++;
      }
    }
    this.pseudoFocus.select(this.optionData[index]);
    this.scrollIntoSelectedModel();
  }
  openAndMoveTo(direction) {
    if (!this.toggleService.open) {
      this.toggleService.openChange.pipe(take(1)).subscribe((open) => {
        if (open) {
          this.moveFocusTo(direction);
        }
      });
      this.toggleService.open = true;
    } else {
      this.moveFocusTo(direction);
    }
  }
  // this service is only interested in keys that may move the focus
  handleTextInput(event) {
    let preventDefault = false;
    const key = normalizeKey(event.key);
    if (event) {
      switch (key) {
        case Keys.Enter:
          if (this.toggleService.open && this.pseudoFocus.model) {
            if (this.selectionService.multiselectable) {
              this.selectionService.toggle(this.pseudoFocus.model.value);
            } else {
              this.selectionService.select(this.pseudoFocus.model.value);
            }
            preventDefault = true;
          }
          break;
        case Keys.Space:
          if (!this.toggleService.open) {
            this.toggleService.open = true;
            preventDefault = true;
          }
          break;
        case Keys.ArrowUp:
          this.preventViewportScrolling(event);
          this.openAndMoveTo(ArrowKeyDirection.UP);
          preventDefault = true;
          break;
        case Keys.ArrowDown:
          this.preventViewportScrolling(event);
          this.openAndMoveTo(ArrowKeyDirection.DOWN);
          preventDefault = true;
          break;
        default:
          if (event.key !== Keys.Tab && !(this.selectionService.multiselectable && event.key === Keys.Backspace) && !(event.key === Keys.Escape) && !this.toggleService.open) {
            this.toggleService.open = true;
          }
          break;
      }
    }
    return preventDefault;
  }
  scrollIntoSelectedModel(behavior = "smooth") {
    if (this.pseudoFocus.model && this.pseudoFocus.model.el) {
      this.pseudoFocus.model.el.scrollIntoView({
        behavior,
        block: "center",
        inline: "nearest"
      });
    }
  }
  preventViewportScrolling(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
  }
  addFocusOnBlurListener(el) {
    if (isPlatformBrowser(this.platformId)) {
      this.renderer.listen(el, "blur", (event) => {
        if (this.focusOutOfComponent(event)) {
          this.toggleService.open = false;
          if (this.componentCdRef) {
            this.componentCdRef.detectChanges();
          }
        }
      });
    }
  }
  focusOutOfComponent(event) {
    const target = event.relatedTarget || document.activeElement;
    return !(this.textInput.contains(target) || this.trigger.contains(target) || this.listbox.contains(target));
  }
};
ComboboxFocusHandler.ɵfac = function ComboboxFocusHandler_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ComboboxFocusHandler)(ɵɵinject(RendererFactory2), ɵɵinject(ClrPopoverToggleService), ɵɵinject(OptionSelectionService), ɵɵinject(PLATFORM_ID));
};
ComboboxFocusHandler.ɵprov = ɵɵdefineInjectable({
  token: ComboboxFocusHandler,
  factory: ComboboxFocusHandler.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ComboboxFocusHandler, [{
    type: Injectable
  }], function() {
    return [{
      type: RendererFactory2
    }, {
      type: ClrPopoverToggleService
    }, {
      type: OptionSelectionService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }];
  }, null);
})();
var COMBOBOX_FOCUS_HANDLER_PROVIDER = customFocusableItemProvider(ComboboxFocusHandler);
var OptionData = class {
  constructor(id, value) {
    this.id = id;
    this.value = value;
  }
  equals(other) {
    if (!other) {
      return false;
    }
    return this.id === other.id && this.value === other.value;
  }
};
var ClrOption = class {
  constructor(elRef, commonStrings, focusHandler, optionSelectionService) {
    this.elRef = elRef;
    this.commonStrings = commonStrings;
    this.focusHandler = focusHandler;
    this.optionSelectionService = optionSelectionService;
    this.optionProxy = new OptionData(null, null);
    this.optionProxy.el = elRef.nativeElement;
  }
  get optionId() {
    return this._id;
  }
  set optionId(id) {
    this._id = id;
    this.optionProxy.id = this._id;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.optionProxy.value = value;
  }
  get selected() {
    return this.optionSelectionService.selectionModel && this.optionSelectionService.selectionModel.containsItem(this.value);
  }
  get focusClass() {
    return this.focusHandler.pseudoFocus.containsItem(this.optionProxy);
  }
  ngOnInit() {
    if (!this._id) {
      this._id = "clr-option-" + uniqueIdFactory();
      this.optionProxy.id = this._id;
    }
  }
  onClick(event) {
    event.stopPropagation();
    if (this.optionSelectionService.multiselectable) {
      this.optionSelectionService.toggle(this.value);
    } else {
      this.optionSelectionService.select(this.value);
    }
    this.focusHandler.focusInput();
  }
};
ClrOption.ɵfac = function ClrOption_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrOption)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(ComboboxFocusHandler), ɵɵdirectiveInject(OptionSelectionService));
};
ClrOption.ɵcmp = ɵɵdefineComponent({
  type: ClrOption,
  selectors: [["clr-option"]],
  hostVars: 9,
  hostBindings: function ClrOption_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function ClrOption_click_HostBindingHandler($event) {
        return ctx.onClick($event);
      });
    }
    if (rf & 2) {
      ɵɵattribute("role", "option")("tabindex", -1)("id", ctx.optionId);
      ɵɵclassProp("clr-combobox-option", true)("active", ctx.selected)("clr-focus", ctx.focusClass);
    }
  },
  inputs: {
    optionId: [0, "id", "optionId"],
    value: [0, "clrValue", "value"]
  },
  standalone: false,
  ngContentSelectors: _c02,
  decls: 2,
  vars: 1,
  consts: [["class", "clr-sr-only", 4, "ngIf"], [1, "clr-sr-only"]],
  template: function ClrOption_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
      ɵɵtemplate(1, ClrOption_span_1_Template, 2, 1, "span", 0);
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.selected);
    }
  },
  dependencies: [NgIf],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrOption, [{
    type: Component,
    args: [{
      selector: "clr-option",
      template: `
    <ng-content></ng-content>
    <span *ngIf="selected" class="clr-sr-only">{{ commonStrings.keys.comboboxSelected }}</span>
  `,
      host: {
        "[class.clr-combobox-option]": "true",
        "[attr.role]": '"option"',
        // Do not remove. Or click-selection will not work.
        "[attr.tabindex]": "-1",
        "[attr.id]": "optionId"
      }
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ClrCommonStringsService
    }, {
      type: ComboboxFocusHandler
    }, {
      type: OptionSelectionService
    }];
  }, {
    optionId: [{
      type: Input,
      args: ["id"]
    }],
    value: [{
      type: Input,
      args: ["clrValue"]
    }],
    selected: [{
      type: HostBinding,
      args: ["class.active"]
    }],
    focusClass: [{
      type: HostBinding,
      args: ["class.clr-focus"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var nbOptionsComponents = 0;
var ClrOptions = class {
  constructor(optionSelectionService, id, el, commonStrings, focusHandler, toggleService, parentHost, document2) {
    this.optionSelectionService = optionSelectionService;
    this.id = id;
    this.el = el;
    this.commonStrings = commonStrings;
    this.focusHandler = focusHandler;
    this.toggleService = toggleService;
    this.document = document2;
    this.loading = false;
    this.subscriptions = [];
    if (!parentHost) {
      throw new Error("clr-options should only be used inside of a clr-combobox");
    }
    if (!this.optionsId) {
      this.optionsId = "clr-options-" + nbOptionsComponents++;
    }
  }
  get items() {
    return this._items;
  }
  set items(items) {
    this._items = items;
    this.focusHandler.addOptionValues(this._items.map((option) => option.optionProxy));
  }
  /**
   * Tests if the list of options is empty, meaning it doesn't contain any items
   */
  get emptyOptions() {
    return !this.optionSelectionService.loading && this.items.length === 0;
  }
  get noResultsElementId() {
    return `${this.optionsId}-no-results`;
  }
  ngAfterViewInit() {
    this.focusHandler.listbox = this.el.nativeElement;
    this.subscriptions.push(fromEvent(this.document, "scroll", {
      capture: true
    }).subscribe((event) => {
      if (this.toggleService.open && event.target !== this.el.nativeElement && event.target !== this.focusHandler.textInput) {
        this.toggleService.open = false;
      }
    }), this.items.changes.subscribe((items) => {
      if (items.length) {
        setTimeout(() => {
          this.focusHandler.focusFirstActive();
        });
      } else {
        this.focusHandler.pseudoFocus.pop();
      }
    }));
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
  searchText(input) {
    return this.commonStrings.parse(this.commonStrings.keys.comboboxSearching, {
      INPUT: input
    });
  }
  loadingStateChange(state2) {
    this.loading = state2 === ClrLoadingState.LOADING;
  }
};
ClrOptions.ɵfac = function ClrOptions_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrOptions)(ɵɵdirectiveInject(OptionSelectionService), ɵɵdirectiveInject(IF_ACTIVE_ID), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(ComboboxFocusHandler), ɵɵdirectiveInject(ClrPopoverToggleService), ɵɵdirectiveInject(POPOVER_HOST_ANCHOR, 8), ɵɵdirectiveInject(DOCUMENT));
};
ClrOptions.ɵcmp = ɵɵdefineComponent({
  type: ClrOptions,
  selectors: [["clr-options"]],
  contentQueries: function ClrOptions_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrOption, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.items = _t);
    }
  },
  hostVars: 4,
  hostBindings: function ClrOptions_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵhostProperty("id", ctx.optionsId);
      ɵɵattribute("role", "listbox");
      ɵɵclassProp("clr-combobox-options", true);
    }
  },
  inputs: {
    optionsId: [0, "id", "optionsId"]
  },
  standalone: false,
  features: [ɵɵProvidersFeature([{
    provide: LoadingListener,
    useExisting: ClrOptions
  }])],
  ngContentSelectors: _c02,
  decls: 3,
  vars: 2,
  consts: [["class", "clr-combobox-options-loading", 4, "ngIf"], ["role", "option", 3, "id", 4, "ngIf"], [1, "clr-combobox-options-loading"], ["clrInline", ""], [1, "clr-combobox-options-text"], ["role", "option", 3, "id"], [1, "clr-combobox-options-empty-text"]],
  template: function ClrOptions_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, ClrOptions_div_0_Template, 5, 2, "div", 0)(1, ClrOptions_div_1_Template, 3, 2, "div", 1);
      ɵɵprojection(2);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.optionSelectionService.loading);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.emptyOptions);
    }
  },
  dependencies: [NgIf, ClrSpinner],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrOptions, [{
    type: Component,
    args: [{
      selector: "clr-options",
      template: `
    <div *ngIf="optionSelectionService.loading" class="clr-combobox-options-loading">
      <clr-spinner clrInline>
        {{ commonStrings.keys.loading }}
      </clr-spinner>
      <span class="clr-combobox-options-text">
        {{ searchText(optionSelectionService.currentInput) }}
      </span>
    </div>

    <!-- Rendered if data set is empty -->
    <div *ngIf="emptyOptions" [id]="noResultsElementId" role="option">
      <span class="clr-combobox-options-empty-text">
        {{ commonStrings.keys.comboboxNoResults }}
      </span>
    </div>

    <!--Option Groups and Options will be projected here-->
    <ng-content></ng-content>
  `,
      providers: [{
        provide: LoadingListener,
        useExisting: ClrOptions
      }],
      host: {
        "[class.clr-combobox-options]": "true",
        "[attr.role]": '"listbox"',
        "[id]": "optionsId"
      }
    }]
  }], function() {
    return [{
      type: OptionSelectionService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [IF_ACTIVE_ID]
      }]
    }, {
      type: ElementRef
    }, {
      type: ClrCommonStringsService
    }, {
      type: ComboboxFocusHandler
    }, {
      type: ClrPopoverToggleService
    }, {
      type: ElementRef,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [POPOVER_HOST_ANCHOR]
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [DOCUMENT]
      }]
    }];
  }, {
    optionsId: [{
      type: Input,
      args: ["id"]
    }],
    items: [{
      type: ContentChildren,
      args: [ClrOption]
    }]
  });
})();
var ClrCombobox = class extends WrappedFormControl {
  constructor(vcr, injector, control, renderer, el, optionSelectionService, commonStrings, toggleService, positionService, controlStateService, containerService, platformId, focusHandler, cdr) {
    super(vcr, ClrComboboxContainer, injector, control, renderer, el);
    this.control = control;
    this.renderer = renderer;
    this.el = el;
    this.optionSelectionService = optionSelectionService;
    this.commonStrings = commonStrings;
    this.toggleService = toggleService;
    this.positionService = positionService;
    this.controlStateService = controlStateService;
    this.containerService = containerService;
    this.platformId = platformId;
    this.focusHandler = focusHandler;
    this.cdr = cdr;
    this.placeholder = "";
    this.clrInputChange = new EventEmitter(false);
    this.clrOpenChange = this.toggleService.openChange;
    this.clrSelectionChange = this.optionSelectionService.selectionChanged;
    this.invalid = false;
    this.focused = false;
    this.smartPosition = {
      axis: ClrAxis.VERTICAL,
      side: ClrSide.AFTER,
      anchor: ClrAlignment.START,
      content: ClrAlignment.START
    };
    this.index = 1;
    this._searchText = "";
    if (control) {
      control.valueAccessor = this;
    }
    optionSelectionService.selectionModel = new SingleSelectComboboxModel();
    this.updateControlValue();
  }
  get multiSelect() {
    return this.optionSelectionService.multiselectable;
  }
  set multiSelect(value) {
    if (value) {
      this.optionSelectionService.selectionModel = new MultiSelectComboboxModel();
    } else {
      this.optionSelectionService.selectionModel = new SingleSelectComboboxModel();
    }
    this.updateControlValue();
  }
  // Override the id of WrappedFormControl, as we want to move it to the embedded input.
  // Otherwise the label/component connection does not work and screen readers do not read the label.
  get id() {
    return this.controlIdService.id + "-combobox";
  }
  set id(id) {
    super.id = id;
  }
  get searchText() {
    return this._searchText;
  }
  set searchText(text) {
    if (text !== this._searchText) {
      if (this.toggleService.open) {
        this.optionSelectionService.showAllOptions = false;
      }
      this._searchText = text;
      this.clrInputChange.emit(this.searchText);
    }
    this.optionSelectionService.currentInput = this.searchText;
  }
  get openState() {
    return this.toggleService.open;
  }
  get multiSelectModel() {
    if (!this.multiSelect) {
      throw Error("multiSelectModel is not available in single selection context");
    }
    return this.optionSelectionService.selectionModel.model;
  }
  get ariaControls() {
    return this.options?.optionsId;
  }
  get ariaOwns() {
    return this.options?.optionsId;
  }
  get ariaDescribedBySelection() {
    return "selection-" + this.id;
  }
  get displayField() {
    return this.optionSelectionService.displayField;
  }
  get disabled() {
    return this.control?.disabled;
  }
  ngAfterContentInit() {
    this.initializeSubscriptions();
    if (!this.optionSelectionService.selectionModel.isEmpty()) {
      this.updateInputValue(this.optionSelectionService.selectionModel);
    }
  }
  ngAfterViewInit() {
    this.focusHandler.componentCdRef = this.cdr;
    this.focusHandler.textInput = this.textbox.nativeElement;
    this.focusHandler.trigger = this.trigger.nativeElement;
    this.el = this.textbox;
  }
  onKeyUp(event) {
    if (event.key === Keys.Backspace && this.multiSelect && this._searchText.length === 0) {
      const multiModel = this.optionSelectionService.selectionModel.model;
      if (multiModel && multiModel.length > 0) {
        const lastItem = multiModel[multiModel.length - 1];
        this.control?.control.markAsTouched();
        this.optionSelectionService.unselect(lastItem);
      }
    }
  }
  inputId() {
    return this.controlIdService.id;
  }
  loadingStateChange(state2) {
    this.optionSelectionService.loading = state2 === ClrLoadingState.LOADING;
    this.positionService.realign();
    if (state2 !== ClrLoadingState.LOADING && isPlatformBrowser(this.platformId)) {
      this.focusFirstActive();
    }
  }
  unselect(item) {
    if (!this.disabled) {
      this.optionSelectionService.unselect(item);
    }
  }
  onBlur() {
    this.onTouchedCallback?.();
    if (this.control?.control.updateOn === "change" && this.control.control.errors?.required) {
      this.updateControlValue();
    }
    if (this.control?.control.updateOn === "blur") {
      this.control.control.updateValueAndValidity();
    }
    this.focused = false;
  }
  onFocus() {
    this.focused = true;
    this.cdr.detectChanges();
  }
  getSelectionAriaLabel() {
    if (this.containerService && this.containerService.labelText) {
      return `${this.containerService.labelText} ${this.commonStrings.keys.comboboxSelection}`;
    }
    return this.commonStrings.keys.comboboxSelection;
  }
  focusFirstActive() {
    setTimeout(() => {
      this.focusHandler.focusFirstActive();
    });
  }
  writeValue(value) {
    this.optionSelectionService.selectionModel.model = value;
    this.updateInputValue(this.optionSelectionService.selectionModel);
  }
  registerOnTouched(onTouched) {
    this.onTouchedCallback = onTouched;
  }
  registerOnChange(onChange) {
    this.onChangeCallback = onChange;
  }
  getActiveDescendant() {
    const model = this.focusHandler.pseudoFocus.model;
    return model ? model.id : this.options?.noResultsElementId;
  }
  setDisabledState() {
  }
  focusInput() {
    this.focusHandler.focusInput();
  }
  initializeSubscriptions() {
    this.subscriptions.push(this.optionSelectionService.selectionChanged.subscribe((newSelection) => {
      this.updateInputValue(newSelection);
      if (this.multiSelect) {
        this.positionService.realign();
      }
      if (!this.multiSelect && newSelection && !newSelection.isEmpty()) {
        this.toggleService.open = false;
      }
      this.updateControlValue();
    }));
    this.subscriptions.push(this.toggleService.openChange.subscribe((open) => {
      if (open) {
        this.focusFirstActive();
      } else {
        this.optionSelectionService.showAllOptions = true;
      }
      if (this.multiSelect) {
        this.searchText = "";
      } else {
        this.searchText = this.getDisplayNames(this.optionSelectionService.selectionModel.model)[0] || "";
      }
    }));
    this.subscriptions.push(this.toggleService.popoverAligned.subscribe((popoverNode) => {
      if (!this.containerService) {
        return;
      }
      const popover = popoverNode;
      if (popover.getBoundingClientRect().top < this.el.nativeElement.getBoundingClientRect().top) {
        this.renderer.setStyle(popoverNode, "top", `${popover.offsetTop + this.containerService.labelOffset}px`);
      }
    }));
    if (this.controlStateService) {
      this.subscriptions.push(this.controlStateService.statusChanges.subscribe((invalid) => {
        this.invalid = this.control?.control.touched && invalid === CONTROL_STATE.INVALID;
      }));
    }
  }
  updateInputValue(model) {
    if (!this.multiSelect) {
      this.searchText = model.model ? this.getDisplayNames(model.model)[0] : "";
      if (this.searchText) {
        this.optionSelectionService.currentInput = this.searchText;
      }
    }
  }
  updateControlValue() {
    if (this.onChangeCallback) {
      this.onChangeCallback(this.optionSelectionService.selectionModel.model);
    }
  }
  getDisplayNames(model) {
    if (this.displayField) {
      if (!Array.isArray(model)) {
        model = [model];
      }
      return model.map((item) => item ? item[this.displayField] : null);
    }
    return [this.optionSelectionService.selectionModel.model];
  }
};
ClrCombobox.ɵfac = function ClrCombobox_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrCombobox)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(NgControl, 10), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(OptionSelectionService), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(ClrPopoverToggleService), ɵɵdirectiveInject(ClrPopoverPositionService), ɵɵdirectiveInject(IfControlStateService, 8), ɵɵdirectiveInject(ComboboxContainerService, 8), ɵɵdirectiveInject(PLATFORM_ID), ɵɵdirectiveInject(ComboboxFocusHandler), ɵɵdirectiveInject(ChangeDetectorRef));
};
ClrCombobox.ɵcmp = ɵɵdefineComponent({
  type: ClrCombobox,
  selectors: [["clr-combobox"]],
  contentQueries: function ClrCombobox_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrOptionSelected, 5);
      ɵɵcontentQuery(dirIndex, ClrOptions, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.optionSelected = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.options = _t.first);
    }
  },
  viewQuery: function ClrCombobox_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c24, 5);
      ɵɵviewQuery(_c25, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.textbox = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.trigger = _t.first);
    }
  },
  hostVars: 6,
  hostBindings: function ClrCombobox_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("keydown", function ClrCombobox_keydown_HostBindingHandler($event) {
        return ctx.onKeyUp($event);
      });
    }
    if (rf & 2) {
      ɵɵclassProp("aria-required", true)("clr-combobox", true)("clr-combobox-disabled", ctx.control == null ? null : ctx.control.disabled);
    }
  },
  inputs: {
    placeholder: "placeholder",
    multiSelect: [0, "clrMulti", "multiSelect"]
  },
  outputs: {
    clrInputChange: "clrInputChange",
    clrOpenChange: "clrOpenChange",
    clrSelectionChange: "clrSelectionChange"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([OptionSelectionService, {
    provide: LoadingListener,
    useExisting: ClrCombobox
  }, IF_ACTIVE_ID_PROVIDER, FOCUS_SERVICE_PROVIDER, COMBOBOX_FOCUS_HANDLER_PROVIDER]), ɵɵHostDirectivesFeature([ClrPopoverHostDirective]), ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c02,
  decls: 10,
  vars: 23,
  consts: [["textboxInput", ""], ["trigger", ""], ["clrPopoverAnchor", "", 1, "clr-combobox-wrapper", 3, "click"], ["role", "grid", "clrRovingTabindex", "", "clrDirection", "both", 3, "clrRovingTabindexDisabled", 4, "ngIf"], [1, "clr-combobox-input-wrapper"], ["type", "text", "role", "combobox", "aria-haspopup", "listbox", "aria-autocomplete", "list", "autocomplete", "off", 1, "clr-input", "clr-combobox-input", 3, "ngModelChange", "blur", "focus", "id", "ngModel", "disabled"], ["clrPopoverOpenCloseButton", "", "type", "button", "tabindex", "-1", 1, "clr-combobox-trigger", 3, "disabled"], ["shape", "angle", "direction", "down"], [1, "clr-focus-indicator"], ["role", "dialog", 4, "clrPopoverContent", "clrPopoverContentAt", "clrPopoverContentOutsideClickToClose", "clrPopoverContentScrollToClose"], ["role", "grid", "clrRovingTabindex", "", "clrDirection", "both", 3, "clrRovingTabindexDisabled"], ["class", "label label-combobox-pill", "role", "row", 4, "ngFor", "ngForOf"], ["role", "row", 1, "label", "label-combobox-pill"], ["role", "gridcell"], ["clrKeyFocusItem", "", 1, "clr-combobox-pill-content"], [3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngIf"], ["clrKeyFocusItem", "", "type", "button", 1, "clr-combobox-remove-btn", 3, "click", "disabled"], ["shape", "window-close", "size", "12"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["role", "dialog"]],
  template: function ClrCombobox_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 2);
      ɵɵlistener("click", function ClrCombobox_Template_div_click_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.focusInput());
      });
      ɵɵtemplate(1, ClrCombobox_span_1_Template, 2, 4, "span", 3);
      ɵɵelementStart(2, "span", 4)(3, "input", 5, 0);
      ɵɵtwoWayListener("ngModelChange", function ClrCombobox_Template_input_ngModelChange_3_listener($event) {
        ɵɵrestoreView(_r1);
        ɵɵtwoWayBindingSet(ctx.searchText, $event) || (ctx.searchText = $event);
        return ɵɵresetView($event);
      });
      ɵɵlistener("blur", function ClrCombobox_Template_input_blur_3_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onBlur());
      })("focus", function ClrCombobox_Template_input_focus_3_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onFocus());
      });
      ɵɵelementEnd()();
      ɵɵelementStart(5, "button", 6, 1);
      ɵɵelement(7, "cds-icon", 7);
      ɵɵelementEnd();
      ɵɵelement(8, "div", 8);
      ɵɵelementEnd();
      ɵɵtemplate(9, ClrCombobox_div_9_Template, 2, 0, "div", 9);
    }
    if (rf & 2) {
      ɵɵclassProp("multi", ctx.multiSelect)("invalid", ctx.invalid)("disabled", (ctx.control == null ? null : ctx.control.disabled) ? true : null);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.multiSelect && ctx.optionSelectionService.selectionModel.model);
      ɵɵadvance(2);
      ɵɵproperty("id", ctx.inputId());
      ɵɵtwoWayProperty("ngModel", ctx.searchText);
      ɵɵproperty("disabled", (ctx.control == null ? null : ctx.control.disabled) ? true : null);
      ɵɵattribute("aria-expanded", ctx.openState)("aria-owns", ctx.ariaOwns)("aria-invalid", (ctx.control == null ? null : ctx.control.invalid) ? true : null)("aria-activedescendant", ctx.getActiveDescendant())("placeholder", ctx.placeholder);
      ɵɵadvance(2);
      ɵɵproperty("disabled", (ctx.control == null ? null : ctx.control.disabled) || null);
      ɵɵattribute("aria-label", ctx.commonStrings.keys.comboboxOpen);
      ɵɵadvance(3);
      ɵɵclassProp("clr-focus", ctx.focused);
      ɵɵadvance();
      ɵɵproperty("clrPopoverContent", ctx.openState)("clrPopoverContentAt", ctx.smartPosition)("clrPopoverContentOutsideClickToClose", false)("clrPopoverContentScrollToClose", false);
    }
  },
  dependencies: [NgForOf, NgIf, NgTemplateOutlet, DefaultValueAccessor, NgControlStatus, NgModel, CdsIconCustomTag, ClrRovingTabindex, ClrKeyFocusItem, ClrPopoverAnchor, ClrPopoverOpenCloseButton, ClrPopoverContent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrCombobox, [{
    type: Component,
    args: [{
      selector: "clr-combobox",
      providers: [OptionSelectionService, {
        provide: LoadingListener,
        useExisting: ClrCombobox
      }, IF_ACTIVE_ID_PROVIDER, FOCUS_SERVICE_PROVIDER, COMBOBOX_FOCUS_HANDLER_PROVIDER],
      hostDirectives: [ClrPopoverHostDirective],
      host: {
        "[class.aria-required]": "true",
        "[class.clr-combobox]": "true",
        "[class.clr-combobox-disabled]": "control?.disabled"
      },
      template: `<!--
  ~ Copyright (c) 2016-2024 Broadcom. All Rights Reserved.
  ~ The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.
  ~ This software is released under MIT license.
  ~ The full license information can be found in LICENSE in the root directory of this project.
-->

<!-- The (click) handler is needed to auto-focus on input field which can not currently occupy the whole
     width of the component, after being wrapped to a new line -->
<div
  class="clr-combobox-wrapper"
  clrPopoverAnchor
  (click)="focusInput()"
  [class.multi]="multiSelect"
  [class.invalid]="invalid"
  [class.disabled]="control?.disabled? true: null"
>
  <span
    *ngIf="multiSelect && optionSelectionService.selectionModel.model"
    role="grid"
    clrRovingTabindex
    [clrRovingTabindexDisabled]="control?.disabled"
    clrDirection="both"
    [attr.aria-label]="getSelectionAriaLabel()"
    [attr.aria-disabled]="control?.disabled? true: null"
  >
    <span *ngFor="let item of multiSelectModel; let i = index" class="label label-combobox-pill" role="row">
      <span role="gridcell">
        <span class="clr-combobox-pill-content" clrKeyFocusItem>
          <ng-container
            *ngIf="optionSelected"
            [ngTemplateOutlet]="optionSelected.template"
            [ngTemplateOutletContext]="{$implicit: optionSelectionService.selectionModel.model[i]}"
          ></ng-container>
        </span>
      </span>
      <span role="gridcell">
        <button
          clrKeyFocusItem
          type="button"
          class="clr-combobox-remove-btn"
          [disabled]="control?.disabled? true: null"
          [attr.aria-label]="commonStrings.keys.comboboxDelete + ' ' + optionSelectionService.selectionModel.toString(displayField, i)"
          (click)="unselect(item)"
        >
          <cds-icon shape="window-close" size="12"></cds-icon>
        </button>
      </span>
    </span>
  </span>

  <span class="clr-combobox-input-wrapper">
    <input
      #textboxInput
      type="text"
      role="combobox"
      [id]="inputId()"
      class="clr-input clr-combobox-input"
      [(ngModel)]="searchText"
      (blur)="onBlur()"
      (focus)="onFocus()"
      [attr.aria-expanded]="openState"
      [attr.aria-owns]="ariaOwns"
      aria-haspopup="listbox"
      aria-autocomplete="list"
      autocomplete="off"
      [attr.aria-invalid]="control?.invalid? true: null"
      [disabled]="control?.disabled? true: null"
      [attr.aria-activedescendant]="getActiveDescendant()"
      [attr.placeholder]="placeholder"
    />
  </span>

  <!-- No click handler, as it uses the handler on the .clr-combobox-wrapper -->
  <button
    clrPopoverOpenCloseButton
    #trigger
    type="button"
    class="clr-combobox-trigger"
    tabindex="-1"
    [disabled]="control?.disabled || null"
    [attr.aria-label]="commonStrings.keys.comboboxOpen"
  >
    <cds-icon shape="angle" direction="down"></cds-icon>
  </button>

  <div class="clr-focus-indicator" [class.clr-focus]="focused"></div>
</div>

<!-- Both close handlers are handled manually due to issues in Edge browser.
     Additionally 'outsideClickToClose' has complex handling that's necessary
     to be manual due to the component architecture -->
<div role="dialog" *clrPopoverContent="openState at smartPosition; outsideClickToClose: false; scrollToClose: false">
  <ng-content></ng-content>
</div>
`
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }, {
      type: Injector
    }, {
      type: NgControl,
      decorators: [{
        type: Self
      }, {
        type: Optional
      }]
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: OptionSelectionService
    }, {
      type: ClrCommonStringsService
    }, {
      type: ClrPopoverToggleService
    }, {
      type: ClrPopoverPositionService
    }, {
      type: IfControlStateService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ComboboxContainerService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }, {
      type: ComboboxFocusHandler
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    placeholder: [{
      type: Input,
      args: ["placeholder"]
    }],
    clrInputChange: [{
      type: Output,
      args: ["clrInputChange"]
    }],
    clrOpenChange: [{
      type: Output,
      args: ["clrOpenChange"]
    }],
    clrSelectionChange: [{
      type: Output,
      args: ["clrSelectionChange"]
    }],
    textbox: [{
      type: ViewChild,
      args: ["textboxInput"]
    }],
    trigger: [{
      type: ViewChild,
      args: ["trigger"]
    }],
    optionSelected: [{
      type: ContentChild,
      args: [ClrOptionSelected]
    }],
    options: [{
      type: ContentChild,
      args: [ClrOptions]
    }],
    multiSelect: [{
      type: Input,
      args: ["clrMulti"]
    }],
    onKeyUp: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }]
  });
})();
var ClrOptionItems = class {
  constructor(template, differs, optionService, positionService, vcr) {
    this.template = template;
    this.differs = differs;
    this.optionService = optionService;
    this.positionService = positionService;
    this.subscriptions = [];
    this.filter = "";
    this.differ = null;
    this.iterableProxy = new NgForOf(vcr, template, differs);
    this.subscriptions.push(optionService.inputChanged.subscribe((filter2) => {
      this.filter = filter2;
      this.updateItems();
    }));
  }
  set rawItems(items) {
    this._rawItems = items ? items : [];
    this.updateItems();
  }
  set trackBy(value) {
    this.iterableProxy.ngForTrackBy = value;
  }
  set field(field) {
    this._filterField = field;
    this.optionService.displayField = field;
  }
  ngDoCheck() {
    if (!this.differ) {
      this.differ = this.differs.find(this.filteredItems).create(this.iterableProxy.ngForTrackBy);
    }
    if (this.differ) {
      const changes = this.differ.diff(this.filteredItems);
      if (changes) {
        this.iterableProxy.ngDoCheck();
        this.positionService.realign();
      }
    }
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
  updateItems() {
    if (!this._rawItems || this.filter === void 0 || this.filter === null) {
      return;
    }
    const normalizedFilterValue = normalizeValue(this.filter);
    if (this.optionService.showAllOptions) {
      this.filteredItems = this._rawItems;
    } else if (this._filterField) {
      this.filteredItems = this._rawItems.filter((item) => {
        const objValue = item[this._filterField];
        return objValue ? normalizeValue(objValue).includes(normalizedFilterValue) : false;
      });
    } else {
      this.filteredItems = this._rawItems.filter((item) => {
        if (typeof item !== "object") {
          return normalizeValue(item).includes(normalizedFilterValue);
        }
        const objValues = Object.values(item).filter((value) => {
          return value !== null && value !== void 0 ? normalizeValue(value).includes(normalizedFilterValue) : false;
        });
        return objValues.length > 0;
      });
    }
    this.iterableProxy.ngForOf = this.filteredItems;
  }
};
ClrOptionItems.ɵfac = function ClrOptionItems_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrOptionItems)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(OptionSelectionService), ɵɵdirectiveInject(ClrPopoverPositionService), ɵɵdirectiveInject(ViewContainerRef));
};
ClrOptionItems.ɵdir = ɵɵdefineDirective({
  type: ClrOptionItems,
  selectors: [["", "clrOptionItems", "", "clrOptionItemsOf", ""]],
  inputs: {
    rawItems: [0, "clrOptionItemsOf", "rawItems"],
    trackBy: [0, "clrOptionItemsTrackBy", "trackBy"],
    field: [0, "clrOptionItemsField", "field"]
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrOptionItems, [{
    type: Directive,
    args: [{
      selector: "[clrOptionItems][clrOptionItemsOf]"
    }]
  }], function() {
    return [{
      type: TemplateRef
    }, {
      type: IterableDiffers
    }, {
      type: OptionSelectionService
    }, {
      type: ClrPopoverPositionService
    }, {
      type: ViewContainerRef
    }];
  }, {
    rawItems: [{
      type: Input,
      args: ["clrOptionItemsOf"]
    }],
    trackBy: [{
      type: Input,
      args: ["clrOptionItemsTrackBy"]
    }],
    field: [{
      type: Input,
      args: ["clrOptionItemsField"]
    }]
  });
})();
function normalizeValue(value) {
  return value.toString().normalize("NFD").replace(new RegExp("\\p{Diacritic}", "gu"), "").toLowerCase();
}
var ClrComboboxModule = class {
  constructor() {
    r.addIcons(o4, e, o, L3);
  }
};
ClrComboboxModule.ɵfac = function ClrComboboxModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrComboboxModule)();
};
ClrComboboxModule.ɵmod = ɵɵdefineNgModule({
  type: ClrComboboxModule,
  declarations: [ClrCombobox, ClrComboboxContainer, ClrOptions, ClrOption, ClrOptionSelected, ClrOptionItems],
  imports: [CommonModule, FormsModule, ClrIconModule, ClrKeyFocusModule, ClrCommonFormsModule, ClrConditionalModule, ClrPopoverModuleNext, ClrSpinnerModule],
  exports: [ClrCommonFormsModule, ClrCombobox, ClrComboboxContainer, ClrOptions, ClrOption, ClrOptionSelected, ClrConditionalModule, ClrOptionItems]
});
ClrComboboxModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, FormsModule, ClrIconModule, ClrKeyFocusModule, ClrCommonFormsModule, ClrConditionalModule, ClrPopoverModuleNext, ClrSpinnerModule, ClrCommonFormsModule, ClrConditionalModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrComboboxModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, ClrIconModule, ClrKeyFocusModule, ClrCommonFormsModule, ClrConditionalModule, ClrPopoverModuleNext, ClrSpinnerModule],
      declarations: [ClrCombobox, ClrComboboxContainer, ClrOptions, ClrOption, ClrOptionSelected, ClrOptionItems],
      exports: [ClrCommonFormsModule, ClrCombobox, ClrComboboxContainer, ClrOptions, ClrOption, ClrOptionSelected, ClrConditionalModule, ClrOptionItems]
    }]
  }], function() {
    return [];
  }, null);
})();
var ClrInputContainer = class extends ClrAbstractContainer {
};
ClrInputContainer.ɵfac = /* @__PURE__ */ (() => {
  let ɵClrInputContainer_BaseFactory;
  return function ClrInputContainer_Factory(__ngFactoryType__) {
    return (ɵClrInputContainer_BaseFactory || (ɵClrInputContainer_BaseFactory = ɵɵgetInheritedFactory(ClrInputContainer)))(__ngFactoryType__ || ClrInputContainer);
  };
})();
ClrInputContainer.ɵcmp = ɵɵdefineComponent({
  type: ClrInputContainer,
  selectors: [["clr-input-container"]],
  hostVars: 6,
  hostBindings: function ClrInputContainer_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-form-control", true)("clr-form-control-disabled", ctx.control == null ? null : ctx.control.disabled)("clr-row", ctx.addGrid());
    }
  },
  standalone: false,
  features: [ɵɵProvidersFeature([IfControlStateService, NgControlService, ControlIdService, ControlClassService]), ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c28,
  decls: 13,
  vars: 7,
  consts: [[4, "ngIf"], [1, "clr-control-container", 3, "ngClass"], [1, "clr-input-wrapper"], [1, "clr-input-group"], ["class", "clr-validate-icon", "shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 4, "ngIf"], ["class", "clr-validate-icon", "shape", "check-circle", "status", "success", "aria-hidden", "true", 4, "ngIf"], ["shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 1, "clr-validate-icon"], ["shape", "check-circle", "status", "success", "aria-hidden", "true", 1, "clr-validate-icon"]],
  template: function ClrInputContainer_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c27);
      ɵɵprojection(0);
      ɵɵtemplate(1, ClrInputContainer_label_1_Template, 1, 0, "label", 0);
      ɵɵelementStart(2, "div", 1)(3, "div", 2)(4, "div", 3);
      ɵɵprojection(5, 1);
      ɵɵprojection(6, 2);
      ɵɵprojection(7, 3);
      ɵɵelementEnd();
      ɵɵtemplate(8, ClrInputContainer_cds_icon_8_Template, 1, 0, "cds-icon", 4)(9, ClrInputContainer_cds_icon_9_Template, 1, 0, "cds-icon", 5);
      ɵɵelementEnd();
      ɵɵtemplate(10, ClrInputContainer_ng_content_10_Template, 1, 0, "ng-content", 0)(11, ClrInputContainer_ng_content_11_Template, 1, 0, "ng-content", 0)(12, ClrInputContainer_ng_content_12_Template, 1, 0, "ng-content", 0);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.label && ctx.addGrid());
      ɵɵadvance();
      ɵɵproperty("ngClass", ctx.controlClass());
      ɵɵadvance(6);
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showHelper);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
    }
  },
  dependencies: [NgClass, NgIf, CdsIconCustomTag, ClrLabel],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrInputContainer, [{
    type: Component,
    args: [{
      selector: "clr-input-container",
      template: `
    <ng-content select="label"></ng-content>
    <label *ngIf="!label && addGrid()"></label>
    <div class="clr-control-container" [ngClass]="controlClass()">
      <div class="clr-input-wrapper">
        <div class="clr-input-group">
          <ng-content select="[clrInputPrefix]"></ng-content>
          <ng-content select="[clrInput]"></ng-content>
          <ng-content select="[clrInputSuffix]"></ng-content>
        </div>
        <cds-icon
          *ngIf="showInvalid"
          class="clr-validate-icon"
          shape="exclamation-circle"
          status="danger"
          aria-hidden="true"
        ></cds-icon>
        <cds-icon
          *ngIf="showValid"
          class="clr-validate-icon"
          shape="check-circle"
          status="success"
          aria-hidden="true"
        ></cds-icon>
      </div>
      <ng-content select="clr-control-helper" *ngIf="showHelper"></ng-content>
      <ng-content select="clr-control-error" *ngIf="showInvalid"></ng-content>
      <ng-content select="clr-control-success" *ngIf="showValid"></ng-content>
    </div>
  `,
      host: {
        "[class.clr-form-control]": "true",
        "[class.clr-form-control-disabled]": "control?.disabled",
        "[class.clr-row]": "addGrid()"
      },
      providers: [IfControlStateService, NgControlService, ControlIdService, ControlClassService]
    }]
  }], null, null);
})();
var ClrInput = class extends WrappedFormControl {
  constructor(vcr, injector, control, renderer, el) {
    super(vcr, ClrInputContainer, injector, control, renderer, el);
    this.index = 1;
    if (this.el.nativeElement.getAttribute("type") === "number") {
      console.warn(`Warning: Inputs of type "number" should utilize the number-input component for proper handling.

  Example usage:
  <clr-number-input-container>
    <label>Number Input</label>
    <input clrNumberInput type="number"/>
  </clr-number-input-container>
      `);
    }
  }
};
ClrInput.ɵfac = function ClrInput_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrInput)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(NgControl, 10), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
};
ClrInput.ɵdir = ɵɵdefineDirective({
  type: ClrInput,
  selectors: [["", "clrInput", ""]],
  hostVars: 2,
  hostBindings: function ClrInput_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-input", true);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrInput, [{
    type: Directive,
    args: [{
      selector: "[clrInput]",
      host: {
        "[class.clr-input]": "true"
      }
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }, {
      type: Injector
    }, {
      type: NgControl,
      decorators: [{
        type: Self
      }, {
        type: Optional
      }]
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }];
  }, null);
})();
var ClrInputModule = class {
  constructor() {
    r.addIcons(
      o4,
      e
      // caret
    );
  }
};
ClrInputModule.ɵfac = function ClrInputModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrInputModule)();
};
ClrInputModule.ɵmod = ɵɵdefineNgModule({
  type: ClrInputModule,
  declarations: [ClrInput, ClrInputContainer],
  imports: [CommonModule, FormsModule, ClrIconModule, ClrCommonFormsModule],
  exports: [ClrCommonFormsModule, ClrInput, ClrInputContainer]
});
ClrInputModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, FormsModule, ClrIconModule, ClrCommonFormsModule, ClrCommonFormsModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrInputModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, ClrIconModule, ClrCommonFormsModule],
      declarations: [ClrInput, ClrInputContainer],
      exports: [ClrCommonFormsModule, ClrInput, ClrInputContainer]
    }]
  }], function() {
    return [];
  }, null);
})();
var counter = 0;
var DatalistIdService = class {
  constructor() {
    this._id = "clr-datalist-" + ++counter;
    this._idChange = new BehaviorSubject(this._id);
  }
  get id() {
    return this._id;
  }
  set id(value) {
    this._id = value;
    this._idChange.next(value);
  }
  get idChange() {
    return this._idChange.asObservable();
  }
};
DatalistIdService.ɵfac = function DatalistIdService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || DatalistIdService)();
};
DatalistIdService.ɵprov = ɵɵdefineInjectable({
  token: DatalistIdService,
  factory: DatalistIdService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatalistIdService, [{
    type: Injectable
  }], null, null);
})();
var ClrDatalist = class {
  constructor(datalistIdService) {
    this.datalistIdService = datalistIdService;
    this.subscriptions = [];
  }
  set id(idValue) {
    if (!!idValue && this.datalistIdService) {
      this.datalistId = idValue;
      this.datalistIdService.id = idValue;
    } else if (idValue) {
      this.datalistId = idValue;
    }
  }
  ngAfterContentInit() {
    if (!this.datalistIdService) {
      return;
    }
    this.subscriptions.push(this.datalistIdService.idChange.subscribe((id) => this.datalistId = id));
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
};
ClrDatalist.ɵfac = function ClrDatalist_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDatalist)(ɵɵdirectiveInject(DatalistIdService, 8));
};
ClrDatalist.ɵdir = ɵɵdefineDirective({
  type: ClrDatalist,
  selectors: [["datalist"]],
  hostVars: 1,
  hostBindings: function ClrDatalist_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵhostProperty("id", ctx.datalistId);
    }
  },
  inputs: {
    id: "id"
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatalist, [{
    type: Directive,
    args: [{
      selector: "datalist",
      host: {
        "[id]": "datalistId"
      }
    }]
  }], function() {
    return [{
      type: DatalistIdService,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    id: [{
      type: Input
    }]
  });
})();
var FocusService2 = class {
  constructor() {
    this._focused = new BehaviorSubject(false);
  }
  get focusChange() {
    return this._focused.asObservable();
  }
  set focused(state2) {
    this._focused.next(state2);
  }
};
FocusService2.ɵfac = function FocusService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || FocusService2)();
};
FocusService2.ɵprov = ɵɵdefineInjectable({
  token: FocusService2,
  factory: FocusService2.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusService2, [{
    type: Injectable
  }], null, null);
})();
var ClrDatalistContainer = class extends ClrAbstractContainer {
  constructor(controlClassService, layoutService, ngControlService, focusService, ifControlStateService) {
    super(ifControlStateService, layoutService, controlClassService, ngControlService);
    this.ifControlStateService = ifControlStateService;
    this.focus = false;
    this.subscriptions.push(focusService.focusChange.subscribe((state2) => this.focus = state2));
  }
};
ClrDatalistContainer.ɵfac = function ClrDatalistContainer_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDatalistContainer)(ɵɵdirectiveInject(ControlClassService), ɵɵdirectiveInject(LayoutService, 8), ɵɵdirectiveInject(NgControlService), ɵɵdirectiveInject(FocusService2), ɵɵdirectiveInject(IfControlStateService));
};
ClrDatalistContainer.ɵcmp = ɵɵdefineComponent({
  type: ClrDatalistContainer,
  selectors: [["clr-datalist-container"]],
  hostVars: 6,
  hostBindings: function ClrDatalistContainer_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-form-control", true)("clr-form-control-disabled", ctx.control == null ? null : ctx.control.disabled)("clr-row", ctx.addGrid());
    }
  },
  standalone: false,
  features: [ɵɵProvidersFeature([ControlClassService, ControlIdService, FocusService2, NgControlService, DatalistIdService, IfControlStateService]), ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c30,
  decls: 13,
  vars: 9,
  consts: [[4, "ngIf"], [1, "clr-control-container", 3, "ngClass"], [1, "clr-input-wrapper"], [1, "clr-input-group"], ["shape", "angle", "direction", "down", 1, "clr-datalist-caret"], ["class", "clr-validate-icon", "shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 4, "ngIf"], ["class", "clr-validate-icon", "shape", "check-circle", "status", "success", "aria-hidden", "true", 4, "ngIf"], ["shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 1, "clr-validate-icon"], ["shape", "check-circle", "status", "success", "aria-hidden", "true", 1, "clr-validate-icon"]],
  template: function ClrDatalistContainer_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c29);
      ɵɵprojection(0);
      ɵɵtemplate(1, ClrDatalistContainer_label_1_Template, 1, 0, "label", 0);
      ɵɵelementStart(2, "div", 1)(3, "div", 2)(4, "div", 3);
      ɵɵprojection(5, 1);
      ɵɵprojection(6, 2);
      ɵɵelement(7, "cds-icon", 4);
      ɵɵelementEnd();
      ɵɵtemplate(8, ClrDatalistContainer_cds_icon_8_Template, 1, 0, "cds-icon", 5)(9, ClrDatalistContainer_cds_icon_9_Template, 1, 0, "cds-icon", 6);
      ɵɵelementEnd();
      ɵɵtemplate(10, ClrDatalistContainer_ng_content_10_Template, 1, 0, "ng-content", 0)(11, ClrDatalistContainer_ng_content_11_Template, 1, 0, "ng-content", 0)(12, ClrDatalistContainer_ng_content_12_Template, 1, 0, "ng-content", 0);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.label && ctx.addGrid());
      ɵɵadvance();
      ɵɵproperty("ngClass", ctx.controlClass());
      ɵɵadvance(2);
      ɵɵclassProp("clr-focus", ctx.focus);
      ɵɵadvance(4);
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showHelper);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
    }
  },
  dependencies: [NgClass, NgIf, ClrLabel, CdsIconCustomTag],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatalistContainer, [{
    type: Component,
    args: [{
      selector: "clr-datalist-container",
      template: `
    <ng-content select="label"></ng-content>
    <label *ngIf="!label && addGrid()"></label>
    <div class="clr-control-container" [ngClass]="controlClass()">
      <div class="clr-input-wrapper">
        <div class="clr-input-group" [class.clr-focus]="focus">
          <ng-content select="[clrDatalistInput]"></ng-content>
          <ng-content select="datalist"></ng-content>
          <cds-icon shape="angle" class="clr-datalist-caret" direction="down"></cds-icon>
        </div>
        <cds-icon
          *ngIf="showInvalid"
          class="clr-validate-icon"
          shape="exclamation-circle"
          status="danger"
          aria-hidden="true"
        ></cds-icon>
        <cds-icon
          *ngIf="showValid"
          class="clr-validate-icon"
          shape="check-circle"
          status="success"
          aria-hidden="true"
        ></cds-icon>
      </div>
      <ng-content select="clr-control-helper" *ngIf="showHelper"></ng-content>
      <ng-content select="clr-control-error" *ngIf="showInvalid"></ng-content>
      <ng-content select="clr-control-success" *ngIf="showValid"></ng-content>
    </div>
  `,
      host: {
        "[class.clr-form-control]": "true",
        "[class.clr-form-control-disabled]": "control?.disabled",
        "[class.clr-row]": "addGrid()"
      },
      providers: [ControlClassService, ControlIdService, FocusService2, NgControlService, DatalistIdService, IfControlStateService]
    }]
  }], function() {
    return [{
      type: ControlClassService
    }, {
      type: LayoutService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: NgControlService
    }, {
      type: FocusService2
    }, {
      type: IfControlStateService
    }];
  }, null);
})();
var ClrDatalistInput = class extends WrappedFormControl {
  constructor(focusService, vcr, injector, control, renderer, el, datalistIdService) {
    super(vcr, ClrDatalistContainer, injector, control, renderer, el);
    this.focusService = focusService;
    this.datalistIdService = datalistIdService;
    if (!focusService) {
      throw new Error("clrDatalist requires being wrapped in <clr-datalist-container>");
    }
  }
  ngAfterContentInit() {
    this.subscriptions.push(this.datalistIdService.idChange.subscribe((id) => this.listValue = id));
  }
  triggerFocus() {
    if (this.focusService) {
      this.focusService.focused = true;
    }
  }
  triggerValidation() {
    super.triggerValidation();
    if (this.focusService) {
      this.focusService.focused = false;
    }
  }
};
ClrDatalistInput.ɵfac = function ClrDatalistInput_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDatalistInput)(ɵɵdirectiveInject(FocusService2, 8), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(NgControl, 10), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(DatalistIdService));
};
ClrDatalistInput.ɵdir = ɵɵdefineDirective({
  type: ClrDatalistInput,
  selectors: [["", "clrDatalistInput", ""]],
  hostVars: 3,
  hostBindings: function ClrDatalistInput_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("focus", function ClrDatalistInput_focus_HostBindingHandler() {
        return ctx.triggerFocus();
      })("blur", function ClrDatalistInput_blur_HostBindingHandler() {
        return ctx.triggerValidation();
      });
    }
    if (rf & 2) {
      ɵɵattribute("list", ctx.listValue);
      ɵɵclassProp("clr-input", true);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatalistInput, [{
    type: Directive,
    args: [{
      selector: "[clrDatalistInput]",
      host: {
        "[class.clr-input]": "true",
        "[attr.list]": "listValue"
      }
    }]
  }], function() {
    return [{
      type: FocusService2,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ViewContainerRef
    }, {
      type: Injector
    }, {
      type: NgControl,
      decorators: [{
        type: Self
      }, {
        type: Optional
      }]
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: DatalistIdService
    }];
  }, {
    triggerFocus: [{
      type: HostListener,
      args: ["focus"]
    }],
    triggerValidation: [{
      type: HostListener,
      args: ["blur"]
    }]
  });
})();
var ClrDatalistModule = class {
  constructor() {
    r.addIcons(o4, e);
  }
};
ClrDatalistModule.ɵfac = function ClrDatalistModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDatalistModule)();
};
ClrDatalistModule.ɵmod = ɵɵdefineNgModule({
  type: ClrDatalistModule,
  declarations: [ClrDatalist, ClrDatalistInput, ClrDatalistContainer],
  imports: [CommonModule, ClrInputModule, ClrIconModule],
  exports: [ClrDatalist, ClrDatalistInput, ClrDatalistContainer]
});
ClrDatalistModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrInputModule, ClrIconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatalistModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ClrInputModule, ClrIconModule],
      declarations: [ClrDatalist, ClrDatalistInput, ClrDatalistContainer],
      exports: [ClrDatalist, ClrDatalistInput, ClrDatalistContainer]
    }]
  }], function() {
    return [];
  }, null);
})();
var CdkTrapFocusModule_CdkTrapFocus = class extends CdkTrapFocus {
  /**
   * Include the constructor to forward all the dependencies to the base class
   * as a workaround to fix Angular "ɵɵinvalidFactoryDep" error after upgrading storybook
   * https://github.com/storybookjs/storybook/issues/23534
   */
  constructor(elementRef, focusTrapFactory, document2) {
    super(elementRef, focusTrapFactory, document2);
  }
};
CdkTrapFocusModule_CdkTrapFocus.ɵfac = function CdkTrapFocusModule_CdkTrapFocus_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || CdkTrapFocusModule_CdkTrapFocus)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(FocusTrapFactory), ɵɵdirectiveInject(DOCUMENT, 8));
};
CdkTrapFocusModule_CdkTrapFocus.ɵdir = ɵɵdefineDirective({
  type: CdkTrapFocusModule_CdkTrapFocus,
  selectors: [["", "cdkTrapFocus", ""]],
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTrapFocusModule_CdkTrapFocus, [{
    type: Directive,
    args: [{
      selector: "[cdkTrapFocus]"
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: FocusTrapFactory
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [DOCUMENT]
      }]
    }];
  }, null);
})();
var CdkTrapFocusModule = class {
};
CdkTrapFocusModule.ɵfac = function CdkTrapFocusModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || CdkTrapFocusModule)();
};
CdkTrapFocusModule.ɵmod = ɵɵdefineNgModule({
  type: CdkTrapFocusModule,
  declarations: [CdkTrapFocusModule_CdkTrapFocus],
  exports: [CdkTrapFocusModule_CdkTrapFocus]
});
CdkTrapFocusModule.ɵinj = ɵɵdefineInjector({});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTrapFocusModule, [{
    type: NgModule,
    args: [{
      declarations: [CdkTrapFocusModule_CdkTrapFocus],
      exports: [CdkTrapFocusModule_CdkTrapFocus]
    }]
  }], null, null);
})();
var DEFAULT_LOCALE_FORMAT = "dd/MM/y";
var LITTLE_ENDIAN_REGEX = /d+.+m+.+y+/i;
var MIDDLE_ENDIAN_REGEX = /m+.+d+.+y+/i;
var DELIMITER_REGEX = /d+|m+|y+/i;
var USER_INPUT_REGEX = /\d+/g;
var MOBILE_USERAGENT_REGEX = /Mobi/i;
var RTL_REGEX = /\u200f/g;
var YEAR = "YYYY";
var MONTH = "MM";
var DATE = "DD";
var LITTLE_ENDIAN = {
  name: "LITTLE_ENDIAN",
  format: [DATE, MONTH, YEAR]
};
var MIDDLE_ENDIAN = {
  name: "MIDDLE_ENDIAN",
  format: [MONTH, DATE, YEAR]
};
var BIG_ENDIAN = {
  name: "BIG_ENDIAN",
  format: [YEAR, MONTH, DATE]
};
var NO_OF_DAYS_IN_A_WEEK = 7;
var NO_OF_ROWS_IN_CALENDAR_VIEW = 6;
var TOTAL_DAYS_IN_DAYS_VIEW = NO_OF_DAYS_IN_A_WEEK * NO_OF_ROWS_IN_CALENDAR_VIEW;
function getNumberOfDaysInTheMonth(year, month) {
  return new Date(year, month + 1, 0).getDate();
}
function getDay(year, month, date) {
  return new Date(year, month, date).getDay();
}
function parseToFourDigitYear(year) {
  if (year > 9999 || year > 100 && year < 999 || year < 10) {
    return -1;
  }
  if (year > 999) {
    return year;
  }
  const currYear = (/* @__PURE__ */ new Date()).getFullYear();
  const century = Math.floor(currYear / 100) * 100;
  let result = year + century;
  if (result > currYear + 20) {
    result = result - 100;
  }
  return result;
}
function datesAreEqual(date1, date2) {
  if (date1 instanceof Date && date2 instanceof Date) {
    return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate();
  } else {
    return false;
  }
}
var DayViewModel = class {
  constructor(dayModel, isTodaysDate = false, isExcluded = false, isDisabled = false, isSelected = false, isFocusable = false) {
    this.dayModel = dayModel;
    this.isTodaysDate = isTodaysDate;
    this.isExcluded = isExcluded;
    this.isDisabled = isDisabled;
    this.isSelected = isSelected;
    this.isFocusable = isFocusable;
  }
  /**
   * Gets the tab index based on the isFocusable flag.
   */
  get tabIndex() {
    return this.isFocusable ? 0 : -1;
  }
};
var DayModel = class _DayModel {
  constructor(year, month, date) {
    this.year = year;
    this.month = month;
    this.date = date;
  }
  /**
   * Checks if the passed CalendarDate is equal to itself.
   */
  isEqual(day) {
    if (day) {
      return this.year === day.year && this.month === day.month && this.date === day.date;
    }
    return false;
  }
  toDate() {
    return new Date(this.year, this.month, this.date);
  }
  /**
   * Returns a new DayModel which is incremented based on the value passed.
   */
  incrementBy(value) {
    const date = new Date(this.year, this.month, this.date + value);
    return new _DayModel(date.getFullYear(), date.getMonth(), date.getDate());
  }
  /**
   * Clones the current day model.
   */
  clone() {
    return new _DayModel(this.year, this.month, this.date);
  }
  toComparisonString() {
    return `${this.year}${this.pad(this.month)}${this.pad(this.date)}`;
  }
  toDateString() {
    return this.toDate().toLocaleDateString(void 0, {
      weekday: "long",
      month: "long",
      day: "numeric",
      year: "numeric"
    });
  }
  pad(num) {
    return num < 10 ? `0${num}` : `${num}`;
  }
};
var CalendarViewModel = class {
  constructor(calendar, selectedDay, focusableDay, today, firstDayOfWeek, excludedDates) {
    this.calendar = calendar;
    this.selectedDay = selectedDay;
    this.focusableDay = focusableDay;
    this.today = today;
    this.firstDayOfWeek = firstDayOfWeek;
    this.excludedDates = excludedDates;
    this.currMonthDayViews = [];
    this.initializeCalendarView();
  }
  /**
   * DayViewModel matrix. Size 6x7
   */
  get calendarView() {
    return this._calendarView;
  }
  /**
   * Updates the focusable day in the calendar.
   */
  updateFocusableDay(day) {
    this.setFocusableFlag(this.focusableDay, false);
    this.setFocusableFlag(day, true);
    this.focusableDay = day;
  }
  /**
   * Updates the selected day in the calendar
   */
  updateSelectedDay(day) {
    this.setSelectedDay(this.selectedDay, false);
    this.selectedDay = day;
    this.setSelectedDay(day, true);
  }
  /**
   * Generates a 6x7 matrix of DayViewModel based on the Calendar.
   * The 6x7 matrix is structured according to the first day of the week.
   * 6 rows to accommodate months which might have dates spanning over 6 weeks.
   * 7 columns because there are 7 days in a week :P :D
   */
  initializeCalendarView() {
    const prevMonthCalendar = this.calendar.previousMonth();
    const nextMonthCalendar = this.calendar.nextMonth();
    const daysFromPrevMonthInCalView = this.numDaysFromPrevMonthInCalView(this.calendar.year, this.calendar.month);
    const daysFromNextMonthInCalView = TOTAL_DAYS_IN_DAYS_VIEW - (this.calendar.days.length + daysFromPrevMonthInCalView);
    let prevMonthDayViews = [];
    let nextMonthDayViews = [];
    if (daysFromPrevMonthInCalView > 0) {
      prevMonthDayViews = this.generateDayViewModels(prevMonthCalendar.days.slice(-1 * daysFromPrevMonthInCalView), true, false);
    }
    this.currMonthDayViews = this.generateDayViewModels(this.calendar.days, false, true);
    if (daysFromNextMonthInCalView > 0) {
      nextMonthDayViews = this.generateDayViewModels(nextMonthCalendar.days.slice(0, daysFromNextMonthInCalView), true, false);
    }
    this._calendarView = this.generateCalendarView(prevMonthDayViews, this.currMonthDayViews, nextMonthDayViews);
    this.initializeSelectedDay();
    this.initializeFocusableDay();
  }
  isDateExcluded(date) {
    const {
      minDate,
      maxDate
    } = this.excludedDates;
    const from2 = minDate.toComparisonString();
    const to = maxDate.toComparisonString();
    const today = date.toComparisonString();
    return !(today >= from2 && today <= to);
  }
  /**
   * Generates a DayViewModel array based on the DayModel passed
   */
  generateDayViewModels(days, isExcluded, isCurrentCalendar) {
    const dayViews = days.map((day) => {
      return new DayViewModel(day, false, isExcluded, this.isDateExcluded(day), false, false);
    });
    if (isCurrentCalendar && this.calendar.isDayInCalendar(this.today)) {
      dayViews[this.today.date - 1].isTodaysDate = true;
    }
    return dayViews;
  }
  /**
   * Gets the first day of the current month to figure out how many dates of previous month
   * are needed to complete the Calendar View based on the first day of the week.
   * eg: Assuming locale en-US, the first day of the week is Sunday,
   * if first day of the current month lands on Wednesday, then
   * (this.getDay function would return 3 since
   * first day of the week is 0), we need the 3 days from the previous month.
   */
  numDaysFromPrevMonthInCalView(currentYear, currentMonth) {
    const firstDayOfCurrMonth = getDay(currentYear, currentMonth, 1);
    if (firstDayOfCurrMonth >= this.firstDayOfWeek) {
      return firstDayOfCurrMonth - this.firstDayOfWeek;
    } else {
      return NO_OF_DAYS_IN_A_WEEK + firstDayOfCurrMonth - this.firstDayOfWeek;
    }
  }
  /**
   * Checks if the Day passed is in the CalendarView.
   */
  isDayInCalendarView(day) {
    if (!this.calendar.isDayInCalendar(day)) {
      return false;
    }
    return true;
  }
  /**
   * Using the DayViewModels from the previous, current and next month, this function
   * generates the CalendarView.
   */
  generateCalendarView(prev, curr, next) {
    const combinationArr = [...prev, ...curr, ...next];
    const calendarView = [];
    for (let i = 0; i < NO_OF_ROWS_IN_CALENDAR_VIEW; i++) {
      calendarView[i] = combinationArr.slice(i * NO_OF_DAYS_IN_A_WEEK, (i + 1) * NO_OF_DAYS_IN_A_WEEK);
    }
    return calendarView;
  }
  /**
   * Initialize the selected day if the day is in the calendar.
   */
  initializeSelectedDay() {
    this.setSelectedDay(this.selectedDay, true);
  }
  /**
   * Initializes the focusable day if the day is in the calendar. If focusable day is not set, then
   * we check for the selected day. If selected day is not set then check if today is in the current
   * calendar. If not then just set the 15th of the current calendar month.
   */
  initializeFocusableDay() {
    if (this.focusableDay && this.isDayInCalendarView(this.focusableDay)) {
      this.setFocusableFlag(this.focusableDay, true);
    } else if (this.selectedDay && this.isDayInCalendarView(this.selectedDay)) {
      this.setFocusableFlag(this.selectedDay, true);
      this.focusableDay = this.selectedDay.clone();
    } else if (this.isDayInCalendarView(this.today)) {
      this.setFocusableFlag(this.today, true);
      this.focusableDay = this.today.clone();
    } else {
      this.focusableDay = new DayModel(this.calendar.year, this.calendar.month, 15);
      this.setFocusableFlag(this.focusableDay, true);
    }
  }
  setFocusableFlag(day, flag) {
    if (day) {
      this.currMonthDayViews[day.date - 1].isFocusable = flag;
    }
  }
  setSelectedDay(day, flag) {
    if (day && this.isDayInCalendarView(day)) {
      this.currMonthDayViews[day?.date - 1].isSelected = flag;
    }
  }
};
var LocaleHelperService = class {
  constructor(locale) {
    this.locale = locale;
    this._firstDayOfWeek = 0;
    this.initializeLocaleData();
  }
  get firstDayOfWeek() {
    return this._firstDayOfWeek;
  }
  get localeDays() {
    return this._localeDays;
  }
  // leave for backward compatibility
  get localeDaysNarrow() {
    return this._localeDays.map((day) => day.narrow);
  }
  get localeMonthsAbbreviated() {
    return this._localeMonthsAbbreviated;
  }
  get localeMonthsWide() {
    return this._localeMonthsWide;
  }
  get localeDateFormat() {
    return this._localeDateFormat;
  }
  /**
   * Initializes the locale data.
   */
  initializeLocaleData() {
    this.initializeFirstDayOfWeek();
    this.initializeLocaleDateFormat();
    this.initializeLocaleMonthsAbbreviated();
    this.initializeLocaleMonthsWide();
    this.initializeLocaleDays();
  }
  /**
   * Initialize day names based on the locale.
   * eg: [{day: Sunday, narrow: S}, {day: Monday, narrow: M}...] for en-US.
   */
  initializeLocaleDays() {
    const tempArr = [];
    const tempWideArr = getLocaleDayNames(this.locale, FormStyle.Standalone, TranslationWidth.Wide).slice();
    const tempNarrowArr = getLocaleDayNames(this.locale, FormStyle.Standalone, TranslationWidth.Narrow).slice();
    const firstDayOfWeek = this.firstDayOfWeek;
    for (let i = 0; i < 7; i++) {
      tempArr.push({
        day: tempWideArr[i],
        narrow: tempNarrowArr[i]
      });
    }
    if (firstDayOfWeek > 0) {
      const prevDays = tempArr.splice(0, firstDayOfWeek);
      tempArr.push(...prevDays);
    }
    this._localeDays = tempArr;
  }
  /**
   * Initializes the array of month names in the TranslationWidth.Abbreviated format.
   * e.g. `[Jan, Feb, ...]` for en-US
   */
  initializeLocaleMonthsAbbreviated() {
    this._localeMonthsAbbreviated = getLocaleMonthNames(this.locale, FormStyle.Standalone, TranslationWidth.Abbreviated).slice();
  }
  /**
   * Initializes the array of month names in the TranslationWidth.Wide format.
   * e.g. `[January, February, ...]` for en-US
   */
  initializeLocaleMonthsWide() {
    this._localeMonthsWide = getLocaleMonthNames(this.locale, FormStyle.Standalone, TranslationWidth.Wide).slice();
  }
  /**
   * Initializes the first day of the week based on the locale.
   */
  initializeFirstDayOfWeek() {
    this._firstDayOfWeek = getLocaleFirstDayOfWeek(this.locale);
  }
  initializeLocaleDateFormat() {
    this._localeDateFormat = getLocaleDateFormat(this.locale, FormatWidth.Short);
  }
};
LocaleHelperService.ɵfac = function LocaleHelperService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || LocaleHelperService)(ɵɵinject(LOCALE_ID));
};
LocaleHelperService.ɵprov = ɵɵdefineInjectable({
  token: LocaleHelperService,
  factory: LocaleHelperService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocaleHelperService, [{
    type: Injectable
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [LOCALE_ID]
      }]
    }];
  }, null);
})();
var CalendarModel = class _CalendarModel {
  constructor(year, month) {
    this.year = year;
    this.month = month;
    this.initializeDaysInCalendar();
  }
  /**
   * Checks if the calendar passed is equal to the current calendar.
   */
  isEqual(calendar) {
    if (calendar) {
      return this.year === calendar.year && this.month === calendar.month;
    }
    return false;
  }
  /**
   * Checks if a DayModel is in the Calendar
   */
  isDayInCalendar(day) {
    if (day) {
      return this.year === day.year && this.month === day.month;
    }
    return false;
  }
  /**
   * Returns CalendarModel of the previous month.
   */
  previousMonth() {
    if (this.month === 0) {
      return new _CalendarModel(this.year - 1, 11);
    } else {
      return new _CalendarModel(this.year, this.month - 1);
    }
  }
  /**
   * Returns CalendarModel of the next month.
   */
  nextMonth() {
    if (this.month === 11) {
      return new _CalendarModel(this.year + 1, 0);
    } else {
      return new _CalendarModel(this.year, this.month + 1);
    }
  }
  /**
   * Populates the days array with the DayModels in the current Calendar.
   */
  initializeDaysInCalendar() {
    const noOfDaysInCalendar = getNumberOfDaysInTheMonth(this.year, this.month);
    this.days = Array(noOfDaysInCalendar).fill(null).map((_date, index) => {
      return new DayModel(this.year, this.month, index + 1);
    });
  }
};
var DateNavigationService = class {
  constructor() {
    this.hasActionButtons = false;
    this._todaysFullDate = /* @__PURE__ */ new Date();
    this._selectedDayChange = new Subject();
    this._displayedCalendarChange = new Subject();
    this._focusOnCalendarChange = new Subject();
    this._focusedDayChange = new Subject();
  }
  get today() {
    return this._today;
  }
  get displayedCalendar() {
    return this._displayedCalendar;
  }
  get selectedDayChange() {
    return this._selectedDayChange.asObservable();
  }
  /**
   * This observable lets the subscriber know that the displayed calendar has changed.
   */
  get displayedCalendarChange() {
    return this._displayedCalendarChange.asObservable();
  }
  /**
   * This observable lets the subscriber know that the focus should be applied on the calendar.
   */
  get focusOnCalendarChange() {
    return this._focusOnCalendarChange.asObservable();
  }
  /**
   * This observable lets the subscriber know that the focused day in the displayed calendar has changed.
   */
  get focusedDayChange() {
    return this._focusedDayChange.asObservable();
  }
  /**
   * Notifies that the selected day has changed so that the date can be emitted to the user.
   */
  notifySelectedDayChanged(dayModel, {
    emitEvent
  } = {
    emitEvent: true
  }) {
    this.selectedDay = dayModel;
    if (emitEvent) {
      this._selectedDayChange.next(dayModel);
    }
  }
  /**
   * Initializes the calendar based on the selected day.
   */
  initializeCalendar() {
    this.focusedDay = null;
    this.initializeTodaysDate();
    if (this.selectedDay) {
      this._displayedCalendar = new CalendarModel(this.selectedDay.year, this.selectedDay.month);
    } else {
      this._displayedCalendar = new CalendarModel(this.today.year, this.today.month);
    }
  }
  changeMonth(month) {
    this.setDisplayedCalendar(new CalendarModel(this._displayedCalendar.year, month));
  }
  changeYear(year) {
    this.setDisplayedCalendar(new CalendarModel(year, this._displayedCalendar.month));
  }
  /**
   * Moves the displayed calendar to the next month.
   */
  moveToNextMonth() {
    this.setDisplayedCalendar(this._displayedCalendar.nextMonth());
  }
  /**
   * Moves the displayed calendar to the previous month.
   */
  moveToPreviousMonth() {
    this.setDisplayedCalendar(this._displayedCalendar.previousMonth());
  }
  /**
   * Moves the displayed calendar to the current month and year.
   */
  moveToCurrentMonth() {
    if (!this.displayedCalendar.isDayInCalendar(this.today)) {
      this.setDisplayedCalendar(new CalendarModel(this.today.year, this.today.month));
    }
    this._focusOnCalendarChange.next();
  }
  incrementFocusDay(value) {
    this.focusedDay = this.focusedDay.incrementBy(value);
    if (this._displayedCalendar.isDayInCalendar(this.focusedDay)) {
      this._focusedDayChange.next(this.focusedDay);
    } else {
      this.setDisplayedCalendar(new CalendarModel(this.focusedDay.year, this.focusedDay.month));
    }
    this._focusOnCalendarChange.next();
  }
  resetSelectedDay() {
    this.selectedDay = this.persistedDate;
  }
  // not a setter because i want this to remain private
  setDisplayedCalendar(value) {
    if (!this._displayedCalendar.isEqual(value)) {
      this._displayedCalendar = value;
      this._displayedCalendarChange.next();
    }
  }
  initializeTodaysDate() {
    this._todaysFullDate = /* @__PURE__ */ new Date();
    this._today = new DayModel(this._todaysFullDate.getFullYear(), this._todaysFullDate.getMonth(), this._todaysFullDate.getDate());
  }
};
DateNavigationService.ɵfac = function DateNavigationService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || DateNavigationService)();
};
DateNavigationService.ɵprov = ɵɵdefineInjectable({
  token: DateNavigationService,
  factory: DateNavigationService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateNavigationService, [{
    type: Injectable
  }], null, null);
})();
var DatepickerFocusService = class {
  constructor(_ngZone, platformId) {
    this._ngZone = _ngZone;
    this.platformId = platformId;
  }
  focusCell(elRef) {
    this._ngZone.runOutsideAngular(() => {
      this.ngZoneIsStableInBrowser().subscribe(() => {
        const focusEl = elRef.nativeElement.querySelector('[tabindex="0"]');
        if (focusEl) {
          focusEl.focus();
        }
      });
    });
  }
  focusInput(element) {
    this._ngZone.runOutsideAngular(() => this.ngZoneIsStableInBrowser().subscribe(() => element.focus()));
  }
  elementIsFocused(element) {
    return isPlatformBrowser(this.platformId) && document.activeElement === element;
  }
  ngZoneIsStableInBrowser() {
    return this._ngZone.onStable.asObservable().pipe(first(), filter(() => isPlatformBrowser(this.platformId)));
  }
};
DatepickerFocusService.ɵfac = function DatepickerFocusService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || DatepickerFocusService)(ɵɵinject(NgZone), ɵɵinject(PLATFORM_ID));
};
DatepickerFocusService.ɵprov = ɵɵdefineInjectable({
  token: DatepickerFocusService,
  factory: DatepickerFocusService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatepickerFocusService, [{
    type: Injectable
  }], function() {
    return [{
      type: NgZone
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }];
  }, null);
})();
var DateIOService = class {
  constructor(localeHelperService) {
    this.disabledDates = {
      // This is the default range. It approximates the beginning of time to the end of time.
      // Unless a minDate or maxDate is set with the native HTML5 api the range is all dates
      // TODO: turn this into an Array of min/max ranges that allow configuration of multiple ranges.
      minDate: new DayModel(0, 0, 1),
      maxDate: new DayModel(9999, 11, 31)
    };
    this.cldrLocaleDateFormat = DEFAULT_LOCALE_FORMAT;
    this.localeDisplayFormat = LITTLE_ENDIAN;
    this.delimiters = ["/", "/"];
    this.cldrLocaleDateFormat = localeHelperService.localeDateFormat;
    this.initializeLocaleDisplayFormat();
  }
  get placeholderText() {
    const format = this.localeDisplayFormat.format;
    return format[0] + this.delimiters[0] + format[1] + this.delimiters[1] + format[2];
  }
  setMinDate(date) {
    if (!date) {
      this.disabledDates.minDate = new DayModel(0, 0, 1);
    } else {
      const [year, month, day] = date.split("-").map((n) => parseInt(n, 10));
      this.disabledDates.minDate = new DayModel(year, month - 1, day);
    }
  }
  setMaxDate(date) {
    if (!date) {
      this.disabledDates.maxDate = new DayModel(9999, 11, 31);
    } else {
      const [year, month, day] = date.split("-").map((n) => parseInt(n, 10));
      this.disabledDates.maxDate = new DayModel(year, month - 1, day);
    }
  }
  toLocaleDisplayFormatString(date) {
    if (date) {
      if (isNaN(date.getTime())) {
        return "";
      }
      const dateNo = date.getDate();
      const monthNo = date.getMonth() + 1;
      const dateStr = dateNo > 9 ? dateNo.toString() : "0" + dateNo;
      const monthStr = monthNo > 9 ? monthNo.toString() : "0" + monthNo;
      if (this.localeDisplayFormat === LITTLE_ENDIAN) {
        return dateStr + this.delimiters[0] + monthStr + this.delimiters[1] + date.getFullYear();
      } else if (this.localeDisplayFormat === MIDDLE_ENDIAN) {
        return monthStr + this.delimiters[0] + dateStr + this.delimiters[1] + date.getFullYear();
      } else {
        return date.getFullYear() + this.delimiters[0] + monthStr + this.delimiters[1] + dateStr;
      }
    }
    return "";
  }
  getDateValueFromDateString(date) {
    if (!date || typeof date !== "string") {
      return null;
    }
    const dateParts = date.match(USER_INPUT_REGEX);
    if (!dateParts || dateParts.length !== 3) {
      return null;
    }
    const [firstPart, secondPart, thirdPart] = dateParts;
    if (this.localeDisplayFormat === LITTLE_ENDIAN) {
      return this.validateAndGetDate(thirdPart, secondPart, firstPart);
    } else if (this.localeDisplayFormat === MIDDLE_ENDIAN) {
      return this.validateAndGetDate(thirdPart, firstPart, secondPart);
    } else {
      return this.validateAndGetDate(firstPart, secondPart, thirdPart);
    }
  }
  initializeLocaleDisplayFormat() {
    const format = this.cldrLocaleDateFormat.toLocaleLowerCase();
    if (LITTLE_ENDIAN_REGEX.test(format)) {
      this.localeDisplayFormat = LITTLE_ENDIAN;
    } else if (MIDDLE_ENDIAN_REGEX.test(format)) {
      this.localeDisplayFormat = MIDDLE_ENDIAN;
    } else {
      this.localeDisplayFormat = BIG_ENDIAN;
    }
    this.extractDelimiters();
  }
  extractDelimiters() {
    if (this.cldrLocaleDateFormat) {
      const localeFormat = this.cldrLocaleDateFormat.replace(RTL_REGEX, "");
      const delimiters = localeFormat.split(DELIMITER_REGEX);
      if (delimiters && delimiters.length === 4) {
        this.delimiters = [delimiters[1], delimiters[2]];
      } else {
        console.error("Unexpected date format received. Delimiters extracted: ", delimiters);
      }
    }
  }
  /**
   * Checks if the month entered by the user is valid or not.
   * Note: Month is 0 based.
   */
  isValidMonth(month) {
    return month > -1 && month < 12;
  }
  /**
   * Checks if the date is valid depending on the year and month provided.
   */
  isValidDate(year, month, date) {
    return date > 0 && date <= getNumberOfDaysInTheMonth(year, month);
  }
  /**
   * Validates the parameters provided and returns the date.
   * If the parameters are not
   * valid then return null.
   * NOTE: (Month here is 1 based since the user has provided that as an input)
   */
  validateAndGetDate(year, month, date) {
    const y = +year;
    const m = +month - 1;
    const d4 = +date;
    if (!this.isValidMonth(m) || !this.isValidDate(y, m, d4)) {
      return null;
    }
    const result = parseToFourDigitYear(y);
    return result !== -1 ? new Date(result, m, d4) : null;
  }
};
DateIOService.ɵfac = function DateIOService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || DateIOService)(ɵɵinject(LocaleHelperService));
};
DateIOService.ɵprov = ɵɵdefineInjectable({
  token: DateIOService,
  factory: DateIOService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateIOService, [{
    type: Injectable
  }], function() {
    return [{
      type: LocaleHelperService
    }];
  }, null);
})();
var DateFormControlService = class {
  constructor() {
    this._touchedChange = new Subject();
    this._dirtyChange = new Subject();
  }
  get touchedChange() {
    return this._touchedChange.asObservable();
  }
  get dirtyChange() {
    return this._dirtyChange.asObservable();
  }
  markAsTouched() {
    this._touchedChange.next();
  }
  markAsDirty() {
    this._dirtyChange.next();
  }
  // friendly wrapper
  setDisabled(state2) {
    this.disabled = state2;
  }
};
DateFormControlService.ɵfac = function DateFormControlService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || DateFormControlService)();
};
DateFormControlService.ɵprov = ɵɵdefineInjectable({
  token: DateFormControlService,
  factory: DateFormControlService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateFormControlService, [{
    type: Injectable
  }], null, null);
})();
var ClrDay = class {
  constructor(_dateNavigationService, commonStrings) {
    this._dateNavigationService = _dateNavigationService;
    this.commonStrings = commonStrings;
    this.onSelectDay = new EventEmitter();
  }
  /**
   * DayViewModel input which is used to build the Day View.
   */
  get dayView() {
    return this._dayView;
  }
  set dayView(day) {
    this._dayView = day;
  }
  get dayString() {
    return this.dayView.isSelected ? this.commonStrings.parse(this.commonStrings.keys.datepickerSelectedLabel, {
      FULL_DATE: this._dayView.dayModel.toDateString()
    }) : this._dayView.dayModel.toDateString();
  }
  /**
   * Updates the focusedDay in the DateNavigationService when the ClrDay is focused.
   */
  onDayViewFocus() {
    this._dateNavigationService.focusedDay = this.dayView.dayModel;
  }
  /**
   * Updates the selectedDay when the ClrDay is selected and closes the datepicker popover.
   */
  selectDay() {
    if (this.dayView.isDisabled) {
      return;
    }
    const day = this.dayView.dayModel;
    this.onSelectDay.emit(day);
  }
};
ClrDay.ɵfac = function ClrDay_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDay)(ɵɵdirectiveInject(DateNavigationService), ɵɵdirectiveInject(ClrCommonStringsService));
};
ClrDay.ɵcmp = ɵɵdefineComponent({
  type: ClrDay,
  selectors: [["clr-day"]],
  hostVars: 2,
  hostBindings: function ClrDay_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("day", true);
    }
  },
  inputs: {
    dayView: [0, "clrDayView", "dayView"]
  },
  outputs: {
    onSelectDay: "selectDay"
  },
  standalone: false,
  decls: 2,
  vars: 13,
  consts: [["type", "button", 1, "day-btn", 3, "click", "focus"]],
  template: function ClrDay_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "button", 0);
      ɵɵlistener("click", function ClrDay_Template_button_click_0_listener() {
        return ctx.selectDay();
      })("focus", function ClrDay_Template_button_focus_0_listener() {
        return ctx.onDayViewFocus();
      });
      ɵɵtext(1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵclassProp("is-today", ctx.dayView.isTodaysDate)("is-excluded", ctx.dayView.isExcluded)("is-disabled", ctx.dayView.isDisabled)("is-selected", ctx.dayView.isSelected);
      ɵɵattribute("tabindex", ctx.dayView.tabIndex)("aria-current", ctx.dayView.isTodaysDate ? "date" : "false")("aria-label", ctx.dayString)("aria-selected", ctx.dayView.isSelected);
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", ctx.dayView.dayModel.date, " ");
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDay, [{
    type: Component,
    args: [{
      selector: "clr-day",
      template: `
    <button
      class="day-btn"
      type="button"
      [class.is-today]="dayView.isTodaysDate"
      [class.is-excluded]="dayView.isExcluded"
      [class.is-disabled]="dayView.isDisabled"
      [class.is-selected]="dayView.isSelected"
      [attr.tabindex]="dayView.tabIndex"
      (click)="selectDay()"
      (focus)="onDayViewFocus()"
      [attr.aria-current]="dayView.isTodaysDate ? 'date' : 'false'"
      [attr.aria-label]="dayString"
      [attr.aria-selected]="dayView.isSelected"
    >
      {{ dayView.dayModel.date }}
    </button>
  `,
      host: {
        "[class.day]": "true"
      }
    }]
  }], function() {
    return [{
      type: DateNavigationService
    }, {
      type: ClrCommonStringsService
    }];
  }, {
    onSelectDay: [{
      type: Output,
      args: ["selectDay"]
    }],
    dayView: [{
      type: Input,
      args: ["clrDayView"]
    }]
  });
})();
var ClrCalendar = class {
  constructor(_localeHelperService, _dateNavigationService, _datepickerFocusService, _dateIOService, _elRef, _dateFormControlService, _toggleService) {
    this._localeHelperService = _localeHelperService;
    this._dateNavigationService = _dateNavigationService;
    this._datepickerFocusService = _datepickerFocusService;
    this._dateIOService = _dateIOService;
    this._elRef = _elRef;
    this._dateFormControlService = _dateFormControlService;
    this._toggleService = _toggleService;
    this._subs = [];
    this.generateCalendarView();
    this.initializeSubscriptions();
  }
  /**
   * Gets the locale days according to the TranslationWidth.Narrow format.
   */
  get localeDays() {
    return this._localeHelperService.localeDays;
  }
  get calendar() {
    return this._dateNavigationService.displayedCalendar;
  }
  get selectedDay() {
    return this._dateNavigationService.selectedDay;
  }
  get focusedDay() {
    return this._dateNavigationService.focusedDay;
  }
  get today() {
    return this._dateNavigationService.today;
  }
  /**
   * Focuses on the focusable day when the Calendar View is initialized.
   */
  ngAfterViewInit() {
    this._datepickerFocusService.focusCell(this._elRef);
  }
  /**
   * Unsubscribe from subscriptions.
   */
  ngOnDestroy() {
    this._subs.forEach((sub) => sub.unsubscribe());
  }
  /**
   * Delegates Keyboard arrow navigation to the DateNavigationService.
   */
  onKeyDown(event) {
    if (event && this.focusedDay) {
      switch (normalizeKey(event.key)) {
        case Keys.ArrowUp:
          event.preventDefault();
          this._dateNavigationService.incrementFocusDay(-1 * NO_OF_DAYS_IN_A_WEEK);
          break;
        case Keys.ArrowDown:
          event.preventDefault();
          this._dateNavigationService.incrementFocusDay(NO_OF_DAYS_IN_A_WEEK);
          break;
        case Keys.ArrowLeft:
          event.preventDefault();
          this._dateNavigationService.incrementFocusDay(-1);
          break;
        case Keys.ArrowRight:
          event.preventDefault();
          this._dateNavigationService.incrementFocusDay(1);
          break;
        default:
          break;
      }
    }
  }
  setSelectedDay(day) {
    const hasActionButtons = this._dateNavigationService.hasActionButtons;
    this.calendarViewModel.updateSelectedDay(day);
    this._dateNavigationService.notifySelectedDayChanged(day, {
      emitEvent: !hasActionButtons
    });
    if (!hasActionButtons) {
      this._dateFormControlService.markAsDirty();
      this._toggleService.open = false;
    }
  }
  /**
   * Initialize subscriptions to:
   * 1. update the calendar view model.
   * 2. update the focusable day in the calendar view model.
   * 3. focus on the focusable day in the calendar.
   */
  initializeSubscriptions() {
    this._subs.push(this._dateNavigationService.displayedCalendarChange.subscribe(() => {
      this.generateCalendarView();
    }));
    this._subs.push(this._dateNavigationService.focusedDayChange.subscribe((focusedDay) => {
      this.calendarViewModel.updateFocusableDay(focusedDay);
    }));
    this._subs.push(this._dateNavigationService.focusOnCalendarChange.subscribe(() => {
      this._datepickerFocusService.focusCell(this._elRef);
    }));
  }
  /**
   * Generates the Calendar View based on the calendar retrieved from the DateNavigationService.
   */
  generateCalendarView() {
    this.calendarViewModel = new CalendarViewModel(this.calendar, this.selectedDay, this.focusedDay, this.today, this._localeHelperService.firstDayOfWeek, this._dateIOService.disabledDates);
  }
};
ClrCalendar.ɵfac = function ClrCalendar_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrCalendar)(ɵɵdirectiveInject(LocaleHelperService), ɵɵdirectiveInject(DateNavigationService), ɵɵdirectiveInject(DatepickerFocusService), ɵɵdirectiveInject(DateIOService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(DateFormControlService), ɵɵdirectiveInject(ClrPopoverToggleService));
};
ClrCalendar.ɵcmp = ɵɵdefineComponent({
  type: ClrCalendar,
  selectors: [["clr-calendar"]],
  hostBindings: function ClrCalendar_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("keydown", function ClrCalendar_keydown_HostBindingHandler($event) {
        return ctx.onKeyDown($event);
      });
    }
  },
  standalone: false,
  decls: 4,
  vars: 2,
  consts: [["role", "presentation", 1, "calendar-table"], [1, "calendar-row", "weekdays"], ["class", "calendar-cell weekday", 4, "ngFor", "ngForOf"], ["class", "calendar-row", 4, "ngFor", "ngForOf"], [1, "calendar-cell", "weekday"], [1, "calendar-row"], ["class", "calendar-cell", 4, "ngFor", "ngForOf"], [1, "calendar-cell"], ["aria-hidden", "true", 3, "selectDay", "clrDayView"]],
  template: function ClrCalendar_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "table", 0)(1, "tr", 1);
      ɵɵtemplate(2, ClrCalendar_th_2_Template, 3, 2, "th", 2);
      ɵɵelementEnd();
      ɵɵtemplate(3, ClrCalendar_tr_3_Template, 2, 1, "tr", 3);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵproperty("ngForOf", ctx.localeDays);
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.calendarViewModel.calendarView);
    }
  },
  dependencies: [NgForOf, ClrDay],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrCalendar, [{
    type: Component,
    args: [{
      selector: "clr-calendar",
      template: '<table class="calendar-table" role="presentation">\n  <tr class="calendar-row weekdays">\n    <th *ngFor="let day of localeDays" class="calendar-cell weekday">\n      <span [attr.aria-label]="day.day">{{day.narrow}}</span>\n    </th>\n  </tr>\n  <tr class="calendar-row" *ngFor="let row of calendarViewModel.calendarView">\n    <td *ngFor="let dayView of row" class="calendar-cell">\n      <clr-day [clrDayView]="dayView" (selectDay)="setSelectedDay($event)" aria-hidden="true"></clr-day>\n    </td>\n  </tr>\n</table>\n'
    }]
  }], function() {
    return [{
      type: LocaleHelperService
    }, {
      type: DateNavigationService
    }, {
      type: DatepickerFocusService
    }, {
      type: DateIOService
    }, {
      type: ElementRef
    }, {
      type: DateFormControlService
    }, {
      type: ClrPopoverToggleService
    }];
  }, {
    onKeyDown: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }]
  });
})();
var DATEPICKER_ENABLE_BREAKPOINT = 768;
var LARGE_BREAKPOINT = 992;
var DatepickerEnabledService = class {
  constructor(_document) {
    this._document = _document;
    this._isUserAgentMobile = false;
    if (_document) {
      this._isUserAgentMobile = MOBILE_USERAGENT_REGEX.test(_document.defaultView.navigator.userAgent);
      this._innerWidth = _document.defaultView.innerWidth;
    }
  }
  /**
   * Returns if the calendar should be active or not.
   * If the user agent is mobile and the screen width is less than DATEPICKER_ACTIVE_BREAKPOINT
   * then the calendar is inactive.
   */
  get isEnabled() {
    if (this._document) {
      if (this._innerWidth < DATEPICKER_ENABLE_BREAKPOINT && this._isUserAgentMobile) {
        return false;
      }
    }
    return true;
  }
};
DatepickerEnabledService.ɵfac = function DatepickerEnabledService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || DatepickerEnabledService)(ɵɵinject(DOCUMENT));
};
DatepickerEnabledService.ɵprov = ɵɵdefineInjectable({
  token: DatepickerEnabledService,
  factory: DatepickerEnabledService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatepickerEnabledService, [{
    type: Injectable
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [DOCUMENT]
      }]
    }];
  }, null);
})();
var ViewManagerService = class {
  constructor() {
    this.position = ClrPopoverPositions["bottom-left"];
    this._currentView = "DAYVIEW";
  }
  get isDayView() {
    return this._currentView === "DAYVIEW";
  }
  get isYearView() {
    return this._currentView === "YEARVIEW";
  }
  get isMonthView() {
    return this._currentView === "MONTHVIEW";
  }
  changeToMonthView() {
    this._currentView = "MONTHVIEW";
  }
  changeToYearView() {
    this._currentView = "YEARVIEW";
  }
  changeToDayView() {
    this._currentView = "DAYVIEW";
  }
};
ViewManagerService.ɵfac = function ViewManagerService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ViewManagerService)();
};
ViewManagerService.ɵprov = ɵɵdefineInjectable({
  token: ViewManagerService,
  factory: ViewManagerService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ViewManagerService, [{
    type: Injectable
  }], null, null);
})();
var ClrMonthpicker = class {
  constructor(_viewManagerService, _localeHelperService, _dateNavigationService, _datepickerFocusService, _elRef) {
    this._viewManagerService = _viewManagerService;
    this._localeHelperService = _localeHelperService;
    this._dateNavigationService = _dateNavigationService;
    this._datepickerFocusService = _datepickerFocusService;
    this._elRef = _elRef;
    this._focusedMonthIndex = this.calendarMonthIndex;
  }
  /**
   * Gets the months array which is used to rendered the monthpicker view.
   * Months are in the TranslationWidth.Wide format.
   */
  get monthNames() {
    return this._localeHelperService.localeMonthsWide;
  }
  /**
   * Gets the month value of the Calendar.
   */
  get calendarMonthIndex() {
    return this._dateNavigationService.displayedCalendar.month;
  }
  /**
   * Focuses on the current calendar month when the View is initialized.
   */
  ngAfterViewInit() {
    this._datepickerFocusService.focusCell(this._elRef);
  }
  /**
   * Handles the Keyboard arrow navigation for the monthpicker.
   */
  onKeyDown(event) {
    if (event) {
      const key = normalizeKey(event.key);
      if (key === Keys.ArrowUp && this._focusedMonthIndex > 0) {
        event.preventDefault();
        this._focusedMonthIndex--;
        this._datepickerFocusService.focusCell(this._elRef);
      } else if (key === Keys.ArrowDown && this._focusedMonthIndex < 11) {
        event.preventDefault();
        this._focusedMonthIndex++;
        this._datepickerFocusService.focusCell(this._elRef);
      } else if (key === Keys.ArrowRight && this._focusedMonthIndex < 6) {
        event.preventDefault();
        this._focusedMonthIndex = this._focusedMonthIndex + 6;
        this._datepickerFocusService.focusCell(this._elRef);
      } else if (key === Keys.ArrowLeft && this._focusedMonthIndex > 5) {
        event.preventDefault();
        this._focusedMonthIndex = this._focusedMonthIndex - 6;
        this._datepickerFocusService.focusCell(this._elRef);
      }
    }
  }
  /**
   * Calls the DateNavigationService to update the month value of the calendar.
   * Also changes the view to the daypicker.
   */
  changeMonth(monthIndex) {
    this._dateNavigationService.changeMonth(monthIndex);
    this._viewManagerService.changeToDayView();
  }
  /**
   * Compares the month passed to the focused month and returns the tab index.
   */
  getTabIndex(monthIndex) {
    return monthIndex === this._focusedMonthIndex ? 0 : -1;
  }
};
ClrMonthpicker.ɵfac = function ClrMonthpicker_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrMonthpicker)(ɵɵdirectiveInject(ViewManagerService), ɵɵdirectiveInject(LocaleHelperService), ɵɵdirectiveInject(DateNavigationService), ɵɵdirectiveInject(DatepickerFocusService), ɵɵdirectiveInject(ElementRef));
};
ClrMonthpicker.ɵcmp = ɵɵdefineComponent({
  type: ClrMonthpicker,
  selectors: [["clr-monthpicker"]],
  hostAttrs: ["role", "application"],
  hostVars: 2,
  hostBindings: function ClrMonthpicker_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("keydown", function ClrMonthpicker_keydown_HostBindingHandler($event) {
        return ctx.onKeyDown($event);
      });
    }
    if (rf & 2) {
      ɵɵclassProp("monthpicker", true);
    }
  },
  standalone: false,
  decls: 1,
  vars: 1,
  consts: [["type", "button", "class", "calendar-btn month", 3, "is-selected", "click", 4, "ngFor", "ngForOf"], ["type", "button", 1, "calendar-btn", "month", 3, "click"]],
  template: function ClrMonthpicker_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, ClrMonthpicker_button_0_Template, 2, 4, "button", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngForOf", ctx.monthNames);
    }
  },
  dependencies: [NgForOf],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrMonthpicker, [{
    type: Component,
    args: [{
      selector: "clr-monthpicker",
      template: `
    <button
      type="button"
      class="calendar-btn month"
      *ngFor="let month of monthNames; let monthIndex = index"
      (click)="changeMonth(monthIndex)"
      [class.is-selected]="monthIndex === calendarMonthIndex"
      [attr.tabindex]="getTabIndex(monthIndex)"
    >
      {{ month }}
    </button>
  `,
      host: {
        "[class.monthpicker]": "true",
        role: "application"
      }
    }]
  }], function() {
    return [{
      type: ViewManagerService
    }, {
      type: LocaleHelperService
    }, {
      type: DateNavigationService
    }, {
      type: DatepickerFocusService
    }, {
      type: ElementRef
    }];
  }, {
    onKeyDown: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }]
  });
})();
var YEARS_TO_DISPLAY = 10;
var YearRangeModel = class _YearRangeModel {
  constructor(year) {
    this.year = year;
    this.yearRange = [];
    this.generateYearRange();
  }
  /**
   * Gets the number in the middle of the range.
   */
  get middleYear() {
    return this.yearRange[Math.floor(this.yearRange.length / 2)];
  }
  /**
   * Generates the YearRangeModel for the next decade.
   */
  nextDecade() {
    return new _YearRangeModel(this.year + 10);
  }
  /**
   * Generates the YearRangeModel for the previous decade.
   */
  previousDecade() {
    return new _YearRangeModel(this.year - 10);
  }
  /**
   * Generates the YearRangeModel for the current decade.
   */
  currentDecade() {
    return new _YearRangeModel((/* @__PURE__ */ new Date()).getFullYear());
  }
  /**
   * Checks if the value is in the YearRangeModel.
   */
  inRange(value) {
    return this.yearRange.indexOf(value) > -1;
  }
  /**
   * Generates the year range based on the year parameter.
   * eg: If 2018 is passed the output will be [2010, 2011, ..., 2019]
   */
  generateYearRange() {
    const remainder = this.year % YEARS_TO_DISPLAY;
    const floor = this.year - remainder;
    const ceil = floor + YEARS_TO_DISPLAY;
    this.yearRange = this.generateRange(floor, ceil);
  }
  /**
   * Function which generate a range of numbers from floor to ceil.
   */
  generateRange(floor, ceil) {
    return Array.from({
      length: ceil - floor
    }, (_v, k) => k + floor);
  }
};
var ClrYearpicker = class {
  constructor(_dateNavigationService, _viewManagerService, _datepickerFocusService, _elRef, commonStrings) {
    this._dateNavigationService = _dateNavigationService;
    this._viewManagerService = _viewManagerService;
    this._datepickerFocusService = _datepickerFocusService;
    this._elRef = _elRef;
    this.commonStrings = commonStrings;
    this.yearRangeModel = new YearRangeModel(this.calendarYear);
    this._focusedYear = this.calendarYear;
  }
  /**
   * Gets the year which the user is currently on.
   */
  get calendarYear() {
    return this._dateNavigationService.displayedCalendar.year;
  }
  /**
   * Focuses on the current calendar year when the View is initialized.
   */
  ngAfterViewInit() {
    this._datepickerFocusService.focusCell(this._elRef);
  }
  /**
   * Handles the Keyboard arrow navigation for the yearpicker.
   */
  onKeyDown(event) {
    if (event) {
      const key = normalizeKey(event.key);
      if (key === Keys.ArrowUp) {
        event.preventDefault();
        this.incrementFocusYearBy(-1);
      } else if (key === Keys.ArrowDown) {
        event.preventDefault();
        this.incrementFocusYearBy(1);
      } else if (key === Keys.ArrowRight) {
        event.preventDefault();
        this.incrementFocusYearBy(5);
      } else if (key === Keys.ArrowLeft) {
        event.preventDefault();
        this.incrementFocusYearBy(-5);
      }
    }
  }
  /**
   * Calls the DateNavigationService to update the year value of the calendar.
   * Also changes the view to the daypicker.
   */
  changeYear(year) {
    this._dateNavigationService.changeYear(year);
    this._viewManagerService.changeToDayView();
  }
  /**
   * Updates the YearRangeModel to the previous decade.
   */
  previousDecade() {
    this.yearRangeModel = this.yearRangeModel.previousDecade();
  }
  /**
   * Updates the YearRangeModel to the current decade.
   */
  currentDecade() {
    if (!this.yearRangeModel.inRange(this._dateNavigationService.today.year)) {
      this.yearRangeModel = this.yearRangeModel.currentDecade();
    }
    this._datepickerFocusService.focusCell(this._elRef);
  }
  /**
   * Updates the YearRangeModel to the next decade.
   */
  nextDecade() {
    this.yearRangeModel = this.yearRangeModel.nextDecade();
  }
  /**
   * Compares the year passed to the focused year and returns the tab index.
   */
  getTabIndex(year) {
    if (!this.yearRangeModel.inRange(this._focusedYear)) {
      if (this.yearRangeModel.inRange(this.calendarYear)) {
        this._focusedYear = this.calendarYear;
      } else {
        this._focusedYear = this.yearRangeModel.middleYear;
      }
    }
    return this._focusedYear === year ? 0 : -1;
  }
  /**
   * Increments the focus year by the value passed. Updates the YearRangeModel if the
   * new value is not in the current decade.
   */
  incrementFocusYearBy(value) {
    this._focusedYear = this._focusedYear + value;
    if (!this.yearRangeModel.inRange(this._focusedYear)) {
      if (value > 0) {
        this.yearRangeModel = this.yearRangeModel.nextDecade();
      } else {
        this.yearRangeModel = this.yearRangeModel.previousDecade();
      }
    }
    this._datepickerFocusService.focusCell(this._elRef);
  }
};
ClrYearpicker.ɵfac = function ClrYearpicker_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrYearpicker)(ɵɵdirectiveInject(DateNavigationService), ɵɵdirectiveInject(ViewManagerService), ɵɵdirectiveInject(DatepickerFocusService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ClrCommonStringsService));
};
ClrYearpicker.ɵcmp = ɵɵdefineComponent({
  type: ClrYearpicker,
  selectors: [["clr-yearpicker"]],
  hostAttrs: ["role", "application"],
  hostVars: 2,
  hostBindings: function ClrYearpicker_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("keydown", function ClrYearpicker_keydown_HostBindingHandler($event) {
        return ctx.onKeyDown($event);
      });
    }
    if (rf & 2) {
      ɵɵclassProp("yearpicker", true);
    }
  },
  standalone: false,
  decls: 9,
  vars: 7,
  consts: [[1, "year-switchers"], ["type", "button", 1, "calendar-btn", "switcher", 3, "click"], ["shape", "angle", "direction", "left"], ["shape", "event"], ["shape", "angle", "direction", "right"], [1, "years"], ["type", "button", "class", "calendar-btn year", 3, "is-selected", "click", 4, "ngFor", "ngForOf"], ["type", "button", 1, "calendar-btn", "year", 3, "click"]],
  template: function ClrYearpicker_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0)(1, "button", 1);
      ɵɵlistener("click", function ClrYearpicker_Template_button_click_1_listener() {
        return ctx.previousDecade();
      });
      ɵɵelement(2, "cds-icon", 2);
      ɵɵelementEnd();
      ɵɵelementStart(3, "button", 1);
      ɵɵlistener("click", function ClrYearpicker_Template_button_click_3_listener() {
        return ctx.currentDecade();
      });
      ɵɵelement(4, "cds-icon", 3);
      ɵɵelementEnd();
      ɵɵelementStart(5, "button", 1);
      ɵɵlistener("click", function ClrYearpicker_Template_button_click_5_listener() {
        return ctx.nextDecade();
      });
      ɵɵelement(6, "cds-icon", 4);
      ɵɵelementEnd()();
      ɵɵelementStart(7, "div", 5);
      ɵɵtemplate(8, ClrYearpicker_button_8_Template, 2, 4, "button", 6);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵattribute("aria-label", ctx.commonStrings.keys.datepickerPreviousDecade);
      ɵɵadvance();
      ɵɵattribute("title", ctx.commonStrings.keys.datepickerPreviousDecade);
      ɵɵadvance();
      ɵɵattribute("aria-label", ctx.commonStrings.keys.datepickerCurrentDecade);
      ɵɵadvance();
      ɵɵattribute("title", ctx.commonStrings.keys.datepickerCurrentDecade);
      ɵɵadvance();
      ɵɵattribute("aria-label", ctx.commonStrings.keys.datepickerNextDecade);
      ɵɵadvance();
      ɵɵattribute("title", ctx.commonStrings.keys.datepickerNextDecade);
      ɵɵadvance(2);
      ɵɵproperty("ngForOf", ctx.yearRangeModel.yearRange);
    }
  },
  dependencies: [NgForOf, CdsIconCustomTag],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrYearpicker, [{
    type: Component,
    args: [{
      selector: "clr-yearpicker",
      template: `
    <div class="year-switchers">
      <button
        class="calendar-btn switcher"
        type="button"
        (click)="previousDecade()"
        [attr.aria-label]="commonStrings.keys.datepickerPreviousDecade"
      >
        <cds-icon shape="angle" direction="left" [attr.title]="commonStrings.keys.datepickerPreviousDecade"></cds-icon>
      </button>
      <button
        class="calendar-btn switcher"
        type="button"
        (click)="currentDecade()"
        [attr.aria-label]="commonStrings.keys.datepickerCurrentDecade"
      >
        <cds-icon shape="event" [attr.title]="commonStrings.keys.datepickerCurrentDecade"></cds-icon>
      </button>
      <button
        class="calendar-btn switcher"
        type="button"
        (click)="nextDecade()"
        [attr.aria-label]="commonStrings.keys.datepickerNextDecade"
      >
        <cds-icon shape="angle" direction="right" [attr.title]="commonStrings.keys.datepickerNextDecade"></cds-icon>
      </button>
    </div>
    <div class="years">
      <button
        *ngFor="let year of yearRangeModel.yearRange"
        type="button"
        class="calendar-btn year"
        [attr.tabindex]="getTabIndex(year)"
        [class.is-selected]="year === calendarYear"
        (click)="changeYear(year)"
      >
        {{ year }}
      </button>
    </div>
  `,
      host: {
        "[class.yearpicker]": "true",
        role: "application"
      }
    }]
  }], function() {
    return [{
      type: DateNavigationService
    }, {
      type: ViewManagerService
    }, {
      type: DatepickerFocusService
    }, {
      type: ElementRef
    }, {
      type: ClrCommonStringsService
    }];
  }, {
    onKeyDown: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }]
  });
})();
var ClrDaypicker = class {
  constructor(_viewManagerService, _dateNavigationService, _localeHelperService, commonStrings) {
    this._viewManagerService = _viewManagerService;
    this._dateNavigationService = _dateNavigationService;
    this._localeHelperService = _localeHelperService;
    this.commonStrings = commonStrings;
  }
  get monthAttrString() {
    return this.commonStrings.parse(this.commonStrings.keys.datepickerSelectMonthText, {
      CALENDAR_MONTH: this.calendarMonth
    });
  }
  get yearAttrString() {
    return this.commonStrings.parse(this.commonStrings.keys.datepickerSelectYearText, {
      CALENDAR_YEAR: this.calendarYear.toString()
    });
  }
  /**
   * Returns the month value of the calendar in the TranslationWidth.Abbreviated format.
   */
  get calendarMonth() {
    return this._localeHelperService.localeMonthsAbbreviated[this._dateNavigationService.displayedCalendar.month];
  }
  /**
   * Returns the year value of the calendar.
   */
  get calendarYear() {
    return this._dateNavigationService.displayedCalendar.year;
  }
  /**
   * Calls the ViewManagerService to change to the monthpicker view.
   */
  changeToMonthView() {
    this._viewManagerService.changeToMonthView();
  }
  /**
   * Calls the ViewManagerService to change to the yearpicker view.
   */
  changeToYearView() {
    this._viewManagerService.changeToYearView();
  }
  /**
   * Calls the DateNavigationService to move to the next month.
   */
  nextMonth() {
    this._dateNavigationService.moveToNextMonth();
  }
  /**
   * Calls the DateNavigationService to move to the previous month.
   */
  previousMonth() {
    this._dateNavigationService.moveToPreviousMonth();
  }
  /**
   * Calls the DateNavigationService to move to the current month.
   */
  currentMonth() {
    this._dateNavigationService.moveToCurrentMonth();
  }
};
ClrDaypicker.ɵfac = function ClrDaypicker_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDaypicker)(ɵɵdirectiveInject(ViewManagerService), ɵɵdirectiveInject(DateNavigationService), ɵɵdirectiveInject(LocaleHelperService), ɵɵdirectiveInject(ClrCommonStringsService));
};
ClrDaypicker.ɵcmp = ɵɵdefineComponent({
  type: ClrDaypicker,
  selectors: [["clr-daypicker"]],
  hostAttrs: ["role", "application"],
  hostVars: 2,
  hostBindings: function ClrDaypicker_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("daypicker", true);
    }
  },
  standalone: false,
  decls: 18,
  vars: 14,
  consts: [[1, "clr-sr-only"], [1, "calendar-header"], [1, "calendar-pickers"], ["type", "button", 1, "calendar-btn", "monthpicker-trigger", 3, "click"], ["type", "button", 1, "calendar-btn", "yearpicker-trigger", 3, "click"], [1, "calendar-switchers"], ["type", "button", 1, "calendar-btn", "switcher", 3, "click"], ["shape", "angle", "direction", "left"], ["shape", "event"], ["shape", "angle", "direction", "right"]],
  template: function ClrDaypicker_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtext(1);
      ɵɵelementEnd();
      ɵɵelementStart(2, "div", 1)(3, "div", 2)(4, "button", 3);
      ɵɵlistener("click", function ClrDaypicker_Template_button_click_4_listener() {
        return ctx.changeToMonthView();
      });
      ɵɵtext(5);
      ɵɵelementEnd();
      ɵɵelementStart(6, "button", 4);
      ɵɵlistener("click", function ClrDaypicker_Template_button_click_6_listener() {
        return ctx.changeToYearView();
      });
      ɵɵtext(7);
      ɵɵelementEnd()();
      ɵɵelementStart(8, "div", 5)(9, "button", 6);
      ɵɵlistener("click", function ClrDaypicker_Template_button_click_9_listener() {
        return ctx.previousMonth();
      });
      ɵɵelement(10, "cds-icon", 7);
      ɵɵelementEnd();
      ɵɵelementStart(11, "button", 6);
      ɵɵlistener("click", function ClrDaypicker_Template_button_click_11_listener() {
        return ctx.currentMonth();
      });
      ɵɵelement(12, "cds-icon", 8);
      ɵɵelementEnd();
      ɵɵelementStart(13, "button", 6);
      ɵɵlistener("click", function ClrDaypicker_Template_button_click_13_listener() {
        return ctx.nextMonth();
      });
      ɵɵelement(14, "cds-icon", 9);
      ɵɵelementEnd()()();
      ɵɵelement(15, "clr-calendar");
      ɵɵelementStart(16, "div", 0);
      ɵɵtext(17);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵtextInterpolate(ctx.commonStrings.keys.modalContentStart);
      ɵɵadvance(3);
      ɵɵattribute("aria-label", ctx.monthAttrString)("title", ctx.monthAttrString);
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", ctx.calendarMonth, " ");
      ɵɵadvance();
      ɵɵattribute("aria-label", ctx.yearAttrString)("title", ctx.yearAttrString);
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", ctx.calendarYear, " ");
      ɵɵadvance(2);
      ɵɵattribute("aria-label", ctx.commonStrings.keys.datepickerPreviousMonth);
      ɵɵadvance();
      ɵɵattribute("title", ctx.commonStrings.keys.datepickerPreviousMonth);
      ɵɵadvance();
      ɵɵattribute("aria-label", ctx.commonStrings.keys.datepickerCurrentMonth);
      ɵɵadvance();
      ɵɵattribute("title", ctx.commonStrings.keys.datepickerCurrentMonth);
      ɵɵadvance();
      ɵɵattribute("aria-label", ctx.commonStrings.keys.datepickerNextMonth);
      ɵɵadvance();
      ɵɵattribute("title", ctx.commonStrings.keys.datepickerNextMonth);
      ɵɵadvance(3);
      ɵɵtextInterpolate(ctx.commonStrings.keys.modalContentEnd);
    }
  },
  dependencies: [CdsIconCustomTag, ClrCalendar],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDaypicker, [{
    type: Component,
    args: [{
      selector: "clr-daypicker",
      host: {
        "[class.daypicker]": "true",
        role: "application"
      },
      template: '<div class="clr-sr-only">{{commonStrings.keys.modalContentStart}}</div>\n<div class="calendar-header">\n  <div class="calendar-pickers">\n    <button\n      class="calendar-btn monthpicker-trigger"\n      type="button"\n      (click)="changeToMonthView()"\n      [attr.aria-label]="monthAttrString"\n      [attr.title]="monthAttrString"\n    >\n      {{calendarMonth}}\n    </button>\n    <button\n      class="calendar-btn yearpicker-trigger"\n      type="button"\n      (click)="changeToYearView()"\n      [attr.aria-label]="yearAttrString"\n      [attr.title]="yearAttrString"\n    >\n      {{calendarYear}}\n    </button>\n  </div>\n  <div class="calendar-switchers">\n    <button\n      class="calendar-btn switcher"\n      type="button"\n      (click)="previousMonth()"\n      [attr.aria-label]="commonStrings.keys.datepickerPreviousMonth"\n    >\n      <cds-icon shape="angle" direction="left" [attr.title]="commonStrings.keys.datepickerPreviousMonth"></cds-icon>\n    </button>\n    <button\n      class="calendar-btn switcher"\n      type="button"\n      (click)="currentMonth()"\n      [attr.aria-label]="commonStrings.keys.datepickerCurrentMonth"\n    >\n      <cds-icon shape="event" [attr.title]="commonStrings.keys.datepickerCurrentMonth"></cds-icon>\n    </button>\n    <button\n      class="calendar-btn switcher"\n      type="button"\n      (click)="nextMonth()"\n      [attr.aria-label]="commonStrings.keys.datepickerNextMonth"\n    >\n      <cds-icon shape="angle" direction="right" [attr.title]="commonStrings.keys.datepickerNextMonth"></cds-icon>\n    </button>\n  </div>\n</div>\n<clr-calendar></clr-calendar>\n<div class="clr-sr-only">{{commonStrings.keys.modalContentEnd}}</div>\n'
    }]
  }], function() {
    return [{
      type: ViewManagerService
    }, {
      type: DateNavigationService
    }, {
      type: LocaleHelperService
    }, {
      type: ClrCommonStringsService
    }];
  }, null);
})();
var ClrDatepickerActions = class {
  constructor(commonStrings, toggleService, dateNavigationService, dateFormControlService) {
    this.commonStrings = commonStrings;
    this.toggleService = toggleService;
    this.dateNavigationService = dateNavigationService;
    this.dateFormControlService = dateFormControlService;
  }
  apply() {
    if (this.dateNavigationService.selectedDay) {
      this.dateNavigationService.notifySelectedDayChanged(this.dateNavigationService.selectedDay);
      this.dateFormControlService.markAsDirty();
    }
    this.toggleService.open = false;
  }
  cancel() {
    this.dateNavigationService.resetSelectedDay();
    this.toggleService.open = false;
  }
};
ClrDatepickerActions.ɵfac = function ClrDatepickerActions_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDatepickerActions)(ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(ClrPopoverToggleService), ɵɵdirectiveInject(DateNavigationService), ɵɵdirectiveInject(DateFormControlService));
};
ClrDatepickerActions.ɵcmp = ɵɵdefineComponent({
  type: ClrDatepickerActions,
  selectors: [["clr-datepicker-actions"]],
  hostVars: 2,
  hostBindings: function ClrDatepickerActions_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("datepicker-actions", true);
    }
  },
  standalone: false,
  decls: 4,
  vars: 2,
  consts: [[1, "btn", "btn-outline", 3, "click"], [1, "btn", "btn-primary", 3, "click"]],
  template: function ClrDatepickerActions_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "button", 0);
      ɵɵlistener("click", function ClrDatepickerActions_Template_button_click_0_listener() {
        return ctx.cancel();
      });
      ɵɵtext(1);
      ɵɵelementEnd();
      ɵɵelementStart(2, "button", 1);
      ɵɵlistener("click", function ClrDatepickerActions_Template_button_click_2_listener() {
        return ctx.apply();
      });
      ɵɵtext(3);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵtextInterpolate(ctx.commonStrings.keys.cancel);
      ɵɵadvance(2);
      ɵɵtextInterpolate(ctx.commonStrings.keys.apply);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatepickerActions, [{
    type: Component,
    args: [{
      selector: "clr-datepicker-actions",
      template: `
    <button class="btn btn-outline" (click)="cancel()">{{ commonStrings.keys.cancel }}</button>
    <button class="btn btn-primary" (click)="apply()">{{ commonStrings.keys.apply }}</button>
  `,
      host: {
        "[class.datepicker-actions]": "true"
      }
    }]
  }], function() {
    return [{
      type: ClrCommonStringsService
    }, {
      type: ClrPopoverToggleService
    }, {
      type: DateNavigationService
    }, {
      type: DateFormControlService
    }];
  }, null);
})();
var ClrDatepickerViewManager = class {
  constructor(commonStrings, viewManagerService, dateNavigationService) {
    this.commonStrings = commonStrings;
    this.viewManagerService = viewManagerService;
    this.dateNavigationService = dateNavigationService;
  }
  /**
   * Returns if the current view is the monthpicker.
   */
  get isMonthView() {
    return this.viewManagerService.isMonthView;
  }
  /**
   * Returns if the current view is the yearpicker.
   */
  get isYearView() {
    return this.viewManagerService.isYearView;
  }
  /**
   * Returns if the current view is the daypicker.
   */
  get isDayView() {
    return this.viewManagerService.isDayView;
  }
  get hasActionButtons() {
    return this.dateNavigationService.hasActionButtons;
  }
};
ClrDatepickerViewManager.ɵfac = function ClrDatepickerViewManager_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDatepickerViewManager)(ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(ViewManagerService), ɵɵdirectiveInject(DateNavigationService));
};
ClrDatepickerViewManager.ɵcmp = ɵɵdefineComponent({
  type: ClrDatepickerViewManager,
  selectors: [["clr-datepicker-view-manager"]],
  hostAttrs: ["role", "dialog"],
  hostVars: 6,
  hostBindings: function ClrDatepickerViewManager_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("aria-modal", true)("aria-label", ctx.commonStrings.keys.datepickerDialogLabel);
      ɵɵclassProp("datepicker", true)("has-action-buttons", ctx.hasActionButtons);
    }
  },
  standalone: false,
  features: [ɵɵProvidersFeature([DatepickerFocusService])],
  decls: 4,
  vars: 4,
  consts: [[4, "ngIf"]],
  template: function ClrDatepickerViewManager_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, ClrDatepickerViewManager_clr_monthpicker_0_Template, 1, 0, "clr-monthpicker", 0)(1, ClrDatepickerViewManager_clr_yearpicker_1_Template, 1, 0, "clr-yearpicker", 0)(2, ClrDatepickerViewManager_clr_daypicker_2_Template, 1, 0, "clr-daypicker", 0)(3, ClrDatepickerViewManager_clr_datepicker_actions_3_Template, 1, 0, "clr-datepicker-actions", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.isMonthView);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.isYearView);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.isDayView);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.hasActionButtons);
    }
  },
  dependencies: [NgIf, ClrMonthpicker, ClrYearpicker, ClrDaypicker, ClrDatepickerActions],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatepickerViewManager, [{
    type: Component,
    args: [{
      selector: "clr-datepicker-view-manager",
      providers: [DatepickerFocusService],
      host: {
        "[class.datepicker]": "true",
        "[class.has-action-buttons]": "hasActionButtons",
        "[attr.aria-modal]": "true",
        "[attr.aria-label]": "commonStrings.keys.datepickerDialogLabel",
        role: "dialog"
      },
      template: '<!--\n  ~ Copyright (c) 2016-2024 Broadcom. All Rights Reserved.\n  ~ The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n-->\n\n<clr-monthpicker *ngIf="isMonthView"></clr-monthpicker>\n<clr-yearpicker *ngIf="isYearView"></clr-yearpicker>\n<clr-daypicker *ngIf="isDayView"></clr-daypicker>\n<clr-datepicker-actions *ngIf="hasActionButtons"></clr-datepicker-actions>\n'
    }]
  }], function() {
    return [{
      type: ClrCommonStringsService
    }, {
      type: ViewManagerService
    }, {
      type: DateNavigationService
    }];
  }, null);
})();
var ClrDateContainer = class extends ClrAbstractContainer {
  constructor(renderer, toggleService, dateNavigationService, datepickerEnabledService, dateFormControlService, dateIOService, commonStrings, focusService, viewManagerService, controlClassService, layoutService, ngControlService, ifControlStateService) {
    super(ifControlStateService, layoutService, controlClassService, ngControlService);
    this.renderer = renderer;
    this.toggleService = toggleService;
    this.dateNavigationService = dateNavigationService;
    this.datepickerEnabledService = datepickerEnabledService;
    this.dateFormControlService = dateFormControlService;
    this.dateIOService = dateIOService;
    this.commonStrings = commonStrings;
    this.viewManagerService = viewManagerService;
    this.controlClassService = controlClassService;
    this.layoutService = layoutService;
    this.ngControlService = ngControlService;
    this.ifControlStateService = ifControlStateService;
    this.focus = false;
    this.subscriptions.push(focusService.focusChange.subscribe((state2) => {
      this.focus = state2;
    }));
    this.subscriptions.push(toggleService.openChange.subscribe(() => {
      dateFormControlService.markAsTouched();
    }));
  }
  set showActionButtons(flag) {
    this.dateNavigationService.hasActionButtons = flag;
  }
  set clrPosition(position) {
    if (position && ClrPopoverPositions[position]) {
      this.viewManagerService.position = ClrPopoverPositions[position];
    }
  }
  set actionButton(button) {
    this.toggleButton = button;
  }
  get popoverPosition() {
    return this.viewManagerService.position;
  }
  get open() {
    return this.toggleService.open;
  }
  /**
   * Returns if the Datepicker is enabled or not. If disabled, hides the datepicker trigger.
   */
  get isEnabled() {
    return this.datepickerEnabledService.isEnabled;
  }
  /**
   * Return if Datepicker is diabled or not as Form Control
   */
  get isInputDateDisabled() {
    return this.control && this.control.disabled || this.dateFormControlService && this.dateFormControlService.disabled;
  }
  ngAfterViewInit() {
    this.subscriptions.push(this.toggleService.openChange.subscribe((open) => {
      if (open) {
        this.initializeCalendar();
      } else {
        this.toggleButton.nativeElement.focus();
        this.dateNavigationService.resetSelectedDay();
      }
    }));
    this.subscriptions.push(this.listenForDateChanges());
  }
  /**
   * Return the label for the toggle button.
   * If there's a selected date, the date is included in the label.
   */
  getToggleButtonLabel(day) {
    if (day) {
      const formattedDate = this.dateIOService.toLocaleDisplayFormatString(day.toDate());
      return this.commonStrings.parse(this.commonStrings.keys.datepickerToggleChangeDateLabel, {
        SELECTED_DATE: formattedDate
      });
    }
    return this.commonStrings.keys.datepickerToggleChooseDateLabel;
  }
  listenForDateChanges() {
    return this.dateNavigationService.selectedDayChange.pipe(startWith(this.dateNavigationService.selectedDay)).subscribe((day) => {
      if (this.isEnabled) {
        const label = this.getToggleButtonLabel(day);
        const toggleEl = this.toggleButton.nativeElement;
        this.renderer.setAttribute(toggleEl, "aria-label", label);
        this.renderer.setAttribute(toggleEl, "title", label);
      }
    });
  }
  /**
   * Processes the user input and Initializes the Calendar everytime the datepicker popover is open.
   */
  initializeCalendar() {
    this.dateNavigationService.initializeCalendar();
  }
};
ClrDateContainer.ɵfac = function ClrDateContainer_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDateContainer)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ClrPopoverToggleService), ɵɵdirectiveInject(DateNavigationService), ɵɵdirectiveInject(DatepickerEnabledService), ɵɵdirectiveInject(DateFormControlService), ɵɵdirectiveInject(DateIOService), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(FocusService2), ɵɵdirectiveInject(ViewManagerService), ɵɵdirectiveInject(ControlClassService), ɵɵdirectiveInject(LayoutService, 8), ɵɵdirectiveInject(NgControlService), ɵɵdirectiveInject(IfControlStateService));
};
ClrDateContainer.ɵcmp = ɵɵdefineComponent({
  type: ClrDateContainer,
  selectors: [["clr-date-container"]],
  viewQuery: function ClrDateContainer_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c31, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.actionButton = _t.first);
    }
  },
  hostVars: 8,
  hostBindings: function ClrDateContainer_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-date-container", true)("clr-form-control-disabled", ctx.isInputDateDisabled)("clr-form-control", true)("clr-row", ctx.addGrid());
    }
  },
  inputs: {
    showActionButtons: "showActionButtons",
    clrPosition: "clrPosition"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([ControlIdService, LocaleHelperService, ControlClassService, FocusService2, NgControlService, DateIOService, DateNavigationService, DatepickerEnabledService, DateFormControlService, ViewManagerService, IfControlStateService]), ɵɵHostDirectivesFeature([ClrPopoverHostDirective]), ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c33,
  decls: 13,
  vars: 14,
  consts: [["actionButton", ""], [4, "ngIf"], [1, "clr-control-container", 3, "ngClass"], ["clrPopoverAnchor", "", 1, "clr-input-wrapper"], [1, "clr-input-group"], ["type", "button", "clrPopoverOpenCloseButton", "", "class", "clr-input-group-icon-action", 3, "disabled", 4, "ngIf"], ["cdkTrapFocus", "", 4, "clrPopoverContent", "clrPopoverContentAt", "clrPopoverContentOutsideClickToClose", "clrPopoverContentScrollToClose"], ["class", "clr-validate-icon", "shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 4, "ngIf"], ["class", "clr-validate-icon", "shape", "check-circle", "status", "success", "aria-hidden", "true", 4, "ngIf"], ["type", "button", "clrPopoverOpenCloseButton", "", 1, "clr-input-group-icon-action", 3, "disabled"], ["status", "info", "shape", "calendar"], ["cdkTrapFocus", ""], ["shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 1, "clr-validate-icon"], ["shape", "check-circle", "status", "success", "aria-hidden", "true", 1, "clr-validate-icon"]],
  template: function ClrDateContainer_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c32);
      ɵɵprojection(0);
      ɵɵtemplate(1, ClrDateContainer_label_1_Template, 1, 0, "label", 1);
      ɵɵelementStart(2, "div", 2)(3, "div", 3)(4, "div", 4);
      ɵɵprojection(5, 1);
      ɵɵtemplate(6, ClrDateContainer_button_6_Template, 3, 1, "button", 5)(7, ClrDateContainer_clr_datepicker_view_manager_7_Template, 1, 0, "clr-datepicker-view-manager", 6);
      ɵɵelementEnd();
      ɵɵtemplate(8, ClrDateContainer_cds_icon_8_Template, 1, 0, "cds-icon", 7)(9, ClrDateContainer_cds_icon_9_Template, 1, 0, "cds-icon", 8);
      ɵɵelementEnd();
      ɵɵtemplate(10, ClrDateContainer_ng_content_10_Template, 1, 0, "ng-content", 1)(11, ClrDateContainer_ng_content_11_Template, 1, 0, "ng-content", 1)(12, ClrDateContainer_ng_content_12_Template, 1, 0, "ng-content", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.label && ctx.addGrid());
      ɵɵadvance();
      ɵɵproperty("ngClass", ctx.controlClass());
      ɵɵadvance(2);
      ɵɵclassProp("clr-focus", ctx.focus);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.isEnabled);
      ɵɵadvance();
      ɵɵproperty("clrPopoverContent", ctx.open)("clrPopoverContentAt", ctx.popoverPosition)("clrPopoverContentOutsideClickToClose", true)("clrPopoverContentScrollToClose", true);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showHelper);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
    }
  },
  dependencies: [NgClass, NgIf, CdkTrapFocusModule_CdkTrapFocus, ClrPopoverAnchor, ClrPopoverOpenCloseButton, ClrPopoverContent, CdsIconCustomTag, ClrLabel, ClrDatepickerViewManager],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDateContainer, [{
    type: Component,
    args: [{
      selector: "clr-date-container",
      template: `
    <ng-content select="label"></ng-content>
    <label *ngIf="!label && addGrid()"></label>
    <div class="clr-control-container" [ngClass]="controlClass()">
      <div class="clr-input-wrapper" clrPopoverAnchor>
        <div class="clr-input-group" [class.clr-focus]="focus">
          <ng-content select="[clrDate]"></ng-content>
          <button
            #actionButton
            type="button"
            clrPopoverOpenCloseButton
            class="clr-input-group-icon-action"
            [disabled]="isInputDateDisabled"
            *ngIf="isEnabled"
          >
            <cds-icon status="info" shape="calendar"></cds-icon>
          </button>
          <clr-datepicker-view-manager
            *clrPopoverContent="open; at: popoverPosition; outsideClickToClose: true; scrollToClose: true"
            cdkTrapFocus
          ></clr-datepicker-view-manager>
        </div>
        <cds-icon
          *ngIf="showInvalid"
          class="clr-validate-icon"
          shape="exclamation-circle"
          status="danger"
          aria-hidden="true"
        ></cds-icon>
        <cds-icon
          *ngIf="showValid"
          class="clr-validate-icon"
          shape="check-circle"
          status="success"
          aria-hidden="true"
        ></cds-icon>
      </div>
      <ng-content select="clr-control-helper" *ngIf="showHelper"></ng-content>
      <ng-content select="clr-control-error" *ngIf="showInvalid"></ng-content>
      <ng-content select="clr-control-success" *ngIf="showValid"></ng-content>
    </div>
  `,
      providers: [ControlIdService, LocaleHelperService, ControlClassService, FocusService2, NgControlService, DateIOService, DateNavigationService, DatepickerEnabledService, DateFormControlService, ViewManagerService, IfControlStateService],
      hostDirectives: [ClrPopoverHostDirective],
      host: {
        "[class.clr-date-container]": "true",
        "[class.clr-form-control-disabled]": "isInputDateDisabled",
        "[class.clr-form-control]": "true",
        "[class.clr-row]": "addGrid()"
      }
    }]
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: ClrPopoverToggleService
    }, {
      type: DateNavigationService
    }, {
      type: DatepickerEnabledService
    }, {
      type: DateFormControlService
    }, {
      type: DateIOService
    }, {
      type: ClrCommonStringsService
    }, {
      type: FocusService2
    }, {
      type: ViewManagerService
    }, {
      type: ControlClassService
    }, {
      type: LayoutService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: NgControlService
    }, {
      type: IfControlStateService
    }];
  }, {
    showActionButtons: [{
      type: Input,
      args: ["showActionButtons"]
    }],
    clrPosition: [{
      type: Input,
      args: ["clrPosition"]
    }],
    actionButton: [{
      type: ViewChild,
      args: ["actionButton"]
    }]
  });
})();
var ClrDateInput = class extends WrappedFormControl {
  constructor(viewContainerRef, injector, el, renderer, control, container, dateIOService, dateNavigationService, datepickerEnabledService, dateFormControlService, platformId, focusService, datepickerFocusService) {
    super(viewContainerRef, ClrDateContainer, injector, control, renderer, el);
    this.el = el;
    this.renderer = renderer;
    this.control = control;
    this.container = container;
    this.dateIOService = dateIOService;
    this.dateNavigationService = dateNavigationService;
    this.datepickerEnabledService = datepickerEnabledService;
    this.dateFormControlService = dateFormControlService;
    this.platformId = platformId;
    this.focusService = focusService;
    this.datepickerFocusService = datepickerFocusService;
    this.dateChange = new EventEmitter(false);
    this.index = 1;
  }
  set date(date) {
    if (this.previousDateChange !== date) {
      this.updateDate(this.getValidDateValueFromDate(date));
    }
    if (!this.initialClrDateInputValue) {
      this.initialClrDateInputValue = date;
    }
  }
  set min(dateString) {
    this.dateIOService.setMinDate(dateString);
    this.triggerControlValidation();
  }
  set max(dateString) {
    this.dateIOService.setMaxDate(dateString);
    this.triggerControlValidation();
  }
  get disabled() {
    if (this.dateFormControlService) {
      return this.dateFormControlService.disabled;
    }
    return null;
  }
  set disabled(value) {
    if (this.dateFormControlService) {
      this.dateFormControlService.setDisabled(isBooleanAttributeSet(value));
    }
  }
  get placeholderText() {
    return this.placeholder ? this.placeholder : this.dateIOService.placeholderText;
  }
  get inputType() {
    return isPlatformBrowser(this.platformId) && this.usingNativeDatepicker() ? "date" : "text";
  }
  ngOnInit() {
    super.ngOnInit();
    this.populateServicesFromContainerComponent();
    this.subscriptions.push(this.listenForUserSelectedDayChanges(), this.listenForControlValueChanges(), this.listenForTouchChanges(), this.listenForDirtyChanges(), this.listenForInputRefocus());
  }
  ngAfterViewInit() {
    this.processInitialInputs();
  }
  setFocusStates() {
    this.setFocus(true);
  }
  triggerValidation() {
    super.triggerValidation();
    this.setFocus(false);
  }
  onValueChange(target) {
    const validDateValue = this.dateIOService.getDateValueFromDateString(target.value);
    if (this.usingClarityDatepicker() && validDateValue) {
      this.updateDate(validDateValue, true);
    } else if (this.usingNativeDatepicker()) {
      const [year, month, day] = target.value.split("-");
      this.updateDate(new Date(+year, +month - 1, +day), true);
    } else {
      this.emitDateOutput(null);
    }
  }
  usingClarityDatepicker() {
    return this.datepickerEnabledService.isEnabled;
  }
  usingNativeDatepicker() {
    return !this.datepickerEnabledService.isEnabled;
  }
  setFocus(focus) {
    if (this.focusService) {
      this.focusService.focused = focus;
    }
  }
  triggerControlValidation() {
    if (this.datepickerHasFormControl()) {
      this.control.control?.updateValueAndValidity({
        emitEvent: false
      });
      this.control.control?.setErrors(this.control.control.errors);
    }
  }
  populateServicesFromContainerComponent() {
    if (!this.container) {
      this.dateIOService = this.getProviderFromContainer(DateIOService);
      this.dateNavigationService = this.getProviderFromContainer(DateNavigationService);
      this.datepickerEnabledService = this.getProviderFromContainer(DatepickerEnabledService);
      this.dateFormControlService = this.getProviderFromContainer(DateFormControlService);
    }
  }
  processInitialInputs() {
    if (this.datepickerHasFormControl()) {
      this.updateDate(this.dateIOService.getDateValueFromDateString(this.control.value));
    } else {
      this.updateDate(this.initialClrDateInputValue);
    }
  }
  updateDate(value, setByUserInteraction = false) {
    const date = this.getValidDateValueFromDate(value);
    if (setByUserInteraction) {
      this.emitDateOutput(date);
    } else {
      this.previousDateChange = date;
    }
    if (this.dateNavigationService) {
      this.dateNavigationService.persistedDate = this.dateNavigationService.selectedDay = date ? new DayModel(date.getFullYear(), date.getMonth(), date.getDate()) : null;
    }
    this.updateInput(date);
  }
  updateInput(date) {
    if (date) {
      const dateString = this.dateIOService.toLocaleDisplayFormatString(date);
      if (this.usingNativeDatepicker()) {
        date.setMinutes(date.getMinutes() - date.getTimezoneOffset());
        this.renderer.setProperty(this.el.nativeElement, "valueAsDate", date);
      } else if (this.datepickerHasFormControl() && dateString !== this.control.value) {
        this.control.control.setValue(dateString);
      } else {
        this.renderer.setProperty(this.el.nativeElement, "value", dateString);
      }
    } else {
      this.renderer.setProperty(this.el.nativeElement, "value", "");
    }
  }
  getValidDateValueFromDate(date) {
    if (this.dateIOService) {
      const dateString = this.dateIOService.toLocaleDisplayFormatString(date);
      return this.dateIOService.getDateValueFromDateString(dateString);
    } else {
      return null;
    }
  }
  emitDateOutput(date) {
    if (!datesAreEqual(date, this.previousDateChange)) {
      this.dateChange.emit(date);
      this.previousDateChange = date;
    } else if (!date && this.previousDateChange) {
      this.dateChange.emit(null);
      this.previousDateChange = null;
    }
  }
  datepickerHasFormControl() {
    return !!this.control;
  }
  listenForControlValueChanges() {
    return of(this.datepickerHasFormControl()).pipe(
      filter((hasControl) => hasControl),
      switchMap(() => this.control.valueChanges),
      // only update date value if not being set by user
      filter(() => !this.datepickerFocusService.elementIsFocused(this.el.nativeElement))
    ).subscribe((value) => this.updateDate(this.dateIOService.getDateValueFromDateString(value)));
  }
  listenForUserSelectedDayChanges() {
    return this.dateNavigationService.selectedDayChange.subscribe((dayModel) => this.updateDate(dayModel.toDate(), true));
  }
  listenForTouchChanges() {
    return this.dateFormControlService.touchedChange.pipe(filter(() => this.datepickerHasFormControl())).subscribe(() => this.control.control.markAsTouched());
  }
  listenForDirtyChanges() {
    return this.dateFormControlService.dirtyChange.pipe(filter(() => this.datepickerHasFormControl())).subscribe(() => this.control.control.markAsDirty());
  }
  listenForInputRefocus() {
    return this.dateNavigationService.selectedDayChange.pipe(filter((date) => !!date)).subscribe(() => this.datepickerFocusService.focusInput(this.el.nativeElement));
  }
};
ClrDateInput.ɵfac = function ClrDateInput_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDateInput)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgControl, 10), ɵɵdirectiveInject(ClrDateContainer, 8), ɵɵdirectiveInject(DateIOService, 8), ɵɵdirectiveInject(DateNavigationService, 8), ɵɵdirectiveInject(DatepickerEnabledService, 8), ɵɵdirectiveInject(DateFormControlService, 8), ɵɵdirectiveInject(PLATFORM_ID), ɵɵdirectiveInject(FocusService2, 8), ɵɵdirectiveInject(DatepickerFocusService));
};
ClrDateInput.ɵdir = ɵɵdefineDirective({
  type: ClrDateInput,
  selectors: [["", "clrDate", ""]],
  hostVars: 5,
  hostBindings: function ClrDateInput_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("focus", function ClrDateInput_focus_HostBindingHandler() {
        return ctx.setFocusStates();
      })("blur", function ClrDateInput_blur_HostBindingHandler() {
        return ctx.triggerValidation();
      })("change", function ClrDateInput_change_HostBindingHandler($event) {
        return ctx.onValueChange($event.target);
      });
    }
    if (rf & 2) {
      ɵɵhostProperty("disabled", ctx.disabled);
      ɵɵattribute("placeholder", ctx.placeholderText)("type", ctx.inputType);
      ɵɵclassProp("clr-input", true);
    }
  },
  inputs: {
    placeholder: "placeholder",
    date: [0, "clrDate", "date"],
    min: "min",
    max: "max",
    disabled: "disabled"
  },
  outputs: {
    dateChange: "clrDateChange"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([DatepickerFocusService]), ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDateInput, [{
    type: Directive,
    args: [{
      selector: "[clrDate]",
      host: {
        "[class.clr-input]": "true"
      },
      providers: [DatepickerFocusService]
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }, {
      type: Injector
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: NgControl,
      decorators: [{
        type: Self
      }, {
        type: Optional
      }]
    }, {
      type: ClrDateContainer,
      decorators: [{
        type: Optional
      }]
    }, {
      type: DateIOService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: DateNavigationService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: DatepickerEnabledService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: DateFormControlService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }, {
      type: FocusService2,
      decorators: [{
        type: Optional
      }]
    }, {
      type: DatepickerFocusService
    }];
  }, {
    placeholder: [{
      type: Input
    }],
    dateChange: [{
      type: Output,
      args: ["clrDateChange"]
    }],
    date: [{
      type: Input,
      args: ["clrDate"]
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    disabled: [{
      type: Input,
      args: ["disabled"]
    }, {
      type: HostBinding,
      args: ["disabled"]
    }],
    placeholderText: [{
      type: HostBinding,
      args: ["attr.placeholder"]
    }],
    inputType: [{
      type: HostBinding,
      args: ["attr.type"]
    }],
    setFocusStates: [{
      type: HostListener,
      args: ["focus"]
    }],
    triggerValidation: [{
      type: HostListener,
      args: ["blur"]
    }],
    onValueChange: [{
      type: HostListener,
      args: ["change", ["$event.target"]]
    }]
  });
})();
var ClrDateInputValidator = class {
  constructor(dateIOService) {
    this.dateIOService = dateIOService;
  }
  validate(control) {
    if (this.dateIOService) {
      const value = this.dateIOService.getDateValueFromDateString(control.value);
      const minDate = this.dateIOService.disabledDates.minDate.toDate();
      const maxDate = this.dateIOService.disabledDates.maxDate.toDate();
      if (value && value < this.dateIOService.disabledDates.minDate.toDate()) {
        return {
          min: {
            min: minDate.toLocaleDateString(),
            actual: value.toLocaleDateString()
          }
        };
      } else if (value && value > this.dateIOService.disabledDates.maxDate.toDate()) {
        return {
          max: {
            max: maxDate.toLocaleDateString(),
            actual: value.toLocaleDateString()
          }
        };
      }
    }
    return null;
  }
};
ClrDateInputValidator.ɵfac = function ClrDateInputValidator_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDateInputValidator)(ɵɵdirectiveInject(DateIOService, 8));
};
ClrDateInputValidator.ɵdir = ɵɵdefineDirective({
  type: ClrDateInputValidator,
  selectors: [["", "clrDate", ""]],
  standalone: false,
  features: [ɵɵProvidersFeature([{
    provide: NG_VALIDATORS,
    useExisting: ClrDateInputValidator,
    multi: true
  }])]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDateInputValidator, [{
    type: Directive,
    args: [{
      selector: "[clrDate]",
      providers: [{
        provide: NG_VALIDATORS,
        useExisting: ClrDateInputValidator,
        multi: true
      }]
    }]
  }], function() {
    return [{
      type: DateIOService,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var CLR_DATEPICKER_DIRECTIVES = [ClrDay, ClrDateContainer, ClrDateInput, ClrDateInputValidator, ClrDatepickerViewManager, ClrMonthpicker, ClrYearpicker, ClrDaypicker, ClrCalendar, ClrDatepickerActions];
var ClrDatepickerModule = class {
  constructor() {
    r.addIcons(o4, e, o, H, C2);
  }
};
ClrDatepickerModule.ɵfac = function ClrDatepickerModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDatepickerModule)();
};
ClrDatepickerModule.ɵmod = ɵɵdefineNgModule({
  type: ClrDatepickerModule,
  declarations: [ClrDay, ClrDateContainer, ClrDateInput, ClrDateInputValidator, ClrDatepickerViewManager, ClrMonthpicker, ClrYearpicker, ClrDaypicker, ClrCalendar, ClrDatepickerActions],
  imports: [CommonModule, CdkTrapFocusModule, ClrHostWrappingModule, ClrConditionalModule, ClrPopoverModuleNext, ClrIconModule, ClrCommonFormsModule],
  exports: [ClrDay, ClrDateContainer, ClrDateInput, ClrDateInputValidator, ClrDatepickerViewManager, ClrMonthpicker, ClrYearpicker, ClrDaypicker, ClrCalendar, ClrDatepickerActions]
});
ClrDatepickerModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, CdkTrapFocusModule, ClrHostWrappingModule, ClrConditionalModule, ClrPopoverModuleNext, ClrIconModule, ClrCommonFormsModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatepickerModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, CdkTrapFocusModule, ClrHostWrappingModule, ClrConditionalModule, ClrPopoverModuleNext, ClrIconModule, ClrCommonFormsModule],
      declarations: [CLR_DATEPICKER_DIRECTIVES],
      exports: [CLR_DATEPICKER_DIRECTIVES]
    }]
  }], function() {
    return [];
  }, null);
})();
function buildFileList(files) {
  const dataTransfer = new DataTransfer();
  for (const file of files) {
    dataTransfer.items.add(file);
  }
  return dataTransfer.files;
}
function selectFiles(fileInputElement, files) {
  fileInputElement.files = files instanceof FileList ? files : buildFileList(files);
  fileInputElement.dispatchEvent(new Event("change", {
    bubbles: true,
    cancelable: true
  }));
}
function clearFiles(fileInputElement) {
  fileInputElement.value = "";
  fileInputElement.dispatchEvent(new Event("change", {
    bubbles: true,
    cancelable: true
  }));
}
var CLR_FILE_MESSAGES_TEMPLATE_CONTEXT = new InjectionToken("ClrFileMessagesTemplateContext");
var ClrFileInfo = class {
};
ClrFileInfo.ɵfac = function ClrFileInfo_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrFileInfo)();
};
ClrFileInfo.ɵcmp = ɵɵdefineComponent({
  type: ClrFileInfo,
  selectors: [["clr-file-info"]],
  hostVars: 2,
  hostBindings: function ClrFileInfo_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-subtext", true);
    }
  },
  standalone: false,
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrFileInfo_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrFileInfo, [{
    type: Component,
    args: [{
      selector: "clr-file-info",
      template: `<ng-content></ng-content>`,
      host: {
        "[class.clr-subtext]": "true"
      }
    }]
  }], null, null);
})();
var ClrFileSuccess = class {
  constructor() {
    this.context = inject(CLR_FILE_MESSAGES_TEMPLATE_CONTEXT);
  }
};
ClrFileSuccess.ɵfac = function ClrFileSuccess_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrFileSuccess)();
};
ClrFileSuccess.ɵcmp = ɵɵdefineComponent({
  type: ClrFileSuccess,
  selectors: [["clr-file-success"]],
  hostVars: 6,
  hostBindings: function ClrFileSuccess_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵstyleProp("display", ctx.context.success ? "inline-block" : "none");
      ɵɵclassProp("clr-subtext", true)("success", true);
    }
  },
  standalone: false,
  ngContentSelectors: _c02,
  decls: 1,
  vars: 1,
  consts: [[4, "ngIf"]],
  template: function ClrFileSuccess_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, ClrFileSuccess_ng_content_0_Template, 1, 0, "ng-content", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.context.success);
    }
  },
  dependencies: [NgIf],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrFileSuccess, [{
    type: Component,
    args: [{
      selector: "clr-file-success",
      // We check for success here so that consumers don't have to.
      template: `<ng-content *ngIf="context.success"></ng-content>`,
      host: {
        "[style.display]": 'context.success ? "inline-block" : "none"',
        "[class.clr-subtext]": "true",
        "[class.success]": "true"
      }
    }]
  }], null, null);
})();
var ClrFileError = class {
};
ClrFileError.ɵfac = function ClrFileError_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrFileError)();
};
ClrFileError.ɵcmp = ɵɵdefineComponent({
  type: ClrFileError,
  selectors: [["clr-file-error"]],
  hostVars: 4,
  hostBindings: function ClrFileError_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-subtext", true)("error", true);
    }
  },
  standalone: false,
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrFileError_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrFileError, [{
    type: Component,
    args: [{
      selector: "clr-file-error",
      // The host should have an `*ngIf` or `@if` that checks for the relevant error.
      template: `<ng-content></ng-content>`,
      host: {
        "[class.clr-subtext]": "true",
        "[class.error]": "true"
      }
    }]
  }], null, null);
})();
var ClrFileMessagesTemplate = class {
  constructor() {
    this.templateRef = inject(TemplateRef);
  }
  static ngTemplateContextGuard(directive, context) {
    return true;
  }
};
ClrFileMessagesTemplate.ɵfac = function ClrFileMessagesTemplate_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrFileMessagesTemplate)();
};
ClrFileMessagesTemplate.ɵdir = ɵɵdefineDirective({
  type: ClrFileMessagesTemplate,
  selectors: [["ng-template", "clr-file-messages", ""]],
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrFileMessagesTemplate, [{
    type: Directive,
    args: [{
      selector: "ng-template[clr-file-messages]"
    }]
  }], null, null);
})();
var ClrFileList = class {
  constructor() {
    this.injector = inject(Injector);
    this.commonStrings = inject(ClrCommonStringsService);
    this.ngControlService = inject(NgControlService, {
      optional: true
    });
    this.fileInputContainer = inject(ClrFileInputContainer, {
      optional: true
    });
    if (!this.ngControlService || !this.fileInputContainer) {
      throw new Error("The clr-file-list component can only be used within a clr-file-input-container.");
    }
  }
  get files() {
    if (!this.fileInputContainer.fileInput) {
      return [];
    }
    const fileInputElement = this.fileInputContainer.fileInput.elementRef.nativeElement;
    return Array.from(fileInputElement.files).sort((a, b) => a.name.localeCompare(b.name));
  }
  getClearFileLabel(filename) {
    return this.commonStrings.parse(this.commonStrings.keys.clearFile, {
      FILE: filename
    });
  }
  clearFile(fileToRemove) {
    if (!this.fileInputContainer.fileInput) {
      return;
    }
    const fileInputElement = this.fileInputContainer.fileInput.elementRef.nativeElement;
    const files = Array.from(fileInputElement.files);
    const newFiles = files.filter((file) => file !== fileToRemove);
    selectFiles(fileInputElement, newFiles);
    this.fileInputContainer.focusBrowseButton();
  }
  createFileMessagesTemplateContext(file) {
    const fileInputErrors = this.ngControlService.control.errors || {};
    const errors = {
      accept: fileInputErrors.accept?.find((error) => error.name === file.name),
      minFileSize: fileInputErrors.minFileSize?.find((error) => error.name === file.name),
      maxFileSize: fileInputErrors.maxFileSize?.find((error) => error.name === file.name)
    };
    const success = Object.values(errors).every((error) => !error);
    return {
      $implicit: file,
      success,
      errors
    };
  }
  createFileMessagesTemplateInjector(fileMessagesTemplateContext) {
    return Injector.create({
      parent: this.injector,
      providers: [{
        provide: CLR_FILE_MESSAGES_TEMPLATE_CONTEXT,
        useValue: fileMessagesTemplateContext
      }]
    });
  }
};
ClrFileList.ɵfac = function ClrFileList_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrFileList)();
};
ClrFileList.ɵcmp = ɵɵdefineComponent({
  type: ClrFileList,
  selectors: [["clr-file-list"]],
  contentQueries: function ClrFileList_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrFileMessagesTemplate, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.fileMessagesTemplate = _t.first);
    }
  },
  hostVars: 3,
  hostBindings: function ClrFileList_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", "list");
      ɵɵclassProp("clr-file-list", true);
    }
  },
  standalone: false,
  decls: 1,
  vars: 1,
  consts: [[4, "ngFor", "ngForOf"], ["role", "listitem", "class", "clr-file-list-item", 3, "ngClass", 4, "ngIf"], ["role", "listitem", 1, "clr-file-list-item", 3, "ngClass"], [1, "clr-file-label-and-status-icon"], [1, "label", "clr-file-label"], [1, "btn", "btn-sm", "btn-link-neutral", "btn-icon", "clr-file-clear-button", 3, "click"], ["shape", "times"], ["aria-hidden", "true", 1, "clr-validate-icon"], [3, "ngTemplateOutlet", "ngTemplateOutletContext", "ngTemplateOutletInjector"]],
  template: function ClrFileList_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, ClrFileList_ng_container_0_Template, 2, 1, "ng-container", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngForOf", ctx.files);
    }
  },
  dependencies: [NgClass, NgForOf, NgIf, NgTemplateOutlet, CdsIconCustomTag],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrFileList, [{
    type: Component,
    args: [{
      selector: "clr-file-list",
      template: `
    <ng-container *ngFor="let file of files">
      <div
        *ngIf="createFileMessagesTemplateContext(file); let fileMessagesTemplateContext"
        role="listitem"
        class="clr-file-list-item"
        [ngClass]="{
          'clr-error': !fileMessagesTemplateContext.success,
          'clr-success': fileMessagesTemplateContext.success
        }"
      >
        <div class="clr-file-label-and-status-icon">
          <span class="label clr-file-label">
            {{ file.name }}
            <button
              class="btn btn-sm btn-link-neutral btn-icon clr-file-clear-button"
              [attr.aria-label]="getClearFileLabel(file.name)"
              (click)="clearFile(file)"
            >
              <cds-icon shape="times"></cds-icon>
            </button>
          </span>

          <cds-icon
            class="clr-validate-icon"
            [attr.shape]="fileMessagesTemplateContext.success ? 'check-circle' : 'exclamation-circle'"
            [attr.status]="fileMessagesTemplateContext.success ? 'success' : 'danger'"
            aria-hidden="true"
          ></cds-icon>
        </div>

        <ng-container
          [ngTemplateOutlet]="fileMessagesTemplate.templateRef"
          [ngTemplateOutletContext]="fileMessagesTemplateContext"
          [ngTemplateOutletInjector]="createFileMessagesTemplateInjector(fileMessagesTemplateContext)"
        ></ng-container>
      </div>
    </ng-container>
  `,
      host: {
        "[attr.role]": '"list"',
        "[class.clr-file-list]": "true"
      }
    }]
  }], function() {
    return [];
  }, {
    fileMessagesTemplate: [{
      type: ContentChild,
      args: [ClrFileMessagesTemplate]
    }]
  });
})();
var ClrFileInputContainer = class extends ClrAbstractContainer {
  constructor() {
    super(...arguments);
    this.commonStrings = inject(ClrCommonStringsService);
  }
  get accept() {
    return this.fileInput.elementRef.nativeElement.accept;
  }
  get multiple() {
    return this.fileInput.elementRef.nativeElement.multiple;
  }
  get disabled() {
    return this.fileInput.elementRef.nativeElement.disabled;
  }
  get browseButtonText() {
    const selectionButtonLabel = this.fileList ? void 0 : this.fileInput?.selection?.buttonLabel;
    return selectionButtonLabel || this.customButtonLabel || this.commonStrings.keys.browse;
  }
  get browseButtonDescribedBy() {
    return `${this.label?.forAttr} ${this.fileInput.elementRef.nativeElement.getAttribute("aria-describedby")}`;
  }
  get successMessagePresent() {
    return super.successMessagePresent || !!this.fileSuccessComponent;
  }
  get errorMessagePresent() {
    return super.errorMessagePresent || !!this.fileErrorComponent;
  }
  focusBrowseButton() {
    this.browseButtonElementRef.nativeElement.focus();
  }
  browse() {
    const fileInputElementRef = this.fileList && this.multiple ? this.fileListFileInputElementRef : this.fileInput.elementRef;
    fileInputElementRef.nativeElement.click();
  }
  clearSelectedFiles() {
    this.fileInput.elementRef.nativeElement.value = "";
    this.fileInput.elementRef.nativeElement.dispatchEvent(new Event("change", {
      bubbles: true,
      cancelable: true
    }));
    this.focusBrowseButton();
  }
  addFilesToSelection(newFiles) {
    if (!newFiles.length) {
      return;
    }
    const mergedFiles = [...newFiles];
    for (const existingFile of this.fileInput.elementRef.nativeElement.files) {
      if (!mergedFiles.some((file) => file.name === existingFile.name)) {
        mergedFiles.push(existingFile);
      }
    }
    selectFiles(this.fileInput.elementRef.nativeElement, mergedFiles);
  }
};
ClrFileInputContainer.ɵfac = /* @__PURE__ */ (() => {
  let ɵClrFileInputContainer_BaseFactory;
  return function ClrFileInputContainer_Factory(__ngFactoryType__) {
    return (ɵClrFileInputContainer_BaseFactory || (ɵClrFileInputContainer_BaseFactory = ɵɵgetInheritedFactory(ClrFileInputContainer)))(__ngFactoryType__ || ClrFileInputContainer);
  };
})();
ClrFileInputContainer.ɵcmp = ɵɵdefineComponent({
  type: ClrFileInputContainer,
  selectors: [["clr-file-input-container"]],
  contentQueries: function ClrFileInputContainer_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrFileInput, 5);
      ɵɵcontentQuery(dirIndex, ClrFileList, 5);
      ɵɵcontentQuery(dirIndex, ClrFileSuccess, 5);
      ɵɵcontentQuery(dirIndex, ClrFileError, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.fileInput = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.fileList = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.fileSuccessComponent = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.fileErrorComponent = _t.first);
    }
  },
  viewQuery: function ClrFileInputContainer_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c35, 5);
      ɵɵviewQuery(_c36, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.browseButtonElementRef = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.fileListFileInputElementRef = _t.first);
    }
  },
  hostVars: 6,
  hostBindings: function ClrFileInputContainer_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-form-control", true)("clr-form-control-disabled", ctx.disabled)("clr-row", ctx.addGrid());
    }
  },
  inputs: {
    customButtonLabel: [0, "clrButtonLabel", "customButtonLabel"]
  },
  standalone: false,
  features: [ɵɵProvidersFeature([IfControlStateService, NgControlService, ControlIdService, ControlClassService]), ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c38,
  decls: 20,
  vars: 12,
  consts: [["browseButton", ""], ["fileListFileInput", ""], [4, "ngIf"], [1, "clr-control-container", 3, "ngClass"], [1, "clr-file-input-wrapper"], ["type", "file", "class", "clr-file-input", "tabindex", "-1", "aria-hidden", "true", 3, "accept", "multiple", "disabled", "change", 4, "ngIf"], ["type", "button", 1, "btn", "btn-sm", "clr-file-input-browse-button", 3, "click", "disabled"], ["shape", "folder-open"], [1, "clr-file-input-browse-button-text"], ["type", "button", "class", "btn btn-sm clr-file-input-clear-button", 3, "click", 4, "ngIf"], ["class", "clr-validate-icon", "shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 4, "ngIf"], ["class", "clr-validate-icon", "shape", "check-circle", "status", "success", "aria-hidden", "true", 4, "ngIf"], [1, "clr-file-list-break"], ["type", "file", "tabindex", "-1", "aria-hidden", "true", 1, "clr-file-input", 3, "change", "accept", "multiple", "disabled"], ["type", "button", 1, "btn", "btn-sm", "clr-file-input-clear-button", 3, "click"], ["shape", "times", "status", "neutral", "size", "md"], ["shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 1, "clr-validate-icon"], ["shape", "check-circle", "status", "success", "aria-hidden", "true", 1, "clr-validate-icon"]],
  template: function ClrFileInputContainer_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵprojectionDef(_c37);
      ɵɵprojection(0);
      ɵɵtemplate(1, ClrFileInputContainer_label_1_Template, 1, 0, "label", 2);
      ɵɵelementStart(2, "div", 3)(3, "div", 4);
      ɵɵprojection(4, 1);
      ɵɵtemplate(5, ClrFileInputContainer_input_5_Template, 2, 3, "input", 5);
      ɵɵelementStart(6, "button", 6, 0);
      ɵɵlistener("click", function ClrFileInputContainer_Template_button_click_6_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.browse());
      });
      ɵɵelement(8, "cds-icon", 7);
      ɵɵelementStart(9, "span", 8);
      ɵɵtext(10);
      ɵɵelementEnd()();
      ɵɵtemplate(11, ClrFileInputContainer_button_11_Template, 2, 1, "button", 9)(12, ClrFileInputContainer_cds_icon_12_Template, 1, 0, "cds-icon", 10)(13, ClrFileInputContainer_cds_icon_13_Template, 1, 0, "cds-icon", 11);
      ɵɵelementEnd();
      ɵɵtemplate(14, ClrFileInputContainer_ng_content_14_Template, 1, 0, "ng-content", 2)(15, ClrFileInputContainer_ng_content_15_Template, 1, 0, "ng-content", 2)(16, ClrFileInputContainer_ng_content_16_Template, 1, 0, "ng-content", 2);
      ɵɵelementContainerStart(17);
      ɵɵelement(18, "div", 12);
      ɵɵprojection(19, 2);
      ɵɵelementContainerEnd();
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.label && ctx.addGrid());
      ɵɵadvance();
      ɵɵproperty("ngClass", ctx.controlClass());
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.fileList);
      ɵɵadvance();
      ɵɵproperty("disabled", ctx.disabled);
      ɵɵattribute("aria-describedby", ctx.browseButtonDescribedBy);
      ɵɵadvance(4);
      ɵɵtextInterpolate(ctx.browseButtonText);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.fileList && (ctx.fileInput == null ? null : ctx.fileInput.selection == null ? null : ctx.fileInput.selection.fileCount));
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showHelper);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
    }
  },
  dependencies: [NgClass, NgIf, CdsIconCustomTag, ClrLabel],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrFileInputContainer, [{
    type: Component,
    args: [{
      selector: "clr-file-input-container",
      template: `
    <ng-content select="label"></ng-content>
    <label *ngIf="!label && addGrid()"></label>
    <div class="clr-control-container" [ngClass]="controlClass()">
      <div class="clr-file-input-wrapper">
        <ng-content select="[clrFileInput]"></ng-content>

        <!-- file input to handle adding new files to selection when file list is present (prevent replacing selected files on the main file input) -->
        <input
          *ngIf="fileList"
          #fileListFileInput
          type="file"
          class="clr-file-input"
          tabindex="-1"
          aria-hidden="true"
          [accept]="accept"
          [multiple]="multiple"
          [disabled]="disabled"
          (change)="addFilesToSelection(fileListFileInput.files)"
        />

        <button
          #browseButton
          type="button"
          class="btn btn-sm clr-file-input-browse-button"
          [attr.aria-describedby]="browseButtonDescribedBy"
          [disabled]="disabled"
          (click)="browse()"
        >
          <cds-icon shape="folder-open"></cds-icon>
          <span class="clr-file-input-browse-button-text">{{ browseButtonText }}</span>
        </button>
        <button
          *ngIf="!fileList && fileInput?.selection?.fileCount"
          type="button"
          class="btn btn-sm clr-file-input-clear-button"
          [attr.aria-label]="fileInput?.selection?.clearFilesButtonLabel"
          (click)="clearSelectedFiles()"
        >
          <cds-icon shape="times" status="neutral" size="md"></cds-icon>
        </button>
        <cds-icon
          *ngIf="showInvalid"
          class="clr-validate-icon"
          shape="exclamation-circle"
          status="danger"
          aria-hidden="true"
        ></cds-icon>
        <cds-icon
          *ngIf="showValid"
          class="clr-validate-icon"
          shape="check-circle"
          status="success"
          aria-hidden="true"
        ></cds-icon>
      </div>
      <ng-content select="clr-control-helper" *ngIf="showHelper"></ng-content>
      <ng-content select="clr-control-error" *ngIf="showInvalid"></ng-content>
      <ng-content select="clr-control-success" *ngIf="showValid"></ng-content>

      <!-- If this is present, this file input becomes an "advanced" file input. -->
      <ng-container>
        <div class="clr-file-list-break"></div>
        <ng-content select="clr-file-list"></ng-content>
      </ng-container>
    </div>
  `,
      host: {
        "[class.clr-form-control]": "true",
        "[class.clr-form-control-disabled]": "disabled",
        "[class.clr-row]": "addGrid()"
      },
      providers: [IfControlStateService, NgControlService, ControlIdService, ControlClassService]
    }]
  }], null, {
    customButtonLabel: [{
      type: Input,
      args: ["clrButtonLabel"]
    }],
    fileInput: [{
      type: ContentChild,
      args: [forwardRef(() => ClrFileInput)]
    }],
    fileList: [{
      type: ContentChild,
      args: [forwardRef(() => ClrFileList)]
    }],
    browseButtonElementRef: [{
      type: ViewChild,
      args: ["browseButton"]
    }],
    fileListFileInputElementRef: [{
      type: ViewChild,
      args: ["fileListFileInput"]
    }],
    fileSuccessComponent: [{
      type: ContentChild,
      args: [ClrFileSuccess]
    }],
    fileErrorComponent: [{
      type: ContentChild,
      args: [ClrFileError]
    }]
  });
})();
var ClrFileInput = class extends WrappedFormControl {
  constructor(injector, renderer, viewContainerRef, elementRef, control, commonStrings) {
    super(viewContainerRef, ClrFileInputContainer, injector, control, renderer, elementRef);
    this.elementRef = elementRef;
    this.commonStrings = commonStrings;
    this.selection = void 0;
  }
  handleChange() {
    this.updateSelection();
  }
  updateSelection() {
    const files = this.elementRef.nativeElement.files;
    let selectionButtonLabel;
    let clearFilesButtonLabel;
    if (files?.length === 1) {
      const filename = files[0].name;
      selectionButtonLabel = filename;
      clearFilesButtonLabel = this.commonStrings.parse(this.commonStrings.keys.clearFile, {
        FILE: filename
      });
    } else if (files?.length > 1) {
      const fileCount = files.length.toString();
      selectionButtonLabel = this.commonStrings.parse(this.commonStrings.keys.fileCount, {
        COUNT: fileCount
      });
      clearFilesButtonLabel = this.commonStrings.parse(this.commonStrings.keys.clearFiles, {
        COUNT: fileCount
      });
    }
    this.selection = {
      fileCount: files.length,
      buttonLabel: selectionButtonLabel,
      clearFilesButtonLabel
    };
  }
};
ClrFileInput.ɵfac = function ClrFileInput_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrFileInput)(ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgControl, 10), ɵɵdirectiveInject(ClrCommonStringsService));
};
ClrFileInput.ɵdir = ɵɵdefineDirective({
  type: ClrFileInput,
  selectors: [["input", "type", "file", "clrFileInput", ""]],
  hostAttrs: ["tabindex", "-1", "aria-hidden", "true"],
  hostVars: 2,
  hostBindings: function ClrFileInput_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("change", function ClrFileInput_change_HostBindingHandler() {
        return ctx.handleChange();
      });
    }
    if (rf & 2) {
      ɵɵclassProp("clr-file-input", true);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrFileInput, [{
    type: Directive,
    args: [{
      selector: 'input[type="file"][clrFileInput]',
      host: {
        tabindex: "-1",
        "aria-hidden": "true",
        "[class.clr-file-input]": "true"
      }
    }]
  }], function() {
    return [{
      type: Injector
    }, {
      type: Renderer2
    }, {
      type: ViewContainerRef
    }, {
      type: ElementRef
    }, {
      type: NgControl,
      decorators: [{
        type: Self
      }, {
        type: Optional
      }]
    }, {
      type: ClrCommonStringsService
    }];
  }, {
    handleChange: [{
      type: HostListener,
      args: ["change"]
    }]
  });
})();
var ClrFileInputValidator = class {
  constructor(elementRef) {
    this.elementRef = elementRef;
  }
  validate(control) {
    const files = control.value;
    const fileInputElement = this.elementRef.nativeElement;
    const errors = {};
    if (fileInputElement.required && files?.length === 0) {
      errors.required = true;
    }
    const accept = fileInputElement.accept ? fileInputElement.accept.split(",").map((type) => type.trim()) : null;
    if (files?.length > 0 && (accept || this.minFileSize || this.maxFileSize)) {
      for (let i = 0; i < files.length; i++) {
        const file = files.item(i);
        if (accept) {
          const [fileExtension] = file.name.match(/\..+$/);
          if (!accept.includes(file.type) && !accept.includes(fileExtension)) {
            errors.accept = errors.accept || [];
            errors.accept.push({
              name: file.name,
              accept,
              type: file.type,
              extension: fileExtension
            });
          }
        }
        if (this.minFileSize && file.size < this.minFileSize) {
          errors.minFileSize = errors.minFileSize || [];
          errors.minFileSize.push({
            name: file.name,
            minFileSize: this.minFileSize,
            actualFileSize: file.size
          });
        }
        if (this.maxFileSize && file.size > this.maxFileSize) {
          errors.maxFileSize = errors.maxFileSize || [];
          errors.maxFileSize.push({
            name: file.name,
            maxFileSize: this.maxFileSize,
            actualFileSize: file.size
          });
        }
      }
    }
    return Object.keys(errors).length ? errors : null;
  }
};
ClrFileInputValidator.ɵfac = function ClrFileInputValidator_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrFileInputValidator)(ɵɵdirectiveInject(ElementRef));
};
ClrFileInputValidator.ɵdir = ɵɵdefineDirective({
  type: ClrFileInputValidator,
  selectors: [["input", "type", "file", "clrFileInput", ""]],
  inputs: {
    minFileSize: [0, "clrMinFileSize", "minFileSize"],
    maxFileSize: [0, "clrMaxFileSize", "maxFileSize"]
  },
  standalone: false,
  features: [ɵɵProvidersFeature([{
    provide: NG_VALIDATORS,
    useExisting: ClrFileInputValidator,
    multi: true
  }])]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrFileInputValidator, [{
    type: Directive,
    args: [{
      selector: 'input[type="file"][clrFileInput]',
      providers: [{
        provide: NG_VALIDATORS,
        useExisting: ClrFileInputValidator,
        multi: true
      }]
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, {
    minFileSize: [{
      type: Input,
      args: ["clrMinFileSize"]
    }],
    maxFileSize: [{
      type: Input,
      args: ["clrMaxFileSize"]
    }]
  });
})();
var ClrFileInputValueAccessor = class {
  constructor(elementRef) {
    this.elementRef = elementRef;
    this.onChange = (_value) => {
    };
    this.onTouched = () => {
    };
  }
  writeValue(value) {
    if (value !== void 0 && value !== null && !(value instanceof FileList)) {
      throw new Error("The value of a file input control must be a FileList.");
    }
    if (value) {
      selectFiles(this.elementRef.nativeElement, value);
    } else if (this.elementRef.nativeElement.files.length) {
      clearFiles(this.elementRef.nativeElement);
    }
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  handleChange() {
    this.onTouched();
    this.onChange(this.elementRef.nativeElement.files);
  }
};
ClrFileInputValueAccessor.ɵfac = function ClrFileInputValueAccessor_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrFileInputValueAccessor)(ɵɵdirectiveInject(ElementRef));
};
ClrFileInputValueAccessor.ɵdir = ɵɵdefineDirective({
  type: ClrFileInputValueAccessor,
  selectors: [["input", "type", "file", "clrFileInput", ""]],
  hostBindings: function ClrFileInputValueAccessor_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("change", function ClrFileInputValueAccessor_change_HostBindingHandler() {
        return ctx.handleChange();
      });
    }
  },
  standalone: false,
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: ClrFileInputValueAccessor,
    multi: true
  }])]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrFileInputValueAccessor, [{
    type: Directive,
    args: [{
      selector: 'input[type="file"][clrFileInput]',
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: ClrFileInputValueAccessor,
        multi: true
      }]
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, {
    handleChange: [{
      type: HostListener,
      args: ["change"]
    }]
  });
})();
var ClrFileInputModule = class {
  constructor() {
    r.addIcons(L2);
  }
};
ClrFileInputModule.ɵfac = function ClrFileInputModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrFileInputModule)();
};
ClrFileInputModule.ɵmod = ɵɵdefineNgModule({
  type: ClrFileInputModule,
  declarations: [ClrFileInput, ClrFileInputContainer, ClrFileInputValidator, ClrFileInputValueAccessor, ClrFileList, ClrFileMessagesTemplate, ClrFileInfo, ClrFileSuccess, ClrFileError],
  imports: [CommonModule, ClrIconModule, ClrCommonFormsModule],
  exports: [ClrCommonFormsModule, ClrFileInput, ClrFileInputContainer, ClrFileInputValidator, ClrFileInputValueAccessor, ClrFileList, ClrFileMessagesTemplate, ClrFileInfo, ClrFileSuccess, ClrFileError]
});
ClrFileInputModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrIconModule, ClrCommonFormsModule, ClrCommonFormsModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrFileInputModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ClrIconModule, ClrCommonFormsModule],
      declarations: [ClrFileInput, ClrFileInputContainer, ClrFileInputValidator, ClrFileInputValueAccessor, ClrFileList, ClrFileMessagesTemplate, ClrFileInfo, ClrFileSuccess, ClrFileError],
      exports: [ClrCommonFormsModule, ClrFileInput, ClrFileInputContainer, ClrFileInputValidator, ClrFileInputValueAccessor, ClrFileList, ClrFileMessagesTemplate, ClrFileInfo, ClrFileSuccess, ClrFileError]
    }]
  }], function() {
    return [];
  }, null);
})();
var ClrNumberInputContainer = class extends ClrAbstractContainer {
  constructor(controlClassService, layoutService, ngControlService, focusService, ifControlStateService) {
    super(ifControlStateService, layoutService, controlClassService, ngControlService);
    this.ifControlStateService = ifControlStateService;
    this.focus = false;
    this.subscriptions.push(focusService.focusChange.subscribe((state2) => this.focus = state2));
  }
};
ClrNumberInputContainer.ɵfac = function ClrNumberInputContainer_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrNumberInputContainer)(ɵɵdirectiveInject(ControlClassService), ɵɵdirectiveInject(LayoutService, 8), ɵɵdirectiveInject(NgControlService), ɵɵdirectiveInject(FocusService2), ɵɵdirectiveInject(IfControlStateService));
};
ClrNumberInputContainer.ɵcmp = ɵɵdefineComponent({
  type: ClrNumberInputContainer,
  selectors: [["clr-number-input-container"]],
  contentQueries: function ClrNumberInputContainer_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrNumberInput, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.input = _t.first);
    }
  },
  hostVars: 8,
  hostBindings: function ClrNumberInputContainer_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-form-control", true)("clr-form-control-disabled", ctx.control == null ? null : ctx.control.disabled)("clr-form-control-readonly", ctx.input.readonly)("clr-row", ctx.addGrid());
    }
  },
  standalone: false,
  features: [ɵɵProvidersFeature([FocusService2, IfControlStateService, NgControlService, ControlIdService, ControlClassService]), ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c40,
  decls: 17,
  vars: 11,
  consts: [[4, "ngIf"], [1, "clr-control-container", 3, "ngClass"], [1, "clr-number-input-wrapper"], [1, "clr-input-group"], [1, "clr-input-group-actions"], ["type", "button", 1, "clr-input-group-icon-action", 3, "click", "disabled"], ["shape", "minus", "size", "sm"], [1, "clr-number-input-separator"], ["shape", "plus", "size", "sm"], ["class", "clr-validate-icon", "shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 4, "ngIf"], ["class", "clr-validate-icon", "shape", "check-circle", "status", "success", "aria-hidden", "true", 4, "ngIf"], ["shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 1, "clr-validate-icon"], ["shape", "check-circle", "status", "success", "aria-hidden", "true", 1, "clr-validate-icon"]],
  template: function ClrNumberInputContainer_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c39);
      ɵɵprojection(0);
      ɵɵtemplate(1, ClrNumberInputContainer_label_1_Template, 1, 0, "label", 0);
      ɵɵelementStart(2, "div", 1)(3, "div", 2)(4, "div", 3);
      ɵɵprojection(5, 1);
      ɵɵelementStart(6, "div", 4)(7, "button", 5);
      ɵɵlistener("click", function ClrNumberInputContainer_Template_button_click_7_listener() {
        return ctx.input.stepDown();
      });
      ɵɵelement(8, "cds-icon", 6);
      ɵɵelementEnd();
      ɵɵelement(9, "div", 7);
      ɵɵelementStart(10, "button", 5);
      ɵɵlistener("click", function ClrNumberInputContainer_Template_button_click_10_listener() {
        return ctx.input.stepUp();
      });
      ɵɵelement(11, "cds-icon", 8);
      ɵɵelementEnd()()();
      ɵɵtemplate(12, ClrNumberInputContainer_cds_icon_12_Template, 1, 0, "cds-icon", 9)(13, ClrNumberInputContainer_cds_icon_13_Template, 1, 0, "cds-icon", 10);
      ɵɵelementEnd();
      ɵɵtemplate(14, ClrNumberInputContainer_ng_content_14_Template, 1, 0, "ng-content", 0)(15, ClrNumberInputContainer_ng_content_15_Template, 1, 0, "ng-content", 0)(16, ClrNumberInputContainer_ng_content_16_Template, 1, 0, "ng-content", 0);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.label && ctx.addGrid());
      ɵɵadvance();
      ɵɵproperty("ngClass", ctx.controlClass());
      ɵɵadvance(2);
      ɵɵclassProp("clr-focus", ctx.focus);
      ɵɵadvance(3);
      ɵɵproperty("disabled", ctx.control == null ? null : ctx.control.disabled);
      ɵɵadvance(3);
      ɵɵproperty("disabled", ctx.control == null ? null : ctx.control.disabled);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showHelper);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
    }
  },
  dependencies: [NgClass, NgIf, CdsIconCustomTag, ClrLabel],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrNumberInputContainer, [{
    type: Component,
    args: [{
      selector: "clr-number-input-container",
      template: `
    <ng-content select="label"></ng-content>
    <label *ngIf="!label && addGrid()"></label>
    <div class="clr-control-container" [ngClass]="controlClass()">
      <div class="clr-number-input-wrapper">
        <div class="clr-input-group" [class.clr-focus]="focus">
          <ng-content select="[clrNumberInput]"></ng-content>
          <div class="clr-input-group-actions">
            <button
              type="button"
              class="clr-input-group-icon-action"
              (click)="input.stepDown()"
              [disabled]="control?.disabled"
            >
              <cds-icon shape="minus" size="sm"></cds-icon>
            </button>
            <div class="clr-number-input-separator"></div>
            <button
              type="button"
              class="clr-input-group-icon-action"
              (click)="input.stepUp()"
              [disabled]="control?.disabled"
            >
              <cds-icon shape="plus" size="sm"></cds-icon>
            </button>
          </div>
        </div>
        <cds-icon
          *ngIf="showInvalid"
          class="clr-validate-icon"
          shape="exclamation-circle"
          status="danger"
          aria-hidden="true"
        ></cds-icon>
        <cds-icon
          *ngIf="showValid"
          class="clr-validate-icon"
          shape="check-circle"
          status="success"
          aria-hidden="true"
        ></cds-icon>
      </div>
      <ng-content select="clr-control-helper" *ngIf="showHelper"></ng-content>
      <ng-content select="clr-control-error" *ngIf="showInvalid"></ng-content>
      <ng-content select="clr-control-success" *ngIf="showValid"></ng-content>
    </div>
  `,
      host: {
        "[class.clr-form-control]": "true",
        "[class.clr-form-control-disabled]": "control?.disabled",
        "[class.clr-form-control-readonly]": "input.readonly",
        "[class.clr-row]": "addGrid()"
      },
      providers: [FocusService2, IfControlStateService, NgControlService, ControlIdService, ControlClassService]
    }]
  }], function() {
    return [{
      type: ControlClassService
    }, {
      type: LayoutService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: NgControlService
    }, {
      type: FocusService2
    }, {
      type: IfControlStateService
    }];
  }, {
    input: [{
      type: ContentChild,
      args: [forwardRef(() => ClrNumberInput)]
    }]
  });
})();
var ClrNumberInput = class extends WrappedFormControl {
  constructor(focusService, vcr, injector, control, renderer, el) {
    super(vcr, ClrNumberInputContainer, injector, control, renderer, el);
    this.focusService = focusService;
    this.control = control;
    this.el = el;
    this.index = 1;
    if (!focusService) {
      throw new Error("clrNumberInput requires being wrapped in <clr-number-input-container>");
    }
  }
  get readonly() {
    return this.el.nativeElement.getAttribute("readonly") !== null;
  }
  triggerFocus() {
    if (!this.readonly && this.focusService) {
      this.focusService.focused = true;
    }
  }
  triggerValidation() {
    if (!this.readonly) {
      super.triggerValidation();
      if (this.focusService) {
        this.focusService.focused = false;
      }
    }
  }
  stepUp() {
    this.el.nativeElement.stepUp();
    this.el.nativeElement.dispatchEvent(new Event("input", {
      bubbles: true,
      cancelable: true
    }));
    this.control.control.markAllAsTouched();
  }
  stepDown() {
    this.el.nativeElement.stepDown();
    this.el.nativeElement.dispatchEvent(new Event("input", {
      bubbles: true,
      cancelable: true
    }));
    this.control.control.markAllAsTouched();
  }
};
ClrNumberInput.ɵfac = function ClrNumberInput_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrNumberInput)(ɵɵdirectiveInject(FocusService2, 8), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(NgControl, 10), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
};
ClrNumberInput.ɵdir = ɵɵdefineDirective({
  type: ClrNumberInput,
  selectors: [["input", "type", "number", "clrNumberInput", ""]],
  hostVars: 4,
  hostBindings: function ClrNumberInput_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("focus", function ClrNumberInput_focus_HostBindingHandler() {
        return ctx.triggerFocus();
      })("blur", function ClrNumberInput_blur_HostBindingHandler() {
        return ctx.triggerValidation();
      });
    }
    if (rf & 2) {
      ɵɵclassProp("clr-input", true)("clr-number-input", true);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrNumberInput, [{
    type: Directive,
    args: [{
      selector: 'input[type="number"][clrNumberInput]',
      host: {
        "[class.clr-input]": "true",
        "[class.clr-number-input]": "true"
      }
    }]
  }], function() {
    return [{
      type: FocusService2,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ViewContainerRef
    }, {
      type: Injector
    }, {
      type: NgControl,
      decorators: [{
        type: Self
      }, {
        type: Optional
      }]
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }];
  }, {
    triggerFocus: [{
      type: HostListener,
      args: ["focus"]
    }],
    triggerValidation: [{
      type: HostListener,
      args: ["blur"]
    }]
  });
})();
var ClrNumberInputModule = class {
  constructor() {
    r.addIcons(o4, e);
  }
};
ClrNumberInputModule.ɵfac = function ClrNumberInputModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrNumberInputModule)();
};
ClrNumberInputModule.ɵmod = ɵɵdefineNgModule({
  type: ClrNumberInputModule,
  declarations: [ClrNumberInput, ClrNumberInputContainer],
  imports: [CommonModule, FormsModule, ClrIconModule, ClrCommonFormsModule],
  exports: [ClrCommonFormsModule, ClrNumberInput, ClrNumberInputContainer]
});
ClrNumberInputModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, FormsModule, ClrIconModule, ClrCommonFormsModule, ClrCommonFormsModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrNumberInputModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, ClrIconModule, ClrCommonFormsModule],
      declarations: [ClrNumberInput, ClrNumberInputContainer],
      exports: [ClrCommonFormsModule, ClrNumberInput, ClrNumberInputContainer]
    }]
  }], function() {
    return [];
  }, null);
})();
var TOGGLE_SERVICE = new InjectionToken(void 0);
function ToggleServiceFactory() {
  return new BehaviorSubject(false);
}
var TOGGLE_SERVICE_PROVIDER = {
  provide: TOGGLE_SERVICE,
  useFactory: ToggleServiceFactory
};
var ClrPasswordContainer = class extends ClrAbstractContainer {
  constructor(ifControlStateService, layoutService, controlClassService, ngControlService, focusService, toggleService, commonStrings) {
    super(ifControlStateService, layoutService, controlClassService, ngControlService);
    this.focusService = focusService;
    this.toggleService = toggleService;
    this.commonStrings = commonStrings;
    this.show = false;
    this.focus = false;
    this._toggle = true;
    this.subscriptions.push(focusService.focusChange.subscribe((state2) => {
      this.focus = state2;
    }));
  }
  get clrToggle() {
    return this._toggle;
  }
  set clrToggle(state2) {
    this._toggle = state2;
    if (!state2) {
      this.show = false;
    }
  }
  toggle() {
    this.show = !this.show;
    this.toggleService.next(this.show);
  }
  showPasswordText(label) {
    return this.commonStrings.parse(this.commonStrings.keys.passwordShow, {
      LABEL: label
    });
  }
  hidePasswordText(label) {
    return this.commonStrings.parse(this.commonStrings.keys.passwordHide, {
      LABEL: label
    });
  }
};
ClrPasswordContainer.ɵfac = function ClrPasswordContainer_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrPasswordContainer)(ɵɵdirectiveInject(IfControlStateService), ɵɵdirectiveInject(LayoutService, 8), ɵɵdirectiveInject(ControlClassService), ɵɵdirectiveInject(NgControlService), ɵɵdirectiveInject(FocusService2), ɵɵdirectiveInject(TOGGLE_SERVICE), ɵɵdirectiveInject(ClrCommonStringsService));
};
ClrPasswordContainer.ɵcmp = ɵɵdefineComponent({
  type: ClrPasswordContainer,
  selectors: [["clr-password-container"]],
  hostVars: 6,
  hostBindings: function ClrPasswordContainer_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-form-control", true)("clr-form-control-disabled", ctx.control == null ? null : ctx.control.disabled)("clr-row", ctx.addGrid());
    }
  },
  inputs: {
    clrToggle: "clrToggle"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([NgControlService, ControlIdService, ControlClassService, FocusService2, TOGGLE_SERVICE_PROVIDER, IfControlStateService]), ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c42,
  decls: 12,
  vars: 10,
  consts: [[4, "ngIf"], [1, "clr-control-container", 3, "ngClass"], [1, "clr-input-wrapper"], [1, "clr-input-group"], ["class", "clr-input-group-icon-action", "type", "button", 3, "disabled", "click", 4, "ngIf"], ["class", "clr-validate-icon", "shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 4, "ngIf"], ["class", "clr-validate-icon", "shape", "check-circle", "status", "success", "aria-hidden", "true", 4, "ngIf"], ["type", "button", 1, "clr-input-group-icon-action", 3, "click", "disabled"], [1, "clr-password-eye-icon"], [1, "clr-sr-only"], ["shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 1, "clr-validate-icon"], ["shape", "check-circle", "status", "success", "aria-hidden", "true", 1, "clr-validate-icon"]],
  template: function ClrPasswordContainer_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c41);
      ɵɵprojection(0);
      ɵɵtemplate(1, ClrPasswordContainer_label_1_Template, 1, 0, "label", 0);
      ɵɵelementStart(2, "div", 1)(3, "div", 2)(4, "div", 3);
      ɵɵprojection(5, 1);
      ɵɵtemplate(6, ClrPasswordContainer_button_6_Template, 4, 3, "button", 4);
      ɵɵelementEnd();
      ɵɵtemplate(7, ClrPasswordContainer_cds_icon_7_Template, 1, 0, "cds-icon", 5)(8, ClrPasswordContainer_cds_icon_8_Template, 1, 0, "cds-icon", 6);
      ɵɵelementEnd();
      ɵɵtemplate(9, ClrPasswordContainer_ng_content_9_Template, 1, 0, "ng-content", 0)(10, ClrPasswordContainer_ng_content_10_Template, 1, 0, "ng-content", 0)(11, ClrPasswordContainer_ng_content_11_Template, 1, 0, "ng-content", 0);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.label && ctx.addGrid());
      ɵɵadvance();
      ɵɵproperty("ngClass", ctx.controlClass());
      ɵɵadvance(2);
      ɵɵclassProp("clr-focus", ctx.focus);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.clrToggle);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showHelper);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
    }
  },
  dependencies: [NgClass, NgIf, CdsIconCustomTag, ClrLabel],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrPasswordContainer, [{
    type: Component,
    args: [{
      selector: "clr-password-container",
      template: `
    <ng-content select="label"></ng-content>
    <label *ngIf="!label && addGrid()"></label>
    <div class="clr-control-container" [ngClass]="controlClass()">
      <div class="clr-input-wrapper">
        <div class="clr-input-group" [class.clr-focus]="focus">
          <ng-content select="[clrPassword]"></ng-content>
          <button
            *ngIf="clrToggle"
            (click)="toggle()"
            [disabled]="control?.disabled"
            class="clr-input-group-icon-action"
            type="button"
          >
            <cds-icon class="clr-password-eye-icon" [attr.shape]="show ? 'eye-hide' : 'eye'"></cds-icon>
            <span class="clr-sr-only">
              {{ show ? hidePasswordText(label?.labelText) : showPasswordText(label?.labelText) }}
            </span>
          </button>
        </div>
        <cds-icon
          *ngIf="showInvalid"
          class="clr-validate-icon"
          shape="exclamation-circle"
          status="danger"
          aria-hidden="true"
        ></cds-icon>
        <cds-icon
          *ngIf="showValid"
          class="clr-validate-icon"
          shape="check-circle"
          status="success"
          aria-hidden="true"
        ></cds-icon>
      </div>
      <ng-content select="clr-control-helper" *ngIf="showHelper"></ng-content>
      <ng-content select="clr-control-error" *ngIf="showInvalid"></ng-content>
      <ng-content select="clr-control-success" *ngIf="showValid"></ng-content>
    </div>
  `,
      host: {
        "[class.clr-form-control]": "true",
        "[class.clr-form-control-disabled]": "control?.disabled",
        "[class.clr-row]": "addGrid()"
      },
      providers: [NgControlService, ControlIdService, ControlClassService, FocusService2, TOGGLE_SERVICE_PROVIDER, IfControlStateService]
    }]
  }], function() {
    return [{
      type: IfControlStateService
    }, {
      type: LayoutService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ControlClassService
    }, {
      type: NgControlService
    }, {
      type: FocusService2
    }, {
      type: BehaviorSubject,
      decorators: [{
        type: Inject,
        args: [TOGGLE_SERVICE]
      }]
    }, {
      type: ClrCommonStringsService
    }];
  }, {
    clrToggle: [{
      type: Input,
      args: ["clrToggle"]
    }]
  });
})();
var ClrPassword = class extends WrappedFormControl {
  constructor(vcr, injector, control, renderer, el, focusService, toggleService) {
    super(vcr, ClrPasswordContainer, injector, control, renderer, el);
    this.focusService = focusService;
    this.index = 1;
    if (!focusService) {
      throw new Error("clrPassword requires being wrapped in <clr-password-container>");
    }
    this.subscriptions.push(toggleService.subscribe((toggle) => {
      renderer.setProperty(el.nativeElement, "type", toggle ? "text" : "password");
    }));
  }
  triggerFocus() {
    if (this.focusService) {
      this.focusService.focused = true;
    }
  }
  triggerValidation() {
    super.triggerValidation();
    if (this.focusService) {
      this.focusService.focused = false;
    }
  }
};
ClrPassword.ɵfac = function ClrPassword_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrPassword)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(NgControl, 10), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(FocusService2, 8), ɵɵdirectiveInject(TOGGLE_SERVICE, 8));
};
ClrPassword.ɵdir = ɵɵdefineDirective({
  type: ClrPassword,
  selectors: [["", "clrPassword", ""]],
  hostVars: 2,
  hostBindings: function ClrPassword_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("focus", function ClrPassword_focus_HostBindingHandler() {
        return ctx.triggerFocus();
      })("blur", function ClrPassword_blur_HostBindingHandler() {
        return ctx.triggerValidation();
      });
    }
    if (rf & 2) {
      ɵɵclassProp("clr-input", true);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrPassword, [{
    type: Directive,
    args: [{
      selector: "[clrPassword]",
      host: {
        "[class.clr-input]": "true"
      }
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }, {
      type: Injector
    }, {
      type: NgControl,
      decorators: [{
        type: Self
      }, {
        type: Optional
      }]
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: FocusService2,
      decorators: [{
        type: Optional
      }]
    }, {
      type: BehaviorSubject,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [TOGGLE_SERVICE]
      }]
    }];
  }, {
    triggerFocus: [{
      type: HostListener,
      args: ["focus"]
    }],
    triggerValidation: [{
      type: HostListener,
      args: ["blur"]
    }]
  });
})();
var ClrPasswordModule = class {
  constructor() {
    r.addIcons(e3, o5, o4, e);
  }
};
ClrPasswordModule.ɵfac = function ClrPasswordModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrPasswordModule)();
};
ClrPasswordModule.ɵmod = ɵɵdefineNgModule({
  type: ClrPasswordModule,
  declarations: [ClrPassword, ClrPasswordContainer],
  imports: [CommonModule, FormsModule, ClrIconModule, ClrCommonFormsModule],
  exports: [ClrCommonFormsModule, ClrPassword, ClrPasswordContainer]
});
ClrPasswordModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, FormsModule, ClrIconModule, ClrCommonFormsModule, ClrCommonFormsModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrPasswordModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, ClrIconModule, ClrCommonFormsModule],
      declarations: [ClrPassword, ClrPasswordContainer],
      exports: [ClrCommonFormsModule, ClrPassword, ClrPasswordContainer]
    }]
  }], function() {
    return [];
  }, null);
})();
var ClrRadioWrapper = class {
  constructor() {
    this._dynamic = false;
  }
  ngOnInit() {
    if (this.label) {
      this.label.disableGrid();
    }
  }
};
ClrRadioWrapper.ɵfac = function ClrRadioWrapper_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrRadioWrapper)();
};
ClrRadioWrapper.ɵcmp = ɵɵdefineComponent({
  type: ClrRadioWrapper,
  selectors: [["clr-radio-wrapper"]],
  contentQueries: function ClrRadioWrapper_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrLabel, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.label = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function ClrRadioWrapper_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-radio-wrapper", true);
    }
  },
  standalone: false,
  features: [ɵɵProvidersFeature([ControlIdService])],
  ngContentSelectors: _c44,
  decls: 3,
  vars: 1,
  consts: [[4, "ngIf"]],
  template: function ClrRadioWrapper_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c43);
      ɵɵprojection(0);
      ɵɵprojection(1, 1);
      ɵɵtemplate(2, ClrRadioWrapper_label_2_Template, 1, 0, "label", 0);
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵproperty("ngIf", !ctx.label);
    }
  },
  dependencies: [NgIf, ClrLabel],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrRadioWrapper, [{
    type: Component,
    args: [{
      selector: "clr-radio-wrapper",
      template: `
    <ng-content select="[clrRadio]"></ng-content>
    <ng-content select="label"></ng-content>
    <label *ngIf="!label"></label>
  `,
      host: {
        "[class.clr-radio-wrapper]": "true"
      },
      providers: [ControlIdService]
    }]
  }], null, {
    label: [{
      type: ContentChild,
      args: [ClrLabel, {
        static: true
      }]
    }]
  });
})();
var ClrRadio = class extends WrappedFormControl {
  constructor(vcr, injector, control, renderer, el) {
    super(vcr, ClrRadioWrapper, injector, control, renderer, el);
  }
};
ClrRadio.ɵfac = function ClrRadio_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrRadio)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(NgControl, 10), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
};
ClrRadio.ɵdir = ɵɵdefineDirective({
  type: ClrRadio,
  selectors: [["", "clrRadio", ""]],
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrRadio, [{
    type: Directive,
    args: [{
      selector: "[clrRadio]"
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }, {
      type: Injector
    }, {
      type: NgControl,
      decorators: [{
        type: Self
      }, {
        type: Optional
      }]
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }];
  }, null);
})();
var ClrRadioContainer = class extends ClrAbstractContainer {
  constructor(layoutService, controlClassService, ngControlService, ifControlStateService) {
    super(ifControlStateService, layoutService, controlClassService, ngControlService);
    this.layoutService = layoutService;
    this.controlClassService = controlClassService;
    this.ngControlService = ngControlService;
    this.ifControlStateService = ifControlStateService;
    this.inline = false;
    this._generatedId = uniqueIdFactory();
  }
  /*
   * Here we want to support the following cases
   * clrInline - true by presence
   * clrInline="true|false" - unless it is explicitly false, strings are considered true
   * [clrInline]="true|false" - expect a boolean
   */
  get clrInline() {
    return this.inline;
  }
  set clrInline(value) {
    if (typeof value === "string") {
      this.inline = value === "false" ? false : true;
    } else {
      this.inline = !!value;
    }
  }
  ngAfterContentInit() {
    this.setAriaRoles();
    this.setAriaLabelledBy();
  }
  setAriaRoles() {
    this.role = this.radios.length ? "radiogroup" : null;
  }
  setAriaLabelledBy() {
    const _id = this.groupLabel?.nativeElement.getAttribute("id");
    if (!_id) {
      this.groupLabel?.nativeElement.setAttribute("id", this._generatedId);
      this.ariaLabelledBy = this.radios.length ? this._generatedId : null;
    } else {
      this.ariaLabelledBy = this.radios.length ? _id : null;
    }
  }
};
ClrRadioContainer.ɵfac = function ClrRadioContainer_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrRadioContainer)(ɵɵdirectiveInject(LayoutService, 8), ɵɵdirectiveInject(ControlClassService), ɵɵdirectiveInject(NgControlService), ɵɵdirectiveInject(IfControlStateService));
};
ClrRadioContainer.ɵcmp = ɵɵdefineComponent({
  type: ClrRadioContainer,
  selectors: [["clr-radio-container"]],
  contentQueries: function ClrRadioContainer_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrLabel, 7, ElementRef);
      ɵɵcontentQuery(dirIndex, ClrRadio, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.groupLabel = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.radios = _t);
    }
  },
  hostVars: 8,
  hostBindings: function ClrRadioContainer_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", ctx.role)("aria-labelledby", ctx.ariaLabelledBy);
      ɵɵclassProp("clr-form-control", true)("clr-form-control-disabled", ctx.control == null ? null : ctx.control.disabled)("clr-row", ctx.addGrid());
    }
  },
  inputs: {
    clrInline: "clrInline"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([NgControlService, IfControlStateService, ControlClassService, ContainerIdService]), ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c46,
  decls: 6,
  vars: 6,
  consts: [[4, "ngIf"], [1, "clr-control-container", 3, "ngClass"], ["class", "clr-subtext-wrapper", 4, "ngIf"], [1, "clr-subtext-wrapper"], ["class", "clr-validate-icon", "shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 4, "ngIf"], ["class", "clr-validate-icon", "shape", "check-circle", "status", "success", "aria-hidden", "true", 4, "ngIf"], ["shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 1, "clr-validate-icon"], ["shape", "check-circle", "status", "success", "aria-hidden", "true", 1, "clr-validate-icon"]],
  template: function ClrRadioContainer_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c45);
      ɵɵprojection(0);
      ɵɵtemplate(1, ClrRadioContainer_label_1_Template, 1, 0, "label", 0);
      ɵɵelementStart(2, "div", 1);
      ɵɵprojection(3, 1);
      ɵɵtemplate(4, ClrRadioContainer_div_4_Template, 2, 0, "div", 2)(5, ClrRadioContainer_div_5_Template, 5, 4, "div", 2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.label && ctx.addGrid());
      ɵɵadvance();
      ɵɵclassProp("clr-control-inline", ctx.clrInline);
      ɵɵproperty("ngClass", ctx.controlClass());
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.showHelper);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid || ctx.showInvalid);
    }
  },
  dependencies: [NgClass, NgIf, ClrLabel, CdsIconCustomTag],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrRadioContainer, [{
    type: Component,
    args: [{
      selector: "clr-radio-container",
      template: `
    <ng-content select="label"></ng-content>
    <label *ngIf="!label && addGrid()"></label>
    <div class="clr-control-container" [class.clr-control-inline]="clrInline" [ngClass]="controlClass()">
      <ng-content select="clr-radio-wrapper"></ng-content>
      <div *ngIf="showHelper" class="clr-subtext-wrapper">
        <ng-content select="clr-control-helper"></ng-content>
      </div>
      <div *ngIf="showValid || showInvalid" class="clr-subtext-wrapper">
        <cds-icon
          *ngIf="showInvalid"
          class="clr-validate-icon"
          shape="exclamation-circle"
          status="danger"
          aria-hidden="true"
        ></cds-icon>
        <cds-icon
          *ngIf="showValid"
          class="clr-validate-icon"
          shape="check-circle"
          status="success"
          aria-hidden="true"
        ></cds-icon>
        <ng-content select="clr-control-error" *ngIf="showInvalid"></ng-content>
        <ng-content select="clr-control-success" *ngIf="showValid"></ng-content>
      </div>
    </div>
  `,
      host: {
        "[class.clr-form-control]": "true",
        "[class.clr-form-control-disabled]": "control?.disabled",
        "[class.clr-row]": "addGrid()",
        "[attr.role]": "role",
        "[attr.aria-labelledby]": "ariaLabelledBy"
      },
      providers: [NgControlService, IfControlStateService, ControlClassService, ContainerIdService]
    }]
  }], function() {
    return [{
      type: LayoutService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ControlClassService
    }, {
      type: NgControlService
    }, {
      type: IfControlStateService
    }];
  }, {
    radios: [{
      type: ContentChildren,
      args: [ClrRadio, {
        descendants: true
      }]
    }],
    groupLabel: [{
      type: ContentChild,
      args: [ClrLabel, {
        read: ElementRef,
        static: true
      }]
    }],
    clrInline: [{
      type: Input
    }]
  });
})();
var ClrRadioModule = class {
  constructor() {
    r.addIcons(o4, e);
  }
};
ClrRadioModule.ɵfac = function ClrRadioModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrRadioModule)();
};
ClrRadioModule.ɵmod = ɵɵdefineNgModule({
  type: ClrRadioModule,
  declarations: [ClrRadio, ClrRadioContainer, ClrRadioWrapper],
  imports: [CommonModule, ClrCommonFormsModule, ClrHostWrappingModule, ClrIconModule],
  exports: [ClrCommonFormsModule, ClrRadio, ClrRadioContainer, ClrRadioWrapper]
});
ClrRadioModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrCommonFormsModule, ClrHostWrappingModule, ClrIconModule, ClrCommonFormsModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrRadioModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ClrCommonFormsModule, ClrHostWrappingModule, ClrIconModule],
      declarations: [ClrRadio, ClrRadioContainer, ClrRadioWrapper],
      exports: [ClrCommonFormsModule, ClrRadio, ClrRadioContainer, ClrRadioWrapper]
    }]
  }], function() {
    return [];
  }, null);
})();
var ClrRangeContainer = class extends ClrAbstractContainer {
  constructor(layoutService, controlClassService, ngControlService, renderer, idService, ifControlStateService) {
    super(ifControlStateService, layoutService, controlClassService, ngControlService);
    this.renderer = renderer;
    this.idService = idService;
    this.ifControlStateService = ifControlStateService;
    this._hasProgress = false;
  }
  get hasProgress() {
    return this._hasProgress;
  }
  set hasProgress(val) {
    const valBool = !!val;
    if (valBool !== this._hasProgress) {
      this._hasProgress = valBool;
    }
  }
  getRangeProgressFillWidth() {
    const input = this.selectRangeElement();
    if (!input) {
      return this.lastRangeProgressFillWidth;
    }
    const inputWidth = input.offsetWidth;
    const inputMinValue = +input.min;
    let inputMaxValue = +input.max;
    if (inputMinValue === 0 && inputMaxValue === 0) {
      inputMaxValue = 100;
    }
    const inputMiddle = (inputMinValue + inputMaxValue) / 2;
    const inputValue = !!this.control && this.control.value !== void 0 ? this.control.value : inputMiddle;
    const valueAsPercent = (inputValue - inputMinValue) * 100 / (inputMaxValue - inputMinValue);
    this.lastRangeProgressFillWidth = valueAsPercent * inputWidth / 100 + "px";
    return this.lastRangeProgressFillWidth;
  }
  selectRangeElement() {
    try {
      return this.renderer.selectRootElement("[clrRange]#" + this.idService.id);
    } catch {
      return void 0;
    }
  }
};
ClrRangeContainer.ɵfac = function ClrRangeContainer_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrRangeContainer)(ɵɵdirectiveInject(LayoutService, 8), ɵɵdirectiveInject(ControlClassService), ɵɵdirectiveInject(NgControlService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ControlIdService), ɵɵdirectiveInject(IfControlStateService));
};
ClrRangeContainer.ɵcmp = ɵɵdefineComponent({
  type: ClrRangeContainer,
  selectors: [["clr-range-container"]],
  hostVars: 6,
  hostBindings: function ClrRangeContainer_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-form-control", true)("clr-form-control-disabled", ctx.control == null ? null : ctx.control.disabled)("clr-row", ctx.addGrid());
    }
  },
  inputs: {
    hasProgress: [0, "clrRangeHasProgress", "hasProgress"]
  },
  standalone: false,
  features: [ɵɵProvidersFeature([IfControlStateService, NgControlService, ControlIdService, ControlClassService]), ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c48,
  decls: 11,
  vars: 10,
  consts: [[4, "ngIf"], [1, "clr-control-container", 3, "ngClass"], [1, "clr-range-wrapper"], ["class", "fill-input", 3, "width", 4, "ngIf"], ["class", "clr-validate-icon", "shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 4, "ngIf"], ["class", "clr-validate-icon", "shape", "check-circle", "status", "success", "aria-hidden", "true", 4, "ngIf"], [1, "fill-input"], ["shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 1, "clr-validate-icon"], ["shape", "check-circle", "status", "success", "aria-hidden", "true", 1, "clr-validate-icon"]],
  template: function ClrRangeContainer_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c47);
      ɵɵprojection(0);
      ɵɵtemplate(1, ClrRangeContainer_label_1_Template, 1, 0, "label", 0);
      ɵɵelementStart(2, "div", 1)(3, "div", 2);
      ɵɵprojection(4, 1);
      ɵɵtemplate(5, ClrRangeContainer_span_5_Template, 1, 2, "span", 3)(6, ClrRangeContainer_cds_icon_6_Template, 1, 0, "cds-icon", 4)(7, ClrRangeContainer_cds_icon_7_Template, 1, 0, "cds-icon", 5);
      ɵɵelementEnd();
      ɵɵtemplate(8, ClrRangeContainer_ng_content_8_Template, 1, 0, "ng-content", 0)(9, ClrRangeContainer_ng_content_9_Template, 1, 0, "ng-content", 0)(10, ClrRangeContainer_ng_content_10_Template, 1, 0, "ng-content", 0);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.label && ctx.addGrid());
      ɵɵadvance();
      ɵɵproperty("ngClass", ctx.controlClass());
      ɵɵadvance();
      ɵɵclassProp("progress-fill", ctx.hasProgress);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.hasProgress);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showHelper);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
    }
  },
  dependencies: [NgClass, NgIf, ClrLabel, CdsIconCustomTag],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrRangeContainer, [{
    type: Component,
    args: [{
      selector: "clr-range-container",
      template: `
    <ng-content select="label"></ng-content>
    <label *ngIf="!label && addGrid()"></label>
    <div class="clr-control-container" [ngClass]="controlClass()">
      <div class="clr-range-wrapper" [class.progress-fill]="hasProgress">
        <ng-content select="[clrRange]"></ng-content>
        <span *ngIf="hasProgress" class="fill-input" [style.width]="getRangeProgressFillWidth()"></span>
        <cds-icon
          *ngIf="showInvalid"
          class="clr-validate-icon"
          shape="exclamation-circle"
          status="danger"
          aria-hidden="true"
        ></cds-icon>
        <cds-icon
          *ngIf="showValid"
          class="clr-validate-icon"
          shape="check-circle"
          status="success"
          aria-hidden="true"
        ></cds-icon>
      </div>
      <ng-content select="clr-control-helper" *ngIf="showHelper"></ng-content>
      <ng-content select="clr-control-error" *ngIf="showInvalid"></ng-content>
      <ng-content select="clr-control-success" *ngIf="showValid"></ng-content>
    </div>
  `,
      host: {
        "[class.clr-form-control]": "true",
        "[class.clr-form-control-disabled]": "control?.disabled",
        "[class.clr-row]": "addGrid()"
      },
      providers: [IfControlStateService, NgControlService, ControlIdService, ControlClassService]
    }]
  }], function() {
    return [{
      type: LayoutService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ControlClassService
    }, {
      type: NgControlService
    }, {
      type: Renderer2
    }, {
      type: ControlIdService
    }, {
      type: IfControlStateService
    }];
  }, {
    hasProgress: [{
      type: Input,
      args: ["clrRangeHasProgress"]
    }]
  });
})();
var ClrRange = class extends WrappedFormControl {
  constructor(vcr, injector, control, renderer, el) {
    super(vcr, ClrRangeContainer, injector, control, renderer, el);
  }
};
ClrRange.ɵfac = function ClrRange_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrRange)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(NgControl, 10), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
};
ClrRange.ɵdir = ɵɵdefineDirective({
  type: ClrRange,
  selectors: [["", "clrRange", ""]],
  hostVars: 2,
  hostBindings: function ClrRange_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-range", true);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrRange, [{
    type: Directive,
    args: [{
      selector: "[clrRange]",
      host: {
        "[class.clr-range]": "true"
      }
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }, {
      type: Injector
    }, {
      type: NgControl,
      decorators: [{
        type: Self
      }, {
        type: Optional
      }]
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }];
  }, null);
})();
var ClrRangeModule = class {
  constructor() {
    r.addIcons(o4, e);
  }
};
ClrRangeModule.ɵfac = function ClrRangeModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrRangeModule)();
};
ClrRangeModule.ɵmod = ɵɵdefineNgModule({
  type: ClrRangeModule,
  declarations: [ClrRange, ClrRangeContainer],
  imports: [CommonModule, ClrCommonFormsModule, ClrHostWrappingModule, ClrIconModule],
  exports: [ClrCommonFormsModule, ClrRange, ClrRangeContainer]
});
ClrRangeModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrCommonFormsModule, ClrHostWrappingModule, ClrIconModule, ClrCommonFormsModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrRangeModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ClrCommonFormsModule, ClrHostWrappingModule, ClrIconModule],
      declarations: [ClrRange, ClrRangeContainer],
      exports: [ClrCommonFormsModule, ClrRange, ClrRangeContainer]
    }]
  }], function() {
    return [];
  }, null);
})();
var ClrSelectContainer = class extends ClrAbstractContainer {
  constructor(layoutService, controlClassService, ngControlService, ifControlStateService) {
    super(ifControlStateService, layoutService, controlClassService, ngControlService);
    this.layoutService = layoutService;
    this.controlClassService = controlClassService;
    this.ngControlService = ngControlService;
    this.ifControlStateService = ifControlStateService;
    this.multi = false;
  }
  ngOnInit() {
    this.subscriptions.push(this.ngControlService.controlChanges.subscribe((control) => {
      if (control) {
        this.multi = control.valueAccessor instanceof SelectMultipleControlValueAccessor;
        this.control = control;
      }
    }));
  }
  wrapperClass() {
    return this.multi ? "clr-multiselect-wrapper" : "clr-select-wrapper";
  }
};
ClrSelectContainer.ɵfac = function ClrSelectContainer_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrSelectContainer)(ɵɵdirectiveInject(LayoutService, 8), ɵɵdirectiveInject(ControlClassService), ɵɵdirectiveInject(NgControlService), ɵɵdirectiveInject(IfControlStateService));
};
ClrSelectContainer.ɵcmp = ɵɵdefineComponent({
  type: ClrSelectContainer,
  selectors: [["clr-select-container"]],
  contentQueries: function ClrSelectContainer_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, SelectMultipleControlValueAccessor, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.multiple = _t.first);
    }
  },
  hostVars: 6,
  hostBindings: function ClrSelectContainer_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-form-control", true)("clr-form-control-disabled", ctx.control == null ? null : ctx.control.disabled)("clr-row", ctx.addGrid());
    }
  },
  standalone: false,
  features: [ɵɵProvidersFeature([IfControlStateService, NgControlService, ControlIdService, ControlClassService]), ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c50,
  decls: 10,
  vars: 8,
  consts: [[4, "ngIf"], [1, "clr-control-container", 3, "ngClass"], [3, "ngClass"], ["class", "clr-validate-icon", "shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 4, "ngIf"], ["class", "clr-validate-icon", "shape", "check-circle", "status", "success", "aria-hidden", "true", 4, "ngIf"], ["shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 1, "clr-validate-icon"], ["shape", "check-circle", "status", "success", "aria-hidden", "true", 1, "clr-validate-icon"]],
  template: function ClrSelectContainer_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c49);
      ɵɵprojection(0);
      ɵɵtemplate(1, ClrSelectContainer_label_1_Template, 1, 0, "label", 0);
      ɵɵelementStart(2, "div", 1)(3, "div", 2);
      ɵɵprojection(4, 1);
      ɵɵtemplate(5, ClrSelectContainer_cds_icon_5_Template, 1, 0, "cds-icon", 3)(6, ClrSelectContainer_cds_icon_6_Template, 1, 0, "cds-icon", 4);
      ɵɵelementEnd();
      ɵɵtemplate(7, ClrSelectContainer_ng_content_7_Template, 1, 0, "ng-content", 0)(8, ClrSelectContainer_ng_content_8_Template, 1, 0, "ng-content", 0)(9, ClrSelectContainer_ng_content_9_Template, 1, 0, "ng-content", 0);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.label && ctx.addGrid());
      ɵɵadvance();
      ɵɵproperty("ngClass", ctx.controlClass());
      ɵɵadvance();
      ɵɵproperty("ngClass", ctx.wrapperClass());
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showHelper);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
    }
  },
  dependencies: [NgClass, NgIf, CdsIconCustomTag, ClrLabel],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrSelectContainer, [{
    type: Component,
    args: [{
      selector: "clr-select-container",
      template: `
    <ng-content select="label"></ng-content>
    <label *ngIf="!label && addGrid()"></label>
    <div class="clr-control-container" [ngClass]="controlClass()">
      <div [ngClass]="wrapperClass()">
        <ng-content select="[clrSelect]"></ng-content>
        <cds-icon
          *ngIf="showInvalid"
          class="clr-validate-icon"
          shape="exclamation-circle"
          status="danger"
          aria-hidden="true"
        ></cds-icon>
        <cds-icon
          *ngIf="showValid"
          class="clr-validate-icon"
          shape="check-circle"
          status="success"
          aria-hidden="true"
        ></cds-icon>
      </div>
      <ng-content select="clr-control-helper" *ngIf="showHelper"></ng-content>
      <ng-content select="clr-control-error" *ngIf="showInvalid"></ng-content>
      <ng-content select="clr-control-success" *ngIf="showValid"></ng-content>
    </div>
  `,
      host: {
        "[class.clr-form-control]": "true",
        "[class.clr-form-control-disabled]": "control?.disabled",
        "[class.clr-row]": "addGrid()"
      },
      providers: [IfControlStateService, NgControlService, ControlIdService, ControlClassService]
    }]
  }], function() {
    return [{
      type: LayoutService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ControlClassService
    }, {
      type: NgControlService
    }, {
      type: IfControlStateService
    }];
  }, {
    multiple: [{
      type: ContentChild,
      args: [SelectMultipleControlValueAccessor, {
        static: false
      }]
    }]
  });
})();
var ClrSelect = class extends WrappedFormControl {
  constructor(vcr, injector, control, renderer, el) {
    super(vcr, ClrSelectContainer, injector, control, renderer, el);
    this.index = 1;
  }
};
ClrSelect.ɵfac = function ClrSelect_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrSelect)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(NgControl, 10), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
};
ClrSelect.ɵdir = ɵɵdefineDirective({
  type: ClrSelect,
  selectors: [["", "clrSelect", ""]],
  hostVars: 2,
  hostBindings: function ClrSelect_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-select", true);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrSelect, [{
    type: Directive,
    args: [{
      selector: "[clrSelect]",
      host: {
        "[class.clr-select]": "true"
      }
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }, {
      type: Injector
    }, {
      type: NgControl,
      decorators: [{
        type: Self
      }, {
        type: Optional
      }]
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }];
  }, null);
})();
var ClrSelectModule = class {
  constructor() {
    r.addIcons(o4, e);
  }
};
ClrSelectModule.ɵfac = function ClrSelectModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrSelectModule)();
};
ClrSelectModule.ɵmod = ɵɵdefineNgModule({
  type: ClrSelectModule,
  declarations: [ClrSelect, ClrSelectContainer],
  imports: [CommonModule, FormsModule, ClrIconModule, ClrCommonFormsModule],
  exports: [ClrCommonFormsModule, ClrSelect, ClrSelectContainer]
});
ClrSelectModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, FormsModule, ClrIconModule, ClrCommonFormsModule, ClrCommonFormsModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrSelectModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, ClrIconModule, ClrCommonFormsModule],
      declarations: [ClrSelect, ClrSelectContainer],
      exports: [ClrCommonFormsModule, ClrSelect, ClrSelectContainer]
    }]
  }], function() {
    return [];
  }, null);
})();
var ClrTextareaContainer = class extends ClrAbstractContainer {
};
ClrTextareaContainer.ɵfac = /* @__PURE__ */ (() => {
  let ɵClrTextareaContainer_BaseFactory;
  return function ClrTextareaContainer_Factory(__ngFactoryType__) {
    return (ɵClrTextareaContainer_BaseFactory || (ɵClrTextareaContainer_BaseFactory = ɵɵgetInheritedFactory(ClrTextareaContainer)))(__ngFactoryType__ || ClrTextareaContainer);
  };
})();
ClrTextareaContainer.ɵcmp = ɵɵdefineComponent({
  type: ClrTextareaContainer,
  selectors: [["clr-textarea-container"]],
  hostVars: 6,
  hostBindings: function ClrTextareaContainer_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-form-control", true)("clr-form-control-disabled", ctx.control == null ? null : ctx.control.disabled)("clr-row", ctx.addGrid());
    }
  },
  standalone: false,
  features: [ɵɵProvidersFeature([IfControlStateService, NgControlService, ControlIdService, ControlClassService]), ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c52,
  decls: 10,
  vars: 7,
  consts: [[4, "ngIf"], [1, "clr-control-container", 3, "ngClass"], [1, "clr-textarea-wrapper"], ["class", "clr-validate-icon", "shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 4, "ngIf"], ["class", "clr-validate-icon", "shape", "check-circle", "status", "success", "aria-hidden", "true", 4, "ngIf"], ["shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 1, "clr-validate-icon"], ["shape", "check-circle", "status", "success", "aria-hidden", "true", 1, "clr-validate-icon"]],
  template: function ClrTextareaContainer_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c51);
      ɵɵprojection(0);
      ɵɵtemplate(1, ClrTextareaContainer_label_1_Template, 1, 0, "label", 0);
      ɵɵelementStart(2, "div", 1)(3, "div", 2);
      ɵɵprojection(4, 1);
      ɵɵtemplate(5, ClrTextareaContainer_cds_icon_5_Template, 1, 0, "cds-icon", 3)(6, ClrTextareaContainer_cds_icon_6_Template, 1, 0, "cds-icon", 4);
      ɵɵelementEnd();
      ɵɵtemplate(7, ClrTextareaContainer_ng_content_7_Template, 1, 0, "ng-content", 0)(8, ClrTextareaContainer_ng_content_8_Template, 1, 0, "ng-content", 0)(9, ClrTextareaContainer_ng_content_9_Template, 1, 0, "ng-content", 0);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.label && ctx.addGrid());
      ɵɵadvance();
      ɵɵproperty("ngClass", ctx.controlClass());
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showHelper);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
    }
  },
  dependencies: [NgClass, NgIf, CdsIconCustomTag, ClrLabel],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTextareaContainer, [{
    type: Component,
    args: [{
      selector: "clr-textarea-container",
      template: `
    <ng-content select="label"></ng-content>
    <label *ngIf="!label && addGrid()"></label>
    <div class="clr-control-container" [ngClass]="controlClass()">
      <div class="clr-textarea-wrapper">
        <ng-content select="[clrTextarea]"></ng-content>
        <cds-icon
          *ngIf="showInvalid"
          class="clr-validate-icon"
          shape="exclamation-circle"
          status="danger"
          aria-hidden="true"
        ></cds-icon>
        <cds-icon
          *ngIf="showValid"
          class="clr-validate-icon"
          shape="check-circle"
          status="success"
          aria-hidden="true"
        ></cds-icon>
      </div>
      <ng-content select="clr-control-helper" *ngIf="showHelper"></ng-content>
      <ng-content select="clr-control-error" *ngIf="showInvalid"></ng-content>
      <ng-content select="clr-control-success" *ngIf="showValid"></ng-content>
    </div>
  `,
      host: {
        "[class.clr-form-control]": "true",
        "[class.clr-form-control-disabled]": "control?.disabled",
        "[class.clr-row]": "addGrid()"
      },
      providers: [IfControlStateService, NgControlService, ControlIdService, ControlClassService]
    }]
  }], null, null);
})();
var ClrTextarea = class extends WrappedFormControl {
  constructor(vcr, injector, control, renderer, el) {
    super(vcr, ClrTextareaContainer, injector, control, renderer, el);
    this.index = 1;
  }
};
ClrTextarea.ɵfac = function ClrTextarea_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrTextarea)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(NgControl, 10), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
};
ClrTextarea.ɵdir = ɵɵdefineDirective({
  type: ClrTextarea,
  selectors: [["", "clrTextarea", ""]],
  hostVars: 2,
  hostBindings: function ClrTextarea_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-textarea", true);
    }
  },
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTextarea, [{
    type: Directive,
    args: [{
      selector: "[clrTextarea]",
      host: {
        "[class.clr-textarea]": "true"
      }
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }, {
      type: Injector
    }, {
      type: NgControl,
      decorators: [{
        type: Self
      }, {
        type: Optional
      }]
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }];
  }, null);
})();
var ClrTextareaModule = class {
  constructor() {
    r.addIcons(o4, e);
  }
};
ClrTextareaModule.ɵfac = function ClrTextareaModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrTextareaModule)();
};
ClrTextareaModule.ɵmod = ɵɵdefineNgModule({
  type: ClrTextareaModule,
  declarations: [ClrTextarea, ClrTextareaContainer],
  imports: [CommonModule, FormsModule, ClrIconModule, ClrCommonFormsModule],
  exports: [ClrCommonFormsModule, ClrTextarea, ClrTextareaContainer]
});
ClrTextareaModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, FormsModule, ClrIconModule, ClrCommonFormsModule, ClrCommonFormsModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTextareaModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, ClrIconModule, ClrCommonFormsModule],
      declarations: [ClrTextarea, ClrTextareaContainer],
      exports: [ClrCommonFormsModule, ClrTextarea, ClrTextareaContainer]
    }]
  }], function() {
    return [];
  }, null);
})();
var ClrFormsModule = class {
};
ClrFormsModule.ɵfac = function ClrFormsModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrFormsModule)();
};
ClrFormsModule.ɵmod = ɵɵdefineNgModule({
  type: ClrFormsModule,
  imports: [CommonModule],
  exports: [ClrCommonFormsModule, ClrCheckboxModule, ClrComboboxModule, ClrDatepickerModule, ClrFileInputModule, ClrInputModule, ClrPasswordModule, ClrRadioModule, ClrSelectModule, ClrTextareaModule, ClrRangeModule, ClrDatalistModule, ClrNumberInputModule]
});
ClrFormsModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrCommonFormsModule, ClrCheckboxModule, ClrComboboxModule, ClrDatepickerModule, ClrFileInputModule, ClrInputModule, ClrPasswordModule, ClrRadioModule, ClrSelectModule, ClrTextareaModule, ClrRangeModule, ClrDatalistModule, ClrNumberInputModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrFormsModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      exports: [ClrCommonFormsModule, ClrCheckboxModule, ClrComboboxModule, ClrDatepickerModule, ClrFileInputModule, ClrInputModule, ClrPasswordModule, ClrRadioModule, ClrSelectModule, ClrTextareaModule, ClrRangeModule, ClrDatalistModule, ClrNumberInputModule]
    }]
  }], null, null);
})();
var ClrExpandableAnimationModule = class {
};
ClrExpandableAnimationModule.ɵfac = function ClrExpandableAnimationModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrExpandableAnimationModule)();
};
ClrExpandableAnimationModule.ɵmod = ɵɵdefineNgModule({
  type: ClrExpandableAnimationModule,
  declarations: [ClrExpandableAnimation],
  imports: [CommonModule],
  exports: [ClrExpandableAnimation]
});
ClrExpandableAnimationModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrExpandableAnimationModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [EXPANDABLE_ANIMATION_DIRECTIVES],
      exports: [EXPANDABLE_ANIMATION_DIRECTIVES]
    }]
  }], null, null);
})();
var CdkDragModule_CdkDrag = class extends CdkDrag {
  /**
   * Include the constructor to forward all the dependencies to the base class
   * as a workaround to fix Angular "ɵɵinvalidFactoryDep" error after upgrading storybook
   * https://github.com/storybookjs/storybook/issues/23534
   */
  constructor(elementRef, dropContainer, document2, ngZone, viewContainerRef, config, dir, dragDrop, changeDetectorRef) {
    super(elementRef, dropContainer, document2, ngZone, viewContainerRef, config, dir, dragDrop, changeDetectorRef);
  }
};
CdkDragModule_CdkDrag.ɵfac = function CdkDragModule_CdkDrag_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || CdkDragModule_CdkDrag)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(CDK_DROP_LIST, 8), ɵɵdirectiveInject(DOCUMENT, 8), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(CDK_DRAG_CONFIG, 8), ɵɵdirectiveInject(Directionality), ɵɵdirectiveInject(DragDrop), ɵɵdirectiveInject(ChangeDetectorRef));
};
CdkDragModule_CdkDrag.ɵdir = ɵɵdefineDirective({
  type: CdkDragModule_CdkDrag,
  selectors: [["", "cdkDrag", ""]],
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDragModule_CdkDrag, [{
    type: Directive,
    args: [{
      selector: "[cdkDrag]"
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [CDK_DROP_LIST]
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [DOCUMENT]
      }]
    }, {
      type: NgZone
    }, {
      type: ViewContainerRef
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [CDK_DRAG_CONFIG]
      }]
    }, {
      type: Directionality
    }, {
      type: DragDrop
    }, {
      type: ChangeDetectorRef
    }];
  }, null);
})();
var CdkDragModule = class {
};
CdkDragModule.ɵfac = function CdkDragModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || CdkDragModule)();
};
CdkDragModule.ɵmod = ɵɵdefineNgModule({
  type: CdkDragModule,
  declarations: [CdkDragModule_CdkDrag],
  exports: [CdkDragModule_CdkDrag]
});
CdkDragModule.ɵinj = ɵɵdefineInjector({});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDragModule, [{
    type: NgModule,
    args: [{
      declarations: [CdkDragModule_CdkDrag],
      exports: [CdkDragModule_CdkDrag]
    }]
  }], null, null);
})();
var OutsideClick = class {
  constructor(host, renderer, ngZone) {
    this.strict = false;
    this.outsideClick = new EventEmitter(false);
    ngZone.runOutsideAngular(() => {
      this.documentClickListener = renderer.listen("document", "click", (event) => {
        if (host.nativeElement === event.target) {
          return;
        }
        if (!this.strict && host.nativeElement.contains(event.target)) {
          return;
        }
        ngZone.run(() => {
          this.outsideClick.emit(event);
        });
      });
    });
  }
  ngOnDestroy() {
    this.documentClickListener();
  }
};
OutsideClick.ɵfac = function OutsideClick_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || OutsideClick)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone));
};
OutsideClick.ɵdir = ɵɵdefineDirective({
  type: OutsideClick,
  selectors: [["", "clrOutsideClick", ""]],
  inputs: {
    strict: [0, "clrStrict", "strict"]
  },
  outputs: {
    outsideClick: "clrOutsideClick"
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OutsideClick, [{
    type: Directive,
    args: [{
      selector: "[clrOutsideClick]"
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }];
  }, {
    strict: [{
      type: Input,
      args: ["clrStrict"]
    }],
    outsideClick: [{
      type: Output,
      args: ["clrOutsideClick"]
    }]
  });
})();
var OUSTIDE_CLICK_DIRECTIVES = [OutsideClick];
var ClrOutsideClickModule = class {
};
ClrOutsideClickModule.ɵfac = function ClrOutsideClickModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrOutsideClickModule)();
};
ClrOutsideClickModule.ɵmod = ɵɵdefineNgModule({
  type: ClrOutsideClickModule,
  declarations: [OutsideClick],
  imports: [CommonModule],
  exports: [OutsideClick]
});
ClrOutsideClickModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrOutsideClickModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [OUSTIDE_CLICK_DIRECTIVES],
      exports: [OUSTIDE_CLICK_DIRECTIVES]
    }]
  }], null, null);
})();
var CustomFilter = class {
};
var StateDebouncer = class {
  constructor() {
    this.nbChanges = 0;
    this._change = new Subject();
  }
  // We do not want to expose the Subject itself, but the Observable which is read-only
  get change() {
    return this._change.asObservable();
  }
  changeStart() {
    this.nbChanges++;
  }
  changeDone() {
    if (--this.nbChanges === 0) {
      this._change.next();
    }
  }
};
StateDebouncer.ɵfac = function StateDebouncer_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || StateDebouncer)();
};
StateDebouncer.ɵprov = ɵɵdefineInjectable({
  token: StateDebouncer,
  factory: StateDebouncer.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StateDebouncer, [{
    type: Injectable
  }], null, null);
})();
var Page = class {
  constructor(stateDebouncer) {
    this.stateDebouncer = stateDebouncer;
    this.activated = false;
    this._size = 0;
    this._current = 1;
    this._change = new Subject();
    this.preventEmit = false;
    this._sizeChange = new Subject();
  }
  get size() {
    return this._size;
  }
  set size(size) {
    const oldSize = this._size;
    if (size !== oldSize) {
      if (!this.preventEmit) {
        this.stateDebouncer.changeStart();
      }
      this._size = size;
      if (size === 0) {
        this._current = 1;
      } else {
        this._current = Math.floor(oldSize / size * (this._current - 1)) + 1;
      }
      if (!this.preventEmit) {
        this._change.next(this._current);
        this._sizeChange.next(this._size);
        this.stateDebouncer.changeDone();
      }
    }
    this.preventEmit = false;
  }
  get totalItems() {
    return this._totalItems || 0;
  }
  set totalItems(total) {
    this._totalItems = total;
    if (this.current > this.last) {
      this.current = this.last;
    }
  }
  get last() {
    if (this._last) {
      return this._last;
    }
    if (this.size > 0 && this.totalItems) {
      return Math.ceil(this.totalItems / this.size);
    }
    return 1;
  }
  set last(page) {
    this._last = page;
  }
  // We do not want to expose the Subject itself, but the Observable which is read-only
  get change() {
    return this._change.asObservable();
  }
  get sizeChange() {
    return this._sizeChange.asObservable();
  }
  get current() {
    return this._current;
  }
  set current(page) {
    if (page !== this._current) {
      this.stateDebouncer.changeStart();
      this._current = page;
      this._change.next(page);
      this.stateDebouncer.changeDone();
    }
  }
  /**
   * Index of the first item displayed on the current page, starting at 0, -1 if none displayed
   */
  get firstItem() {
    if (this._totalItems === 0) {
      return -1;
    }
    if (this.size === 0) {
      return 0;
    }
    return (this.current - 1) * this.size;
  }
  /**
   * Index of the last item displayed on the current page, starting at 0, -1 if none displayed
   */
  get lastItem() {
    if (this._totalItems === 0) {
      return -1;
    }
    if (this.size === 0) {
      return this.totalItems - 1;
    }
    let lastInPage = this.current * this.size - 1;
    if (this.totalItems) {
      lastInPage = Math.min(lastInPage, this.totalItems - 1);
    }
    return lastInPage;
  }
  /**
   * Moves to the previous page if it exists
   */
  previous() {
    if (this.current > 1) {
      this.current--;
    }
  }
  /**
   * Moves to the next page if it exists
   */
  next() {
    if (this.current < this.last) {
      this.current++;
    }
  }
  /**
   * Resets the page size to 0
   */
  resetPageSize(preventEmit = false) {
    this.preventEmit = preventEmit;
    this.size = 0;
  }
};
Page.ɵfac = function Page_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Page)(ɵɵinject(StateDebouncer));
};
Page.ɵprov = ɵɵdefineInjectable({
  token: Page,
  factory: Page.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Page, [{
    type: Injectable
  }], function() {
    return [{
      type: StateDebouncer
    }];
  }, null);
})();
var FiltersProvider = class {
  constructor(_page, stateDebouncer) {
    this._page = _page;
    this.stateDebouncer = stateDebouncer;
    this._change = new Subject();
    this._all = [];
  }
  // We do not want to expose the Subject itself, but the Observable which is read-only
  get change() {
    return this._change.asObservable();
  }
  /**
   * Tests if at least one filter is currently active
   */
  hasActiveFilters() {
    for (const {
      filter: filter2
    } of this._all) {
      if (filter2 && filter2.isActive()) {
        return true;
      }
    }
    return false;
  }
  /**
   * Returns a list of all currently active filters
   */
  getActiveFilters() {
    const ret = [];
    for (const {
      filter: filter2
    } of this._all) {
      if (filter2 && filter2.isActive()) {
        ret.push(filter2);
      }
    }
    return ret;
  }
  /**
   * Registers a filter, and returns a deregistration function
   */
  add(filter2) {
    const subscription = filter2.changes.subscribe(() => this.resetPageAndEmitFilterChange([filter2]));
    let hasUnregistered = false;
    const registered = new RegisteredFilter(filter2, () => {
      if (hasUnregistered) {
        return;
      }
      subscription.unsubscribe();
      const matchIndex = this._all.findIndex((item) => item.filter === filter2);
      if (matchIndex >= 0) {
        this._all.splice(matchIndex, 1);
      }
      if (filter2.isActive()) {
        this.resetPageAndEmitFilterChange([]);
      }
      hasUnregistered = true;
    });
    this._all.push(registered);
    if (filter2.isActive()) {
      this.resetPageAndEmitFilterChange([filter2]);
    }
    return registered;
  }
  /**
   * Accepts an item if it is accepted by all currently active filters
   */
  accepts(item) {
    for (const {
      filter: filter2
    } of this._all) {
      if (filter2 && filter2.isActive() && !filter2.accepts(item)) {
        return false;
      }
    }
    return true;
  }
  resetPageAndEmitFilterChange(filters) {
    this.stateDebouncer.changeStart();
    this._page.current = 1;
    this._change.next(filters);
    this.stateDebouncer.changeDone();
  }
};
FiltersProvider.ɵfac = function FiltersProvider_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || FiltersProvider)(ɵɵinject(Page), ɵɵinject(StateDebouncer));
};
FiltersProvider.ɵprov = ɵɵdefineInjectable({
  token: FiltersProvider,
  factory: FiltersProvider.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FiltersProvider, [{
    type: Injectable
  }], function() {
    return [{
      type: Page
    }, {
      type: StateDebouncer
    }];
  }, null);
})();
var RegisteredFilter = class {
  constructor(filter2, unregister) {
    this.filter = filter2;
    this.unregister = unregister;
  }
};
var DatagridFilterRegistrar = class {
  constructor(filters) {
    this.filters = filters;
  }
  get filter() {
    return this.registered && this.registered.filter;
  }
  ngOnDestroy() {
    this.deleteFilter();
  }
  setFilter(filter2) {
    this.deleteFilter();
    if (filter2 instanceof RegisteredFilter) {
      this.registered = filter2;
    } else if (filter2) {
      this.registered = this.filters.add(filter2);
    }
  }
  deleteFilter() {
    if (this.registered) {
      this.registered.unregister();
      delete this.registered;
    }
  }
};
DatagridFilterRegistrar.ɵfac = function DatagridFilterRegistrar_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || DatagridFilterRegistrar)(ɵɵdirectiveInject(FiltersProvider));
};
DatagridFilterRegistrar.ɵdir = ɵɵdefineDirective({
  type: DatagridFilterRegistrar,
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatagridFilterRegistrar, [{
    type: Directive
  }], function() {
    return [{
      type: FiltersProvider
    }];
  }, null);
})();
function getTabableItems(el) {
  const tabableSelector = ["a[href]", "area[href]", "input:not([disabled])", "button:not([disabled])", "select:not([disabled])", "textarea:not([disabled])", "iframe", "object", "embed", "*[tabindex]:not([disabled])", "*[contenteditable=true]", "[role=button]:not([disabled])"].join(",");
  return Array.from(el.querySelectorAll(tabableSelector));
}
var KeyNavigationGridController = class {
  constructor(zone) {
    this.zone = zone;
    this.skipItemFocus = false;
    this.listenersAdded = false;
    this.destroy$ = new Subject();
    this._activeCell = null;
    this.config = {
      keyGridRows: "[role=row]:not(.datagrid-placeholder)",
      keyGridCells: "[role=gridcell]:not(.datagrid-hidden-column):not(.datagrid-placeholder-content), [role=columnheader]:not(.datagrid-hidden-column):not(.datagrid-placeholder-content), .datagrid-detail-caret",
      keyGrid: "[role=grid]"
    };
  }
  get grid() {
    return this.host?.querySelector(this.config.keyGrid);
  }
  get rows() {
    return this.host?.querySelectorAll(this.config.keyGridRows);
  }
  get cells() {
    return this.host?.querySelectorAll(this.config.keyGridCells);
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  addListeners() {
    if (this.listenersAdded) {
      return;
    }
    this.zone.runOutsideAngular(() => {
      fromEvent(this.grid, "mousedown").pipe(takeUntil(this.destroy$)).subscribe((e5) => {
        if (e5.buttons === 1 && !e5.ctrlKey) {
          const activeCell = this.cells ? Array.from(this.cells).find((c) => c === e5.target || c === e5.target.closest(this.config.keyGridCells)) : null;
          if (activeCell) {
            this.setActiveCell(activeCell);
          }
        }
      });
      fromEvent(this.grid, "wheel").pipe(takeUntil(this.destroy$)).subscribe(() => {
        this.removeActiveCell();
      });
      fromEvent(this.grid, "keydown").pipe(takeUntil(this.destroy$)).subscribe((e5) => {
        if (e5.target.classList.contains("drag-handle") && (e5.code === "ArrowLeft" || e5.code === "ArrowRight")) {
          return;
        }
        if (e5.code === "ArrowUp" || e5.code === "ArrowDown" || e5.code === "ArrowLeft" || e5.code === "ArrowRight" || e5.code === "End" || e5.code === "Home" || e5.code === "PageUp" || e5.code === "PageDown") {
          const {
            x,
            y
          } = this.getNextItemCoordinate(e5);
          const activeItem = this.rows ? Array.from(this.rows[y].querySelectorAll(this.config.keyGridCells))[x] : null;
          if (activeItem) {
            this.setActiveCell(activeItem);
          }
          e5.preventDefault();
        }
      });
    });
    this.listenersAdded = true;
  }
  initializeKeyGrid(host) {
    this.host = host;
    this.addListeners();
    this.resetKeyGrid();
  }
  resetKeyGrid() {
    this.cells?.forEach((i) => i.setAttribute("tabindex", "-1"));
    const firstCell = this.cells ? this.cells[0] : null;
    firstCell?.setAttribute("tabindex", "0");
  }
  removeActiveCell() {
    this._activeCell = null;
  }
  getActiveCell() {
    return this._activeCell;
  }
  setActiveCell(activeCell) {
    const prior = this.cells ? Array.from(this.cells).find((c) => c.getAttribute("tabindex") === "0") : null;
    if (prior) {
      prior.setAttribute("tabindex", "-1");
    }
    activeCell.setAttribute("tabindex", "0");
    this._activeCell = activeCell;
    const items = getTabableItems(activeCell);
    const item = activeCell.getAttribute("role") !== "columnheader" && items[0] ? items[0] : activeCell;
    if (!this.skipItemFocus) {
      item.focus();
    }
  }
  getNextItemCoordinate(e5) {
    let currentCell = this.cells ? Array.from(this.cells).find((i) => i.getAttribute("tabindex") === "0") : null;
    if (e5.code === "Tab") {
      currentCell = document.activeElement;
    }
    const currentRow = this.rows && currentCell ? Array.from(this.rows).find((r5) => r5.contains(currentCell)) : null;
    const numOfRows = this.rows ? this.rows.length - 1 : 0;
    const numOfColumns = this.cells ? Math.floor(this.cells.length / this.rows.length - 1) : 0;
    let x = currentRow && currentCell ? Array.from(currentRow.querySelectorAll(this.config.keyGridCells)).indexOf(currentCell) : 0;
    let y = currentRow && currentCell && this.rows ? Array.from(this.rows).indexOf(currentRow) : 0;
    const dir = this.host.dir;
    const inlineStart = dir === "rtl" ? "ArrowRight" : "ArrowLeft";
    const inlineEnd = dir === "rtl" ? "ArrowLeft" : "ArrowRight";
    const itemsPerPage = Math.floor(this.host?.querySelector(".datagrid").clientHeight / this.rows[0].clientHeight) - 1 || 0;
    if (e5.code === "ArrowUp" && y !== 0) {
      y = y - 1;
    } else if (e5.code === "ArrowDown" && y < numOfRows) {
      y = y + 1;
    } else if (e5.code === inlineStart && x !== 0) {
      x = x - 1;
    } else if (e5.code === inlineEnd && x < numOfColumns) {
      x = x + 1;
    } else if (e5.code === "End") {
      x = numOfColumns;
      if (e5.ctrlKey) {
        y = numOfRows;
      }
    } else if (e5.code === "Home") {
      x = 0;
      if (e5.ctrlKey) {
        y = 0;
      }
    } else if (e5.code === "PageUp") {
      y = y - itemsPerPage > 0 ? y - itemsPerPage + 1 : 1;
    } else if (e5.code === "PageDown") {
      y = y + itemsPerPage < numOfRows ? y + itemsPerPage : numOfRows;
    }
    return {
      x,
      y
    };
  }
};
KeyNavigationGridController.ɵfac = function KeyNavigationGridController_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || KeyNavigationGridController)(ɵɵinject(NgZone));
};
KeyNavigationGridController.ɵprov = ɵɵdefineInjectable({
  token: KeyNavigationGridController,
  factory: KeyNavigationGridController.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(KeyNavigationGridController, [{
    type: Injectable
  }], function() {
    return [{
      type: NgZone
    }];
  }, null);
})();
var ClrDatagridFilter = class extends DatagridFilterRegistrar {
  constructor(_filters, commonStrings, smartToggleService, platformId, elementRef, keyNavigation) {
    super(_filters);
    this.commonStrings = commonStrings;
    this.smartToggleService = smartToggleService;
    this.platformId = platformId;
    this.elementRef = elementRef;
    this.keyNavigation = keyNavigation;
    this.openChange = new EventEmitter(false);
    this.ariaExpanded = false;
    this.popoverId = uniqueIdFactory();
    this.smartPosition = {
      axis: ClrAxis.VERTICAL,
      side: ClrSide.AFTER,
      anchor: ClrAlignment.END,
      content: ClrAlignment.END
    };
    this._open = false;
    this.subs = [];
    this.subs.push(smartToggleService.openChange.subscribe((change) => {
      this.open = change;
      this.ariaExpanded = change;
    }));
  }
  get open() {
    return this._open;
  }
  set open(open) {
    open = !!open;
    if (this.open !== open) {
      this.smartToggleService.open = open;
      this.openChange.emit(open);
      if (!open && isPlatformBrowser(this.platformId)) {
        this.anchor.nativeElement.focus();
      }
      if (this.keyNavigation) {
        this.keyNavigation.skipItemFocus = open;
      }
      this._open = open;
    }
  }
  set customFilter(filter2) {
    this.setFilter(filter2);
  }
  /**
   * Indicates if the filter is currently active
   */
  get active() {
    return !!this.filter && this.filter.isActive();
  }
  ngOnChanges() {
    setTimeout(() => {
      this.setToggleButtonAriaLabel();
    });
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    this.subs.forEach((sub) => sub.unsubscribe());
  }
  /**
   * This is not in a getter to prevent "expression has changed after it was checked" errors.
   * And it's more performant this way since it only runs on change.
   */
  setToggleButtonAriaLabel() {
    const columnElement = this.elementRef.nativeElement?.closest("clr-dg-column");
    const columnTitleElement = columnElement?.querySelector(".datagrid-column-title");
    const columnTitle = columnTitleElement?.textContent.trim().toLocaleLowerCase();
    this.toggleButtonAriaLabel = this.commonStrings.parse(this.commonStrings.keys.datagridFilterAriaLabel, {
      COLUMN: columnTitle || ""
    });
  }
};
ClrDatagridFilter.ɵfac = function ClrDatagridFilter_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDatagridFilter)(ɵɵdirectiveInject(FiltersProvider), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(ClrPopoverToggleService), ɵɵdirectiveInject(PLATFORM_ID), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(KeyNavigationGridController, 8));
};
ClrDatagridFilter.ɵcmp = ɵɵdefineComponent({
  type: ClrDatagridFilter,
  selectors: [["clr-dg-filter"]],
  viewQuery: function ClrDatagridFilter_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c53, 5, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.anchor = _t.first);
    }
  },
  inputs: {
    open: [0, "clrDgFilterOpen", "open"],
    customFilter: [0, "clrDgFilter", "customFilter"]
  },
  outputs: {
    openChange: "clrDgFilterOpenChange"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([{
    provide: CustomFilter,
    useExisting: ClrDatagridFilter
  }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
  ngContentSelectors: _c02,
  decls: 4,
  vars: 13,
  consts: [["anchor", ""], ["type", "button", "clrPopoverAnchor", "", "clrPopoverOpenCloseButton", "", 1, "datagrid-filter-toggle"], ["solid", ""], ["class", "datagrid-filter", "cdkTrapFocus", "", "role", "dialog", 3, "id", 4, "clrPopoverContent", "clrPopoverContentAt", "clrPopoverContentOutsideClickToClose", "clrPopoverContentScrollToClose"], ["cdkTrapFocus", "", "role", "dialog", 1, "datagrid-filter", 3, "id"], [1, "datagrid-filter-close-wrapper"], ["type", "button", "clrPopoverCloseButton", "", 1, "close"], ["shape", "window-close"]],
  template: function ClrDatagridFilter_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "button", 1, 0);
      ɵɵelement(2, "cds-icon", 2);
      ɵɵelementEnd();
      ɵɵtemplate(3, ClrDatagridFilter_div_3_Template, 5, 3, "div", 3);
    }
    if (rf & 2) {
      ɵɵclassProp("datagrid-filter-open", ctx.open)("datagrid-filtered", ctx.active);
      ɵɵattribute("aria-label", ctx.toggleButtonAriaLabel)("aria-expanded", ctx.ariaExpanded)("aria-controls", ctx.popoverId);
      ɵɵadvance(2);
      ɵɵattribute("status", ctx.active ? "info" : null)("shape", ctx.active ? "filter-grid-circle" : "filter-grid");
      ɵɵadvance();
      ɵɵproperty("clrPopoverContent", ctx.open)("clrPopoverContentAt", ctx.smartPosition)("clrPopoverContentOutsideClickToClose", true)("clrPopoverContentScrollToClose", true);
    }
  },
  dependencies: [CdkTrapFocusModule_CdkTrapFocus, CdsIconCustomTag, ClrPopoverAnchor, ClrPopoverCloseButton, ClrPopoverOpenCloseButton, ClrPopoverContent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridFilter, [{
    type: Component,
    args: [{
      selector: "clr-dg-filter",
      // We register this component as a CustomFilter, for the parent column to detect it.
      providers: [{
        provide: CustomFilter,
        useExisting: ClrDatagridFilter
      }],
      template: `
    <button
      class="datagrid-filter-toggle"
      type="button"
      #anchor
      [attr.aria-label]="toggleButtonAriaLabel"
      [attr.aria-expanded]="ariaExpanded"
      [attr.aria-controls]="popoverId"
      clrPopoverAnchor
      clrPopoverOpenCloseButton
      [class.datagrid-filter-open]="open"
      [class.datagrid-filtered]="active"
    >
      <cds-icon
        [attr.status]="active ? 'info' : null"
        [attr.shape]="active ? 'filter-grid-circle' : 'filter-grid'"
        solid
      ></cds-icon>
    </button>

    <div
      class="datagrid-filter"
      [id]="popoverId"
      cdkTrapFocus
      *clrPopoverContent="open; at: smartPosition; outsideClickToClose: true; scrollToClose: true"
      role="dialog"
      [attr.aria-label]="commonStrings.keys.datagridFilterDialogAriaLabel"
    >
      <div class="datagrid-filter-close-wrapper">
        <button type="button" class="close" clrPopoverCloseButton>
          <cds-icon shape="window-close" [attr.title]="commonStrings.keys.close"></cds-icon>
        </button>
      </div>

      <ng-content></ng-content>
    </div>
  `
    }]
  }], function() {
    return [{
      type: FiltersProvider
    }, {
      type: ClrCommonStringsService
    }, {
      type: ClrPopoverToggleService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }, {
      type: ElementRef
    }, {
      type: KeyNavigationGridController,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    openChange: [{
      type: Output,
      args: ["clrDgFilterOpenChange"]
    }],
    anchor: [{
      type: ViewChild,
      args: ["anchor", {
        read: ElementRef
      }]
    }],
    open: [{
      type: Input,
      args: ["clrDgFilterOpen"]
    }],
    customFilter: [{
      type: Input,
      args: ["clrDgFilter"]
    }]
  });
})();
var NestedProperty = class {
  constructor(prop) {
    this.prop = prop;
    if (prop.indexOf(".") >= 0) {
      this.splitProp = prop.split(".");
    }
  }
  // Safe getter for a deep object property, will not throw an error but return
  // undefined if one of the intermediate properties is null or undefined.
  getPropValue(item) {
    if (this.splitProp) {
      let value = item;
      for (const nestedProp of this.splitProp) {
        if (value === null || typeof value === "undefined" || typeof value[nestedProp] === "undefined") {
          return void 0;
        }
        value = value[nestedProp];
      }
      return value;
    } else {
      return item[this.prop];
    }
  }
};
var DatagridPropertyNumericFilter = class {
  constructor(prop, exact = false) {
    this.prop = prop;
    this.exact = exact;
    this.nestedProp = new NestedProperty(prop);
  }
  accepts(item, low, high) {
    const propValue = this.nestedProp.getPropValue(item);
    if (propValue === void 0) {
      return false;
    }
    if (low !== null && (typeof propValue !== "number" || propValue < low)) {
      return false;
    }
    if (high !== null && (typeof propValue !== "number" || propValue > high)) {
      return false;
    }
    return true;
  }
};
var DatagridNumericFilterImpl = class _DatagridNumericFilterImpl {
  constructor(filterFn) {
    this.filterFn = filterFn;
    this._changes = new Subject();
    this._low = null;
    this._high = null;
  }
  // We do not want to expose the Subject itself, but the Observable which is read-only
  get changes() {
    return this._changes.asObservable();
  }
  get value() {
    return [this._low, this._high];
  }
  set value(vals) {
    const low = vals[0];
    const high = vals[1];
    if (low !== this._low || high !== this._high) {
      this._low = low;
      this._high = high;
      this._changes.next([this._low, this._high]);
    }
  }
  get low() {
    return this._low;
  }
  set low(low) {
    if (low !== this._low) {
      this._low = low;
      this._changes.next([this._low, this._high]);
    }
  }
  get high() {
    return this._high;
  }
  set high(high) {
    if (high !== this._high) {
      this._high = high;
      this._changes.next([this._low, this._high]);
    }
  }
  get state() {
    if (this.filterFn instanceof DatagridPropertyNumericFilter) {
      return {
        property: this.filterFn.prop,
        low: this._low,
        high: this._high
      };
    }
    return this;
  }
  /**
   * Indicates if the filter is currently active, (at least one input is set)
   */
  isActive() {
    return this._low !== null || this.high !== null;
  }
  /**
   * Tests if an item matches a search text
   */
  accepts(item) {
    return this.filterFn.accepts(item, this._low, this._high);
  }
  equals(other) {
    if (other instanceof _DatagridNumericFilterImpl) {
      if (other.filterFn instanceof DatagridPropertyNumericFilter) {
        return this.filterFn instanceof DatagridPropertyNumericFilter && other.filterFn.prop === this.filterFn.prop && other.low === this._low && other.high === this._high;
      }
      return other === this;
    }
    return false;
  }
};
var DatagridNumericFilter = class extends DatagridFilterRegistrar {
  constructor(filters, domAdapter, commonStrings, popoverToggleService, ngZone) {
    super(filters);
    this.domAdapter = domAdapter;
    this.commonStrings = commonStrings;
    this.popoverToggleService = popoverToggleService;
    this.ngZone = ngZone;
    this.filterValueChange = new EventEmitter();
    this.open = false;
    this.subscriptions = [];
  }
  /**
   * Common setter for the input values
   */
  get value() {
    return [this.filter.low, this.filter.high];
  }
  set value(values) {
    if (this.filter && Array.isArray(values)) {
      if (values && (values[0] !== this.filter.low || values[1] !== this.filter.high)) {
        if (typeof values[0] === "number") {
          this.filter.low = values[0];
        } else {
          this.filter.low = null;
        }
        if (typeof values[1] === "number") {
          this.filter.high = values[1];
        } else {
          this.filter.high = null;
        }
        this.filterValueChange.emit(values);
      }
    } else {
      this.initFilterValues = values;
    }
  }
  /**
   * Customizable filter logic based on high and low values
   */
  set customNumericFilter(value) {
    if (value instanceof RegisteredFilter) {
      this.setFilter(value);
    } else {
      this.setFilter(new DatagridNumericFilterImpl(value));
    }
    if (this.initFilterValues) {
      this.value = this.initFilterValues;
      delete this.initFilterValues;
    }
  }
  get maxPlaceholderValue() {
    return this.maxPlaceholder || this.commonStrings.keys.maxValue;
  }
  get minPlaceholderValue() {
    return this.minPlaceholder || this.commonStrings.keys.minValue;
  }
  get fromLabelValue() {
    return this.fromLabel || this.commonStrings.keys.fromLabel;
  }
  get toLabelValue() {
    return this.toLabel || this.commonStrings.keys.toLabel;
  }
  get low() {
    if (typeof this.filter.low === "number" && isFinite(this.filter.low)) {
      return this.filter.low;
    } else {
      return null;
    }
  }
  set low(low) {
    if (typeof low === "number" && low !== this.filter.low) {
      this.filter.low = low;
      this.filterValueChange.emit([this.filter.low, this.filter.high]);
    } else if (typeof low !== "number") {
      this.filter.low = null;
      this.filterValueChange.emit([this.filter.low, this.filter.high]);
    }
  }
  get high() {
    if (typeof this.filter.high === "number" && isFinite(this.filter.high)) {
      return this.filter.high;
    } else {
      return null;
    }
  }
  set high(high) {
    if (typeof high === "number" && high !== this.filter.high) {
      this.filter.high = high;
      this.filterValueChange.emit([this.filter.low, this.filter.high]);
    } else if (typeof high !== "number") {
      this.filter.high = null;
      this.filterValueChange.emit([this.filter.low, this.filter.high]);
    }
  }
  ngAfterViewInit() {
    this.subscriptions.push(this.popoverToggleService.openChange.subscribe((openChange) => {
      this.open = openChange;
      this.ngZone.runOutsideAngular(() => {
        requestAnimationFrame(() => {
          this.domAdapter.focus(this.input.nativeElement);
        });
      });
    }));
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    this.subscriptions.forEach((sub) => {
      sub.unsubscribe();
    });
  }
};
DatagridNumericFilter.ɵfac = function DatagridNumericFilter_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || DatagridNumericFilter)(ɵɵdirectiveInject(FiltersProvider), ɵɵdirectiveInject(DomAdapter), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(ClrPopoverToggleService), ɵɵdirectiveInject(NgZone));
};
DatagridNumericFilter.ɵcmp = ɵɵdefineComponent({
  type: DatagridNumericFilter,
  selectors: [["clr-dg-numeric-filter"]],
  viewQuery: function DatagridNumericFilter_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c54, 5);
      ɵɵviewQuery(ClrDatagridFilter, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.input = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.filterContainer = _t.first);
    }
  },
  inputs: {
    minPlaceholder: [0, "clrFilterMinPlaceholder", "minPlaceholder"],
    maxPlaceholder: [0, "clrFilterMaxPlaceholder", "maxPlaceholder"],
    fromLabel: [0, "clrFilterFromLabel", "fromLabel"],
    toLabel: [0, "clrFilterToLabel", "toLabel"],
    value: [0, "clrFilterValue", "value"],
    customNumericFilter: [0, "clrDgNumericFilter", "customNumericFilter"]
  },
  outputs: {
    filterValueChange: "clrFilterValueChange"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([{
    provide: CustomFilter,
    useExisting: DatagridNumericFilter
  }]), ɵɵInheritDefinitionFeature],
  decls: 12,
  vars: 10,
  consts: [["input_low", ""], ["input_high", ""], [3, "clrDgFilterOpenChange", "clrDgFilter", "clrDgFilterOpen"], [1, "datagrid-numeric-filter-form"], [1, "clr-control-label"], ["clrNumberInput", "", "type", "number", "autocomplete", "off", "name", "low", 1, "datagrid-numeric-filter-input", 3, "ngModelChange", "ngModel", "placeholder"], ["clrNumberInput", "", "type", "number", "autocomplete", "off", "name", "high", 1, "datagrid-numeric-filter-input", 3, "ngModelChange", "ngModel", "placeholder"]],
  template: function DatagridNumericFilter_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "clr-dg-filter", 2);
      ɵɵtwoWayListener("clrDgFilterOpenChange", function DatagridNumericFilter_Template_clr_dg_filter_clrDgFilterOpenChange_0_listener($event) {
        ɵɵrestoreView(_r1);
        ɵɵtwoWayBindingSet(ctx.open, $event) || (ctx.open = $event);
        return ɵɵresetView($event);
      });
      ɵɵelementStart(1, "div", 3)(2, "clr-number-input-container")(3, "label", 4);
      ɵɵtext(4);
      ɵɵelementEnd();
      ɵɵelementStart(5, "input", 5, 0);
      ɵɵtwoWayListener("ngModelChange", function DatagridNumericFilter_Template_input_ngModelChange_5_listener($event) {
        ɵɵrestoreView(_r1);
        ɵɵtwoWayBindingSet(ctx.low, $event) || (ctx.low = $event);
        return ɵɵresetView($event);
      });
      ɵɵelementEnd()();
      ɵɵelementStart(7, "clr-number-input-container")(8, "label", 4);
      ɵɵtext(9);
      ɵɵelementEnd();
      ɵɵelementStart(10, "input", 6, 1);
      ɵɵtwoWayListener("ngModelChange", function DatagridNumericFilter_Template_input_ngModelChange_10_listener($event) {
        ɵɵrestoreView(_r1);
        ɵɵtwoWayBindingSet(ctx.high, $event) || (ctx.high = $event);
        return ɵɵresetView($event);
      });
      ɵɵelementEnd()()()();
    }
    if (rf & 2) {
      ɵɵproperty("clrDgFilter", ctx.registered);
      ɵɵtwoWayProperty("clrDgFilterOpen", ctx.open);
      ɵɵadvance(4);
      ɵɵtextInterpolate(ctx.fromLabelValue);
      ɵɵadvance();
      ɵɵtwoWayProperty("ngModel", ctx.low);
      ɵɵproperty("placeholder", ctx.minPlaceholderValue);
      ɵɵattribute("aria-label", ctx.minPlaceholderValue);
      ɵɵadvance(4);
      ɵɵtextInterpolate(ctx.toLabelValue);
      ɵɵadvance();
      ɵɵtwoWayProperty("ngModel", ctx.high);
      ɵɵproperty("placeholder", ctx.maxPlaceholderValue);
      ɵɵattribute("aria-label", ctx.maxPlaceholderValue);
    }
  },
  dependencies: [ClrLabel, ClrNumberInput, ClrNumberInputContainer, DefaultValueAccessor, NumberValueAccessor, NgControlStatus, NgModel, ClrDatagridFilter],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatagridNumericFilter, [{
    type: Component,
    args: [{
      selector: "clr-dg-numeric-filter",
      providers: [{
        provide: CustomFilter,
        useExisting: DatagridNumericFilter
      }],
      template: `
    <clr-dg-filter [clrDgFilter]="registered" [(clrDgFilterOpen)]="open">
      <div class="datagrid-numeric-filter-form">
        <clr-number-input-container>
          <label class="clr-control-label">{{ fromLabelValue }}</label>
          <input
            clrNumberInput
            class="datagrid-numeric-filter-input"
            #input_low
            type="number"
            autocomplete="off"
            name="low"
            [(ngModel)]="low"
            [placeholder]="minPlaceholderValue"
            [attr.aria-label]="minPlaceholderValue"
          />
        </clr-number-input-container>
        <clr-number-input-container>
          <label class="clr-control-label">{{ toLabelValue }}</label>
          <input
            clrNumberInput
            class="datagrid-numeric-filter-input"
            #input_high
            type="number"
            autocomplete="off"
            name="high"
            [(ngModel)]="high"
            [placeholder]="maxPlaceholderValue"
            [attr.aria-label]="maxPlaceholderValue"
          />
        </clr-number-input-container>
      </div>
    </clr-dg-filter>
  `
    }]
  }], function() {
    return [{
      type: FiltersProvider
    }, {
      type: DomAdapter
    }, {
      type: ClrCommonStringsService
    }, {
      type: ClrPopoverToggleService
    }, {
      type: NgZone
    }];
  }, {
    minPlaceholder: [{
      type: Input,
      args: ["clrFilterMinPlaceholder"]
    }],
    maxPlaceholder: [{
      type: Input,
      args: ["clrFilterMaxPlaceholder"]
    }],
    fromLabel: [{
      type: Input,
      args: ["clrFilterFromLabel"]
    }],
    toLabel: [{
      type: Input,
      args: ["clrFilterToLabel"]
    }],
    filterValueChange: [{
      type: Output,
      args: ["clrFilterValueChange"]
    }],
    input: [{
      type: ViewChild,
      args: ["input_low"]
    }],
    filterContainer: [{
      type: ViewChild,
      args: [ClrDatagridFilter]
    }],
    value: [{
      type: Input,
      args: ["clrFilterValue"]
    }],
    customNumericFilter: [{
      type: Input,
      args: ["clrDgNumericFilter"]
    }]
  });
})();
var DatagridPropertyStringFilter = class {
  constructor(prop, exact = false) {
    this.prop = prop;
    this.exact = exact;
    this.nestedProp = new NestedProperty(prop);
  }
  accepts(item, search) {
    const propValue = this.nestedProp.getPropValue(item);
    if (typeof propValue === "undefined") {
      return false;
    } else if (this.exact) {
      return ("" + propValue).toLowerCase() === search;
    } else {
      return ("" + propValue).toLowerCase().indexOf(search) >= 0;
    }
  }
};
var DatagridStringFilterImpl = class _DatagridStringFilterImpl {
  constructor(filterFn) {
    this.filterFn = filterFn;
    this._changes = new Subject();
    this._lowerCaseValue = "";
    this._rawValue = "";
  }
  // We do not want to expose the Subject itself, but the Observable which is read-only
  get changes() {
    return this._changes.asObservable();
  }
  get lowerCaseValue() {
    return this._lowerCaseValue;
  }
  get state() {
    if (this.filterFn instanceof DatagridPropertyStringFilter) {
      return {
        property: this.filterFn.prop,
        value: this.value
      };
    }
    return this;
  }
  get value() {
    return this._rawValue;
  }
  /**
   * Common setter for the input value
   */
  set value(value) {
    if (!value) {
      value = "";
    }
    if (value !== this._rawValue) {
      this._rawValue = value;
      this._lowerCaseValue = value.toLowerCase().trim();
      this._changes.next(value);
    }
  }
  /**
   * Indicates if the filter is currently active, meaning the input is not empty
   */
  isActive() {
    return !!this.value;
  }
  /**
   * Tests if an item matches a search text
   */
  accepts(item) {
    return this.filterFn.accepts(item, this.lowerCaseValue);
  }
  equals(other) {
    if (other instanceof _DatagridStringFilterImpl) {
      if (other.filterFn instanceof DatagridPropertyStringFilter) {
        return this.filterFn instanceof DatagridPropertyStringFilter && other.filterFn.prop === this.filterFn.prop && other.value === this.value;
      }
      return other === this;
    }
    return false;
  }
};
var DatagridStringFilter = class extends DatagridFilterRegistrar {
  constructor(filters, domAdapter, commonStrings, smartToggleService, elementRef, cdr, ngZone) {
    super(filters);
    this.domAdapter = domAdapter;
    this.commonStrings = commonStrings;
    this.smartToggleService = smartToggleService;
    this.elementRef = elementRef;
    this.cdr = cdr;
    this.ngZone = ngZone;
    this.filterValueChange = new EventEmitter();
    this.open = false;
    this.labelValue = "";
    this.subs = [];
  }
  /**
   * Customizable filter logic based on a search text
   */
  set customStringFilter(value) {
    if (value instanceof RegisteredFilter) {
      this.setFilter(value);
    } else {
      this.setFilter(new DatagridStringFilterImpl(value));
    }
    if (this.initFilterValue) {
      this.value = this.initFilterValue;
      delete this.initFilterValue;
    }
  }
  /**
   * Common setter for the input value
   */
  get value() {
    return this.filter.value;
  }
  set value(value) {
    if (this.filter && typeof value === "string") {
      if (!value) {
        value = "";
      }
      if (value !== this.filter.value) {
        this.filter.value = value;
        this.filterValueChange.emit(value);
      }
    } else {
      this.initFilterValue = value;
    }
  }
  get placeholderValue() {
    return this.placeholder || this.commonStrings.keys.filterItems;
  }
  ngAfterViewInit() {
    this.subs.push(this.smartToggleService.openChange.subscribe((openChange) => {
      this.open = openChange;
      this.ngZone.runOutsideAngular(() => {
        requestAnimationFrame(() => {
          this.domAdapter.focus(this.input.nativeElement);
        });
      });
    }));
  }
  ngOnChanges() {
    setTimeout(() => {
      this.setFilterLabel();
      this.cdr.markForCheck();
    });
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    this.subs.forEach((sub) => sub.unsubscribe());
  }
  /**
   * This is not in a getter to prevent "expression has changed after it was checked" errors.
   */
  setFilterLabel() {
    if (this.label) {
      this.labelValue = this.label;
      return;
    }
    const columnElement = this.elementRef.nativeElement?.closest("clr-dg-column");
    const columnTitleElement = columnElement?.querySelector(".datagrid-column-title");
    this.labelValue = this.commonStrings.parse(this.commonStrings.keys.datagridFilterLabel, {
      COLUMN: columnTitleElement?.textContent.trim() || ""
    });
  }
};
DatagridStringFilter.ɵfac = function DatagridStringFilter_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || DatagridStringFilter)(ɵɵdirectiveInject(FiltersProvider), ɵɵdirectiveInject(DomAdapter), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(ClrPopoverToggleService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone));
};
DatagridStringFilter.ɵcmp = ɵɵdefineComponent({
  type: DatagridStringFilter,
  selectors: [["clr-dg-string-filter"]],
  viewQuery: function DatagridStringFilter_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c55, 5);
      ɵɵviewQuery(ClrDatagridFilter, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.input = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.filterContainer = _t.first);
    }
  },
  inputs: {
    placeholder: [0, "clrFilterPlaceholder", "placeholder"],
    label: [0, "clrFilterLabel", "label"],
    customStringFilter: [0, "clrDgStringFilter", "customStringFilter"],
    value: [0, "clrFilterValue", "value"]
  },
  outputs: {
    filterValueChange: "clrFilterValueChange"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([{
    provide: CustomFilter,
    useExisting: DatagridStringFilter
  }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
  decls: 6,
  vars: 6,
  consts: [["input", ""], [3, "clrDgFilterOpenChange", "clrDgFilter", "clrDgFilterOpen"], ["type", "text", "autocomplete", "off", "name", "search", "clrInput", "", 3, "ngModelChange", "ngModel", "placeholder"]],
  template: function DatagridStringFilter_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "clr-dg-filter", 1);
      ɵɵtwoWayListener("clrDgFilterOpenChange", function DatagridStringFilter_Template_clr_dg_filter_clrDgFilterOpenChange_0_listener($event) {
        ɵɵrestoreView(_r1);
        ɵɵtwoWayBindingSet(ctx.open, $event) || (ctx.open = $event);
        return ɵɵresetView($event);
      });
      ɵɵelementStart(1, "clr-input-container")(2, "label");
      ɵɵtext(3);
      ɵɵelementEnd();
      ɵɵelementStart(4, "input", 2, 0);
      ɵɵtwoWayListener("ngModelChange", function DatagridStringFilter_Template_input_ngModelChange_4_listener($event) {
        ɵɵrestoreView(_r1);
        ɵɵtwoWayBindingSet(ctx.value, $event) || (ctx.value = $event);
        return ɵɵresetView($event);
      });
      ɵɵelementEnd()()();
    }
    if (rf & 2) {
      ɵɵproperty("clrDgFilter", ctx.registered);
      ɵɵtwoWayProperty("clrDgFilterOpen", ctx.open);
      ɵɵadvance(3);
      ɵɵtextInterpolate(ctx.labelValue);
      ɵɵadvance();
      ɵɵtwoWayProperty("ngModel", ctx.value);
      ɵɵproperty("placeholder", ctx.placeholderValue);
      ɵɵattribute("aria-label", ctx.placeholderValue);
    }
  },
  dependencies: [ClrLabel, ClrInput, ClrInputContainer, DefaultValueAccessor, NgControlStatus, NgModel, ClrDatagridFilter],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatagridStringFilter, [{
    type: Component,
    args: [{
      selector: "clr-dg-string-filter",
      providers: [{
        provide: CustomFilter,
        useExisting: DatagridStringFilter
      }],
      template: `
    <clr-dg-filter [clrDgFilter]="registered" [(clrDgFilterOpen)]="open">
      <clr-input-container>
        <label>{{ labelValue }}</label>
        <input
          #input
          type="text"
          autocomplete="off"
          name="search"
          [(ngModel)]="value"
          clrInput
          [attr.aria-label]="placeholderValue"
          [placeholder]="placeholderValue"
        />
      </clr-input-container>
    </clr-dg-filter>
  `
    }]
  }], function() {
    return [{
      type: FiltersProvider
    }, {
      type: DomAdapter
    }, {
      type: ClrCommonStringsService
    }, {
      type: ClrPopoverToggleService
    }, {
      type: ElementRef
    }, {
      type: ChangeDetectorRef
    }, {
      type: NgZone
    }];
  }, {
    placeholder: [{
      type: Input,
      args: ["clrFilterPlaceholder"]
    }],
    label: [{
      type: Input,
      args: ["clrFilterLabel"]
    }],
    filterValueChange: [{
      type: Output,
      args: ["clrFilterValueChange"]
    }],
    input: [{
      type: ViewChild,
      args: ["input"]
    }],
    filterContainer: [{
      type: ViewChild,
      args: [ClrDatagridFilter]
    }],
    customStringFilter: [{
      type: Input,
      args: ["clrDgStringFilter"]
    }],
    value: [{
      type: Input,
      args: ["clrFilterValue"]
    }]
  });
})();
var DatagridWillyWonka = class extends WillyWonka {
};
DatagridWillyWonka.ɵfac = /* @__PURE__ */ (() => {
  let ɵDatagridWillyWonka_BaseFactory;
  return function DatagridWillyWonka_Factory(__ngFactoryType__) {
    return (ɵDatagridWillyWonka_BaseFactory || (ɵDatagridWillyWonka_BaseFactory = ɵɵgetInheritedFactory(DatagridWillyWonka)))(__ngFactoryType__ || DatagridWillyWonka);
  };
})();
DatagridWillyWonka.ɵdir = ɵɵdefineDirective({
  type: DatagridWillyWonka,
  selectors: [["clr-datagrid"]],
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatagridWillyWonka, [{
    type: Directive,
    args: [{
      selector: "clr-datagrid"
    }]
  }], null, null);
})();
var RowActionService = class {
  constructor() {
    this.actionableCount = 0;
  }
  /**
   * false means no rows with action
   */
  get hasActionableRow() {
    return this.actionableCount > 0;
  }
  register() {
    this.actionableCount++;
  }
  unregister() {
    this.actionableCount--;
  }
};
RowActionService.ɵfac = function RowActionService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RowActionService)();
};
RowActionService.ɵprov = ɵɵdefineInjectable({
  token: RowActionService,
  factory: RowActionService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RowActionService, [{
    type: Injectable
  }], null, null);
})();
var ActionableOompaLoompa = class extends OompaLoompa {
  constructor(cdr, willyWonka, rowActions) {
    if (!willyWonka) {
      throw new Error("clr-dg-row should only be used inside of a clr-datagrid");
    }
    super(cdr, willyWonka);
    this.rowActions = rowActions;
  }
  get flavor() {
    return this.rowActions.hasActionableRow;
  }
};
ActionableOompaLoompa.ɵfac = function ActionableOompaLoompa_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ActionableOompaLoompa)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(DatagridWillyWonka, 8), ɵɵdirectiveInject(RowActionService));
};
ActionableOompaLoompa.ɵdir = ɵɵdefineDirective({
  type: ActionableOompaLoompa,
  selectors: [["clr-datagrid"], ["clr-dg-row"]],
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ActionableOompaLoompa, [{
    type: Directive,
    args: [{
      selector: "clr-datagrid, clr-dg-row"
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: DatagridWillyWonka,
      decorators: [{
        type: Optional
      }]
    }, {
      type: RowActionService
    }];
  }, null);
})();
var ModalStackService = class {
  constructor(platformId) {
    this.platformId = platformId;
    this.modalStack = [];
    this.keyUpEventListener = this.onKeyUp.bind(this);
  }
  trackModalOpen(openedModal) {
    if (this.modalStack.includes(openedModal) === false) {
      this.modalStack.unshift(openedModal);
    }
    if (isPlatformBrowser(this.platformId)) {
      document.body.addEventListener("keyup", this.keyUpEventListener);
    }
  }
  trackModalClose(closedModal) {
    const closedModalIndex = this.modalStack.indexOf(closedModal);
    if (closedModalIndex > -1) {
      this.modalStack.splice(closedModalIndex, 1);
    }
    if (this.modalStack.length === 0 && isPlatformBrowser(this.platformId)) {
      document.body.removeEventListener("keyup", this.keyUpEventListener);
    }
  }
  onKeyUp(event) {
    if (this.modalStack.length && normalizeKey(event.key) === Keys.Escape) {
      document.activeElement.blur();
      this.modalStack[0].close();
    }
  }
};
ModalStackService.ɵfac = function ModalStackService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ModalStackService)(ɵɵinject(PLATFORM_ID));
};
ModalStackService.ɵprov = ɵɵdefineInjectable({
  token: ModalStackService,
  factory: ModalStackService.ɵfac,
  providedIn: "root"
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ModalStackService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }];
  }, null);
})();
var DetailService = class {
  constructor(modalStackService) {
    this.modalStackService = modalStackService;
    this.preventScroll = false;
    this.toggleState = false;
    this._enabled = false;
    this._state = new BehaviorSubject(this.toggleState);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(state2) {
    this._enabled = state2;
  }
  get preventFocusScroll() {
    return this.preventScroll;
  }
  set preventFocusScroll(preventScroll) {
    this.preventScroll = preventScroll;
  }
  get state() {
    return this.cache;
  }
  get stateChange() {
    return this._state.asObservable();
  }
  get isOpen() {
    return this.toggleState === true;
  }
  open(item, button) {
    this.cache = item;
    this.button = button;
    this.toggleState = true;
    this._state.next(this.toggleState);
    this.modalStackService.trackModalOpen(this);
  }
  close() {
    this.toggleState = false;
    this.returnFocus();
    this._state.next(this.toggleState);
    this.modalStackService.trackModalClose(this);
  }
  returnFocus() {
    if (this.button) {
      this.button.focus({
        preventScroll: this.preventFocusScroll
      });
      this.button = null;
    }
  }
  toggle(item, button) {
    if (this.isRowOpen(item) || !item) {
      this.close();
    } else {
      this.open(item, button);
    }
  }
  isRowOpen(item) {
    return !!(this.toggleState && this.cache === item);
  }
};
DetailService.ɵfac = function DetailService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || DetailService)(ɵɵinject(ModalStackService));
};
DetailService.ɵprov = ɵɵdefineInjectable({
  token: DetailService,
  factory: DetailService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DetailService, [{
    type: Injectable
  }], function() {
    return [{
      type: ModalStackService
    }];
  }, null);
})();
var ExpandableRowsCount = class {
  constructor(detailService) {
    this.detailService = detailService;
    this.expandableCount = 0;
  }
  /**
   * false means no rows with action
   * check if details are on, and disable rows entirely
   */
  get hasExpandableRow() {
    return !this.detailService.enabled && this.expandableCount > 0;
  }
  register() {
    this.expandableCount++;
  }
  unregister() {
    this.expandableCount--;
  }
};
ExpandableRowsCount.ɵfac = function ExpandableRowsCount_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ExpandableRowsCount)(ɵɵinject(DetailService));
};
ExpandableRowsCount.ɵprov = ɵɵdefineInjectable({
  token: ExpandableRowsCount,
  factory: ExpandableRowsCount.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExpandableRowsCount, [{
    type: Injectable
  }], function() {
    return [{
      type: DetailService
    }];
  }, null);
})();
var ExpandableOompaLoompa = class extends OompaLoompa {
  constructor(cdr, willyWonka, expandableCount) {
    if (!willyWonka) {
      throw new Error("clr-dg-row should only be used inside of a clr-datagrid");
    }
    super(cdr, willyWonka);
    this.expandableCount = expandableCount;
  }
  get flavor() {
    return this.expandableCount.hasExpandableRow;
  }
};
ExpandableOompaLoompa.ɵfac = function ExpandableOompaLoompa_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ExpandableOompaLoompa)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(DatagridWillyWonka, 8), ɵɵdirectiveInject(ExpandableRowsCount));
};
ExpandableOompaLoompa.ɵdir = ɵɵdefineDirective({
  type: ExpandableOompaLoompa,
  selectors: [["clr-datagrid"], ["clr-dg-row"]],
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExpandableOompaLoompa, [{
    type: Directive,
    args: [{
      selector: "clr-datagrid, clr-dg-row"
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: DatagridWillyWonka,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ExpandableRowsCount
    }];
  }, null);
})();
var DatagridPropertyComparator = class {
  constructor(prop) {
    this.prop = prop;
    this.nestedProp = new NestedProperty(prop);
  }
  compare(a, b) {
    let propA = this.nestedProp.getPropValue(a);
    let propB = this.nestedProp.getPropValue(b);
    if (typeof propA === "string") {
      propA = propA.toLowerCase();
    }
    if (typeof propB === "string") {
      propB = propB.toLowerCase();
    }
    if (typeof propA === "undefined" || propA === null) {
      if (typeof propB === "undefined" || propB === null) {
        return 0;
      } else {
        return 1;
      }
    } else {
      if (typeof propB === "undefined" || propB === null) {
        return -1;
      } else if (propA < propB) {
        return -1;
      } else if (propA > propB) {
        return 1;
      } else {
        return 0;
      }
    }
  }
};
var ClrDatagridSortOrder;
(function(ClrDatagridSortOrder2) {
  ClrDatagridSortOrder2[ClrDatagridSortOrder2["UNSORTED"] = 0] = "UNSORTED";
  ClrDatagridSortOrder2[ClrDatagridSortOrder2["ASC"] = 1] = "ASC";
  ClrDatagridSortOrder2[ClrDatagridSortOrder2["DESC"] = -1] = "DESC";
})(ClrDatagridSortOrder || (ClrDatagridSortOrder = {}));
var STRICT_WIDTH_CLASS = "datagrid-fixed-width";
var HIDDEN_COLUMN_CLASS = "datagrid-hidden-column";
var WrappedColumn = class {
  constructor() {
    this._dynamic = false;
  }
  ngAfterViewInit() {
    this.columnView = this.templateRef.createEmbeddedView(null);
  }
  ngOnDestroy() {
    this.columnView.destroy();
  }
};
WrappedColumn.ɵfac = function WrappedColumn_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || WrappedColumn)();
};
WrappedColumn.ɵcmp = ɵɵdefineComponent({
  type: WrappedColumn,
  selectors: [["dg-wrapped-column"]],
  viewQuery: function WrappedColumn_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c56, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.templateRef = _t.first);
    }
  },
  standalone: false,
  ngContentSelectors: _c02,
  decls: 2,
  vars: 0,
  consts: [["columnPortal", ""]],
  template: function WrappedColumn_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, WrappedColumn_ng_template_0_Template, 1, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WrappedColumn, [{
    type: Component,
    args: [{
      selector: "dg-wrapped-column",
      template: `
    <ng-template #columnPortal>
      <ng-content></ng-content>
    </ng-template>
  `
    }]
  }], null, {
    templateRef: [{
      type: ViewChild,
      args: ["columnPortal"]
    }]
  });
})();
var Sort = class {
  constructor(stateDebouncer) {
    this.stateDebouncer = stateDebouncer;
    this._reverse = false;
    this._change = new Subject();
  }
  get comparator() {
    return this._comparator;
  }
  set comparator(value) {
    this.stateDebouncer.changeStart();
    this._comparator = value;
    this.emitChange();
    this.stateDebouncer.changeDone();
  }
  get reverse() {
    return this._reverse;
  }
  set reverse(value) {
    this.stateDebouncer.changeStart();
    this._reverse = value;
    this.emitChange();
    this.stateDebouncer.changeDone();
  }
  // We do not want to expose the Subject itself, but the Observable which is read-only
  get change() {
    return this._change.asObservable();
  }
  /**
   * Sets a comparator as the current one, or toggles reverse if the comparator is already used. The
   * optional forceReverse input parameter allows to override that toggling behavior by sorting in
   * reverse order if `true`.
   *
   * @memberof Sort
   */
  toggle(sortBy, forceReverse) {
    this.stateDebouncer.changeStart();
    if (this.comparator === sortBy) {
      this._reverse = typeof forceReverse !== "undefined" ? forceReverse || !this._reverse : !this._reverse;
    } else {
      this._comparator = sortBy;
      this._reverse = typeof forceReverse !== "undefined" ? forceReverse : false;
    }
    this.emitChange();
    this.stateDebouncer.changeDone();
  }
  /**
   * Clears the current sorting order
   */
  clear() {
    this.comparator = null;
  }
  /**
   * Compares two objects according to the current comparator
   */
  compare(a, b) {
    return (this.reverse ? -1 : 1) * this.comparator.compare(a, b);
  }
  emitChange() {
    this._change.next(this);
  }
};
Sort.ɵfac = function Sort_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Sort)(ɵɵinject(StateDebouncer));
};
Sort.ɵprov = ɵɵdefineInjectable({
  token: Sort,
  factory: Sort.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Sort, [{
    type: Injectable
  }], function() {
    return [{
      type: StateDebouncer
    }];
  }, null);
})();
var DatagridRenderStep;
(function(DatagridRenderStep2) {
  DatagridRenderStep2[DatagridRenderStep2["ALIGN_COLUMNS"] = 0] = "ALIGN_COLUMNS";
  DatagridRenderStep2[DatagridRenderStep2["CALCULATE_MODE_ON"] = 1] = "CALCULATE_MODE_ON";
  DatagridRenderStep2[DatagridRenderStep2["CALCULATE_MODE_OFF"] = 2] = "CALCULATE_MODE_OFF";
  DatagridRenderStep2[DatagridRenderStep2["CLEAR_WIDTHS"] = 3] = "CLEAR_WIDTHS";
  DatagridRenderStep2[DatagridRenderStep2["COMPUTE_COLUMN_WIDTHS"] = 4] = "COMPUTE_COLUMN_WIDTHS";
})(DatagridRenderStep || (DatagridRenderStep = {}));
var DatagridRenderOrganizer = class {
  constructor() {
    this._renderStep = new Subject();
    this.alreadySized = false;
  }
  get renderStep() {
    return this._renderStep.asObservable();
  }
  filterRenderSteps(step) {
    return this.renderStep.pipe(filter((testStep) => step === testStep));
  }
  resize() {
    this._renderStep.next(DatagridRenderStep.CALCULATE_MODE_ON);
    if (this.alreadySized) {
      this._renderStep.next(DatagridRenderStep.CLEAR_WIDTHS);
    }
    this._renderStep.next(DatagridRenderStep.COMPUTE_COLUMN_WIDTHS);
    this._renderStep.next(DatagridRenderStep.ALIGN_COLUMNS);
    this.alreadySized = true;
    this._renderStep.next(DatagridRenderStep.CALCULATE_MODE_OFF);
  }
};
DatagridRenderOrganizer.ɵfac = function DatagridRenderOrganizer_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || DatagridRenderOrganizer)();
};
DatagridRenderOrganizer.ɵprov = ɵɵdefineInjectable({
  token: DatagridRenderOrganizer,
  factory: DatagridRenderOrganizer.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatagridRenderOrganizer, [{
    type: Injectable
  }], null, null);
})();
var MIN_COLUMN_WIDTH = 96;
var ColumnResizerService = class {
  constructor(el, domAdapter, organizer) {
    this.el = el;
    this.domAdapter = domAdapter;
    this.organizer = organizer;
    this._resizedBy = 0;
  }
  get resizedBy() {
    return this._resizedBy;
  }
  get minColumnWidth() {
    return this.domAdapter.minWidth(this.el.nativeElement) || MIN_COLUMN_WIDTH;
  }
  get maxResizeRange() {
    return this.widthBeforeResize - this.minColumnWidth;
  }
  get widthAfterResize() {
    return this.widthBeforeResize + this._resizedBy;
  }
  startResize() {
    this._resizedBy = 0;
    this.isWithinMaxResizeRange = true;
    this.widthBeforeResize = this.domAdapter.clientRect(this.el.nativeElement).width;
  }
  endResize() {
    this.organizer.resize();
  }
  calculateResize(resizedBy) {
    if (resizedBy < -this.maxResizeRange) {
      this._resizedBy = -this.maxResizeRange;
      this.isWithinMaxResizeRange = false;
    } else {
      this._resizedBy = resizedBy;
      this.isWithinMaxResizeRange = true;
    }
  }
};
ColumnResizerService.ɵfac = function ColumnResizerService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ColumnResizerService)(ɵɵinject(ElementRef), ɵɵinject(DomAdapter), ɵɵinject(DatagridRenderOrganizer));
};
ColumnResizerService.ɵprov = ɵɵdefineInjectable({
  token: ColumnResizerService,
  factory: ColumnResizerService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnResizerService, [{
    type: Injectable
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: DomAdapter
    }, {
      type: DatagridRenderOrganizer
    }];
  }, null);
})();
var TableSizeService = class {
  constructor(platformId) {
    this.platformId = platformId;
  }
  get tableRef() {
    return this._tableRef;
  }
  set tableRef(element) {
    this._tableRef = element;
  }
  set table(table) {
    if (isPlatformBrowser(this.platformId) && table.nativeElement) {
      this.tableRef = table.nativeElement.querySelector(".datagrid-table");
    }
  }
  // Used when resizing columns to show the column border being dragged.
  getColumnDragHeight() {
    if (!this.tableRef) {
      return null;
    }
    return `${this.tableRef.clientHeight}px`;
  }
};
TableSizeService.ɵfac = function TableSizeService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TableSizeService)(ɵɵinject(PLATFORM_ID));
};
TableSizeService.ɵprov = ɵɵdefineInjectable({
  token: TableSizeService,
  factory: TableSizeService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableSizeService, [{
    type: Injectable
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }];
  }, null);
})();
var KEYBOARD_RESIZE_LENGTH = 12;
var ClrDatagridColumnSeparator = class {
  constructor(columnResizerService, renderer, ngZone, tableSizeService, commonString, document2) {
    this.columnResizerService = columnResizerService;
    this.renderer = renderer;
    this.ngZone = ngZone;
    this.tableSizeService = tableSizeService;
    this.commonString = commonString;
    this.document = document2;
    this.columnSeparatorId = uniqueIdFactory();
    this.resizeStartedOnKeyDown = false;
    this.unlisteners = [];
  }
  get descriptionId() {
    return `${this.columnSeparatorId}-aria-describedby`;
  }
  get resizeTrackerEl() {
    return this.resizeTrackerRef.nativeElement;
  }
  get columnHandleEl() {
    return this.columnHandleRef.nativeElement;
  }
  ngAfterViewInit() {
    this.ngZone.runOutsideAngular(() => {
      this.unlisteners.push(this.renderer.listen(this.columnHandleEl, "keydown", (event) => {
        this.showTrackerOnFirstKeyDown(event);
        this.moveTrackerOnKeyDown(event);
      }));
      this.unlisteners.push(this.renderer.listen(this.columnHandleEl, "keyup", (event) => {
        this.hideTrackerOnKeyUp(event);
      }));
    });
  }
  ngOnDestroy() {
    this.unlisteners.forEach((unlistener) => unlistener());
  }
  showTracker() {
    this.columnResizerService.startResize();
    const tableHeight = this.tableSizeService.getColumnDragHeight();
    this.renderer.setStyle(this.resizeTrackerEl, "height", tableHeight);
    this.renderer.setStyle(this.resizeTrackerEl, "display", "block");
  }
  moveTracker(movedBy) {
    this.columnResizerService.calculateResize(movedBy);
    this.renderer.setStyle(this.resizeTrackerEl, "transform", `translateX(${this.columnResizerService.resizedBy}px)`);
    this.renderer.setStyle(this.document.body, "cursor", "col-resize");
    this.redFlagTracker();
  }
  hideTracker() {
    this.columnResizerService.endResize();
    this.renderer.setStyle(this.resizeTrackerEl, "display", "none");
    this.renderer.setStyle(this.resizeTrackerEl, "transform", `translateX(0px)`);
    this.renderer.setStyle(this.columnHandleEl, "transform", `translateX(0px)`);
    this.renderer.setStyle(this.document.body, "cursor", "auto");
  }
  showTrackerOnFirstKeyDown(event) {
    if (!this.resizeStartedOnKeyDown && (this.isArrowLeftKeyEvent(event) || this.isArrowRightKeyEvent(event))) {
      this.resizeStartedOnKeyDown = true;
      this.renderer.addClass(this.resizeTrackerEl, "on-arrow-key-resize");
      this.showTracker();
    }
  }
  moveTrackerOnKeyDown(event) {
    if (this.isArrowLeftKeyEvent(event)) {
      event.stopPropagation();
      this.moveTracker(this.columnResizerService.resizedBy - KEYBOARD_RESIZE_LENGTH);
    } else if (this.isArrowRightKeyEvent(event)) {
      event.stopPropagation();
      this.moveTracker(this.columnResizerService.resizedBy + KEYBOARD_RESIZE_LENGTH);
    }
  }
  hideTrackerOnKeyUp(event) {
    if (this.resizeStartedOnKeyDown && (this.isArrowLeftKeyEvent(event) || this.isArrowRightKeyEvent(event))) {
      this.resizeStartedOnKeyDown = false;
      this.renderer.removeClass(this.resizeTrackerEl, "on-arrow-key-resize");
      this.hideTracker();
      this.columnHandleEl.focus();
    }
  }
  redFlagTracker() {
    if (this.isWithinMaxResizeRange !== this.columnResizerService.isWithinMaxResizeRange) {
      this.isWithinMaxResizeRange = this.columnResizerService.isWithinMaxResizeRange;
      if (!this.isWithinMaxResizeRange) {
        this.renderer.addClass(this.resizeTrackerEl, "exceeded-max");
      } else {
        this.renderer.removeClass(this.resizeTrackerEl, "exceeded-max");
      }
    }
  }
  isArrowLeftKeyEvent(event) {
    return normalizeKey(event.key) === Keys.ArrowLeft;
  }
  isArrowRightKeyEvent(event) {
    return normalizeKey(event.key) === Keys.ArrowRight;
  }
};
ClrDatagridColumnSeparator.ɵfac = function ClrDatagridColumnSeparator_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDatagridColumnSeparator)(ɵɵdirectiveInject(ColumnResizerService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(TableSizeService), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(DOCUMENT));
};
ClrDatagridColumnSeparator.ɵcmp = ɵɵdefineComponent({
  type: ClrDatagridColumnSeparator,
  selectors: [["clr-dg-column-separator"]],
  viewQuery: function ClrDatagridColumnSeparator_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c57, 5);
      ɵɵviewQuery(_c58, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.resizeTrackerRef = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columnHandleRef = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function ClrDatagridColumnSeparator_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("datagrid-column-separator", true);
    }
  },
  standalone: false,
  decls: 6,
  vars: 4,
  consts: [["columnHandle", ""], ["resizeTracker", ""], ["type", "button", "cdkDrag", "", "cdkDragLockAxis", "x", 1, "datagrid-column-handle", 3, "cdkDragStarted", "cdkDragMoved", "cdkDragEnded"], [1, "clr-sr-only"], [1, "datagrid-column-resize-tracker"]],
  template: function ClrDatagridColumnSeparator_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "button", 2, 0);
      ɵɵlistener("cdkDragStarted", function ClrDatagridColumnSeparator_Template_button_cdkDragStarted_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.showTracker());
      })("cdkDragMoved", function ClrDatagridColumnSeparator_Template_button_cdkDragMoved_0_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.moveTracker($event.distance.x));
      })("cdkDragEnded", function ClrDatagridColumnSeparator_Template_button_cdkDragEnded_0_listener($event) {
        ɵɵrestoreView(_r1);
        ctx.hideTracker();
        return ɵɵresetView($event.source._dragRef.reset());
      });
      ɵɵelementEnd();
      ɵɵelementStart(2, "span", 3);
      ɵɵtext(3);
      ɵɵelementEnd();
      ɵɵelement(4, "div", 4, 1);
    }
    if (rf & 2) {
      ɵɵattribute("aria-label", ctx.commonString.keys.columnSeparatorAriaLabel)("aria-describedby", ctx.descriptionId);
      ɵɵadvance(2);
      ɵɵattribute("id", ctx.descriptionId);
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", ctx.commonString.keys.columnSeparatorDescription, " ");
    }
  },
  dependencies: [CdkDragModule_CdkDrag],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridColumnSeparator, [{
    type: Component,
    args: [{
      selector: "clr-dg-column-separator",
      template: `
    <button
      type="button"
      class="datagrid-column-handle"
      [attr.aria-label]="commonString.keys.columnSeparatorAriaLabel"
      [attr.aria-describedby]="descriptionId"
      cdkDrag
      cdkDragLockAxis="x"
      (cdkDragStarted)="showTracker()"
      (cdkDragMoved)="moveTracker($event.distance.x)"
      (cdkDragEnded)="hideTracker(); $event.source._dragRef.reset()"
      #columnHandle
    ></button>
    <span class="clr-sr-only" [attr.id]="descriptionId">
      {{ commonString.keys.columnSeparatorDescription }}
    </span>
    <div class="datagrid-column-resize-tracker" #resizeTracker></div>
  `,
      host: {
        "[class.datagrid-column-separator]": "true"
      }
    }]
  }], function() {
    return [{
      type: ColumnResizerService
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }, {
      type: TableSizeService
    }, {
      type: ClrCommonStringsService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [DOCUMENT]
      }]
    }];
  }, {
    resizeTrackerRef: [{
      type: ViewChild,
      args: ["resizeTracker"]
    }],
    columnHandleRef: [{
      type: ViewChild,
      args: ["columnHandle"]
    }]
  });
})();
var ClrDatagridColumn = class extends DatagridFilterRegistrar {
  constructor(el, _sort, filters, vcr, detailService, changeDetectorRef) {
    super(filters);
    this.el = el;
    this._sort = _sort;
    this.vcr = vcr;
    this.detailService = detailService;
    this.changeDetectorRef = changeDetectorRef;
    this.sortOrderChange = new EventEmitter();
    this.filterValueChange = new EventEmitter();
    this.customFilter = false;
    this._colType = "string";
    this._sortOrder = ClrDatagridSortOrder.UNSORTED;
    this.subscriptions = [];
    this._showSeparator = true;
    this.subscriptions.push(this.listenForSortingChanges());
    this.subscriptions.push(this.listenForDetailPaneChanges());
  }
  get isHidden() {
    return this.el.nativeElement.classList.contains(HIDDEN_COLUMN_CLASS);
  }
  get showSeparator() {
    return this._showSeparator;
  }
  set showSeparator(value) {
    this._showSeparator = value;
    this.changeDetectorRef.markForCheck();
  }
  // TODO: We might want to make this an enum in the future
  get colType() {
    return this._colType;
  }
  set colType(value) {
    this._colType = value;
  }
  get field() {
    return this._field;
  }
  set field(field) {
    if (typeof field === "string") {
      this._field = field;
      if (!this._sortBy) {
        this._sortBy = new DatagridPropertyComparator(field);
      }
    }
  }
  get sortBy() {
    return this._sortBy;
  }
  set sortBy(comparator) {
    if (typeof comparator === "string") {
      this._sortBy = new DatagridPropertyComparator(comparator);
    } else {
      if (comparator) {
        this._sortBy = comparator;
      } else {
        if (this.field) {
          this._sortBy = new DatagridPropertyComparator(this.field);
        } else {
          delete this._sortBy;
        }
      }
    }
  }
  get sortOrder() {
    return this._sortOrder;
  }
  set sortOrder(value) {
    if (typeof value === "undefined") {
      return;
    }
    if (this._sortOrder === value) {
      return;
    }
    switch (value) {
      // the Unsorted case happens when the current state is either Asc or Desc
      default:
      case ClrDatagridSortOrder.UNSORTED:
        this._sort.clear();
        break;
      case ClrDatagridSortOrder.ASC:
        this.sort(false);
        break;
      case ClrDatagridSortOrder.DESC:
        this.sort(true);
        break;
    }
  }
  set updateFilterValue(newValue) {
    if (this.filter) {
      if (this.filter instanceof DatagridStringFilterImpl) {
        if (!newValue || typeof newValue !== "string") {
          newValue = "";
        }
        if (newValue !== this.filter.value) {
          this.filter.value = newValue;
        }
      } else if (this.filter instanceof DatagridNumericFilterImpl) {
        if (!newValue || !(newValue instanceof Array)) {
          newValue = [null, null];
        }
        if (newValue.length === 2 && (newValue[0] !== this.filter.value[0] || newValue[1] !== this.filter.value[1])) {
          this.filter.value = newValue;
        }
      }
    } else {
      this.initFilterValue = newValue;
    }
  }
  set projectedFilter(custom) {
    if (custom) {
      this.deleteFilter();
      this.customFilter = true;
    }
  }
  /**
   * Indicates if the column is sortable
   */
  get sortable() {
    return !!this._sortBy;
  }
  get ariaSort() {
    switch (this._sortOrder) {
      default:
      case ClrDatagridSortOrder.UNSORTED:
        return "none";
      case ClrDatagridSortOrder.ASC:
        return "ascending";
      case ClrDatagridSortOrder.DESC:
        return "descending";
    }
  }
  get sortDirection() {
    return this._sortDirection;
  }
  /**
   * @NOTE type `any` here is to let us pass templateStrictMode, because in our code we try to handle
   * two types of filters String and Number with the same variable but both of them work with different
   * format we got an error for casting. We could not cast anything inside the template so to not mess the
   * casting, the last type is set to `any`
   *
   * Orignial types: string | [number, number]
   */
  get filterValue() {
    if (this.filter instanceof DatagridStringFilterImpl || this.filter instanceof DatagridNumericFilterImpl) {
      return this.filter.value;
    }
    return null;
  }
  set filterValue(newValue) {
    if (this.filter instanceof DatagridStringFilterImpl || this.filter instanceof DatagridNumericFilterImpl) {
      this.updateFilterValue = newValue;
      this.filterValueChange.emit(this.filter.value);
    }
  }
  get _view() {
    return this.wrappedInjector.get(WrappedColumn, this.vcr).columnView;
  }
  ngOnInit() {
    this.wrappedInjector = new HostWrapper(WrappedColumn, this.vcr);
  }
  ngOnChanges(changes) {
    if (changes.colType && changes.colType.currentValue && changes.colType.currentValue !== changes.colType.previousValue) {
      if (!this.customFilter && !this.filter && this.colType && this.field) {
        this.setupDefaultFilter(this.field, this.colType);
      }
    }
    if (changes.field && changes.field.currentValue && changes.field.currentValue !== changes.field.previousValue) {
      if (!this.customFilter && this.colType) {
        this.setupDefaultFilter(this.field, this.colType);
      }
    }
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    this.subscriptions.forEach((s) => s.unsubscribe());
  }
  /**
   * Sorts the datagrid based on this column
   */
  sort(reverse) {
    if (!this.sortable) {
      return;
    }
    this._sort.toggle(this._sortBy, reverse);
    this._sortOrder = this._sort.reverse ? ClrDatagridSortOrder.DESC : ClrDatagridSortOrder.ASC;
    this._sortDirection = this._sortOrder === ClrDatagridSortOrder.DESC ? "down" : "up";
    this.sortOrderChange.emit(this._sortOrder);
  }
  listenForDetailPaneChanges() {
    return this.detailService.stateChange.subscribe((state2) => {
      if (this.showSeparator !== !state2) {
        this.showSeparator = !state2;
      }
    });
  }
  listenForSortingChanges() {
    return this._sort.change.subscribe((sort) => {
      this.changeDetectorRef.markForCheck();
      if (this.sortOrder !== ClrDatagridSortOrder.UNSORTED && sort.comparator !== this._sortBy) {
        this._sortOrder = ClrDatagridSortOrder.UNSORTED;
        this.sortOrderChange.emit(this._sortOrder);
        this._sortDirection = null;
      }
    });
  }
  setupDefaultFilter(field, colType) {
    if (colType === "number") {
      this.setFilter(new DatagridNumericFilterImpl(new DatagridPropertyNumericFilter(field)));
    } else if (colType === "string") {
      this.setFilter(new DatagridStringFilterImpl(new DatagridPropertyStringFilter(field)));
    }
    if (this.filter && this.initFilterValue) {
      this.updateFilterValue = this.initFilterValue;
      delete this.initFilterValue;
    }
  }
};
ClrDatagridColumn.ɵfac = function ClrDatagridColumn_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDatagridColumn)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Sort), ɵɵdirectiveInject(FiltersProvider), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(DetailService), ɵɵdirectiveInject(ChangeDetectorRef));
};
ClrDatagridColumn.ɵcmp = ɵɵdefineComponent({
  type: ClrDatagridColumn,
  selectors: [["clr-dg-column"]],
  contentQueries: function ClrDatagridColumn_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, CustomFilter, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.projectedFilter = _t.first);
    }
  },
  hostAttrs: ["role", "columnheader"],
  hostVars: 3,
  hostBindings: function ClrDatagridColumn_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("aria-sort", ctx.ariaSort);
      ɵɵclassProp("datagrid-column", true);
    }
  },
  inputs: {
    filterStringPlaceholder: [0, "clrFilterStringPlaceholder", "filterStringPlaceholder"],
    filterNumberMaxPlaceholder: [0, "clrFilterNumberMaxPlaceholder", "filterNumberMaxPlaceholder"],
    filterNumberMinPlaceholder: [0, "clrFilterNumberMinPlaceholder", "filterNumberMinPlaceholder"],
    colType: [0, "clrDgColType", "colType"],
    field: [0, "clrDgField", "field"],
    sortBy: [0, "clrDgSortBy", "sortBy"],
    sortOrder: [0, "clrDgSortOrder", "sortOrder"],
    updateFilterValue: [0, "clrFilterValue", "updateFilterValue"]
  },
  outputs: {
    sortOrderChange: "clrDgSortOrderChange",
    filterValueChange: "clrFilterValueChange"
  },
  standalone: false,
  features: [ɵɵHostDirectivesFeature([ClrPopoverHostDirective]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
  ngContentSelectors: _c60,
  decls: 9,
  vars: 5,
  consts: [["columnTitle", ""], [1, "datagrid-column-flex"], ["class", "datagrid-column-title", "type", "button", 3, "click", 4, "ngIf"], [3, "clrFilterPlaceholder", "clrDgStringFilter", "clrFilterValue", "clrFilterValueChange", 4, "ngIf"], [3, "clrFilterMaxPlaceholder", "clrFilterMinPlaceholder", "clrDgNumericFilter", "clrFilterValue", "clrFilterValueChange", 4, "ngIf"], ["class", "datagrid-column-title", 4, "ngIf"], [4, "ngIf"], ["type", "button", 1, "datagrid-column-title", 3, "click"], [4, "ngTemplateOutlet"], ["shape", "arrow", "aria-hidden", "true", "class", "sort-icon", 4, "ngIf"], ["shape", "arrow", "aria-hidden", "true", 1, "sort-icon"], [3, "clrFilterValueChange", "clrFilterPlaceholder", "clrDgStringFilter", "clrFilterValue"], [3, "clrFilterValueChange", "clrFilterMaxPlaceholder", "clrFilterMinPlaceholder", "clrDgNumericFilter", "clrFilterValue"], [1, "datagrid-column-title"]],
  template: function ClrDatagridColumn_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c59);
      ɵɵelementStart(0, "div", 1);
      ɵɵtemplate(1, ClrDatagridColumn_button_1_Template, 3, 2, "button", 2);
      ɵɵprojection(2);
      ɵɵtemplate(3, ClrDatagridColumn_clr_dg_string_filter_3_Template, 1, 3, "clr-dg-string-filter", 3)(4, ClrDatagridColumn_clr_dg_numeric_filter_4_Template, 1, 4, "clr-dg-numeric-filter", 4)(5, ClrDatagridColumn_ng_template_5_Template, 1, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor)(7, ClrDatagridColumn_span_7_Template, 2, 1, "span", 5)(8, ClrDatagridColumn_clr_dg_column_separator_8_Template, 1, 0, "clr-dg-column-separator", 6);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.sortable);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.field && !ctx.customFilter && ctx.colType == "string");
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.field && !ctx.customFilter && ctx.colType == "number");
      ɵɵadvance(3);
      ɵɵproperty("ngIf", !ctx.sortable);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showSeparator);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, CdsIconCustomTag, ClrDatagridColumnSeparator, DatagridNumericFilter, DatagridStringFilter],
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridColumn, [{
    type: Component,
    args: [{
      selector: "clr-dg-column",
      template: `
    <div class="datagrid-column-flex">
      <button class="datagrid-column-title" *ngIf="sortable" (click)="sort()" type="button">
        <ng-container *ngTemplateOutlet="columnTitle"></ng-container>
        <cds-icon
          *ngIf="sortDirection"
          shape="arrow"
          [attr.direction]="sortDirection"
          aria-hidden="true"
          class="sort-icon"
        ></cds-icon>
      </button>
      <!-- I'm really not happy with that select since it's not very scalable -->
      <ng-content select="clr-dg-filter, clr-dg-string-filter, clr-dg-numeric-filter"></ng-content>

      <clr-dg-string-filter
        *ngIf="field && !customFilter && colType == 'string'"
        [clrFilterPlaceholder]="filterStringPlaceholder"
        [clrDgStringFilter]="registered"
        [(clrFilterValue)]="filterValue"
      ></clr-dg-string-filter>

      <clr-dg-numeric-filter
        *ngIf="field && !customFilter && colType == 'number'"
        [clrFilterMaxPlaceholder]="filterNumberMaxPlaceholder"
        [clrFilterMinPlaceholder]="filterNumberMinPlaceholder"
        [clrDgNumericFilter]="registered"
        [(clrFilterValue)]="filterValue"
      ></clr-dg-numeric-filter>

      <ng-template #columnTitle>
        <ng-content></ng-content>
      </ng-template>

      <span class="datagrid-column-title" *ngIf="!sortable">
        <ng-container *ngTemplateOutlet="columnTitle"></ng-container>
      </span>

      <clr-dg-column-separator *ngIf="showSeparator"></clr-dg-column-separator>
    </div>
  `,
      hostDirectives: [ClrPopoverHostDirective],
      host: {
        "[class.datagrid-column]": "true",
        "[attr.aria-sort]": "ariaSort",
        role: "columnheader"
      },
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Sort
    }, {
      type: FiltersProvider
    }, {
      type: ViewContainerRef
    }, {
      type: DetailService
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    filterStringPlaceholder: [{
      type: Input,
      args: ["clrFilterStringPlaceholder"]
    }],
    filterNumberMaxPlaceholder: [{
      type: Input,
      args: ["clrFilterNumberMaxPlaceholder"]
    }],
    filterNumberMinPlaceholder: [{
      type: Input,
      args: ["clrFilterNumberMinPlaceholder"]
    }],
    sortOrderChange: [{
      type: Output,
      args: ["clrDgSortOrderChange"]
    }],
    filterValueChange: [{
      type: Output,
      args: ["clrFilterValueChange"]
    }],
    colType: [{
      type: Input,
      args: ["clrDgColType"]
    }],
    field: [{
      type: Input,
      args: ["clrDgField"]
    }],
    sortBy: [{
      type: Input,
      args: ["clrDgSortBy"]
    }],
    sortOrder: [{
      type: Input,
      args: ["clrDgSortOrder"]
    }],
    updateFilterValue: [{
      type: Input,
      args: ["clrFilterValue"]
    }],
    projectedFilter: [{
      type: ContentChild,
      args: [CustomFilter]
    }]
  });
})();
var Items = class {
  constructor(_filters, _sort, _page) {
    this._filters = _filters;
    this._sort = _sort;
    this._page = _page;
    this.loading = false;
    this._smart = false;
    this._displayed = [];
    this._change = new Subject();
    this._allChanges = new Subject();
    this.trackBy = (item) => item;
  }
  get smart() {
    return this._smart;
  }
  get all() {
    return this._all;
  }
  set all(items) {
    this._all = items;
    this.emitAllChanges(items);
    if (this.smart) {
      this._filterItems();
    } else {
      this._displayed = items;
      this.emitChange();
    }
  }
  get displayed() {
    return this._displayed;
  }
  // We do not want to expose the Subject itself, but the Observable which is read-only
  get change() {
    return this._change.asObservable();
  }
  get allChanges() {
    return this._allChanges.asObservable();
  }
  /**
   * Checks if we don't have data to process yet, to abort early operations
   */
  get uninitialized() {
    return !this._all;
  }
  /**
   * Cleans up our subscriptions to other providers
   */
  destroy() {
    if (this._filtersSub) {
      this._filtersSub.unsubscribe();
    }
    if (this._sortSub) {
      this._sortSub.unsubscribe();
    }
    if (this._pageSub) {
      this._pageSub.unsubscribe();
    }
  }
  smartenUp() {
    this._smart = true;
    this._filtersSub = this._filters.change.subscribe(() => this._filterItems());
    this._sortSub = this._sort.change.subscribe(() => {
      if (!this._sort.comparator) {
        this._filterItems();
      } else {
        this._sortItems();
      }
    });
    this._pageSub = this._page.change.subscribe(() => this._changePage());
  }
  /**
   * Manually recompute the list of displayed items
   */
  refresh() {
    if (this.smart) {
      this._filterItems();
    }
  }
  emitChange() {
    this._change.next(this.displayed);
  }
  emitAllChanges(items) {
    this._allChanges.next(items);
  }
  /**
   * FiltersProvider items from the raw list
   */
  _filterItems() {
    if (this.uninitialized) {
      return;
    }
    if (this._filters.hasActiveFilters()) {
      this._filtered = this._all.filter((item) => this._filters.accepts(item));
    } else {
      this._filtered = this._all.slice();
    }
    this._page.totalItems = this._filtered.length;
    this._sortItems();
  }
  /**
   * Sorts items in the filtered list
   */
  _sortItems() {
    if (this.uninitialized) {
      return;
    }
    if (this._sort.comparator) {
      this._filtered.sort((a, b) => this._sort.compare(a, b));
    }
    this._changePage();
  }
  /**
   * Extracts the current page from the sorted list
   */
  _changePage() {
    if (this.uninitialized || this._page.activated && this._page.size === 0) {
      return;
    }
    if (this._page.size > 0) {
      this._displayed = this._filtered.slice(this._page.firstItem, this._page.lastItem + 1);
    } else {
      this._displayed = this._filtered;
    }
    this.emitChange();
  }
};
Items.ɵfac = function Items_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Items)(ɵɵinject(FiltersProvider), ɵɵinject(Sort), ɵɵinject(Page));
};
Items.ɵprov = ɵɵdefineInjectable({
  token: Items,
  factory: Items.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Items, [{
    type: Injectable
  }], function() {
    return [{
      type: FiltersProvider
    }, {
      type: Sort
    }, {
      type: Page
    }];
  }, null);
})();
var ClrDatagridItems = class {
  constructor(template, differs, items, vcr) {
    this.template = template;
    this.differs = differs;
    this.items = items;
    this.differ = null;
    this.subscriptions = [];
    items.smartenUp();
    this.iterableProxy = new NgForOf(vcr, template, differs);
    this.subscriptions.push(items.change.subscribe((newItems) => {
      this.iterableProxy.ngForOf = newItems;
      this.iterableProxy.ngDoCheck();
    }));
  }
  set rawItems(items) {
    this._rawItems = items ? items : [];
  }
  set trackBy(value) {
    this.iterableProxy.ngForTrackBy = value;
  }
  /**
   * Asserts the correct type of the template context that the directive will render.
   * See https://angular.io/guide/structural-directives#typing-the-directives-context
   *
   * The presence of this method is a signal to the Ivy template type-check compiler that the
   * structural directive renders its template with a specific context type.
   */
  static ngTemplateContextGuard(_dir, _ctx) {
    return true;
  }
  ngDoCheck() {
    if (!this.differ) {
      this.differ = this.differs.find(this._rawItems).create(this.iterableProxy.ngForTrackBy);
    }
    if (this.differ) {
      const changes = this.differ.diff(this._rawItems);
      if (changes) {
        this.items.all = this._rawItems;
      }
    }
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
};
ClrDatagridItems.ɵfac = function ClrDatagridItems_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDatagridItems)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(Items), ɵɵdirectiveInject(ViewContainerRef));
};
ClrDatagridItems.ɵdir = ɵɵdefineDirective({
  type: ClrDatagridItems,
  selectors: [["", "clrDgItems", "", "clrDgItemsOf", ""]],
  inputs: {
    rawItems: [0, "clrDgItemsOf", "rawItems"],
    trackBy: [0, "clrDgItemsTrackBy", "trackBy"]
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridItems, [{
    type: Directive,
    args: [{
      selector: "[clrDgItems][clrDgItemsOf]"
    }]
  }], function() {
    return [{
      type: TemplateRef
    }, {
      type: IterableDiffers
    }, {
      type: Items
    }, {
      type: ViewContainerRef
    }];
  }, {
    rawItems: [{
      type: Input,
      args: ["clrDgItemsOf"]
    }],
    trackBy: [{
      type: Input,
      args: ["clrDgItemsTrackBy"]
    }]
  });
})();
var ClrDatagridPlaceholder = class {
  constructor(items) {
    this.items = items;
  }
  /**
   * Tests if the datagrid is empty, meaning it doesn't contain any items
   */
  get emptyDatagrid() {
    return !this.items.loading && (!this.items.displayed || this.items.displayed.length === 0);
  }
};
ClrDatagridPlaceholder.ɵfac = function ClrDatagridPlaceholder_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDatagridPlaceholder)(ɵɵdirectiveInject(Items));
};
ClrDatagridPlaceholder.ɵcmp = ɵɵdefineComponent({
  type: ClrDatagridPlaceholder,
  selectors: [["clr-dg-placeholder"]],
  hostVars: 2,
  hostBindings: function ClrDatagridPlaceholder_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("datagrid-placeholder-container", true);
    }
  },
  standalone: false,
  ngContentSelectors: _c02,
  decls: 4,
  vars: 4,
  consts: [[1, "datagrid-placeholder"], ["class", "datagrid-placeholder-image", 4, "ngIf"], [1, "datagrid-placeholder-content"], [4, "ngIf"], [1, "datagrid-placeholder-image"]],
  template: function ClrDatagridPlaceholder_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 0);
      ɵɵtemplate(1, ClrDatagridPlaceholder_div_1_Template, 1, 0, "div", 1);
      ɵɵelementStart(2, "span", 2);
      ɵɵtemplate(3, ClrDatagridPlaceholder_ng_content_3_Template, 1, 0, "ng-content", 3);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵclassProp("datagrid-empty", ctx.emptyDatagrid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.emptyDatagrid);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.emptyDatagrid);
    }
  },
  dependencies: [NgIf],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridPlaceholder, [{
    type: Component,
    args: [{
      selector: "clr-dg-placeholder",
      template: `
    <div class="datagrid-placeholder" [class.datagrid-empty]="emptyDatagrid">
      <div class="datagrid-placeholder-image" *ngIf="emptyDatagrid"></div>
      <span class="datagrid-placeholder-content"><ng-content *ngIf="emptyDatagrid"></ng-content></span>
    </div>
  `,
      host: {
        "[class.datagrid-placeholder-container]": "true"
      }
    }]
  }], function() {
    return [{
      type: Items
    }];
  }, null);
})();
var WrappedCell = class {
  constructor() {
    this._dynamic = false;
  }
  ngAfterViewInit() {
    this.cellView = this.templateRef.createEmbeddedView(null);
  }
  ngOnDestroy() {
    this.cellView.destroy();
  }
};
WrappedCell.ɵfac = function WrappedCell_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || WrappedCell)();
};
WrappedCell.ɵcmp = ɵɵdefineComponent({
  type: WrappedCell,
  selectors: [["dg-wrapped-cell"]],
  viewQuery: function WrappedCell_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c61, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.templateRef = _t.first);
    }
  },
  standalone: false,
  ngContentSelectors: _c02,
  decls: 2,
  vars: 0,
  consts: [["cellPortal", ""]],
  template: function WrappedCell_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, WrappedCell_ng_template_0_Template, 1, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WrappedCell, [{
    type: Component,
    args: [{
      selector: "dg-wrapped-cell",
      template: `
    <ng-template #cellPortal>
      <ng-content></ng-content>
    </ng-template>
  `
    }]
  }], null, {
    templateRef: [{
      type: ViewChild,
      args: ["cellPortal"]
    }]
  });
})();
var ClrDatagridCell = class {
  constructor(vcr) {
    this.vcr = vcr;
  }
  get _view() {
    return this.wrappedInjector.get(WrappedCell, this.vcr).cellView;
  }
  ngOnInit() {
    this.wrappedInjector = new HostWrapper(WrappedCell, this.vcr);
  }
};
ClrDatagridCell.ɵfac = function ClrDatagridCell_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDatagridCell)(ɵɵdirectiveInject(ViewContainerRef));
};
ClrDatagridCell.ɵcmp = ɵɵdefineComponent({
  type: ClrDatagridCell,
  selectors: [["clr-dg-cell"]],
  contentQueries: function ClrDatagridCell_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrSignpost, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.signpost = _t);
    }
  },
  hostAttrs: ["role", "gridcell"],
  hostVars: 4,
  hostBindings: function ClrDatagridCell_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("datagrid-cell", true)("datagrid-signpost-trigger", ctx.signpost.length > 0);
    }
  },
  standalone: false,
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrDatagridCell_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridCell, [{
    type: Component,
    args: [{
      selector: "clr-dg-cell",
      template: `<ng-content></ng-content>`,
      host: {
        "[class.datagrid-cell]": "true",
        "[class.datagrid-signpost-trigger]": "signpost.length > 0",
        role: "gridcell"
      }
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, {
    signpost: [{
      type: ContentChildren,
      args: [ClrSignpost]
    }]
  });
})();
var nbRow$1 = 0;
var DatagridIfExpandService = class extends IfExpandService {
  constructor() {
    super();
    this.expandableId = "";
    this._replace = new BehaviorSubject(false);
    this._animate = new Subject();
    nbRow$1++;
    this.expandableId = "clr-dg-expandable-row-" + nbRow$1;
  }
  // due to the es5 spec if the set is overridden on base class the getter must also be overridden
  get expanded() {
    return this._expanded;
  }
  set expanded(value) {
    value = !!value;
    if (value !== this._expanded) {
      this._expanded = value;
      this._animate.next();
      this._expandChange.next(value);
    }
  }
  get replace() {
    return this._replace.asObservable();
  }
  get animate() {
    return this._animate.asObservable();
  }
  loadingStateChange(state2) {
    super.loadingStateChange(state2);
    if (state2 !== ClrLoadingState.LOADING) {
      this._animate.next();
    }
  }
  setReplace(replaceValue) {
    this._replace.next(replaceValue);
  }
};
DatagridIfExpandService.ɵfac = function DatagridIfExpandService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || DatagridIfExpandService)();
};
DatagridIfExpandService.ɵprov = ɵɵdefineInjectable({
  token: DatagridIfExpandService,
  factory: DatagridIfExpandService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatagridIfExpandService, [{
    type: Injectable
  }], function() {
    return [];
  }, null);
})();
var DatagridDisplayMode;
(function(DatagridDisplayMode2) {
  DatagridDisplayMode2[DatagridDisplayMode2["DISPLAY"] = 0] = "DISPLAY";
  DatagridDisplayMode2[DatagridDisplayMode2["CALCULATE"] = 1] = "CALCULATE";
})(DatagridDisplayMode || (DatagridDisplayMode = {}));
var SelectionType;
(function(SelectionType2) {
  SelectionType2[SelectionType2["None"] = 0] = "None";
  SelectionType2[SelectionType2["Single"] = 1] = "Single";
  SelectionType2[SelectionType2["Multi"] = 2] = "Multi";
})(SelectionType || (SelectionType = {}));
var WrappedRow = class {
  constructor() {
    this._dynamic = false;
  }
  ngAfterViewInit() {
    this.rowView = this.templateRef.createEmbeddedView(null);
  }
  ngOnDestroy() {
    this.rowView.destroy();
  }
};
WrappedRow.ɵfac = function WrappedRow_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || WrappedRow)();
};
WrappedRow.ɵcmp = ɵɵdefineComponent({
  type: WrappedRow,
  selectors: [["dg-wrapped-row"]],
  viewQuery: function WrappedRow_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c62, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.templateRef = _t.first);
    }
  },
  standalone: false,
  ngContentSelectors: _c02,
  decls: 2,
  vars: 0,
  consts: [["rowPortal", ""]],
  template: function WrappedRow_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, WrappedRow_ng_template_0_Template, 1, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WrappedRow, [{
    type: Component,
    args: [{
      selector: "dg-wrapped-row",
      template: `
    <ng-template #rowPortal>
      <ng-content></ng-content>
    </ng-template>
  `
    }]
  }], null, {
    templateRef: [{
      type: ViewChild,
      args: ["rowPortal"]
    }]
  });
})();
var nbSelection = 0;
var Selection = class {
  constructor(_items, filters) {
    this._items = _items;
    this.preserveSelection = false;
    this.shiftPressed = false;
    this.rowSelectionMode = false;
    this.prevSelectionRefs = [];
    this.lockedRefs = [];
    this.valueCollector = new Subject();
    this._selectionType = SelectionType.None;
    this._change = new Subject();
    this.subscriptions = [];
    this.id = "clr-dg-selection" + nbSelection++;
    this.subscriptions.push(filters.change.subscribe(() => {
      if (!this._selectable || this.preserveSelection) {
        return;
      }
      this.clearSelection();
    }));
    this.subscriptions.push(_items.allChanges.subscribe((updatedItems) => {
      const updateLockedRef = [];
      switch (this.selectionType) {
        case SelectionType.None: {
          break;
        }
        case SelectionType.Single: {
          let newSingle;
          let selectionUpdated = false;
          if (this.currentSingle && !this.prevSingleSelectionRef) {
            this.prevSingleSelectionRef = _items.trackBy(this.currentSingle);
          }
          updatedItems.forEach((item) => {
            const ref = _items.trackBy(item);
            if (this.prevSingleSelectionRef === ref) {
              newSingle = item;
              selectionUpdated = true;
            }
            if (this.lockedRefs.indexOf(ref) > -1) {
              updateLockedRef.push(ref);
            }
          });
          if (_items.smart && !newSingle) {
            selectionUpdated = true;
          }
          setTimeout(() => {
            if (selectionUpdated) {
              this.currentSingle = newSingle;
            }
          }, 0);
          break;
        }
        case SelectionType.Multi: {
          let leftOver = this.current.slice();
          let selectionUpdated = false;
          if (this.current.length > 0 && this.prevSelectionRefs.length !== this.current.length) {
            this.prevSelectionRefs = [];
            this.current.forEach((item) => {
              this.prevSelectionRefs.push(_items.trackBy(item));
            });
          }
          updatedItems.forEach((item) => {
            const ref = _items.trackBy(item);
            if (this.lockedRefs.indexOf(ref) > -1) {
              updateLockedRef.push(ref);
            }
          });
          if (leftOver.length > 0) {
            updatedItems.forEach((item) => {
              const ref = _items.trackBy(item);
              const selectedIndex = this.prevSelectionRefs.indexOf(ref);
              if (selectedIndex > -1) {
                leftOver[selectedIndex] = item;
                selectionUpdated = true;
              }
            });
            if (_items.smart) {
              leftOver = leftOver.filter((selected) => updatedItems.indexOf(selected) > -1);
              if (this.current.length !== leftOver.length) {
                selectionUpdated = true;
              }
            }
            setTimeout(() => {
              if (selectionUpdated) {
                this.current = leftOver;
              }
            }, 0);
          }
          break;
        }
        default: {
          break;
        }
      }
      this.lockedRefs = updateLockedRef;
    }));
    this.subscriptions.push(this.valueCollector.pipe(debounceTime(0)).subscribe(() => this.emitChange()));
  }
  get selectionType() {
    return this._selectionType;
  }
  set selectionType(value) {
    if (value === this.selectionType) {
      return;
    }
    this._selectionType = value;
    if (value === SelectionType.None) {
      delete this.current;
    } else {
      this.updateCurrent([], false);
    }
  }
  get current() {
    return this._current;
  }
  set current(value) {
    this.updateCurrent(value, true);
  }
  get currentSingle() {
    return this._currentSingle;
  }
  set currentSingle(value) {
    if (value === this._currentSingle) {
      return;
    }
    this._currentSingle = value;
    if (value) {
      this.prevSingleSelectionRef = this._items.trackBy(value);
    }
    this.emitChange();
  }
  // We do not want to expose the Subject itself, but the Observable which is read-only
  get change() {
    return this._change.asObservable();
  }
  get _selectable() {
    return this._selectionType === SelectionType.Multi || this._selectionType === SelectionType.Single;
  }
  clearSelection() {
    this._current = [];
    this.prevSelectionRefs = [];
    this.prevSingleSelectionRef = null;
    this._currentSingle = null;
    this.emitChange();
  }
  /**
   * Cleans up our subscriptions to other providers
   */
  destroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
  updateCurrent(value, emit) {
    this._current = value;
    if (emit) {
      this.valueCollector.next(value);
    }
  }
  /**
   * Checks if an item is currently selected
   */
  isSelected(item) {
    if (this._selectionType === SelectionType.Single) {
      return this.currentSingle === item;
    } else if (this._selectionType === SelectionType.Multi) {
      return this.current.indexOf(item) >= 0;
    }
    return false;
  }
  /**
   * Selects or deselects an item
   */
  setSelected(item, selected) {
    const index = this.current ? this.current.indexOf(item) : -1;
    switch (this._selectionType) {
      case SelectionType.None:
        break;
      case SelectionType.Single:
        break;
      case SelectionType.Multi:
        if (index >= 0 && !selected) {
          this.deselectItem(index);
        } else if (index < 0 && selected) {
          this.selectItem(item);
        }
        break;
      default:
        break;
    }
  }
  /**
   * Checks if all currently displayed items are selected
   */
  isAllSelected() {
    if (this._selectionType !== SelectionType.Multi || !this._items.displayed) {
      return false;
    }
    const displayedItems = this._items.displayed.filter((item) => {
      return this.isLocked(item) === false;
    });
    const nbDisplayed = displayedItems.length;
    if (nbDisplayed < 1) {
      return false;
    }
    const temp = displayedItems.filter((item) => this.current.indexOf(item) > -1);
    return temp.length === displayedItems.length;
  }
  /**
   * Lock and unlock item
   */
  lockItem(item, lock) {
    if (this.canItBeLocked()) {
      const ref = this._items.trackBy(item);
      if (lock === true) {
        this.lockedRefs.push(ref);
      } else {
        this.lockedRefs = this.lockedRefs.filter((lockedItem) => ref !== lockedItem);
      }
    }
  }
  /**
   * Check is item locked or not by searching into lockedRefs for entry
   */
  isLocked(item) {
    if (this.canItBeLocked()) {
      const ref = this._items.trackBy(item);
      return this.lockedRefs.indexOf(ref) > -1;
    }
    return false;
  }
  /**
   * Selects or deselects all currently displayed items
   */
  toggleAll() {
    if (this._selectionType === SelectionType.None || this._selectionType === SelectionType.Single) {
      return;
    }
    if (this.isAllSelected()) {
      this._items.displayed.forEach((item) => {
        const currentIndex = this.current.indexOf(item);
        if (currentIndex > -1 && this.isLocked(item) === false) {
          this.deselectItem(currentIndex);
        }
      });
    } else {
      this._items.displayed.forEach((item) => {
        if (this.current.indexOf(item) < 0 && this.isLocked(item) === false) {
          this.selectItem(item);
        }
      });
    }
  }
  /**
   * Selects an item
   */
  selectItem(item) {
    this.current = this.current.concat(item);
    this.prevSelectionRefs.push(this._items.trackBy(item));
  }
  /**
   * Deselects an item
   */
  deselectItem(indexOfItem) {
    this.current = this.current.slice(0, indexOfItem).concat(this.current.slice(indexOfItem + 1));
    if (indexOfItem < this.prevSelectionRefs.length) {
      const removedItems = this.prevSelectionRefs.splice(indexOfItem, 1);
      this.lockedRefs = this.lockedRefs.filter((locked) => locked !== removedItems[0]);
    }
  }
  /**
   * Make sure that it could be locked
   */
  canItBeLocked() {
    return this._selectionType !== SelectionType.None;
  }
  emitChange() {
    if (this._selectionType === SelectionType.Single) {
      this._change.next(this.currentSingle);
    } else if (this._selectionType === SelectionType.Multi) {
      this._change.next(this.current);
    }
  }
};
Selection.ɵfac = function Selection_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || Selection)(ɵɵinject(Items), ɵɵinject(FiltersProvider));
};
Selection.ɵprov = ɵɵdefineInjectable({
  token: Selection,
  factory: Selection.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Selection, [{
    type: Injectable
  }], function() {
    return [{
      type: Items
    }, {
      type: FiltersProvider
    }];
  }, null);
})();
var DisplayModeService = class {
  constructor(renderOrganizer) {
    this._view = new BehaviorSubject(DatagridDisplayMode.DISPLAY);
    this.subscriptions = [];
    this.subscriptions.push(renderOrganizer.filterRenderSteps(DatagridRenderStep.CALCULATE_MODE_ON).subscribe(() => this._view.next(DatagridDisplayMode.CALCULATE)));
    this.subscriptions.push(renderOrganizer.filterRenderSteps(DatagridRenderStep.CALCULATE_MODE_OFF).subscribe(() => this._view.next(DatagridDisplayMode.DISPLAY)));
  }
  get view() {
    return this._view.asObservable();
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
};
DisplayModeService.ɵfac = function DisplayModeService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || DisplayModeService)(ɵɵinject(DatagridRenderOrganizer));
};
DisplayModeService.ɵprov = ɵɵdefineInjectable({
  token: DisplayModeService,
  factory: DisplayModeService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DisplayModeService, [{
    type: Injectable
  }], function() {
    return [{
      type: DatagridRenderOrganizer
    }];
  }, null);
})();
var ClrDatagridSelectionCellDirective = class {
  constructor(selection) {
    this.selection = selection;
  }
  onSelectionCellClick(event) {
    if (this.selection.rowSelectionMode) {
      return;
    }
    if (event.target.tagName !== "LABEL" && event.target.tagName !== "INPUT") {
      event.target.querySelector("input")?.click();
    }
  }
};
ClrDatagridSelectionCellDirective.ɵfac = function ClrDatagridSelectionCellDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDatagridSelectionCellDirective)(ɵɵdirectiveInject(Selection));
};
ClrDatagridSelectionCellDirective.ɵdir = ɵɵdefineDirective({
  type: ClrDatagridSelectionCellDirective,
  selectors: [["", 8, "datagrid-select"]],
  hostBindings: function ClrDatagridSelectionCellDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function ClrDatagridSelectionCellDirective_click_HostBindingHandler($event) {
        return ctx.onSelectionCellClick($event);
      });
    }
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridSelectionCellDirective, [{
    type: Directive,
    args: [{
      selector: ".datagrid-select"
    }]
  }], function() {
    return [{
      type: Selection
    }];
  }, {
    onSelectionCellClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var nbRow = 0;
var ClrDatagridRow = class {
  constructor(selection, rowActionService, globalExpandable, expand, detailService, displayMode, vcr, renderer, el, commonStrings, items, document2) {
    this.selection = selection;
    this.rowActionService = rowActionService;
    this.globalExpandable = globalExpandable;
    this.expand = expand;
    this.detailService = detailService;
    this.displayMode = displayMode;
    this.vcr = vcr;
    this.commonStrings = commonStrings;
    this.items = items;
    this.document = document2;
    this.selectedChanged = new EventEmitter(false);
    this.expandedChange = new EventEmitter(false);
    this.detailDisabled = false;
    this.detailHidden = false;
    this.displayCells = false;
    this.expandAnimationTrigger = false;
    this.SELECTION_TYPE = SelectionType;
    this.itemChanges = new ReplaySubject(1);
    this._selected = false;
    this._detailOpenLabel = "";
    this._detailCloseLabel = "";
    this._rowSelectionLabel = "";
    this.subscriptions = [];
    this._selectable = true;
    nbRow++;
    this.id = "clr-dg-row" + nbRow;
    this.radioId = "clr-dg-row-rd" + nbRow;
    this.checkboxId = "clr-dg-row-cb" + nbRow;
    this.expandableId = expand.expandableId;
    this.subscriptions.push(combineLatest(expand.replace, expand.expandChange).subscribe(([expandReplaceValue, expandChangeValue]) => {
      if (expandReplaceValue && expandChangeValue) {
        this.replaced = true;
        renderer.addClass(el.nativeElement, "datagrid-row-replaced");
      } else {
        this.replaced = false;
        renderer.removeClass(el.nativeElement, "datagrid-row-replaced");
      }
    }));
  }
  /**
   * Model of the row, to use for selection
   */
  get item() {
    return this._item;
  }
  set item(item) {
    this._item = item;
    this.itemChanges.next(item);
    this.clrDgSelectable = this._selectable;
  }
  get clrDgSelectable() {
    return !this.selection.isLocked(this.item);
  }
  set clrDgSelectable(value) {
    if (this.item) {
      this.selection.lockItem(this.item, value === "false" || value === false);
    }
    this._selectable = value;
  }
  /**
   * Indicates if the row is selected
   */
  get selected() {
    if (this.selection.selectionType === SelectionType.None) {
      return this._selected;
    } else {
      return this.selection.isSelected(this.item);
    }
  }
  set selected(value) {
    if (this.selection.selectionType === SelectionType.None) {
      this._selected = value;
    } else {
      if (value && this.selection.selectionType === SelectionType.Multi) {
        this.rangeSelect();
      } else {
        this.selection.rangeStart = null;
      }
      this.selection.setSelected(this.item, value);
    }
  }
  get expanded() {
    return this.expand.expanded;
  }
  set expanded(value) {
    this.expand.expanded = value;
  }
  get clrDgDetailOpenLabel() {
    return this._detailOpenLabel ? this._detailOpenLabel : this.commonStrings.keys.open;
  }
  set clrDgDetailOpenLabel(label) {
    this._detailOpenLabel = label;
  }
  get clrDgDetailCloseLabel() {
    return this._detailCloseLabel ? this._detailCloseLabel : this.commonStrings.keys.close;
  }
  set clrDgDetailCloseLabel(label) {
    this._detailCloseLabel = label;
  }
  // CDE-151: Rename this field to clrDgRowSelectionLabel in v16
  get clrDgRowSelectionLabel() {
    return this._rowSelectionLabel ? this._rowSelectionLabel : this.commonStrings.keys.select;
  }
  set clrDgRowSelectionLabel(label) {
    this._rowSelectionLabel = label;
  }
  get _view() {
    return this.wrappedInjector.get(WrappedRow, this.vcr).rowView;
  }
  ngOnInit() {
    this.wrappedInjector = new HostWrapper(WrappedRow, this.vcr);
    this.selection.lockItem(this.item, this.clrDgSelectable === false);
  }
  ngAfterContentInit() {
    this.dgCells.changes.subscribe(() => {
      this.dgCells.forEach((cell) => {
        if (!cell._view.destroyed) {
          this._scrollableCells.insert(cell._view);
        }
      });
    });
  }
  ngAfterViewInit() {
    this.subscriptions.push(this.displayMode.view.subscribe((viewChange) => {
      for (let i = this._scrollableCells.length; i > 0; i--) {
        this._scrollableCells.detach();
      }
      for (let i = this._calculatedCells.length; i > 0; i--) {
        this._calculatedCells.detach();
      }
      if (viewChange === DatagridDisplayMode.CALCULATE) {
        this.displayCells = false;
        this.dgCells.forEach((cell) => {
          if (!cell._view.destroyed) {
            this._calculatedCells.insert(cell._view);
          }
        });
      } else {
        this.displayCells = true;
        this.dgCells.forEach((cell) => {
          if (!cell._view.destroyed) {
            this._scrollableCells.insert(cell._view);
          }
        });
      }
    }), this.expand.animate.subscribe(() => {
      this.expandAnimationTrigger = !this.expandAnimationTrigger;
    }));
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
  toggle(selected = !this.selected) {
    if (selected !== this.selected) {
      this.selected = selected;
      this.selectedChanged.emit(selected);
    }
  }
  toggleExpand() {
    if (this.expand.expandable) {
      this.expandAnimation.updateStartHeight();
      this.expanded = !this.expanded;
      this.expandedChange.emit(this.expanded);
    }
  }
  /**
   * The default behavior in Chrome and Firefox for shift-clicking on a label is to perform text-selection.
   * This prevents our intended range-selection, because this text-selection overrides our shift-click event.
   * We need to clear the stored selection range when shift-clicking. This will override the mostly unused shift-click
   * selection browser functionality, which is inconsistently implemented in browsers anyway.
   */
  clearRanges(event) {
    if (event.shiftKey) {
      this.document.getSelection().removeAllRanges();
      if (window.navigator.userAgent.indexOf("Firefox") !== -1) {
        event.preventDefault();
        this.toggle(true);
      }
    }
  }
  /**
   * @deprecated related to clrDgRowSelection, which is deprecated
   */
  selectRow(selected = !this.selected, $event) {
    if ($event.target.tagName === "LABEL") {
      return;
    }
    if (this.selection.selectionType === this.SELECTION_TYPE.Single) {
      this.selection.currentSingle = this.item;
    } else {
      this.toggle(selected);
    }
  }
  rangeSelect() {
    const items = this.items.displayed;
    if (!items) {
      return;
    }
    const startIx = items.indexOf(this.selection.rangeStart);
    if (this.selection.rangeStart && this.selection.current.includes(this.selection.rangeStart) && this.selection.shiftPressed && startIx !== -1) {
      const endIx = items.indexOf(this.item);
      const newSelection = new Set(this.selection.current.concat(items.slice(Math.min(startIx, endIx), Math.max(startIx, endIx) + 1)));
      this.selection.clearSelection();
      this.selection.current.push(...newSelection);
    } else {
      this.selection.rangeStart = this.item;
    }
  }
};
ClrDatagridRow.ɵfac = function ClrDatagridRow_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDatagridRow)(ɵɵdirectiveInject(Selection), ɵɵdirectiveInject(RowActionService), ɵɵdirectiveInject(ExpandableRowsCount), ɵɵdirectiveInject(DatagridIfExpandService), ɵɵdirectiveInject(DetailService), ɵɵdirectiveInject(DisplayModeService), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(Items), ɵɵdirectiveInject(DOCUMENT));
};
ClrDatagridRow.ɵcmp = ɵɵdefineComponent({
  type: ClrDatagridRow,
  selectors: [["clr-dg-row"]],
  contentQueries: function ClrDatagridRow_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrDatagridCell, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dgCells = _t);
    }
  },
  viewQuery: function ClrDatagridRow_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(ClrExpandableAnimation, 5);
      ɵɵviewQuery(_c63, 5);
      ɵɵviewQuery(_c64, 5, ViewContainerRef);
      ɵɵviewQuery(_c65, 5, ViewContainerRef);
      ɵɵviewQuery(_c66, 5, ViewContainerRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.expandAnimation = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.detailButton = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._stickyCells = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._scrollableCells = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._calculatedCells = _t.first);
    }
  },
  hostAttrs: ["role", "rowgroup"],
  hostVars: 5,
  hostBindings: function ClrDatagridRow_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("aria-owns", ctx.id);
      ɵɵclassProp("datagrid-row", true)("datagrid-selected", ctx.selected);
    }
  },
  inputs: {
    detailDisabled: [0, "clrDgDetailDisabled", "detailDisabled"],
    detailHidden: [0, "clrDgDetailHidden", "detailHidden"],
    item: [0, "clrDgItem", "item"],
    clrDgSelectable: "clrDgSelectable",
    selected: [0, "clrDgSelected", "selected"],
    expanded: [0, "clrDgExpanded", "expanded"],
    clrDgDetailOpenLabel: "clrDgDetailOpenLabel",
    clrDgDetailCloseLabel: "clrDgDetailCloseLabel",
    clrDgRowSelectionLabel: "clrDgRowSelectionLabel"
  },
  outputs: {
    selectedChanged: "clrDgSelectedChange",
    expandedChange: "clrDgExpandedChange"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([DatagridIfExpandService, {
    provide: IfExpandService,
    useExisting: DatagridIfExpandService
  }, {
    provide: LoadingListener,
    useExisting: DatagridIfExpandService
  }])],
  ngContentSelectors: _c68,
  decls: 9,
  vars: 3,
  consts: [["detail", ""], ["rowContent", ""], ["calculatedCells", ""], ["stickyCells", ""], ["scrollableCells", ""], ["detailButton", ""], ["class", "datagrid-row-clickable", 3, "mousedown", "click", 4, "ngIf"], [3, "clrExpandTrigger", 4, "ngIf"], [4, "ngIf"], [1, "datagrid-row-clickable", 3, "mousedown", "click"], [3, "clrExpandTrigger"], [3, "ngTemplateOutlet"], ["role", "row", 1, "datagrid-row-master", "datagrid-row-flex", 3, "id"], [1, "datagrid-row-sticky"], ["class", "datagrid-select datagrid-fixed-column datagrid-cell", "role", "gridcell", 3, "ngClass", 4, "ngIf"], ["class", "datagrid-row-actions datagrid-fixed-column datagrid-cell", "role", "gridcell", 4, "ngIf"], ["class", "datagrid-expandable-caret datagrid-fixed-column datagrid-cell", "role", "gridcell", 4, "ngIf"], ["class", "datagrid-detail-caret datagrid-fixed-column datagrid-cell", "role", "gridcell", 4, "ngIf"], [1, "datagrid-row-scrollable", 3, "ngClass"], [1, "datagrid-scrolling-cells"], ["role", "gridcell", 1, "datagrid-select", "datagrid-fixed-column", "datagrid-cell", 3, "ngClass"], [1, "clr-checkbox-wrapper"], ["tabindex", "-1", "type", "checkbox", 3, "ngModelChange", "ngModel", "id", "disabled"], [1, "clr-control-label", "clr-col-null", 3, "click", "for"], [1, "clr-sr-only"], ["tabindex", "-1", "type", "radio", "clrRadio", "", 3, "ngModelChange", "id", "name", "value", "ngModel", "checked", "disabled"], [1, "clr-control-label", "clr-col-null", 3, "for"], ["role", "gridcell", 1, "datagrid-row-actions", "datagrid-fixed-column", "datagrid-cell"], ["role", "gridcell", 1, "datagrid-expandable-caret", "datagrid-fixed-column", "datagrid-cell"], ["tabindex", "-1", "type", "button", "class", "datagrid-expandable-caret-button", 3, "click", 4, "ngIf"], ["clrSmall", "", 4, "ngIf"], ["tabindex", "-1", "type", "button", 1, "datagrid-expandable-caret-button", 3, "click"], ["shape", "angle", 1, "datagrid-expandable-caret-icon"], ["clrSmall", ""], ["role", "gridcell", 1, "datagrid-detail-caret", "datagrid-fixed-column", "datagrid-cell"], ["tabindex", "-1", "type", "button", "class", "datagrid-detail-caret-button", "aria-haspopup", "dialog", 3, "disabled", "is-open", "click", 4, "ngIf"], ["tabindex", "-1", "type", "button", "aria-haspopup", "dialog", 1, "datagrid-detail-caret-button", 3, "click", "disabled"], ["shape", "angle-double", 1, "datagrid-detail-caret-icon"]],
  template: function ClrDatagridRow_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c67);
      ɵɵtemplate(0, ClrDatagridRow_div_0_Template, 3, 2, "div", 6)(1, ClrDatagridRow_clr_expandable_animation_1_Template, 2, 2, "clr-expandable-animation", 7)(2, ClrDatagridRow_2_Template, 1, 1, null, 8)(3, ClrDatagridRow_ng_template_3_Template, 1, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor)(5, ClrDatagridRow_ng_template_5_Template, 16, 13, "ng-template", null, 1, ɵɵtemplateRefExtractor);
      ɵɵelementContainer(7, null, 2);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.selection.rowSelectionMode);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.selection.rowSelectionMode && ctx.expand.expandable);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.selection.rowSelectionMode && !ctx.expand.expandable);
    }
  },
  dependencies: [NgClass, NgIf, NgTemplateOutlet, CdsIconCustomTag, ClrLabel, ClrRadio, ClrRadioWrapper, DefaultValueAccessor, CheckboxControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgModel, ClrExpandableAnimation, ClrSpinner, ClrDatagridSelectionCellDirective],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridRow, [{
    type: Component,
    args: [{
      selector: "clr-dg-row",
      host: {
        "[class.datagrid-row]": "true",
        "[class.datagrid-selected]": "selected",
        "[attr.aria-owns]": "id",
        role: "rowgroup"
      },
      providers: [DatagridIfExpandService, {
        provide: IfExpandService,
        useExisting: DatagridIfExpandService
      }, {
        provide: LoadingListener,
        useExisting: DatagridIfExpandService
      }],
      template: `<!--
  We need to wrap the #rowContent in label element if we are in rowSelectionMode.
  Clicking of that wrapper label will equate to clicking on the whole row, which triggers the checkbox to toggle.
-->
<div
  class="datagrid-row-clickable"
  *ngIf="selection.rowSelectionMode"
  (mousedown)="clearRanges($event)"
  (click)="selectRow(!selected, $event)"
>
  <clr-expandable-animation [clrExpandTrigger]="expandAnimationTrigger" *ngIf="expand.expandable">
    <ng-template [ngTemplateOutlet]="rowContent"></ng-template>
  </clr-expandable-animation>
  <ng-template [ngTemplateOutlet]="rowContent" *ngIf="!expand.expandable"></ng-template>
</div>

<clr-expandable-animation
  *ngIf="!selection.rowSelectionMode && expand.expandable"
  [clrExpandTrigger]="expandAnimationTrigger"
>
  <ng-template [ngTemplateOutlet]="rowContent"></ng-template>
</clr-expandable-animation>

<ng-template *ngIf="!selection.rowSelectionMode && !expand.expandable" [ngTemplateOutlet]="rowContent"></ng-template>

<!--
    We need the "project into template" hacks because we need this in 2 different places
    depending on whether the details replace the row or not.
-->
<ng-template #detail>
  <ng-content select="clr-dg-row-detail"></ng-content>
</ng-template>

<ng-template #rowContent>
  <div
    role="row"
    [id]="id"
    class="datagrid-row-master datagrid-row-flex"
    [class.datagrid-row-detail-open]="detailService.isRowOpen(item)"
  >
    <div class="datagrid-row-sticky">
      <!-- Sticky elements here -->
      <ng-container #stickyCells>
        <div
          *ngIf="selection.selectionType === SELECTION_TYPE.Multi"
          class="datagrid-select datagrid-fixed-column datagrid-cell"
          [ngClass]="{ 'clr-form-control-disabled': !clrDgSelectable }"
          role="gridcell"
        >
          <div class="clr-checkbox-wrapper">
            <input
              tabindex="-1"
              type="checkbox"
              [ngModel]="selected"
              (ngModelChange)="toggle($event)"
              [id]="checkboxId"
              [disabled]="clrDgSelectable ? null : true"
              [attr.aria-disabled]="clrDgSelectable ? null : true"
            />
            <!-- Usage of class clr-col-null here prevents clr-col-* classes from being added when a datagrid is wrapped inside clrForm -->
            <label [for]="checkboxId" class="clr-control-label clr-col-null" (click)="clearRanges($event)">
              <span class="clr-sr-only">{{clrDgRowSelectionLabel || commonStrings.keys.select}}</span>
            </label>
          </div>
        </div>
        <div
          *ngIf="selection.selectionType === SELECTION_TYPE.Single"
          class="datagrid-select datagrid-fixed-column datagrid-cell"
          [ngClass]="{ 'clr-form-control-disabled': !clrDgSelectable }"
          role="gridcell"
        >
          <clr-radio-wrapper>
            <input
              tabindex="-1"
              type="radio"
              clrRadio
              [id]="radioId"
              [name]="selection.id + '-radio'"
              [value]="item"
              [(ngModel)]="selection.currentSingle"
              [checked]="selection.currentSingle === item"
              [disabled]="clrDgSelectable ? null : true"
              [attr.aria-disabled]="clrDgSelectable ? null : true"
            />
            <label class="clr-control-label clr-col-null" [for]="radioId">
              <span class="clr-sr-only">{{ clrDgRowSelectionLabel || commonStrings.keys.select }}</span>
            </label>
          </clr-radio-wrapper>
        </div>
        <div
          *ngIf="rowActionService.hasActionableRow"
          class="datagrid-row-actions datagrid-fixed-column datagrid-cell"
          role="gridcell"
        >
          <ng-content select="clr-dg-action-overflow"></ng-content>
        </div>
        <div
          *ngIf="globalExpandable.hasExpandableRow"
          class="datagrid-expandable-caret datagrid-fixed-column datagrid-cell"
          role="gridcell"
        >
          <ng-container *ngIf="expand.expandable">
            <button
              tabindex="-1"
              *ngIf="!expand.loading"
              (click)="toggleExpand()"
              type="button"
              class="datagrid-expandable-caret-button"
              [attr.aria-expanded]="expand.expanded"
              [attr.aria-label]="expand.expanded ? clrDgDetailCloseLabel : clrDgDetailOpenLabel"
              [attr.aria-controls]="expandableId"
            >
              <cds-icon
                shape="angle"
                class="datagrid-expandable-caret-icon"
                [attr.direction]="expand.expanded ? 'down' : 'right'"
                [attr.title]="expand.expanded ? commonStrings.keys.collapse : commonStrings.keys.expand"
              ></cds-icon>
            </button>
            <clr-spinner *ngIf="expand.loading" clrSmall>{{ commonStrings.keys.loading }}</clr-spinner>
          </ng-container>
        </div>
        <div
          *ngIf="detailService.enabled"
          class="datagrid-detail-caret datagrid-fixed-column datagrid-cell"
          role="gridcell"
        >
          <button
            tabindex="-1"
            (click)="detailService.toggle(item, detailButton)"
            type="button"
            #detailButton
            class="datagrid-detail-caret-button"
            [disabled]="detailDisabled"
            *ngIf="!detailHidden"
            [class.is-open]="detailService.isRowOpen(item)"
            [attr.aria-label]="detailService.isRowOpen(item) ? clrDgDetailCloseLabel : clrDgDetailOpenLabel"
            [attr.aria-expanded]="detailService.isRowOpen(item)"
            [attr.aria-controls]="detailService.id"
            aria-haspopup="dialog"
          >
            <cds-icon
              shape="angle-double"
              [attr.direction]="detailService.isRowOpen(item) ? 'left' : 'right'"
              class="datagrid-detail-caret-icon"
              [attr.title]="detailService.isRowOpen(item) ? commonStrings.keys.close: commonStrings.keys.open"
            ></cds-icon>
          </button>
        </div>
      </ng-container>
      <!-- placeholder for projecting other sticky cells as pinned-->
    </div>
    <div class="datagrid-row-scrollable" [ngClass]="{'is-replaced': replaced && expanded}">
      <div class="datagrid-scrolling-cells">
        <ng-content select="clr-dg-cell"></ng-content>
        <ng-container #scrollableCells></ng-container>
      </div>
      <!-- details here when replace, re-visit when sticky container is used for pinned cells -->
      <ng-template *ngIf="replaced && !expand.loading" [ngTemplateOutlet]="detail"></ng-template>
      <ng-template *ngIf="!replaced && !expand.loading" [ngTemplateOutlet]="detail"></ng-template>
    </div>
  </div>
</ng-template>

<ng-container #calculatedCells></ng-container>
`
    }]
  }], function() {
    return [{
      type: Selection
    }, {
      type: RowActionService
    }, {
      type: ExpandableRowsCount
    }, {
      type: DatagridIfExpandService
    }, {
      type: DetailService
    }, {
      type: DisplayModeService
    }, {
      type: ViewContainerRef
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: ClrCommonStringsService
    }, {
      type: Items
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [DOCUMENT]
      }]
    }];
  }, {
    selectedChanged: [{
      type: Output,
      args: ["clrDgSelectedChange"]
    }],
    expandedChange: [{
      type: Output,
      args: ["clrDgExpandedChange"]
    }],
    detailDisabled: [{
      type: Input,
      args: ["clrDgDetailDisabled"]
    }],
    detailHidden: [{
      type: Input,
      args: ["clrDgDetailHidden"]
    }],
    dgCells: [{
      type: ContentChildren,
      args: [ClrDatagridCell]
    }],
    expandAnimation: [{
      type: ViewChild,
      args: [ClrExpandableAnimation]
    }],
    detailButton: [{
      type: ViewChild,
      args: ["detailButton"]
    }],
    _stickyCells: [{
      type: ViewChild,
      args: ["stickyCells", {
        read: ViewContainerRef
      }]
    }],
    _scrollableCells: [{
      type: ViewChild,
      args: ["scrollableCells", {
        read: ViewContainerRef
      }]
    }],
    _calculatedCells: [{
      type: ViewChild,
      args: ["calculatedCells", {
        read: ViewContainerRef
      }]
    }],
    item: [{
      type: Input,
      args: ["clrDgItem"]
    }],
    clrDgSelectable: [{
      type: Input,
      args: ["clrDgSelectable"]
    }],
    selected: [{
      type: Input,
      args: ["clrDgSelected"]
    }],
    expanded: [{
      type: Input,
      args: ["clrDgExpanded"]
    }],
    clrDgDetailOpenLabel: [{
      type: Input
    }],
    clrDgDetailCloseLabel: [{
      type: Input
    }],
    clrDgRowSelectionLabel: [{
      type: Input
    }]
  });
})();
var DatagridColumnChanges;
(function(DatagridColumnChanges2) {
  DatagridColumnChanges2[DatagridColumnChanges2["WIDTH"] = 0] = "WIDTH";
  DatagridColumnChanges2[DatagridColumnChanges2["HIDDEN"] = 1] = "HIDDEN";
  DatagridColumnChanges2[DatagridColumnChanges2["INITIALIZE"] = 2] = "INITIALIZE";
})(DatagridColumnChanges || (DatagridColumnChanges = {}));
var ALL_COLUMN_CHANGES = Object.keys(DatagridColumnChanges).map((key) => DatagridColumnChanges[key]).filter((key) => key === parseInt(key, 10) && key !== DatagridColumnChanges.INITIALIZE);
var ColumnsService = class {
  constructor() {
    this.columns = [];
    this.columnsStateChange = new BehaviorSubject(null);
    this._cache = [];
  }
  get columnStates() {
    return this.columns.map((column) => column.value);
  }
  get hasHideableColumns() {
    return this.columnStates.filter((state2) => state2.hideable).length > 0;
  }
  get visibleColumns() {
    return this.columnStates.filter((state2) => !state2.hidden);
  }
  cache() {
    this._cache = this.columns.map((subject) => {
      const value = __spreadValues({}, subject.value);
      delete value.changes;
      return value;
    });
  }
  hasCache() {
    return !!this._cache.length;
  }
  resetToLastCache() {
    this._cache.forEach((state2, index) => {
      const cachedState = __spreadProps(__spreadValues({}, state2), {
        changes: ALL_COLUMN_CHANGES
      });
      this.columns[index].next(cachedState);
      this.columnsStateChange.next(cachedState);
    });
    this._cache = [];
  }
  // Helper method to emit a change to a column only when there is an actual diff to process for that column
  emitStateChangeAt(columnIndex, diff) {
    if (!this.columns[columnIndex]) {
      return;
    }
    this.emitStateChange(this.columns[columnIndex], diff);
  }
  emitStateChange(column, diff) {
    const changedState = __spreadValues(__spreadValues({}, column.value), diff);
    column.next(changedState);
    this.columnsStateChange.next(changedState);
  }
};
ColumnsService.ɵfac = function ColumnsService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ColumnsService)();
};
ColumnsService.ɵprov = ɵɵdefineInjectable({
  token: ColumnsService,
  factory: ColumnsService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnsService, [{
    type: Injectable
  }], null, null);
})();
var StateProvider = class {
  constructor(filters, sort, page, debouncer) {
    this.filters = filters;
    this.sort = sort;
    this.page = page;
    this.debouncer = debouncer;
    this.change = this.debouncer.change.pipe(map(() => this.state));
  }
  /*
   * By making this a getter, we open the possibility for a setter in the future.
   * It's been requested a couple times.
   */
  get state() {
    const state2 = {};
    if (this.page.size > 0) {
      state2.page = {
        from: this.page.firstItem,
        to: this.page.lastItem,
        size: this.page.size,
        current: this.page.current
      };
    }
    if (this.sort.comparator) {
      if (this.sort.comparator instanceof DatagridPropertyComparator) {
        state2.sort = {
          by: this.sort.comparator.prop,
          reverse: this.sort.reverse
        };
      } else {
        state2.sort = {
          by: this.sort.comparator,
          reverse: this.sort.reverse
        };
      }
    }
    const activeFilters = this.filters.getActiveFilters();
    if (activeFilters.length > 0) {
      state2.filters = [];
      for (const filter2 of activeFilters) {
        if (filter2.state) {
          state2.filters.push(filter2.state);
        } else {
          state2.filters.push(filter2);
        }
      }
    }
    return state2;
  }
};
StateProvider.ɵfac = function StateProvider_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || StateProvider)(ɵɵinject(FiltersProvider), ɵɵinject(Sort), ɵɵinject(Page), ɵɵinject(StateDebouncer));
};
StateProvider.ɵprov = ɵɵdefineInjectable({
  token: StateProvider,
  factory: StateProvider.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StateProvider, [{
    type: Injectable
  }], function() {
    return [{
      type: FiltersProvider
    }, {
      type: Sort
    }, {
      type: Page
    }, {
      type: StateDebouncer
    }];
  }, null);
})();
var DatagridCellRenderer = class {
  constructor(el, renderer, organizer) {
    this.el = el;
    this.renderer = renderer;
    this.subscriptions = [];
    this.subscriptions.push(organizer.filterRenderSteps(DatagridRenderStep.CLEAR_WIDTHS).subscribe(() => this.clearWidth()));
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
    if (this.stateSubscription) {
      this.stateSubscription.unsubscribe();
    }
  }
  resetState(state2) {
    this.setWidth(state2);
    this.setHidden(state2);
  }
  setWidth(state2) {
    if (state2.strictWidth) {
      this.renderer.addClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
    } else {
      this.renderer.removeClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
    }
    this.renderer.setStyle(this.el.nativeElement, "width", state2.width + "px");
  }
  setHidden(state2) {
    if (state2.hidden) {
      this.renderer.addClass(this.el.nativeElement, HIDDEN_COLUMN_CLASS);
    } else {
      this.renderer.removeClass(this.el.nativeElement, HIDDEN_COLUMN_CLASS);
    }
  }
  clearWidth() {
    this.renderer.removeClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
    this.renderer.setStyle(this.el.nativeElement, "width", null);
  }
};
DatagridCellRenderer.ɵfac = function DatagridCellRenderer_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || DatagridCellRenderer)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(DatagridRenderOrganizer));
};
DatagridCellRenderer.ɵdir = ɵɵdefineDirective({
  type: DatagridCellRenderer,
  selectors: [["clr-dg-cell"]],
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatagridCellRenderer, [{
    type: Directive,
    args: [{
      selector: "clr-dg-cell"
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: DatagridRenderOrganizer
    }];
  }, null);
})();
var DatagridRowRenderer = class {
  constructor(columnsService) {
    this.columnsService = columnsService;
    this.subscriptions = [];
  }
  ngAfterContentInit() {
    this.setCellsState();
    this.subscriptions.push(this.cells.changes.subscribe(() => {
      this.setCellsState();
    }));
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
  setCellsState() {
    if (this.cells.length === this.columnsService.columns.length) {
      this.cells.forEach((cell, index) => {
        if (this.columnsService.columns[index]) {
          cell.resetState(this.columnsService.columns[index].value);
        }
      });
    }
  }
};
DatagridRowRenderer.ɵfac = function DatagridRowRenderer_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || DatagridRowRenderer)(ɵɵdirectiveInject(ColumnsService));
};
DatagridRowRenderer.ɵdir = ɵɵdefineDirective({
  type: DatagridRowRenderer,
  selectors: [["clr-dg-row"], ["clr-dg-row-detail"]],
  contentQueries: function DatagridRowRenderer_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, DatagridRowRenderer, 5);
      ɵɵcontentQuery(dirIndex, DatagridCellRenderer, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.expandableRow = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cells = _t);
    }
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatagridRowRenderer, [{
    type: Directive,
    args: [{
      selector: "clr-dg-row, clr-dg-row-detail"
    }]
  }], function() {
    return [{
      type: ColumnsService
    }];
  }, {
    cells: [{
      type: ContentChildren,
      args: [DatagridCellRenderer]
    }],
    expandableRow: [{
      type: ContentChild,
      args: [forwardRef(() => DatagridRowRenderer)]
    }]
  });
})();
var ClrDatagrid = class {
  constructor(organizer, items, expandableRows, selection, rowActionService, stateProvider, displayMode, renderer, detailService, document2, el, page, commonStrings, keyNavigation, zone) {
    this.organizer = organizer;
    this.items = items;
    this.expandableRows = expandableRows;
    this.selection = selection;
    this.rowActionService = rowActionService;
    this.stateProvider = stateProvider;
    this.displayMode = displayMode;
    this.renderer = renderer;
    this.detailService = detailService;
    this.document = document2;
    this.el = el;
    this.page = page;
    this.commonStrings = commonStrings;
    this.keyNavigation = keyNavigation;
    this.zone = zone;
    this.clrDgSingleSelectionAriaLabel = this.commonStrings.keys.singleSelectionAriaLabel;
    this.clrDgSingleActionableAriaLabel = this.commonStrings.keys.singleActionableAriaLabel;
    this.clrDetailExpandableAriaLabel = this.commonStrings.keys.detailExpandableAriaLabel;
    this.clrDgDisablePageFocus = false;
    this.selectedChanged = new EventEmitter(false);
    this.singleSelectedChanged = new EventEmitter(false);
    this.refresh = new EventEmitter(false);
    this.SELECTION_TYPE = SelectionType;
    this._subscriptions = [];
    const datagridId = uniqueIdFactory();
    this.selectAllId = "clr-dg-select-all-" + datagridId;
    detailService.id = datagridId;
  }
  /**
   * Freezes the datagrid while data is loading
   */
  get loading() {
    return this.items.loading;
  }
  set loading(value) {
    this.items.loading = value;
  }
  /**
   * Array of all selected items
   */
  set selected(value) {
    if (value) {
      this.selection.selectionType = SelectionType.Multi;
    } else {
      this.selection.selectionType = SelectionType.None;
    }
    this.selection.updateCurrent(value, false);
  }
  /**
   * Selected item in single-select mode
   */
  set singleSelected(value) {
    this.selection.selectionType = SelectionType.Single;
    if (value) {
      this.selection.currentSingle = value;
    } else if (this.selection.currentSingle) {
      this.selection.currentSingle = null;
    }
  }
  set clrDgPreserveSelection(state2) {
    this.selection.preserveSelection = state2;
  }
  /**
   * @deprecated since 2.0, remove in 3.0
   *
   * Selection/Deselection on row click mode
   */
  set rowSelectionMode(value) {
    this.selection.rowSelectionMode = value;
  }
  set trackBy(value) {
    this.items.trackBy = value;
  }
  /**
   * Indicates if all currently displayed items are selected
   */
  get allSelected() {
    return this.selection.isAllSelected();
  }
  set allSelected(_value) {
    this.selection.toggleAll();
  }
  ngAfterContentInit() {
    if (!this.items.smart) {
      this.items.all = this.rows.map((row) => row.item);
    }
    const rowItemsChanges = this.rows.changes.pipe(switchMap((rows) => merge(
      // immediate update
      of(rows.map((row) => row.item)),
      // subsequent updates once per tick
      combineLatest(rows.map((row) => row.itemChanges)).pipe(debounceTime(0))
    )));
    this._subscriptions.push(rowItemsChanges.subscribe((all) => {
      if (!this.items.smart) {
        this.items.all = all;
      }
    }), this.rows.changes.subscribe(() => {
      for (let i = this._displayedRows.length - 1; i >= 0; i--) {
        if (this._displayedRows.get(i).destroyed) {
          this._displayedRows.remove(i);
        }
      }
      this.rows.forEach((row) => {
        this._displayedRows.insert(row._view);
      });
      this.updateDetailState();
      if (this.hasVirtualScroller) {
        const active = this.keyNavigation.getActiveCell();
        const isFocusInsideDatagrid = this.datagrid.nativeElement.contains(document.activeElement);
        if (active && isFocusInsideDatagrid) {
          this.zone.runOutsideAngular(() => {
            setTimeout(() => this.keyNavigation.setActiveCell(active));
          });
        }
      }
    }));
  }
  /**
   * Our setup happens in the view of some of our components, so we wait for it to be done before starting
   */
  ngAfterViewInit() {
    this.keyNavigation.initializeKeyGrid(this.el.nativeElement);
    this.updateDetailState();
    this.refresh.emit(this.stateProvider.state);
    this._subscriptions.push(
      this.stateProvider.change.subscribe((state2) => this.refresh.emit(state2)),
      this.selection.change.subscribe((s) => {
        if (this.selection.selectionType === SelectionType.Single) {
          this.singleSelectedChanged.emit(s);
        } else if (this.selection.selectionType === SelectionType.Multi) {
          this.selectedChanged.emit(s);
        }
      }),
      // Reinitialize arrow key navigation on page changes
      this.page.change.subscribe(() => {
        this.keyNavigation.resetKeyGrid();
        if (!this.clrDgDisablePageFocus) {
          this.datagridTable.nativeElement.focus();
        }
      }),
      // A subscription that listens for displayMode changes on the datagrid
      this.displayMode.view.subscribe((viewChange) => {
        for (let i = this._projectedDisplayColumns.length; i > 0; i--) {
          this._projectedDisplayColumns.detach();
        }
        for (let i = this._projectedCalculationColumns.length; i > 0; i--) {
          this._projectedCalculationColumns.detach();
        }
        for (let i = this._calculationRows.length; i > 0; i--) {
          this._calculationRows.detach();
        }
        for (let i = this._displayedRows.length; i > 0; i--) {
          this._displayedRows.detach();
        }
        if (viewChange === DatagridDisplayMode.DISPLAY) {
          this.renderer.removeClass(this.el.nativeElement, "datagrid-calculate-mode");
          this.columns.forEach((column) => {
            this._projectedDisplayColumns.insert(column._view);
          });
          this.rows.forEach((row) => {
            this._displayedRows.insert(row._view);
          });
        } else {
          this.renderer.addClass(this.el.nativeElement, "datagrid-calculate-mode");
          this.columns.forEach((column) => {
            this._projectedCalculationColumns.insert(column._view);
          });
          this.rows.forEach((row) => {
            this._calculationRows.insert(row._view);
          });
        }
      })
    );
    this.zone.runOutsideAngular(() => {
      this._subscriptions.push(fromEvent(this.document.body, "keydown").subscribe((event) => {
        if (event.key === "Shift") {
          this.selection.shiftPressed = true;
        }
      }), fromEvent(this.document.body, "keyup").subscribe((event) => {
        if (event.key === "Shift") {
          this.selection.shiftPressed = false;
        }
      }));
    });
  }
  ngOnDestroy() {
    this._subscriptions.forEach((sub) => sub.unsubscribe());
  }
  toggleAllSelected($event) {
    $event.preventDefault();
    if (this.hasVirtualScroller) {
      return;
    }
    this.allSelected = !this.allSelected;
  }
  resize() {
    this.organizer.resize();
  }
  /**
   * Checks the state of detail panel and if it's opened then
   * find the matching row and trigger the detail panel
   */
  updateDetailState() {
    if (this.detailService.state && this.detailService.isOpen) {
      const row = this.rows.find((row2) => this.items.trackBy(row2.item) === this.items.trackBy(this.detailService.state));
      if (row) {
        this.detailService.open(row.item, row.detailButton.nativeElement);
      } else if (!this.hasVirtualScroller) {
        setTimeout(() => {
          this.detailService.close();
        });
      }
    }
  }
  /**
   * Public method to re-trigger the computation of displayed items manually
   */
  dataChanged() {
    this.items.refresh();
  }
};
ClrDatagrid.ɵfac = function ClrDatagrid_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDatagrid)(ɵɵdirectiveInject(DatagridRenderOrganizer), ɵɵdirectiveInject(Items), ɵɵdirectiveInject(ExpandableRowsCount), ɵɵdirectiveInject(Selection), ɵɵdirectiveInject(RowActionService), ɵɵdirectiveInject(StateProvider), ɵɵdirectiveInject(DisplayModeService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(DetailService), ɵɵdirectiveInject(DOCUMENT), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Page), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(KeyNavigationGridController), ɵɵdirectiveInject(NgZone));
};
ClrDatagrid.ɵcmp = ɵɵdefineComponent({
  type: ClrDatagrid,
  selectors: [["clr-datagrid"]],
  contentQueries: function ClrDatagrid_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrDatagridItems, 5);
      ɵɵcontentQuery(dirIndex, ClrDatagridPlaceholder, 5);
      ɵɵcontentQuery(dirIndex, ClrDatagridColumn, 4);
      ɵɵcontentQuery(dirIndex, ClrDatagridRow, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.iterator = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.placeholder = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columns = _t);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.rows = _t);
    }
  },
  viewQuery: function ClrDatagrid_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c71, 5, ElementRef);
      ɵɵviewQuery(_c72, 5, ElementRef);
      ɵɵviewQuery(_c73, 5, ViewContainerRef);
      ɵɵviewQuery(_c74, 5, ViewContainerRef);
      ɵɵviewQuery(_c75, 5, ViewContainerRef);
      ɵɵviewQuery(_c76, 5, ViewContainerRef);
      ɵɵviewQuery(_c77, 5, ViewContainerRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.datagrid = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.datagridTable = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.scrollableColumns = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._projectedDisplayColumns = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._projectedCalculationColumns = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._displayedRows = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._calculationRows = _t.first);
    }
  },
  hostVars: 4,
  hostBindings: function ClrDatagrid_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("datagrid-host", true)("datagrid-detail-open", ctx.detailService.isOpen);
    }
  },
  inputs: {
    loadingMoreItems: [0, "clrLoadingMoreItems", "loadingMoreItems"],
    clrDgSingleSelectionAriaLabel: "clrDgSingleSelectionAriaLabel",
    clrDgSingleActionableAriaLabel: "clrDgSingleActionableAriaLabel",
    clrDetailExpandableAriaLabel: "clrDetailExpandableAriaLabel",
    clrDgDisablePageFocus: "clrDgDisablePageFocus",
    loading: [0, "clrDgLoading", "loading"],
    selected: [0, "clrDgSelected", "selected"],
    singleSelected: [0, "clrDgSingleSelected", "singleSelected"],
    clrDgPreserveSelection: "clrDgPreserveSelection",
    rowSelectionMode: [0, "clrDgRowSelection", "rowSelectionMode"],
    trackBy: [0, "clrDgItemsTrackBy", "trackBy"]
  },
  outputs: {
    selectedChanged: "clrDgSelectedChange",
    singleSelectedChanged: "clrDgSingleSelectedChange",
    refresh: "clrDgRefresh"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([Selection, Sort, FiltersProvider, Page, Items, DatagridRenderOrganizer, RowActionService, ExpandableRowsCount, StateDebouncer, DetailService, StateProvider, TableSizeService, ColumnsService, DisplayModeService, KeyNavigationGridController])],
  ngContentSelectors: _c79,
  decls: 35,
  vars: 9,
  consts: [["datagrid", ""], ["datagridTable", ""], ["projectedDisplayColumns", ""], ["displayedRows", ""], ["projectedCalculationColumns", ""], ["calculationRows", ""], [1, "datagrid-outer-wrapper"], [1, "datagrid-inner-wrapper"], [1, "datagrid"], [1, "datagrid-table-wrapper"], ["role", "grid", "tabindex", "-1", 1, "datagrid-table"], ["role", "rowgroup", 1, "datagrid-header"], ["role", "row", 1, "datagrid-row"], [1, "datagrid-row-master", "datagrid-row-flex"], [1, "datagrid-row-sticky"], ["role", "columnheader", "class", "datagrid-column datagrid-select datagrid-fixed-column", 3, "keydown.space", 4, "ngIf"], ["role", "columnheader", "class", "datagrid-column datagrid-select datagrid-fixed-column", 4, "ngIf"], ["role", "columnheader", "class", "datagrid-column datagrid-row-actions datagrid-fixed-column", 4, "ngIf"], ["role", "columnheader", "class", "datagrid-column datagrid-expandable-caret datagrid-fixed-column", 4, "ngIf"], [1, "datagrid-row-scrollable"], ["role", "presentation", 1, "datagrid-rows"], ["class", "datagrid-row-loading", 4, "ngIf"], [4, "ngIf"], ["class", "datagrid-spinner", 4, "ngIf"], [1, "datagrid-calculation-table"], [1, "datagrid-calculation-header"], ["role", "columnheader", 1, "datagrid-column", "datagrid-select", "datagrid-fixed-column", 3, "keydown.space"], ["class", "clr-checkbox-wrapper", 4, "ngIf"], [1, "datagrid-column-separator"], [1, "clr-checkbox-wrapper"], ["type", "checkbox", "tabindex", "-1", 3, "ngModelChange", "id", "ngModel"], [1, "clr-control-label", "clr-col-null", 3, "for"], [1, "clr-sr-only"], ["role", "columnheader", 1, "datagrid-column", "datagrid-select", "datagrid-fixed-column"], ["role", "columnheader", 1, "datagrid-column", "datagrid-row-actions", "datagrid-fixed-column"], ["role", "columnheader", 1, "datagrid-column", "datagrid-expandable-caret", "datagrid-fixed-column"], [1, "datagrid-row-loading"], ["clrMedium", ""], [1, "datagrid-spinner"]],
  template: function ClrDatagrid_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c78);
      ɵɵprojection(0);
      ɵɵelementStart(1, "div", 6)(2, "div", 7)(3, "div", 8, 0)(5, "div", 9)(6, "div", 10, 1)(8, "div", 11)(9, "div", 12)(10, "div", 13)(11, "div", 14);
      ɵɵtemplate(12, ClrDatagrid_div_12_Template, 3, 1, "div", 15)(13, ClrDatagrid_div_13_Template, 4, 1, "div", 16)(14, ClrDatagrid_div_14_Template, 4, 1, "div", 17)(15, ClrDatagrid_div_15_Template, 4, 1, "div", 18);
      ɵɵelementEnd();
      ɵɵelementStart(16, "div", 19);
      ɵɵelementContainer(17, null, 2);
      ɵɵelementEnd()()()();
      ɵɵelementStart(19, "div", 20);
      ɵɵtemplate(20, ClrDatagrid_clr_dg_row_20_Template, 5, 1, "clr-dg-row", 21);
      ɵɵelementContainer(21, null, 3);
      ɵɵtemplate(23, ClrDatagrid_clr_dg_row_23_Template, 5, 1, "clr-dg-row", 21);
      ɵɵprojection(24, 1);
      ɵɵtemplate(25, ClrDatagrid_clr_dg_placeholder_25_Template, 1, 0, "clr-dg-placeholder", 22);
      ɵɵelementEnd()()()();
      ɵɵprojection(26, 2);
      ɵɵtemplate(27, ClrDatagrid_div_27_Template, 3, 0, "div", 23);
      ɵɵelementEnd();
      ɵɵprojection(28, 3);
      ɵɵelementEnd();
      ɵɵelementStart(29, "div", 24)(30, "div", 25);
      ɵɵelementContainer(31, null, 4);
      ɵɵelementEnd();
      ɵɵelementContainer(33, null, 5);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance(3);
      ɵɵattribute("aria-hidden", ctx.detailService.isOpen ? true : null);
      ɵɵadvance(9);
      ɵɵproperty("ngIf", ctx.selection.selectionType === ctx.SELECTION_TYPE.Multi);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.selection.selectionType === ctx.SELECTION_TYPE.Single);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.rowActionService.hasActionableRow);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.expandableRows.hasExpandableRow || ctx.detailService.enabled);
      ɵɵadvance(5);
      ɵɵproperty("ngIf", ctx.loadingMoreItems);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.loadingMoreItems);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", !ctx.placeholder);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.loading);
    }
  },
  dependencies: [NgIf, ClrLabel, CheckboxControlValueAccessor, NgControlStatus, NgModel, ClrSpinner, ClrDatagridCell, ClrDatagridPlaceholder, ClrDatagridRow, ClrDatagridSelectionCellDirective, DatagridCellRenderer, DatagridRowRenderer, ActionableOompaLoompa, ExpandableOompaLoompa],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagrid, [{
    type: Component,
    args: [{
      selector: "clr-datagrid",
      providers: [Selection, Sort, FiltersProvider, Page, Items, DatagridRenderOrganizer, RowActionService, ExpandableRowsCount, StateDebouncer, DetailService, StateProvider, TableSizeService, ColumnsService, DisplayModeService, KeyNavigationGridController],
      host: {
        "[class.datagrid-host]": "true",
        "[class.datagrid-detail-open]": "detailService.isOpen"
      },
      template: '<!--\n  ~ Copyright (c) 2016-2024 Broadcom. All Rights Reserved.\n  ~ The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<ng-content select="clr-dg-action-bar"></ng-content>\n<div class="datagrid-outer-wrapper">\n  <div class="datagrid-inner-wrapper">\n    <div class="datagrid" #datagrid [attr.aria-hidden]="detailService.isOpen ? true : null">\n      <div class="datagrid-table-wrapper">\n        <div role="grid" class="datagrid-table" tabindex="-1" #datagridTable>\n          <div role="rowgroup" class="datagrid-header">\n            <div role="row" class="datagrid-row">\n              <div class="datagrid-row-master datagrid-row-flex">\n                <div class="datagrid-row-sticky">\n                  <!--header for datagrid where you can select multiple rows -->\n                  <div\n                    role="columnheader"\n                    class="datagrid-column datagrid-select datagrid-fixed-column"\n                    *ngIf="selection.selectionType === SELECTION_TYPE.Multi"\n                    (keydown.space)="toggleAllSelected($event)"\n                  >\n                    <div *ngIf="!hasVirtualScroller" class="clr-checkbox-wrapper">\n                      <!-- We need to move focus and space-key handling to the parent because of keyboard arrow key navigation,\n                           which is not able to transfer focus directly on the input when focused with the tab key -->\n                      <input\n                        type="checkbox"\n                        [id]="selectAllId"\n                        [(ngModel)]="allSelected"\n                        [attr.aria-label]="commonStrings.keys.selectAll"\n                        tabindex="-1"\n                      />\n                      <!-- Usage of class clr-col-null here prevents clr-col-* classes from being added when a datagrid is wrapped inside clrForm -->\n                      <label [for]="selectAllId" class="clr-control-label clr-col-null">\n                        <span class="clr-sr-only">{{commonStrings.keys.selectAll}}</span>\n                      </label>\n                    </div>\n\n                    <div class="datagrid-column-separator"></div>\n                  </div>\n                  <!-- header for datagrid where you can select one row only -->\n                  <div\n                    role="columnheader"\n                    class="datagrid-column datagrid-select datagrid-fixed-column"\n                    *ngIf="selection.selectionType === SELECTION_TYPE.Single"\n                  >\n                    <div class="clr-sr-only">{{clrDgSingleSelectionAriaLabel}}</div>\n                    <div class="datagrid-column-separator"></div>\n                  </div>\n                  <!-- header for single row action; only displayType if we have at least one actionable row in datagrid -->\n                  <div\n                    role="columnheader"\n                    class="datagrid-column datagrid-row-actions datagrid-fixed-column"\n                    *ngIf="rowActionService.hasActionableRow"\n                  >\n                    <div class="clr-sr-only">{{clrDgSingleActionableAriaLabel}}</div>\n                    <div class="datagrid-column-separator"></div>\n                  </div>\n                  <!-- header for carets; only displayType if we have at least one expandable row in datagrid -->\n                  <div\n                    role="columnheader"\n                    class="datagrid-column datagrid-expandable-caret datagrid-fixed-column"\n                    *ngIf="expandableRows.hasExpandableRow || detailService.enabled"\n                  >\n                    <div class="clr-sr-only">{{clrDetailExpandableAriaLabel}}</div>\n                    <div class="datagrid-column-separator"></div>\n                  </div>\n                </div>\n                <div class="datagrid-row-scrollable">\n                  <ng-container #projectedDisplayColumns></ng-container>\n                </div>\n              </div>\n            </div>\n          </div>\n\n          <div role="presentation" class="datagrid-rows">\n            <clr-dg-row class="datagrid-row-loading" *ngIf="loadingMoreItems">\n              <clr-dg-cell>\n                <clr-spinner clrMedium></clr-spinner>\n                <span>{{ commonStrings.keys.loading }}</span>\n              </clr-dg-cell>\n            </clr-dg-row>\n\n            <ng-container #displayedRows></ng-container>\n\n            <clr-dg-row class="datagrid-row-loading" *ngIf="loadingMoreItems">\n              <clr-dg-cell>\n                <clr-spinner clrMedium></clr-spinner>\n                <span>{{ commonStrings.keys.loading }}</span>\n              </clr-dg-cell>\n            </clr-dg-row>\n\n            <!-- Custom placeholder overrides the default empty one -->\n            <ng-content select="clr-dg-placeholder"></ng-content>\n            <clr-dg-placeholder *ngIf="!placeholder"></clr-dg-placeholder>\n          </div>\n        </div>\n      </div>\n    </div>\n    <ng-content select="clr-dg-footer"></ng-content>\n    <div class="datagrid-spinner" *ngIf="loading">\n      <clr-spinner clrMedium>Loading</clr-spinner>\n    </div>\n  </div>\n  <ng-content select="[clrIfDetail],clr-dg-detail"></ng-content>\n</div>\n\n<div class="datagrid-calculation-table">\n  <div class="datagrid-calculation-header">\n    <ng-container #projectedCalculationColumns></ng-container>\n  </div>\n  <ng-container #calculationRows></ng-container>\n</div>\n'
    }]
  }], function() {
    return [{
      type: DatagridRenderOrganizer
    }, {
      type: Items
    }, {
      type: ExpandableRowsCount
    }, {
      type: Selection
    }, {
      type: RowActionService
    }, {
      type: StateProvider
    }, {
      type: DisplayModeService
    }, {
      type: Renderer2
    }, {
      type: DetailService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [DOCUMENT]
      }]
    }, {
      type: ElementRef
    }, {
      type: Page
    }, {
      type: ClrCommonStringsService
    }, {
      type: KeyNavigationGridController
    }, {
      type: NgZone
    }];
  }, {
    loadingMoreItems: [{
      type: Input,
      args: ["clrLoadingMoreItems"]
    }],
    clrDgSingleSelectionAriaLabel: [{
      type: Input
    }],
    clrDgSingleActionableAriaLabel: [{
      type: Input
    }],
    clrDetailExpandableAriaLabel: [{
      type: Input
    }],
    clrDgDisablePageFocus: [{
      type: Input
    }],
    selectedChanged: [{
      type: Output,
      args: ["clrDgSelectedChange"]
    }],
    singleSelectedChanged: [{
      type: Output,
      args: ["clrDgSingleSelectedChange"]
    }],
    refresh: [{
      type: Output,
      args: ["clrDgRefresh"]
    }],
    iterator: [{
      type: ContentChild,
      args: [ClrDatagridItems]
    }],
    placeholder: [{
      type: ContentChild,
      args: [ClrDatagridPlaceholder]
    }],
    columns: [{
      type: ContentChildren,
      args: [ClrDatagridColumn]
    }],
    rows: [{
      type: ContentChildren,
      args: [ClrDatagridRow]
    }],
    datagrid: [{
      type: ViewChild,
      args: ["datagrid", {
        read: ElementRef
      }]
    }],
    datagridTable: [{
      type: ViewChild,
      args: ["datagridTable", {
        read: ElementRef
      }]
    }],
    scrollableColumns: [{
      type: ViewChild,
      args: ["scrollableColumns", {
        read: ViewContainerRef
      }]
    }],
    _projectedDisplayColumns: [{
      type: ViewChild,
      args: ["projectedDisplayColumns", {
        read: ViewContainerRef
      }]
    }],
    _projectedCalculationColumns: [{
      type: ViewChild,
      args: ["projectedCalculationColumns", {
        read: ViewContainerRef
      }]
    }],
    _displayedRows: [{
      type: ViewChild,
      args: ["displayedRows", {
        read: ViewContainerRef
      }]
    }],
    _calculationRows: [{
      type: ViewChild,
      args: ["calculationRows", {
        read: ViewContainerRef
      }]
    }],
    loading: [{
      type: Input,
      args: ["clrDgLoading"]
    }],
    selected: [{
      type: Input,
      args: ["clrDgSelected"]
    }],
    singleSelected: [{
      type: Input,
      args: ["clrDgSingleSelected"]
    }],
    clrDgPreserveSelection: [{
      type: Input
    }],
    rowSelectionMode: [{
      type: Input,
      args: ["clrDgRowSelection"]
    }],
    trackBy: [{
      type: Input,
      args: ["clrDgItemsTrackBy"]
    }]
  });
})();
var ClrDatagridActionBar = class {
};
ClrDatagridActionBar.ɵfac = function ClrDatagridActionBar_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDatagridActionBar)();
};
ClrDatagridActionBar.ɵcmp = ɵɵdefineComponent({
  type: ClrDatagridActionBar,
  selectors: [["clr-dg-action-bar"]],
  hostVars: 2,
  hostBindings: function ClrDatagridActionBar_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("datagrid-action-bar", true);
    }
  },
  standalone: false,
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrDatagridActionBar_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridActionBar, [{
    type: Component,
    args: [{
      selector: "clr-dg-action-bar",
      template: `<ng-content></ng-content>`,
      host: {
        "[class.datagrid-action-bar]": "true"
      }
    }]
  }], null, null);
})();
var clrDgActionId = 0;
var ClrDatagridActionOverflow = class {
  constructor(rowActionService, commonStrings, platformId, smartToggleService) {
    this.rowActionService = rowActionService;
    this.commonStrings = commonStrings;
    this.platformId = platformId;
    this.smartToggleService = smartToggleService;
    this.openChange = new EventEmitter(false);
    this.popoverId = uniqueIdFactory();
    this.smartPosition = {
      axis: ClrAxis.HORIZONTAL,
      side: ClrSide.AFTER,
      anchor: ClrAlignment.CENTER,
      content: ClrAlignment.CENTER
    };
    this._open = false;
    this.subscriptions = [];
    rowActionService.register();
    this.subscriptions.push(smartToggleService.openChange.subscribe((openState) => {
      this.open = openState;
    }), smartToggleService.popoverVisible.subscribe((visible) => {
      if (visible) {
        this.initializeFocus();
      }
    }));
    this.popoverId = "clr-action-menu" + clrDgActionId++;
  }
  get open() {
    return this._open;
  }
  set open(open) {
    const openState = !!open;
    if (!!openState !== this.open) {
      this.smartToggleService.open = openState;
      this.openChange.emit(openState);
      this._open = openState;
    }
  }
  ngOnDestroy() {
    this.rowActionService.unregister();
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
  closeOverflowContent(event) {
    this.smartToggleService.toggleWithEvent(event);
  }
  initializeFocus() {
    if (isPlatformBrowser(this.platformId)) {
      const buttons = Array.from(document.querySelectorAll("button.action-item"));
      if (buttons.length) {
        this.keyFocus.current = 0;
        this.keyFocus.focusableItems = buttons;
        this.keyFocus.focusCurrent();
      }
    }
  }
};
ClrDatagridActionOverflow.ɵfac = function ClrDatagridActionOverflow_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDatagridActionOverflow)(ɵɵdirectiveInject(RowActionService), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(PLATFORM_ID), ɵɵdirectiveInject(ClrPopoverToggleService));
};
ClrDatagridActionOverflow.ɵcmp = ɵɵdefineComponent({
  type: ClrDatagridActionOverflow,
  selectors: [["clr-dg-action-overflow"]],
  viewQuery: function ClrDatagridActionOverflow_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(ClrKeyFocus, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.keyFocus = _t.first);
    }
  },
  inputs: {
    buttonLabel: [0, "clrDgActionOverflowButtonLabel", "buttonLabel"],
    open: [0, "clrDgActionOverflowOpen", "open"]
  },
  outputs: {
    openChange: "clrDgActionOverflowOpenChange"
  },
  standalone: false,
  features: [ɵɵHostDirectivesFeature([ClrPopoverHostDirective])],
  ngContentSelectors: _c02,
  decls: 4,
  vars: 8,
  consts: [["anchor", ""], ["tabindex", "-1", "type", "button", "role", "button", "aria-haspopup", "true", "clrPopoverAnchor", "", "clrPopoverOpenCloseButton", "", 1, "datagrid-action-toggle"], ["shape", "ellipsis-vertical"], ["class", "datagrid-action-overflow", "clrKeyFocus", "", "cdkTrapFocus", "", 3, "id", "click", 4, "clrPopoverContent", "clrPopoverContentAt", "clrPopoverContentOutsideClickToClose", "clrPopoverContentScrollToClose"], ["clrKeyFocus", "", "cdkTrapFocus", "", 1, "datagrid-action-overflow", 3, "click", "id"]],
  template: function ClrDatagridActionOverflow_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "button", 1, 0);
      ɵɵelement(2, "cds-icon", 2);
      ɵɵelementEnd();
      ɵɵtemplate(3, ClrDatagridActionOverflow_div_3_Template, 2, 3, "div", 3);
    }
    if (rf & 2) {
      ɵɵattribute("aria-controls", ctx.popoverId)("aria-expanded", ctx.open)("aria-label", ctx.buttonLabel || ctx.commonStrings.keys.rowActions);
      ɵɵadvance(2);
      ɵɵattribute("title", ctx.buttonLabel || ctx.commonStrings.keys.rowActions);
      ɵɵadvance();
      ɵɵproperty("clrPopoverContent", ctx.open)("clrPopoverContentAt", ctx.smartPosition)("clrPopoverContentOutsideClickToClose", true)("clrPopoverContentScrollToClose", true);
    }
  },
  dependencies: [CdkTrapFocusModule_CdkTrapFocus, CdsIconCustomTag, ClrPopoverAnchor, ClrPopoverOpenCloseButton, ClrPopoverContent, ClrKeyFocus],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridActionOverflow, [{
    type: Component,
    args: [{
      selector: "clr-dg-action-overflow",
      hostDirectives: [ClrPopoverHostDirective],
      template: `
    <button
      tabindex="-1"
      class="datagrid-action-toggle"
      type="button"
      role="button"
      aria-haspopup="true"
      #anchor
      [attr.aria-controls]="popoverId"
      [attr.aria-expanded]="open"
      [attr.aria-label]="buttonLabel || commonStrings.keys.rowActions"
      clrPopoverAnchor
      clrPopoverOpenCloseButton
    >
      <cds-icon shape="ellipsis-vertical" [attr.title]="buttonLabel || commonStrings.keys.rowActions"></cds-icon>
    </button>

    <div
      class="datagrid-action-overflow"
      [id]="popoverId"
      [attr.aria-hidden]="!open"
      [attr.id]="popoverId"
      clrKeyFocus
      cdkTrapFocus
      (click)="closeOverflowContent($event)"
      *clrPopoverContent="open; at: smartPosition; outsideClickToClose: true; scrollToClose: true"
    >
      <ng-content></ng-content>
    </div>
  `
    }]
  }], function() {
    return [{
      type: RowActionService
    }, {
      type: ClrCommonStringsService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }, {
      type: ClrPopoverToggleService
    }];
  }, {
    buttonLabel: [{
      type: Input,
      args: ["clrDgActionOverflowButtonLabel"]
    }],
    openChange: [{
      type: Output,
      args: ["clrDgActionOverflowOpenChange"]
    }],
    keyFocus: [{
      type: ViewChild,
      args: [ClrKeyFocus]
    }],
    open: [{
      type: Input,
      args: ["clrDgActionOverflowOpen"]
    }]
  });
})();
var columnToggleTrackByFn = (index) => index;
var ClrDatagridColumnToggleButton = class {
  constructor(commonStrings, columnsService) {
    this.commonStrings = commonStrings;
    this.columnsService = columnsService;
    this.allSelected = new EventEmitter();
  }
  get clrAllSelected() {
    return this.allSelected.asObservable();
  }
  get allHideablesVisible() {
    return this.hideableColumns().filter((column) => column.value.hidden).length === 0;
  }
  selectAll() {
    this.hideableColumns().forEach((hideableColumn) => this.columnsService.emitStateChange(hideableColumn, {
      hidden: false,
      changes: [DatagridColumnChanges.HIDDEN]
    }));
    this.allSelected.next(true);
  }
  hideableColumns() {
    return this.columnsService.columns.filter((column) => column.value.hideable);
  }
};
ClrDatagridColumnToggleButton.ɵfac = function ClrDatagridColumnToggleButton_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDatagridColumnToggleButton)(ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(ColumnsService));
};
ClrDatagridColumnToggleButton.ɵcmp = ɵɵdefineComponent({
  type: ClrDatagridColumnToggleButton,
  selectors: [["clr-dg-column-toggle-button"]],
  outputs: {
    clrAllSelected: "clrAllSelected"
  },
  standalone: false,
  decls: 2,
  vars: 2,
  consts: [["type", "button", 1, "btn", "btn-sm", "btn-link", "switch-button", 3, "click", "disabled"]],
  template: function ClrDatagridColumnToggleButton_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "button", 0);
      ɵɵlistener("click", function ClrDatagridColumnToggleButton_Template_button_click_0_listener() {
        return ctx.selectAll();
      });
      ɵɵtext(1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("disabled", ctx.allHideablesVisible);
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", ctx.commonStrings.keys.selectAll, " ");
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridColumnToggleButton, [{
    type: Component,
    args: [{
      selector: "clr-dg-column-toggle-button",
      template: `
    <button
      class="btn btn-sm btn-link switch-button"
      (click)="selectAll()"
      [disabled]="allHideablesVisible"
      type="button"
    >
      {{ commonStrings.keys.selectAll }}
    </button>
  `
    }]
  }], function() {
    return [{
      type: ClrCommonStringsService
    }, {
      type: ColumnsService
    }];
  }, {
    clrAllSelected: [{
      type: Output,
      args: ["clrAllSelected"]
    }]
  });
})();
var ClrDatagridColumnToggle = class {
  constructor(commonStrings, columnsService, popoverToggleService) {
    this.commonStrings = commonStrings;
    this.columnsService = columnsService;
    this.popoverId = uniqueIdFactory();
    this.smartPosition = {
      axis: ClrAxis.VERTICAL,
      side: ClrSide.BEFORE,
      anchor: ClrAlignment.START,
      content: ClrAlignment.START
    };
    this.trackByFn = columnToggleTrackByFn;
    this.subscription = popoverToggleService.openChange.subscribe((change) => this.openState = change);
  }
  get allColumnsVisible() {
    return this._allColumnsVisible;
  }
  set allColumnsVisible(value) {
    this._allColumnsVisible = value;
  }
  get hideableColumnStates() {
    const hideables = this.columnsService.columns.filter((column) => column.value.hideable);
    return hideables.map((column) => column.value);
  }
  get hasOnlyOneVisibleColumn() {
    const nbNonHideableColumns = this.columnsService.columns.length - this.hideableColumnStates.length;
    return nbNonHideableColumns === 0 && this.hideableColumnStates.filter((columnState) => !columnState.hidden).length === 1;
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
  toggleColumnState(columnState, event) {
    const columnToToggle = this.columnsService.columns.filter((column) => column.value === columnState)[0];
    this.columnsService.emitStateChange(columnToToggle, {
      hidden: event,
      changes: [DatagridColumnChanges.HIDDEN]
    });
  }
  toggleSwitchPanel() {
    this.openState = !this.openState;
  }
  allColumnsSelected() {
    this.allSelectedElement.nativeElement.focus();
  }
};
ClrDatagridColumnToggle.ɵfac = function ClrDatagridColumnToggle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDatagridColumnToggle)(ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(ColumnsService), ɵɵdirectiveInject(ClrPopoverToggleService));
};
ClrDatagridColumnToggle.ɵcmp = ɵɵdefineComponent({
  type: ClrDatagridColumnToggle,
  selectors: [["clr-dg-column-toggle"]],
  viewQuery: function ClrDatagridColumnToggle_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c80, 5, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.allSelectedElement = _t.first);
    }
  },
  hostVars: 4,
  hostBindings: function ClrDatagridColumnToggle_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("column-switch-wrapper", true)("active", ctx.openState);
    }
  },
  standalone: false,
  features: [ɵɵHostDirectivesFeature([ClrPopoverHostDirective])],
  decls: 3,
  vars: 8,
  consts: [["allSelected", ""], ["role", "button", "type", "button", "clrPopoverAnchor", "", "clrPopoverOpenCloseButton", "", 1, "btn", "btn-sm", "column-toggle--action"], ["class", "column-switch", "role", "dialog", "cdkTrapFocus", "", 3, "id", 4, "clrPopoverContent", "clrPopoverContentAt", "clrPopoverContentOutsideClickToClose", "clrPopoverContentScrollToClose"], ["role", "dialog", "cdkTrapFocus", "", 1, "column-switch", 3, "id"], [1, "switch-header"], ["tabindex", "-1", 1, "clr-sr-only"], ["clrPopoverCloseButton", "", "type", "button", 1, "btn", "btn-sm", "btn-link", "toggle-switch-close-button"], ["shape", "window-close", "aria-hidden", "true"], [1, "clr-sr-only"], [1, "switch-content", "list-unstyled"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "switch-footer"], [3, "clrAllSelected"], ["clrCheckbox", "", "type", "checkbox", 3, "ngModelChange", "disabled", "ngModel"], [3, "ngTemplateOutlet"]],
  template: function ClrDatagridColumnToggle_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "button", 1);
      ɵɵtext(1);
      ɵɵelementEnd();
      ɵɵtemplate(2, ClrDatagridColumnToggle_div_2_Template, 15, 9, "div", 2);
    }
    if (rf & 2) {
      ɵɵattribute("aria-controls", ctx.popoverId)("aria-owns", ctx.popoverId)("aria-expanded", ctx.openState);
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", ctx.commonStrings.keys.pickColumns, " ");
      ɵɵadvance();
      ɵɵproperty("clrPopoverContent", ctx.openState)("clrPopoverContentAt", ctx.smartPosition)("clrPopoverContentOutsideClickToClose", true)("clrPopoverContentScrollToClose", true);
    }
  },
  dependencies: [NgForOf, NgTemplateOutlet, CdkTrapFocusModule_CdkTrapFocus, CdsIconCustomTag, ClrLabel, ClrCheckbox, ClrCheckboxWrapper, CheckboxControlValueAccessor, NgControlStatus, NgModel, ClrPopoverAnchor, ClrPopoverCloseButton, ClrPopoverOpenCloseButton, ClrPopoverContent, ClrDatagridColumnToggleButton],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridColumnToggle, [{
    type: Component,
    args: [{
      selector: "clr-dg-column-toggle",
      template: `
    <button
      role="button"
      type="button"
      class="btn btn-sm column-toggle--action"
      clrPopoverAnchor
      clrPopoverOpenCloseButton
      [attr.aria-controls]="popoverId"
      [attr.aria-owns]="popoverId"
      [attr.aria-expanded]="openState"
    >
      {{ commonStrings.keys.pickColumns }}
    </button>
    <div
      class="column-switch"
      role="dialog"
      [attr.aria-label]="commonStrings.keys.showColumnsMenuDescription"
      [id]="popoverId"
      cdkTrapFocus
      *clrPopoverContent="openState; at: smartPosition; outsideClickToClose: true; scrollToClose: true"
    >
      <div class="switch-header">
        <div class="clr-sr-only" tabindex="-1" #allSelected>{{ commonStrings.keys.allColumnsSelected }}</div>
        <h2>{{ commonStrings.keys.showColumns }}</h2>
        <button
          class="btn btn-sm btn-link toggle-switch-close-button"
          clrPopoverCloseButton
          type="button"
          [attr.aria-label]="commonStrings.keys.close"
        >
          <cds-icon shape="window-close" aria-hidden="true" [attr.title]="commonStrings.keys.close"></cds-icon>
          <span class="clr-sr-only">{{ commonStrings.keys.close }}</span>
        </button>
      </div>
      <ul class="switch-content list-unstyled">
        <li *ngFor="let columnState of hideableColumnStates; trackBy: trackByFn">
          <clr-checkbox-wrapper>
            <input
              clrCheckbox
              type="checkbox"
              [disabled]="hasOnlyOneVisibleColumn && !columnState.hidden"
              [ngModel]="!columnState.hidden"
              (ngModelChange)="toggleColumnState(columnState, !$event)"
            />
            <label>
              <ng-template [ngTemplateOutlet]="columnState.titleTemplateRef"></ng-template>
            </label>
          </clr-checkbox-wrapper>
        </li>
      </ul>
      <div class="switch-footer">
        <clr-dg-column-toggle-button (clrAllSelected)="allColumnsSelected()"></clr-dg-column-toggle-button>
      </div>
    </div>
  `,
      host: {
        "[class.column-switch-wrapper]": "true",
        "[class.active]": "openState"
      },
      hostDirectives: [ClrPopoverHostDirective]
    }]
  }], function() {
    return [{
      type: ClrCommonStringsService
    }, {
      type: ColumnsService
    }, {
      type: ClrPopoverToggleService
    }];
  }, {
    allSelectedElement: [{
      type: ViewChild,
      args: ["allSelected", {
        read: ElementRef
      }]
    }]
  });
})();
var ClrDatagridDetailHeader = class {
  constructor(detailService, commonStrings) {
    this.detailService = detailService;
    this.commonStrings = commonStrings;
  }
  get titleId() {
    return `${this.detailService.id}-title`;
  }
  ngAfterViewInit() {
    this.title.nativeElement.focus();
  }
};
ClrDatagridDetailHeader.ɵfac = function ClrDatagridDetailHeader_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDatagridDetailHeader)(ɵɵdirectiveInject(DetailService), ɵɵdirectiveInject(ClrCommonStringsService));
};
ClrDatagridDetailHeader.ɵcmp = ɵɵdefineComponent({
  type: ClrDatagridDetailHeader,
  selectors: [["clr-dg-detail-header"]],
  viewQuery: function ClrDatagridDetailHeader_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c81, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.title = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function ClrDatagridDetailHeader_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("datagrid-detail-header", true);
    }
  },
  standalone: false,
  ngContentSelectors: _c02,
  decls: 6,
  vars: 2,
  consts: [["title", ""], ["tabindex", "-1", 1, "datagrid-detail-header-title", 3, "id"], [1, "datagrid-detail-pane-close"], ["type", "button", 1, "btn", "btn-link", 3, "click"], ["shape", "times"]],
  template: function ClrDatagridDetailHeader_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 1, 0);
      ɵɵprojection(2);
      ɵɵelementEnd();
      ɵɵelementStart(3, "div", 2)(4, "button", 3);
      ɵɵlistener("click", function ClrDatagridDetailHeader_Template_button_click_4_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.detailService.close());
      });
      ɵɵelement(5, "cds-icon", 4);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵproperty("id", ctx.titleId);
      ɵɵadvance(4);
      ɵɵattribute("aria-label", ctx.commonStrings.keys.close);
    }
  },
  dependencies: [CdsIconCustomTag],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridDetailHeader, [{
    type: Component,
    args: [{
      selector: "clr-dg-detail-header",
      host: {
        "[class.datagrid-detail-header]": "true"
      },
      template: `
    <div #title class="datagrid-detail-header-title" tabindex="-1" [id]="titleId">
      <ng-content></ng-content>
    </div>
    <div class="datagrid-detail-pane-close">
      <button
        type="button"
        class="btn btn-link"
        (click)="detailService.close()"
        [attr.aria-label]="commonStrings.keys.close"
      >
        <cds-icon shape="times"></cds-icon>
      </button>
    </div>
  `
    }]
  }], function() {
    return [{
      type: DetailService
    }, {
      type: ClrCommonStringsService
    }];
  }, {
    title: [{
      type: ViewChild,
      args: ["title"]
    }]
  });
})();
var ClrDatagridDetail = class {
  constructor(detailService, commonStrings) {
    this.detailService = detailService;
    this.commonStrings = commonStrings;
  }
  get labelledBy() {
    if (this.ariaLabelledBy) {
      return this.header ? `${this.header.titleId} ${this.ariaLabelledBy}` : this.ariaLabelledBy;
    } else if (this.ariaLabel) {
      return null;
    } else {
      return this.header?.titleId || "";
    }
  }
  get label() {
    if (!this.ariaLabelledBy) {
      return this.ariaLabel || null;
    } else {
      return null;
    }
  }
  close() {
    this.detailService.close();
  }
};
ClrDatagridDetail.ɵfac = function ClrDatagridDetail_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDatagridDetail)(ɵɵdirectiveInject(DetailService), ɵɵdirectiveInject(ClrCommonStringsService));
};
ClrDatagridDetail.ɵcmp = ɵɵdefineComponent({
  type: ClrDatagridDetail,
  selectors: [["clr-dg-detail"]],
  contentQueries: function ClrDatagridDetail_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrDatagridDetailHeader, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.header = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function ClrDatagridDetail_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("datagrid-detail-pane", true);
    }
  },
  inputs: {
    ariaLabelledBy: [0, "clrDetailAriaLabelledBy", "ariaLabelledBy"],
    ariaLabel: [0, "clrDetailAriaLabel", "ariaLabel"]
  },
  standalone: false,
  ngContentSelectors: _c02,
  decls: 1,
  vars: 1,
  consts: [["cdkTrapFocus", "", "class", "datagrid-detail-pane-content", "role", "dialog", "aria-modal", "true", 3, "cdkTrapFocusAutoCapture", "id", 4, "ngIf"], ["cdkTrapFocus", "", "role", "dialog", "aria-modal", "true", 1, "datagrid-detail-pane-content", 3, "cdkTrapFocusAutoCapture", "id"], [1, "clr-sr-only"]],
  template: function ClrDatagridDetail_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, ClrDatagridDetail_div_0_Template, 6, 6, "div", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.detailService.isOpen);
    }
  },
  dependencies: [NgIf, CdkTrapFocusModule_CdkTrapFocus],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridDetail, [{
    type: Component,
    args: [{
      selector: "clr-dg-detail",
      host: {
        "[class.datagrid-detail-pane]": "true"
      },
      // We put the *ngIf on the cdkTrapFocus so it doesn't always exist on the page
      // have to test for presence of header for aria-describedby because it was causing unit tests to crash
      template: `
    <div
      cdkTrapFocus
      [cdkTrapFocusAutoCapture]="!header"
      class="datagrid-detail-pane-content"
      *ngIf="detailService.isOpen"
      role="dialog"
      [id]="detailService.id"
      aria-modal="true"
      [attr.aria-labelledby]="labelledBy"
      [attr.aria-label]="label"
    >
      <div class="clr-sr-only">{{ commonStrings.keys.detailPaneStart }}</div>
      <ng-content></ng-content>
      <div class="clr-sr-only">{{ commonStrings.keys.detailPaneEnd }}</div>
    </div>
  `
    }]
  }], function() {
    return [{
      type: DetailService
    }, {
      type: ClrCommonStringsService
    }];
  }, {
    ariaLabelledBy: [{
      type: Input,
      args: ["clrDetailAriaLabelledBy"]
    }],
    ariaLabel: [{
      type: Input,
      args: ["clrDetailAriaLabel"]
    }],
    header: [{
      type: ContentChild,
      args: [ClrDatagridDetailHeader]
    }]
  });
})();
var ClrDatagridDetailBody = class {
};
ClrDatagridDetailBody.ɵfac = function ClrDatagridDetailBody_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDatagridDetailBody)();
};
ClrDatagridDetailBody.ɵcmp = ɵɵdefineComponent({
  type: ClrDatagridDetailBody,
  selectors: [["clr-dg-detail-body"]],
  hostVars: 2,
  hostBindings: function ClrDatagridDetailBody_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("datagrid-detail-body", true);
    }
  },
  standalone: false,
  ngContentSelectors: _c02,
  decls: 2,
  vars: 0,
  consts: [[1, "clr-dg-detail-body-wrapper"]],
  template: function ClrDatagridDetailBody_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 0);
      ɵɵprojection(1);
      ɵɵelementEnd();
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridDetailBody, [{
    type: Component,
    args: [{
      selector: "clr-dg-detail-body",
      template: `
    <div class="clr-dg-detail-body-wrapper">
      <ng-content></ng-content>
    </div>
  `,
      host: {
        "[class.datagrid-detail-body]": "true"
      }
    }]
  }], null, null);
})();
var DatagridDetailRegisterer = class {
  constructor(expandableRowsCount) {
    this.expandableRowsCount = expandableRowsCount;
    if (expandableRowsCount) {
      expandableRowsCount.register();
    }
  }
  ngOnDestroy() {
    if (this.expandableRowsCount) {
      this.expandableRowsCount.unregister();
    }
  }
};
DatagridDetailRegisterer.ɵfac = function DatagridDetailRegisterer_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || DatagridDetailRegisterer)(ɵɵdirectiveInject(ExpandableRowsCount, 8));
};
DatagridDetailRegisterer.ɵdir = ɵɵdefineDirective({
  type: DatagridDetailRegisterer,
  selectors: [["", "clrIfExpanded", ""]],
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatagridDetailRegisterer, [{
    type: Directive,
    args: [{
      selector: "[clrIfExpanded]"
    }]
  }], function() {
    return [{
      type: ExpandableRowsCount,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var ClrDatagridFooter = class {
  constructor(selection, detailService, columnsService, commonStrings) {
    this.selection = selection;
    this.detailService = detailService;
    this.columnsService = columnsService;
    this.commonStrings = commonStrings;
    this.SELECTION_TYPE = SelectionType;
  }
  get hasHideableColumns() {
    return this.columnsService.hasHideableColumns;
  }
};
ClrDatagridFooter.ɵfac = function ClrDatagridFooter_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDatagridFooter)(ɵɵdirectiveInject(Selection), ɵɵdirectiveInject(DetailService), ɵɵdirectiveInject(ColumnsService), ɵɵdirectiveInject(ClrCommonStringsService));
};
ClrDatagridFooter.ɵcmp = ɵɵdefineComponent({
  type: ClrDatagridFooter,
  selectors: [["clr-dg-footer"]],
  hostVars: 2,
  hostBindings: function ClrDatagridFooter_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("datagrid-footer", true);
    }
  },
  standalone: false,
  ngContentSelectors: _c83,
  decls: 3,
  vars: 2,
  consts: [[4, "ngIf"], [1, "clr-form-control-disabled"], [1, "datagrid-footer-select"], ["clrCheckbox", "", "type", "checkbox", "checked", "checked", "disabled", ""], [1, "clr-sr-only"], [1, "datagrid-footer-description"]],
  template: function ClrDatagridFooter_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c82);
      ɵɵtemplate(0, ClrDatagridFooter_ng_container_0_Template, 8, 2, "ng-container", 0)(1, ClrDatagridFooter_ng_container_1_Template, 4, 1, "ng-container", 0);
      ɵɵprojection(2);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.selection.selectionType === ctx.SELECTION_TYPE.Multi && ctx.selection.current.length > 0);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.detailService.isOpen);
    }
  },
  dependencies: [NgIf, ClrLabel, ClrCheckbox, ClrCheckboxWrapper, ClrDatagridColumnToggle],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridFooter, [{
    type: Component,
    args: [{
      selector: "clr-dg-footer",
      template: `
    <ng-container *ngIf="selection.selectionType === SELECTION_TYPE.Multi && selection.current.length > 0">
      <div class="clr-form-control-disabled">
        <clr-checkbox-wrapper class="datagrid-footer-select">
          <input clrCheckbox type="checkbox" checked="checked" disabled />
          <label>{{ selection.current.length }}</label>
          <span class="clr-sr-only">{{ commonStrings.keys.selectedRows }}</span>
        </clr-checkbox-wrapper>
      </div>
    </ng-container>
    <ng-container *ngIf="!detailService.isOpen">
      <clr-dg-column-toggle *ngIf="hasHideableColumns"></clr-dg-column-toggle>
      <div class="datagrid-footer-description">
        <ng-content></ng-content>
      </div>
    </ng-container>
    <ng-content select="clr-dg-pagination"></ng-content>
  `,
      host: {
        "[class.datagrid-footer]": "true"
      }
    }]
  }], function() {
    return [{
      type: Selection
    }, {
      type: DetailService
    }, {
      type: ColumnsService
    }, {
      type: ClrCommonStringsService
    }];
  }, null);
})();
var COLUMN_STATE = new InjectionToken("COLUMN_STATE");
function columnStateFactory() {
  return new BehaviorSubject({
    changes: []
  });
}
var COLUMN_STATE_PROVIDER = {
  provide: COLUMN_STATE,
  useFactory: columnStateFactory
};
var ClrDatagridHideableColumn = class {
  constructor(titleTemplateRef, viewContainerRef, columnsService, columnState) {
    this.titleTemplateRef = titleTemplateRef;
    this.columnsService = columnsService;
    this.columnState = columnState;
    this.hiddenChange = new EventEmitter();
    this.subscriptions = [];
    viewContainerRef.createEmbeddedView(titleTemplateRef);
    if (!columnState) {
      throw new Error("The *clrDgHideableColumn directive can only be used inside of a clr-dg-column component.");
    }
  }
  /**
   *
   * @description
   * Setter fn for the @Input with the same name as this structural directive.
   * It allows the user to pre-configure the column's hide/show state. { hidden: true }
   * It's more verbose but has more Clarity.
   *
   * @example
   * *clrDgHideableColumn
   * *clrDgHideableColumn={hidden: false}
   * *clrDgHideableColumn={hidden: true}
   *
   */
  set clrDgHideableColumn(value) {
    if (typeof value === "string") {
      this.clrDgHidden = false;
      return;
    }
    this.clrDgHidden = value && value.hidden ? value.hidden : false;
  }
  set clrDgHidden(hidden) {
    this._hidden = hidden ? hidden : false;
    this.columnsService.emitStateChange(this.columnState, {
      hidden: this._hidden,
      changes: [DatagridColumnChanges.HIDDEN]
    });
  }
  ngOnInit() {
    this.columnsService.emitStateChange(this.columnState, {
      hideable: true,
      titleTemplateRef: this.titleTemplateRef,
      hidden: this._hidden,
      changes: [DatagridColumnChanges.HIDDEN]
    });
    this.subscriptions.push(this.columnState.subscribe((state2) => {
      if (state2.changes && state2.changes.indexOf(DatagridColumnChanges.HIDDEN) > -1) {
        this.hiddenChange.emit(state2.hidden);
      }
    }));
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
};
ClrDatagridHideableColumn.ɵfac = function ClrDatagridHideableColumn_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDatagridHideableColumn)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(ColumnsService), ɵɵdirectiveInject(COLUMN_STATE, 8));
};
ClrDatagridHideableColumn.ɵdir = ɵɵdefineDirective({
  type: ClrDatagridHideableColumn,
  selectors: [["", "clrDgHideableColumn", ""]],
  inputs: {
    clrDgHideableColumn: "clrDgHideableColumn",
    clrDgHidden: "clrDgHidden"
  },
  outputs: {
    hiddenChange: "clrDgHiddenChange"
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridHideableColumn, [{
    type: Directive,
    args: [{
      selector: "[clrDgHideableColumn]"
    }]
  }], function() {
    return [{
      type: TemplateRef
    }, {
      type: ViewContainerRef
    }, {
      type: ColumnsService
    }, {
      type: BehaviorSubject,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [COLUMN_STATE]
      }]
    }];
  }, {
    hiddenChange: [{
      type: Output,
      args: ["clrDgHiddenChange"]
    }],
    clrDgHideableColumn: [{
      type: Input,
      args: ["clrDgHideableColumn"]
    }],
    clrDgHidden: [{
      type: Input,
      args: ["clrDgHidden"]
    }]
  });
})();
var ClrIfDetail = class {
  constructor(templateRef, viewContainer, detailService) {
    this.templateRef = templateRef;
    this.viewContainer = viewContainer;
    this.detailService = detailService;
    this.stateChange = new EventEmitter(null);
    this.subscriptions = [];
    this.skip = false;
    detailService.enabled = true;
  }
  set state(model) {
    if (!this.skip) {
      this.detailService.toggle(model);
    }
    this.skip = false;
  }
  get viewContext() {
    return {
      $implicit: this.detailService.state
    };
  }
  ngOnInit() {
    this.subscriptions.push(this.detailService.stateChange.subscribe((state2) => {
      if (state2 === true) {
        this.togglePanel(true);
      } else {
        this.togglePanel(false);
      }
    }));
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
  togglePanel(showPanel) {
    let stateChangeParams = null;
    if (showPanel === true) {
      if (!this.embeddedViewRef) {
        const viewContext = this._createContextForwardProxy();
        this.embeddedViewRef = this.viewContainer.createEmbeddedView(this.templateRef, viewContext);
      }
      this.skip = true;
      stateChangeParams = this.detailService.state;
    } else {
      this.viewContainer.clear();
      this.embeddedViewRef = null;
    }
    this.stateChange.emit(stateChangeParams);
  }
  /**
   * For a given outlet instance, we create a proxy object that delegates
   * to the user-specified context. This allows changing, or swapping out
   * the context object completely without having to destroy/re-create the view.
   */
  _createContextForwardProxy() {
    return new Proxy({}, {
      set: (_target, prop, newValue) => {
        if (!this.viewContext) {
          return false;
        }
        return Reflect.set(this.viewContext, prop, newValue);
      },
      get: (_target, prop, receiver) => {
        if (!this.viewContext) {
          return void 0;
        }
        return Reflect.get(this.viewContext, prop, receiver);
      }
    });
  }
};
ClrIfDetail.ɵfac = function ClrIfDetail_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrIfDetail)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(DetailService));
};
ClrIfDetail.ɵdir = ɵɵdefineDirective({
  type: ClrIfDetail,
  selectors: [["", "clrIfDetail", ""]],
  inputs: {
    state: [0, "clrIfDetail", "state"]
  },
  outputs: {
    stateChange: "clrIfDetailChange"
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrIfDetail, [{
    type: Directive,
    args: [{
      selector: "[clrIfDetail]"
    }]
  }], function() {
    return [{
      type: TemplateRef
    }, {
      type: ViewContainerRef
    }, {
      type: DetailService
    }];
  }, {
    stateChange: [{
      type: Output,
      args: ["clrIfDetailChange"]
    }],
    state: [{
      type: Input,
      args: ["clrIfDetail"]
    }]
  });
})();
var ClrDatagridPageSize = class {
  constructor(page) {
    this.page = page;
    this.pageSizeOptionsId = uniqueIdFactory();
  }
  ngOnInit() {
    if (!this.pageSizeOptions || this.pageSizeOptions.length === 0) {
      this.pageSizeOptions = [this.page.size];
    }
  }
};
ClrDatagridPageSize.ɵfac = function ClrDatagridPageSize_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDatagridPageSize)(ɵɵdirectiveInject(Page));
};
ClrDatagridPageSize.ɵcmp = ɵɵdefineComponent({
  type: ClrDatagridPageSize,
  selectors: [["clr-dg-page-size"]],
  inputs: {
    pageSizeOptions: [0, "clrPageSizeOptions", "pageSizeOptions"],
    pageSizeOptionsId: [0, "clrPageSizeOptionsId", "pageSizeOptionsId"]
  },
  standalone: false,
  ngContentSelectors: _c02,
  decls: 5,
  vars: 6,
  consts: [[3, "for"], [1, "clr-select-wrapper"], [3, "ngModelChange", "id", "ngModel"], [3, "ngValue", 4, "ngFor", "ngForOf"], [3, "ngValue"]],
  template: function ClrDatagridPageSize_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "label", 0);
      ɵɵprojection(1);
      ɵɵelementEnd();
      ɵɵelementStart(2, "div", 1)(3, "select", 2);
      ɵɵtwoWayListener("ngModelChange", function ClrDatagridPageSize_Template_select_ngModelChange_3_listener($event) {
        ɵɵtwoWayBindingSet(ctx.page.size, $event) || (ctx.page.size = $event);
        return $event;
      });
      ɵɵtemplate(4, ClrDatagridPageSize_option_4_Template, 2, 2, "option", 3);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵproperty("for", ctx.pageSizeOptionsId);
      ɵɵadvance(3);
      ɵɵclassProp("clr-page-size-select", true);
      ɵɵproperty("id", ctx.pageSizeOptionsId);
      ɵɵtwoWayProperty("ngModel", ctx.page.size);
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.pageSizeOptions);
    }
  },
  dependencies: [NgForOf, ClrLabel, NgSelectOption, ɵNgSelectMultipleOption, SelectControlValueAccessor, NgControlStatus, NgModel],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridPageSize, [{
    type: Component,
    args: [{
      selector: "clr-dg-page-size",
      template: `
    <label [for]="pageSizeOptionsId"><ng-content></ng-content></label>
    <div class="clr-select-wrapper">
      <select [id]="pageSizeOptionsId" [class.clr-page-size-select]="true" [(ngModel)]="page.size">
        <option *ngFor="let option of pageSizeOptions" [ngValue]="option">{{ option }}</option>
      </select>
    </div>
  `
    }]
  }], function() {
    return [{
      type: Page
    }];
  }, {
    pageSizeOptions: [{
      type: Input,
      args: ["clrPageSizeOptions"]
    }],
    pageSizeOptionsId: [{
      type: Input,
      args: ["clrPageSizeOptionsId"]
    }]
  });
})();
var ClrDatagridPagination = class {
  constructor(page, commonStrings, detailService) {
    this.page = page;
    this.commonStrings = commonStrings;
    this.detailService = detailService;
    this.currentChanged = new EventEmitter(false);
    page.activated = true;
  }
  /**
   * Page size
   */
  get pageSize() {
    return this.page.size;
  }
  set pageSize(size) {
    if (typeof size === "number") {
      this.page.size = size;
    }
  }
  /**
   * Total items (needed to guess the last page)
   */
  get totalItems() {
    return this.page.totalItems;
  }
  set totalItems(total) {
    if (typeof total === "number") {
      this.page.totalItems = total;
    }
  }
  /**
   * Last page
   */
  get lastPage() {
    return this.page.last;
  }
  set lastPage(last) {
    if (typeof last === "number") {
      this.page.last = last;
    }
  }
  /**
   * Current page
   */
  get currentPage() {
    return this.page.current;
  }
  set currentPage(page) {
    if (typeof page === "number") {
      this.page.current = page;
    }
  }
  /**
   * Index of the first item displayed on the current page, starting at 0, -1 if none displayed
   */
  get firstItem() {
    return this.page.firstItem;
  }
  /**
   * Index of the last item displayed on the current page, starting at 0, -1 if none displayed
   */
  get lastItem() {
    return this.page.lastItem;
  }
  /**
   * Conditionally adds page numbers before and after the current page
   */
  get middlePages() {
    const middlePages = [];
    if (this.page.current > 1) {
      middlePages.push(this.page.current - 1);
    }
    middlePages.push(this.page.current);
    if (this.page.current < this.page.last) {
      middlePages.push(this.page.current + 1);
    }
    return middlePages;
  }
  /**********
   * Subscription to the Page service for page changes.
   * Note: this only emits after the datagrid is initialized/stabalized and the page changes.
   */
  ngOnInit() {
    if (!this.page.size) {
      this.page.size = 10;
    }
    this._pageSubscription = this.page.change.subscribe((current) => this.currentChanged.emit(current));
  }
  ngOnDestroy() {
    this.page.resetPageSize(true);
    if (this._pageSubscription) {
      this._pageSubscription.unsubscribe();
    }
  }
  /**
   * Moves to the previous page if it exists
   */
  previous() {
    this.page.previous();
  }
  /**
   * Moves to the next page if it exists
   */
  next() {
    this.page.next();
  }
  verifyCurrentPage(event) {
    const parsed = parseInt(event.target.value, 10);
    if (parsed !== this.page.current) {
      event.target.value = this.page.current;
    }
  }
  /**
   * We only update the pagination's current page on enter.
   */
  updateCurrentPage(event) {
    const parsed = parseInt(event.target.value, 10);
    if (!isNaN(parsed)) {
      if (parsed < 1) {
        this.page.current = 1;
      } else if (parsed > this.page.last) {
        this.page.current = this.page.last;
      } else {
        this.page.current = parsed;
      }
    }
    this.currentPageInputRef.nativeElement.value = this.page.current.toString();
  }
};
ClrDatagridPagination.ɵfac = function ClrDatagridPagination_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDatagridPagination)(ɵɵdirectiveInject(Page), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(DetailService));
};
ClrDatagridPagination.ɵcmp = ɵɵdefineComponent({
  type: ClrDatagridPagination,
  selectors: [["clr-dg-pagination"]],
  contentQueries: function ClrDatagridPagination_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrDatagridPageSize, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._pageSizeComponent = _t.first);
    }
  },
  viewQuery: function ClrDatagridPagination_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c84, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.currentPageInputRef = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function ClrDatagridPagination_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("pagination", true);
    }
  },
  inputs: {
    disableCurrentPageInput: [0, "clrDgPageInputDisabled", "disableCurrentPageInput"],
    pageSize: [0, "clrDgPageSize", "pageSize"],
    totalItems: [0, "clrDgTotalItems", "totalItems"],
    lastPage: [0, "clrDgLastPage", "lastPage"],
    currentPage: [0, "clrDgPage", "currentPage"]
  },
  outputs: {
    currentChanged: "clrDgPageChange"
  },
  standalone: false,
  ngContentSelectors: _c86,
  decls: 2,
  vars: 2,
  consts: [["readOnly", ""], ["currentPageInput", ""], [4, "ngIf"], ["class", "pagination-size", 4, "ngIf"], [1, "pagination-description"], ["class", "pagination-list", 4, "ngIf"], [1, "pagination-size"], [1, "pagination-list"], ["type", "button", 1, "pagination-first", 3, "click", "disabled"], [1, "clr-sr-only"], ["shape", "step-forward-2", "direction", "down"], ["type", "button", 1, "pagination-previous", 3, "click", "disabled"], ["shape", "angle", "direction", "left"], ["type", "text", "class", "pagination-current clr-input", 3, "size", "value", "keydown.enter", "blur", 4, "ngIf", "ngIfElse"], ["type", "button", 1, "pagination-next", 3, "click", "disabled"], ["shape", "angle", "direction", "right"], ["type", "button", 1, "pagination-last", 3, "click", "disabled"], ["shape", "step-forward-2", "direction", "up"], ["type", "text", 1, "pagination-current", "clr-input", 3, "keydown.enter", "blur", "size", "value"], [1, "pagination-description-compact"]],
  template: function ClrDatagridPagination_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c85);
      ɵɵtemplate(0, ClrDatagridPagination_ng_container_0_Template, 5, 2, "ng-container", 2)(1, ClrDatagridPagination_ng_container_1_Template, 14, 10, "ng-container", 2);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", !ctx.detailService.isOpen);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.detailService.isOpen);
    }
  },
  dependencies: [NgIf, CdsIconCustomTag],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridPagination, [{
    type: Component,
    args: [{
      selector: "clr-dg-pagination",
      template: `
    <ng-container *ngIf="!detailService.isOpen">
      <div class="pagination-size" *ngIf="_pageSizeComponent">
        <ng-content select="clr-dg-page-size"></ng-content>
      </div>
      <div class="pagination-description">
        <ng-content></ng-content>
      </div>
      <div class="pagination-list" *ngIf="page.last > 1">
        <button
          type="button"
          class="pagination-first"
          [disabled]="page.current <= 1"
          (click)="page.current = 1"
          [attr.aria-label]="commonStrings.keys.firstPage"
        >
          <span class="clr-sr-only">{{ commonStrings.keys.firstPage }}</span>
          <cds-icon shape="step-forward-2" direction="down"></cds-icon>
        </button>
        <button
          type="button"
          class="pagination-previous"
          [disabled]="page.current <= 1"
          (click)="page.current = page.current - 1"
          [attr.aria-label]="commonStrings.keys.previousPage"
        >
          <span class="clr-sr-only">{{ commonStrings.keys.previousPage }}</span>
          <cds-icon shape="angle" direction="left"></cds-icon>
        </button>
        <input
          *ngIf="!disableCurrentPageInput; else readOnly"
          #currentPageInput
          type="text"
          class="pagination-current clr-input"
          [size]="page.last.toString().length"
          [value]="page.current"
          (keydown.enter)="updateCurrentPage($event)"
          (blur)="verifyCurrentPage($event)"
          [attr.aria-label]="commonStrings.keys.currentPage"
        />
        <ng-template #readOnly>
          <span>{{ page.current }}</span>
        </ng-template>

        &nbsp;/&nbsp;<span [attr.aria-label]="commonStrings.keys.totalPages">{{ page.last }}</span>
        <button
          type="button"
          class="pagination-next"
          [disabled]="page.current >= page.last"
          (click)="page.current = page.current + 1"
          [attr.aria-label]="commonStrings.keys.nextPage"
        >
          <span class="clr-sr-only">{{ commonStrings.keys.nextPage }}</span>
          <cds-icon shape="angle" direction="right"></cds-icon>
        </button>
        <button
          type="button"
          class="pagination-last"
          [disabled]="page.current >= page.last"
          (click)="page.current = page.last"
          [attr.aria-label]="commonStrings.keys.lastPage"
        >
          <span class="clr-sr-only">{{ commonStrings.keys.lastPage }}</span>
          <cds-icon shape="step-forward-2" direction="up"></cds-icon>
        </button>
      </div>
    </ng-container>
    <ng-container *ngIf="detailService.isOpen">
      <div class="pagination-description-compact">
        {{ page.firstItem + 1 }}-{{ page.lastItem + 1 }} / {{ page.totalItems }}
      </div>
      <div class="pagination-list">
        <button
          type="button"
          class="pagination-previous"
          [disabled]="page.current <= 1"
          (click)="page.current = page.current - 1"
          [attr.aria-label]="commonStrings.keys.previousPage"
        >
          <span class="clr-sr-only">{{ commonStrings.keys.previousPage }}</span>
          <cds-icon shape="angle" direction="left"></cds-icon>
        </button>
        <span>{{ page.current }}</span>
        <button
          type="button"
          class="pagination-next"
          [disabled]="page.current >= page.last"
          (click)="page.current = page.current + 1"
          [attr.aria-label]="commonStrings.keys.nextPage"
        >
          <span class="clr-sr-only">{{ commonStrings.keys.nextPage }}</span>
          <cds-icon shape="angle" direction="right"></cds-icon>
        </button>
      </div>
    </ng-container>
  `,
      host: {
        "[class.pagination]": "true"
      }
    }]
  }], function() {
    return [{
      type: Page
    }, {
      type: ClrCommonStringsService
    }, {
      type: DetailService
    }];
  }, {
    disableCurrentPageInput: [{
      type: Input,
      args: ["clrDgPageInputDisabled"]
    }],
    currentChanged: [{
      type: Output,
      args: ["clrDgPageChange"]
    }],
    _pageSizeComponent: [{
      type: ContentChild,
      args: [ClrDatagridPageSize]
    }],
    currentPageInputRef: [{
      type: ViewChild,
      args: ["currentPageInput"]
    }],
    pageSize: [{
      type: Input,
      args: ["clrDgPageSize"]
    }],
    totalItems: [{
      type: Input,
      args: ["clrDgTotalItems"]
    }],
    lastPage: [{
      type: Input,
      args: ["clrDgLastPage"]
    }],
    currentPage: [{
      type: Input,
      args: ["clrDgPage"]
    }]
  });
})();
var ClrDatagridRowDetail = class {
  constructor(selection, rowActionService, expand, expandableRows, commonStrings) {
    this.selection = selection;
    this.rowActionService = rowActionService;
    this.expand = expand;
    this.expandableRows = expandableRows;
    this.commonStrings = commonStrings;
    this.replacedRow = false;
    this.SELECTION_TYPE = SelectionType;
    this.subscriptions = [];
  }
  set replace(value) {
    this.expand.setReplace(!!value);
  }
  get beginningOfExpandableContentAriaText() {
    return this._beginningOfExpandableContentAriaText || `${this.commonStrings.keys.datagridExpandableBeginningOf} 
      ${this.commonStrings.keys.datagridExpandableRowContent}`;
  }
  get endOfExpandableContentAriaText() {
    return this._endOfExpandableContentAriaText || `${this.commonStrings.keys.datagridExpandableEndOf} 
      ${this.commonStrings.keys.datagridExpandableRowContent}`;
  }
  ngAfterContentInit() {
    this.subscriptions.push(this.expand.replace.subscribe((replaceChange) => {
      this.replacedRow = replaceChange;
    }));
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
};
ClrDatagridRowDetail.ɵfac = function ClrDatagridRowDetail_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDatagridRowDetail)(ɵɵdirectiveInject(Selection), ɵɵdirectiveInject(RowActionService), ɵɵdirectiveInject(DatagridIfExpandService), ɵɵdirectiveInject(ExpandableRowsCount), ɵɵdirectiveInject(ClrCommonStringsService));
};
ClrDatagridRowDetail.ɵcmp = ɵɵdefineComponent({
  type: ClrDatagridRowDetail,
  selectors: [["clr-dg-row-detail"]],
  contentQueries: function ClrDatagridRowDetail_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrDatagridCell, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cells = _t);
    }
  },
  hostAttrs: ["role", "gridcell"],
  hostVars: 7,
  hostBindings: function ClrDatagridRowDetail_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("id", ctx.expand.expandableId);
      ɵɵclassProp("datagrid-row-flex", true)("datagrid-row-detail", true)("datagrid-container", ctx.cells.length === 0);
    }
  },
  inputs: {
    _beginningOfExpandableContentAriaText: [0, "clrRowDetailBeginningAriaText", "_beginningOfExpandableContentAriaText"],
    _endOfExpandableContentAriaText: [0, "clrRowDetailEndAriaText", "_endOfExpandableContentAriaText"],
    replace: [0, "clrDgReplace", "replace"]
  },
  standalone: false,
  ngContentSelectors: _c02,
  decls: 5,
  vars: 3,
  consts: [[1, "clr-sr-only"]],
  template: function ClrDatagridRowDetail_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 0);
      ɵɵtext(1);
      ɵɵelementEnd();
      ɵɵprojection(2);
      ɵɵelementStart(3, "div", 0);
      ɵɵtext(4);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵtextInterpolate2(" ", ctx.beginningOfExpandableContentAriaText, " ", ctx.commonStrings.keys.datagridExpandableRowsHelperText, " ");
      ɵɵadvance(3);
      ɵɵtextInterpolate(ctx.endOfExpandableContentAriaText);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridRowDetail, [{
    type: Component,
    args: [{
      selector: "clr-dg-row-detail",
      template: `
    <div class="clr-sr-only">
      {{ beginningOfExpandableContentAriaText }}
      {{ commonStrings.keys.datagridExpandableRowsHelperText }}
    </div>
    <ng-content></ng-content>
    <div class="clr-sr-only">{{ endOfExpandableContentAriaText }}</div>
  `,
      host: {
        "[class.datagrid-row-flex]": "true",
        "[class.datagrid-row-detail]": "true",
        "[class.datagrid-container]": "cells.length === 0",
        "[attr.id]": "expand.expandableId",
        role: "gridcell"
      }
    }]
  }], function() {
    return [{
      type: Selection
    }, {
      type: RowActionService
    }, {
      type: DatagridIfExpandService
    }, {
      type: ExpandableRowsCount
    }, {
      type: ClrCommonStringsService
    }];
  }, {
    _beginningOfExpandableContentAriaText: [{
      type: Input,
      args: ["clrRowDetailBeginningAriaText"]
    }],
    _endOfExpandableContentAriaText: [{
      type: Input,
      args: ["clrRowDetailEndAriaText"]
    }],
    cells: [{
      type: ContentChildren,
      args: [ClrDatagridCell]
    }],
    replace: [{
      type: Input,
      args: ["clrDgReplace"]
    }]
  });
})();
var defaultCdkFixedSizeVirtualScrollInputs = {
  itemSize: 32,
  minBufferPx: 200,
  maxBufferPx: 400
};
var ClrDatagridVirtualScrollDirective = class {
  constructor(changeDetectorRef, iterableDiffers, items, ngZone, renderer2, templateRef, viewContainerRef, directionality, scrollDispatcher, viewportRuler, datagrid, columnsService, injector) {
    this.changeDetectorRef = changeDetectorRef;
    this.iterableDiffers = iterableDiffers;
    this.items = items;
    this.ngZone = ngZone;
    this.renderer2 = renderer2;
    this.templateRef = templateRef;
    this.viewContainerRef = viewContainerRef;
    this.directionality = directionality;
    this.scrollDispatcher = scrollDispatcher;
    this.viewportRuler = viewportRuler;
    this.datagrid = datagrid;
    this.columnsService = columnsService;
    this.injector = injector;
    this.renderedRangeChange = new EventEmitter();
    this._cdkFixedSizeVirtualScrollInputs = __spreadValues({}, defaultCdkFixedSizeVirtualScrollInputs);
    this.subscriptions = [];
    this.mutationChanges = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.target.classList.contains("datagrid-compact") && this.itemSize > 24) {
          this.itemSize = 24;
        }
      });
    });
    this.viewRepeater = new _RecycleViewRepeaterStrategy();
    this.cdkVirtualForInputs = {
      cdkVirtualForTrackBy: (index) => index
    };
    items.smartenUp();
    datagrid.hasVirtualScroller = true;
    datagrid.detailService.preventFocusScroll = true;
    this.datagridElementRef = datagrid.el;
    this.cdkVirtualForTemplateCacheSize = 20;
    this.mutationChanges.observe(this.datagridElementRef.nativeElement, {
      attributeFilter: ["class"],
      attributeOldValue: true
    });
    this.virtualScrollStrategy = new FixedSizeVirtualScrollStrategy(this._cdkFixedSizeVirtualScrollInputs.itemSize, this._cdkFixedSizeVirtualScrollInputs.minBufferPx, this._cdkFixedSizeVirtualScrollInputs.maxBufferPx);
  }
  get cdkVirtualForOf() {
    return this.cdkVirtualForInputs.cdkVirtualForOf;
  }
  set cdkVirtualForOf(value) {
    this.cdkVirtualForInputs.cdkVirtualForOf = value;
    this.items.all = value;
    this.updateCdkVirtualForInputs();
  }
  get cdkVirtualForTrackBy() {
    return this.cdkVirtualForInputs.cdkVirtualForTrackBy;
  }
  set cdkVirtualForTrackBy(value) {
    this.cdkVirtualForInputs.cdkVirtualForTrackBy = value;
    this.updateCdkVirtualForInputs();
  }
  get cdkVirtualForTemplate() {
    return this?.cdkVirtualForInputs?.cdkVirtualForTemplate;
  }
  set cdkVirtualForTemplate(value) {
    this.cdkVirtualForInputs.cdkVirtualForTemplate = value;
    this.updateCdkVirtualForInputs();
  }
  get cdkVirtualForTemplateCacheSize() {
    return this.cdkVirtualForInputs.cdkVirtualForTemplateCacheSize;
  }
  set cdkVirtualForTemplateCacheSize(value) {
    this.cdkVirtualForInputs.cdkVirtualForTemplateCacheSize = coerceNumberProperty(value);
    this.updateCdkVirtualForInputs();
  }
  get itemSize() {
    return this._cdkFixedSizeVirtualScrollInputs.itemSize;
  }
  set itemSize(value) {
    this._cdkFixedSizeVirtualScrollInputs.itemSize = coerceNumberProperty(value);
    this.updateFixedSizeVirtualScrollInputs();
  }
  get minBufferPx() {
    return this._cdkFixedSizeVirtualScrollInputs.minBufferPx;
  }
  set minBufferPx(value) {
    this._cdkFixedSizeVirtualScrollInputs.minBufferPx = coerceNumberProperty(value);
    this.updateFixedSizeVirtualScrollInputs();
  }
  get maxBufferPx() {
    return this._cdkFixedSizeVirtualScrollInputs.maxBufferPx;
  }
  set maxBufferPx(value) {
    this._cdkFixedSizeVirtualScrollInputs.maxBufferPx = coerceNumberProperty(value);
    this.updateFixedSizeVirtualScrollInputs();
  }
  ngAfterViewInit() {
    this.injector.runInContext(() => {
      this.virtualScrollViewport = this.createVirtualScrollViewportForDatagrid(this.changeDetectorRef, this.ngZone, this.renderer2, this.directionality, this.scrollDispatcher, this.viewportRuler, this.datagridElementRef, this.virtualScrollStrategy);
      this.cdkVirtualFor = createCdkVirtualForOfDirective(this.viewContainerRef, this.templateRef, this.iterableDiffers, this.viewRepeater, this.virtualScrollViewport, this.ngZone);
      this.virtualScrollViewport.ngOnInit();
    });
    this.gridRoleElement = this.datagridElementRef.nativeElement.querySelector('[role="grid"]');
    this.updateCdkVirtualForInputs();
    this.subscriptions.push(this.items.change.subscribe((newItems) => {
      this.cdkVirtualFor.cdkVirtualForOf = newItems;
    }), this.cdkVirtualFor.dataStream.subscribe((data) => {
      this.updateAriaRowCount(data.length);
    }), this.virtualScrollViewport.renderedRangeStream.subscribe((renderedRange) => {
      this.renderedRangeChange.emit(renderedRange);
    }), this.datagrid.refresh.subscribe((datagridState) => {
      if (datagridState.filters) {
        this.virtualScrollViewport.scrollToIndex(0);
      }
    }), this.columnsService.columnsStateChange.subscribe(() => {
      this.viewRepeater.detach();
    }));
  }
  ngDoCheck() {
    this.cdkVirtualFor?.ngDoCheck();
    this.updateAriaRowIndexes();
  }
  ngOnDestroy() {
    this.cdkVirtualFor?.ngOnDestroy();
    this.virtualScrollViewport?.ngOnDestroy();
    this.mutationChanges?.disconnect();
    this.subscriptions.forEach((subscription) => {
      subscription.unsubscribe();
    });
  }
  updateCdkVirtualForInputs() {
    if (this.cdkVirtualFor) {
      for (const cdkVirtualForInputKey of Object.keys(this.cdkVirtualForInputs)) {
        if (this.cdkVirtualFor[cdkVirtualForInputKey] !== this.cdkVirtualForInputs[cdkVirtualForInputKey]) {
          this.cdkVirtualFor[cdkVirtualForInputKey] = this.cdkVirtualForInputs[cdkVirtualForInputKey];
        }
      }
    }
  }
  updateFixedSizeVirtualScrollInputs() {
    if (this.virtualScrollStrategy) {
      this.virtualScrollStrategy.updateItemAndBufferSize(this._cdkFixedSizeVirtualScrollInputs.itemSize, this._cdkFixedSizeVirtualScrollInputs.minBufferPx, this._cdkFixedSizeVirtualScrollInputs.maxBufferPx);
    }
  }
  updateAriaRowCount(rowCount) {
    this.gridRoleElement?.setAttribute("aria-rowcount", rowCount.toString());
  }
  updateAriaRowIndexes() {
    for (let i = 0; i < this.viewContainerRef.length; i++) {
      const viewRef = this.viewContainerRef.get(i);
      const rootElements = viewRef.rootNodes;
      const datagridRowElement = rootElements.find((rowElement) => rowElement.tagName === "CLR-DG-ROW");
      const rowRoleElement = datagridRowElement?.querySelector('[role="row"]');
      rowRoleElement?.setAttribute("aria-rowindex", (viewRef.context.index + 1).toString());
    }
  }
  createVirtualScrollViewportForDatagrid(changeDetectorRef, ngZone, renderer2, directionality, scrollDispatcher, viewportRuler, datagridElementRef, virtualScrollStrategy) {
    const datagridDivElement = datagridElementRef.nativeElement.querySelector(".datagrid");
    const datagridTableElement = datagridElementRef.nativeElement.querySelector(".datagrid-table");
    const datagridRowsElement = datagridElementRef.nativeElement.querySelector(".datagrid-rows");
    const datagridDivElementRef = {
      nativeElement: datagridDivElement
    };
    let topOffset = 0;
    let totalContentSize = 0;
    function updateDatagridElementStyles() {
      datagridRowsElement.style.transform = `translateY(${topOffset}px)`;
      datagridRowsElement.style.height = `${totalContentSize - topOffset}px`;
    }
    const virtualScrollViewport = createCdkVirtualScrollViewport(datagridDivElementRef, changeDetectorRef, ngZone, renderer2, virtualScrollStrategy, directionality, scrollDispatcher, viewportRuler, null);
    virtualScrollViewport._contentWrapper = {
      nativeElement: {
        style: {
          set transform(value) {
            topOffset = value === void 0 ? 0 : +/translateY\(([0-9]+)px\)/.exec(value)?.[1];
            updateDatagridElementStyles();
          }
        }
      }
    };
    virtualScrollViewport.setTotalContentSize = (value) => {
      totalContentSize = value;
      datagridTableElement.style.height = `${totalContentSize}px`;
      updateDatagridElementStyles();
    };
    return virtualScrollViewport;
  }
};
ClrDatagridVirtualScrollDirective.ɵfac = function ClrDatagridVirtualScrollDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDatagridVirtualScrollDirective)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(Items, 4), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Directionality), ɵɵdirectiveInject(ScrollDispatcher), ɵɵdirectiveInject(ViewportRuler), ɵɵdirectiveInject(ClrDatagrid), ɵɵdirectiveInject(ColumnsService), ɵɵdirectiveInject(EnvironmentInjector));
};
ClrDatagridVirtualScrollDirective.ɵdir = ɵɵdefineDirective({
  type: ClrDatagridVirtualScrollDirective,
  selectors: [["", "ClrVirtualScroll", ""]],
  inputs: {
    cdkVirtualForOf: [0, "clrVirtualRowsOf", "cdkVirtualForOf"],
    cdkVirtualForTrackBy: [0, "clrVirtualRowsTrackBy", "cdkVirtualForTrackBy"],
    cdkVirtualForTemplate: [0, "clrVirtualRowsTemplate", "cdkVirtualForTemplate"],
    cdkVirtualForTemplateCacheSize: [0, "clrVirtualRowsTemplateCacheSize", "cdkVirtualForTemplateCacheSize"],
    itemSize: [0, "clrVirtualRowsItemSize", "itemSize"],
    minBufferPx: [0, "clrVirtualRowsMinBufferPx", "minBufferPx"],
    maxBufferPx: [0, "clrVirtualRowsMaxBufferPx", "maxBufferPx"]
  },
  outputs: {
    renderedRangeChange: "renderedRangeChange"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([Items])]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridVirtualScrollDirective, [{
    type: Directive,
    args: [{
      selector: "[ClrVirtualScroll]",
      providers: [Items]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: IterableDiffers
    }, {
      type: Items,
      decorators: [{
        type: SkipSelf
      }]
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: TemplateRef
    }, {
      type: ViewContainerRef
    }, {
      type: Directionality
    }, {
      type: ScrollDispatcher
    }, {
      type: ViewportRuler
    }, {
      type: ClrDatagrid
    }, {
      type: ColumnsService
    }, {
      type: EnvironmentInjector
    }];
  }, {
    renderedRangeChange: [{
      type: Output
    }],
    cdkVirtualForOf: [{
      type: Input,
      args: ["clrVirtualRowsOf"]
    }],
    cdkVirtualForTrackBy: [{
      type: Input,
      args: ["clrVirtualRowsTrackBy"]
    }],
    cdkVirtualForTemplate: [{
      type: Input,
      args: ["clrVirtualRowsTemplate"]
    }],
    cdkVirtualForTemplateCacheSize: [{
      type: Input,
      args: ["clrVirtualRowsTemplateCacheSize"]
    }],
    itemSize: [{
      type: Input,
      args: ["clrVirtualRowsItemSize"]
    }],
    minBufferPx: [{
      type: Input,
      args: ["clrVirtualRowsMinBufferPx"]
    }],
    maxBufferPx: [{
      type: Input,
      args: ["clrVirtualRowsMaxBufferPx"]
    }]
  });
})();
function createCdkVirtualScrollViewport(datagridDivElementRef, changeDetectorRef, ngZone, renderer2, virtualScrollStrategy, directionality, scrollDispatcher, viewportRuler, scrollable) {
  if (+VERSION.major < 19) {
    return new CdkVirtualScrollViewport(datagridDivElementRef, changeDetectorRef, ngZone, virtualScrollStrategy, directionality, scrollDispatcher, viewportRuler, scrollable);
  } else {
    const virtualScrollViewportInjector = Injector.create({
      parent: inject(EnvironmentInjector),
      providers: [{
        provide: ElementRef,
        useValue: datagridDivElementRef
      }, {
        provide: ChangeDetectorRef,
        useValue: changeDetectorRef
      }, {
        provide: NgZone,
        useValue: ngZone
      }, {
        provide: Renderer2,
        useValue: renderer2
      }, {
        provide: VIRTUAL_SCROLL_STRATEGY,
        useValue: virtualScrollStrategy
      }, {
        provide: Directionality,
        useValue: directionality
      }, {
        provide: ScrollDispatcher,
        useValue: scrollDispatcher
      }, {
        provide: ViewportRuler,
        useValue: viewportRuler
      }, {
        provide: CdkVirtualScrollable,
        useValue: scrollable
      }, {
        provide: CdkVirtualScrollViewport,
        useClass: CdkVirtualScrollViewport
      }]
    });
    return virtualScrollViewportInjector.get(CdkVirtualScrollViewport);
  }
}
function createCdkVirtualForOfDirective(viewContainerRef, templateRef, iterableDiffers, viewRepeater, virtualScrollViewport, ngZone) {
  if (+VERSION.major < 19) {
    return new CdkVirtualForOf(viewContainerRef, templateRef, iterableDiffers, viewRepeater, virtualScrollViewport, ngZone);
  } else {
    const virtualScrollViewportInjector = Injector.create({
      parent: inject(EnvironmentInjector),
      providers: [{
        provide: CdkVirtualScrollViewport,
        useValue: virtualScrollViewport
      }]
    });
    const cdkVirtualForInjector = Injector.create({
      parent: virtualScrollViewportInjector,
      providers: [{
        provide: ViewContainerRef,
        useValue: viewContainerRef
      }, {
        provide: TemplateRef,
        useValue: templateRef
      }, {
        provide: IterableDiffers,
        useValue: iterableDiffers
      }, {
        provide: _VIEW_REPEATER_STRATEGY,
        useValue: viewRepeater
      }, {
        provide: NgZone,
        useValue: ngZone
      }, {
        provide: CdkVirtualForOf,
        useClass: CdkVirtualForOf
      }]
    });
    return cdkVirtualForInjector.get(CdkVirtualForOf);
  }
}
var DatagridHeaderRenderer = class {
  constructor(el, renderer, organizer, domAdapter, columnResizerService, columnsService, columnState) {
    this.el = el;
    this.renderer = renderer;
    this.domAdapter = domAdapter;
    this.columnResizerService = columnResizerService;
    this.columnsService = columnsService;
    this.columnState = columnState;
    this.resizeEmitter = new EventEmitter();
    this.widthSet = false;
    this.autoSet = false;
    this.subscriptions = [];
    this.subscriptions.push(organizer.filterRenderSteps(DatagridRenderStep.CLEAR_WIDTHS).subscribe(() => this.clearWidth()));
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
  getColumnWidthState() {
    const strictWidth = this.detectStrictWidth();
    return {
      width: this.computeWidth(strictWidth),
      strictWidth
    };
  }
  setColumnState(index) {
    this.columnsService.columns[index] = this.columnState;
  }
  setWidth(state2) {
    if (state2.strictWidth) {
      if (this.columnResizerService.resizedBy) {
        this.resizeEmitter.emit(state2.width);
        this.renderer.setStyle(this.el.nativeElement, "width", state2.width + "px");
        this.widthSet = false;
      }
      this.renderer.addClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
      this.autoSet = false;
    } else {
      this.renderer.removeClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
      this.renderer.setStyle(this.el.nativeElement, "width", state2.width + "px");
      this.widthSet = true;
      this.autoSet = true;
    }
  }
  setHidden(state2) {
    if (state2.hidden) {
      this.renderer.addClass(this.el.nativeElement, HIDDEN_COLUMN_CLASS);
    } else {
      this.renderer.removeClass(this.el.nativeElement, HIDDEN_COLUMN_CLASS);
    }
  }
  clearWidth() {
    if (this.widthSet && !this.columnResizerService.resizedBy) {
      this.renderer.setStyle(this.el.nativeElement, "width", null);
    }
    if (this.autoSet) {
      this.renderer.removeClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
    }
  }
  detectStrictWidth() {
    if (this.columnResizerService.resizedBy) {
      return this.columnResizerService.widthAfterResize;
    } else if (this.autoSet) {
      return 0;
    } else {
      return this.domAdapter.userDefinedWidth(this.el.nativeElement);
    }
  }
  computeWidth(strictWidth) {
    let width = strictWidth;
    if (!width) {
      width = this.domAdapter.scrollWidth(this.el.nativeElement);
    }
    return width;
  }
};
DatagridHeaderRenderer.ɵfac = function DatagridHeaderRenderer_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || DatagridHeaderRenderer)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(DatagridRenderOrganizer), ɵɵdirectiveInject(DomAdapter), ɵɵdirectiveInject(ColumnResizerService), ɵɵdirectiveInject(ColumnsService), ɵɵdirectiveInject(COLUMN_STATE));
};
DatagridHeaderRenderer.ɵdir = ɵɵdefineDirective({
  type: DatagridHeaderRenderer,
  selectors: [["clr-dg-column"]],
  outputs: {
    resizeEmitter: "clrDgColumnResize"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([ColumnResizerService, COLUMN_STATE_PROVIDER])]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatagridHeaderRenderer, [{
    type: Directive,
    args: [{
      selector: "clr-dg-column",
      providers: [ColumnResizerService, COLUMN_STATE_PROVIDER]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: DatagridRenderOrganizer
    }, {
      type: DomAdapter
    }, {
      type: ColumnResizerService
    }, {
      type: ColumnsService
    }, {
      type: BehaviorSubject,
      decorators: [{
        type: Inject,
        args: [COLUMN_STATE]
      }]
    }];
  }, {
    resizeEmitter: [{
      type: Output,
      args: ["clrDgColumnResize"]
    }]
  });
})();
var NoopDomAdapter = class {
  userDefinedWidth(_element) {
    return 0;
  }
  scrollBarWidth(_element) {
    return 0;
  }
  scrollWidth(_element) {
    return 0;
  }
  computedHeight(_element) {
    return 0;
  }
  clientRect(_element) {
    return {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      width: 0,
      height: 0
    };
  }
  minWidth(_element) {
    return 0;
  }
  focus(_element) {
  }
};
NoopDomAdapter.ɵfac = function NoopDomAdapter_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || NoopDomAdapter)();
};
NoopDomAdapter.ɵprov = ɵɵdefineInjectable({
  token: NoopDomAdapter,
  factory: NoopDomAdapter.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NoopDomAdapter, [{
    type: Injectable
  }], null, null);
})();
var domAdapterFactory = (platformId) => {
  if (isPlatformBrowser(platformId)) {
    return new DomAdapter();
  } else {
    return new NoopDomAdapter();
  }
};
var DatagridMainRenderer = class {
  constructor(datagrid, organizer, items, page, el, renderer, detailService, tableSizeService, columnsService, ngZone, keyNavigation) {
    this.datagrid = datagrid;
    this.organizer = organizer;
    this.items = items;
    this.page = page;
    this.el = el;
    this.renderer = renderer;
    this.tableSizeService = tableSizeService;
    this.columnsService = columnsService;
    this.ngZone = ngZone;
    this.keyNavigation = keyNavigation;
    this._heightSet = false;
    this.shouldStabilizeColumns = true;
    this.subscriptions = [];
    this.columnsSizesStable = false;
    this.subscriptions.push(organizer.filterRenderSteps(DatagridRenderStep.COMPUTE_COLUMN_WIDTHS).subscribe(() => this.computeHeadersWidth()));
    this.subscriptions.push(page.sizeChange.subscribe(() => {
      if (this._heightSet) {
        this.resetDatagridHeight();
      }
    }));
    this.subscriptions.push(detailService.stateChange.subscribe((state2) => this.toggleDetailPane(state2)));
    this.subscriptions.push(items.change.subscribe(() => this.shouldStabilizeColumns = true));
  }
  ngOnInit() {
    this.columnsService.columnsStateChange.subscribe((change) => this.columnStateChanged(change));
  }
  ngAfterContentInit() {
    this.setupColumns();
    this.subscriptions.push(this.headers.changes.subscribe(() => {
      this.setupColumns();
      this.columnsSizesStable = false;
      this.stabilizeColumns();
    }));
  }
  // Initialize and set Table width for horizontal scrolling here.
  ngAfterViewInit() {
    this.tableSizeService.table = this.el;
  }
  ngAfterViewChecked() {
    const datagridIsVisible = this.checkAndUpdateVisibility();
    if (this.shouldStabilizeColumns && datagridIsVisible) {
      this.stabilizeColumns();
    }
    if (this.shouldComputeHeight()) {
      this.ngZone.runOutsideAngular(() => {
        setTimeout(() => {
          this.computeDatagridHeight();
        });
      });
    }
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
  toggleDetailPane(state2) {
    if (this.headers) {
      if (state2 && !this.columnsService.hasCache()) {
        this.columnsService.cache();
        this.columnsService.visibleColumns.forEach((header, index) => {
          if (index > 0) {
            this.columnsService.emitStateChangeAt(header.columnIndex, {
              changes: [DatagridColumnChanges.HIDDEN],
              hidden: state2
            });
          }
        });
      } else if (!state2) {
        this.columnsService.resetToLastCache();
      }
    }
  }
  setupColumns() {
    this.headers.forEach((header, index) => header.setColumnState(index));
    this.columnsService.columns.splice(this.headers.length);
    this.columnsService.columns.forEach((column, index) => {
      this.columnsService.emitStateChange(column, {
        changes: [DatagridColumnChanges.INITIALIZE],
        columnIndex: index
      });
    });
  }
  shouldComputeHeight() {
    if (!this._heightSet && this.page.size > 0) {
      if (this.items.displayed.length === this.page.size) {
        return true;
      }
    }
    return false;
  }
  /**
   * Computes the height of the datagrid.
   *
   * NOTE: We had to choose to set the height instead of the min-height because
   * IE 11 requires the height on the parent for the children flex grow/shrink properties to work.
   * When we used min-height, 1 1 auto doesn't used to work in IE11 :-(
   * But this doesn't affect the fix. It works in both fixed & variable height datagrids.
   *
   * Refer: http://stackoverflow.com/questions/24396205/flex-grow-not-working-in-internet-explorer-11-0
   */
  computeDatagridHeight() {
    const height = window.getComputedStyle(this.el.nativeElement).height;
    this.renderer.setStyle(this.el.nativeElement, "height", height);
    this._heightSet = true;
  }
  resetDatagridHeight() {
    this.renderer.setStyle(this.el.nativeElement, "height", "");
    this._heightSet = false;
  }
  /**
   * Makes each header compute its width.
   */
  computeHeadersWidth() {
    const nbColumns = this.headers.length;
    const headerWidths = this.headers.map((header) => {
      return header.getColumnWidthState();
    });
    let allStrict = true;
    this.headers.forEach((header, index) => {
      const state2 = __spreadValues({
        changes: [DatagridColumnChanges.WIDTH]
      }, headerWidths[index]);
      if (!state2.strictWidth) {
        allStrict = false;
      }
      if (nbColumns === index + 1 && allStrict) {
        state2.strictWidth = 0;
      }
      this.columnsService.emitStateChangeAt(index, state2);
    });
  }
  columnStateChanged(state2) {
    if (!this.headers || state2.columnIndex == null) {
      return;
    }
    const columnIndex = state2.columnIndex;
    if (state2.changes && state2.changes.length) {
      state2.changes.forEach((change) => {
        switch (change) {
          case DatagridColumnChanges.WIDTH:
            this.headers.get(columnIndex).setWidth(state2);
            this.rows.forEach((row) => {
              if (row?.cells.length === this.columnsService.columns.length) {
                row.cells.get(columnIndex).setWidth(state2);
                row.expandableRow?.cells.get(columnIndex)?.setWidth(state2);
              }
            });
            break;
          case DatagridColumnChanges.HIDDEN:
            this.headers.get(columnIndex).setHidden(state2);
            this.rows.forEach((row) => {
              if (row.cells && row.cells.length) {
                row.cells.get(columnIndex).setHidden(state2);
                row.expandableRow?.cells.get(columnIndex)?.setHidden(state2);
              }
            });
            this.updateColumnSeparatorsVisibility();
            this.keyNavigation.resetKeyGrid();
            break;
          case DatagridColumnChanges.INITIALIZE:
            if (state2.hideable && state2.hidden) {
              this.headers.get(columnIndex).setHidden(state2);
              this.rows.forEach((row) => {
                row.setCellsState();
                row.expandableRow?.setCellsState();
              });
            }
            break;
          default:
            break;
        }
      });
    }
  }
  /**
   * Triggers a whole re-rendring cycle to set column sizes, if needed.
   */
  stabilizeColumns() {
    this.shouldStabilizeColumns = false;
    if (this.columnsSizesStable) {
      return;
    }
    if (this.items.displayed.length > 0) {
      this.organizer.resize();
      this.columnsSizesStable = true;
    }
  }
  checkAndUpdateVisibility() {
    if (this.el.nativeElement.offsetParent) {
      this.datagrid.datagrid.nativeElement.style.visibility = "visible";
      return true;
    } else {
      this.datagrid.datagrid.nativeElement.style.visibility = "hidden";
      return false;
    }
  }
  updateColumnSeparatorsVisibility() {
    const visibleColumns = this.datagrid.columns.filter((column) => !column.isHidden);
    visibleColumns.forEach((column, index) => {
      if (index === visibleColumns.length - 1) {
        column.showSeparator = false;
      } else if (!column.showSeparator) {
        column.showSeparator = true;
      }
    });
  }
};
DatagridMainRenderer.ɵfac = function DatagridMainRenderer_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || DatagridMainRenderer)(ɵɵdirectiveInject(ClrDatagrid), ɵɵdirectiveInject(DatagridRenderOrganizer), ɵɵdirectiveInject(Items), ɵɵdirectiveInject(Page), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(DetailService), ɵɵdirectiveInject(TableSizeService), ɵɵdirectiveInject(ColumnsService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(KeyNavigationGridController));
};
DatagridMainRenderer.ɵdir = ɵɵdefineDirective({
  type: DatagridMainRenderer,
  selectors: [["clr-datagrid"]],
  contentQueries: function DatagridMainRenderer_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, DatagridHeaderRenderer, 4);
      ɵɵcontentQuery(dirIndex, DatagridRowRenderer, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headers = _t);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.rows = _t);
    }
  },
  standalone: false,
  features: [ɵɵProvidersFeature([{
    provide: DomAdapter,
    useFactory: domAdapterFactory,
    deps: [PLATFORM_ID]
  }])]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatagridMainRenderer, [{
    type: Directive,
    args: [{
      selector: "clr-datagrid",
      providers: [{
        provide: DomAdapter,
        useFactory: domAdapterFactory,
        deps: [PLATFORM_ID]
      }]
    }]
  }], function() {
    return [{
      type: ClrDatagrid
    }, {
      type: DatagridRenderOrganizer
    }, {
      type: Items
    }, {
      type: Page
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: DetailService
    }, {
      type: TableSizeService
    }, {
      type: ColumnsService
    }, {
      type: NgZone
    }, {
      type: KeyNavigationGridController
    }];
  }, {
    headers: [{
      type: ContentChildren,
      args: [DatagridHeaderRenderer]
    }],
    rows: [{
      type: ContentChildren,
      args: [DatagridRowRenderer]
    }]
  });
})();
var CLR_DATAGRID_DIRECTIVES = [
  // Core
  ClrDatagrid,
  ClrDatagridActionBar,
  ClrDatagridActionOverflow,
  ClrDatagridCell,
  ClrDatagridColumn,
  ClrDatagridColumnSeparator,
  ClrDatagridDetail,
  ClrDatagridDetailBody,
  ClrDatagridDetailHeader,
  ClrDatagridFilter,
  ClrDatagridFooter,
  ClrDatagridHideableColumn,
  ClrDatagridItems,
  ClrDatagridPageSize,
  ClrDatagridPagination,
  ClrDatagridPlaceholder,
  ClrDatagridRow,
  ClrDatagridRowDetail,
  ClrDatagridSelectionCellDirective,
  ClrDatagridVirtualScrollDirective,
  ClrIfDetail,
  DatagridDetailRegisterer,
  WrappedCell,
  WrappedColumn,
  WrappedRow,
  // Renderers
  DatagridCellRenderer,
  DatagridHeaderRenderer,
  DatagridMainRenderer,
  DatagridRowRenderer,
  // Chocolate
  ActionableOompaLoompa,
  DatagridWillyWonka,
  ExpandableOompaLoompa,
  // Built-in shortcuts
  DatagridNumericFilter,
  DatagridStringFilter
];
var CLR_DATAGRID_INTERNAL_DIRECTIVES = [ClrDatagridColumnToggle, ClrDatagridColumnToggleButton];
var ClrDatagridModule = class {
  constructor() {
    r.addIcons(e2, l2, L3, C, e4, o8, o2, l, L);
  }
};
ClrDatagridModule.ɵfac = function ClrDatagridModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDatagridModule)();
};
ClrDatagridModule.ɵmod = ɵɵdefineNgModule({
  type: ClrDatagridModule,
  declarations: [
    // Core
    ClrDatagrid,
    ClrDatagridActionBar,
    ClrDatagridActionOverflow,
    ClrDatagridCell,
    ClrDatagridColumn,
    ClrDatagridColumnSeparator,
    ClrDatagridDetail,
    ClrDatagridDetailBody,
    ClrDatagridDetailHeader,
    ClrDatagridFilter,
    ClrDatagridFooter,
    ClrDatagridHideableColumn,
    ClrDatagridItems,
    ClrDatagridPageSize,
    ClrDatagridPagination,
    ClrDatagridPlaceholder,
    ClrDatagridRow,
    ClrDatagridRowDetail,
    ClrDatagridSelectionCellDirective,
    ClrDatagridVirtualScrollDirective,
    ClrIfDetail,
    DatagridDetailRegisterer,
    WrappedCell,
    WrappedColumn,
    WrappedRow,
    // Renderers
    DatagridCellRenderer,
    DatagridHeaderRenderer,
    DatagridMainRenderer,
    DatagridRowRenderer,
    // Chocolate
    ActionableOompaLoompa,
    DatagridWillyWonka,
    ExpandableOompaLoompa,
    // Built-in shortcuts
    DatagridNumericFilter,
    DatagridStringFilter,
    ClrDatagridColumnToggle,
    ClrDatagridColumnToggleButton
  ],
  imports: [CommonModule, CdkDragModule, CdkTrapFocusModule, ClrIconModule, ClrFormsModule, FormsModule, ClrLoadingModule, ClrConditionalModule, ClrOutsideClickModule, ClrExpandableAnimationModule, ClrSpinnerModule, ClrPopoverModuleNext, ClrKeyFocusModule],
  exports: [
    // Core
    ClrDatagrid,
    ClrDatagridActionBar,
    ClrDatagridActionOverflow,
    ClrDatagridCell,
    ClrDatagridColumn,
    ClrDatagridColumnSeparator,
    ClrDatagridDetail,
    ClrDatagridDetailBody,
    ClrDatagridDetailHeader,
    ClrDatagridFilter,
    ClrDatagridFooter,
    ClrDatagridHideableColumn,
    ClrDatagridItems,
    ClrDatagridPageSize,
    ClrDatagridPagination,
    ClrDatagridPlaceholder,
    ClrDatagridRow,
    ClrDatagridRowDetail,
    ClrDatagridSelectionCellDirective,
    ClrDatagridVirtualScrollDirective,
    ClrIfDetail,
    DatagridDetailRegisterer,
    WrappedCell,
    WrappedColumn,
    WrappedRow,
    // Renderers
    DatagridCellRenderer,
    DatagridHeaderRenderer,
    DatagridMainRenderer,
    DatagridRowRenderer,
    // Chocolate
    ActionableOompaLoompa,
    DatagridWillyWonka,
    ExpandableOompaLoompa,
    // Built-in shortcuts
    DatagridNumericFilter,
    DatagridStringFilter
  ]
});
ClrDatagridModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, CdkDragModule, CdkTrapFocusModule, ClrIconModule, ClrFormsModule, FormsModule, ClrLoadingModule, ClrConditionalModule, ClrOutsideClickModule, ClrExpandableAnimationModule, ClrSpinnerModule, ClrPopoverModuleNext, ClrKeyFocusModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, CdkDragModule, CdkTrapFocusModule, ClrIconModule, ClrFormsModule, FormsModule, ClrLoadingModule, ClrConditionalModule, ClrOutsideClickModule, ClrExpandableAnimationModule, ClrSpinnerModule, ClrPopoverModuleNext, ClrKeyFocusModule],
      declarations: [CLR_DATAGRID_DIRECTIVES, CLR_DATAGRID_INTERNAL_DIRECTIVES],
      exports: [CLR_DATAGRID_DIRECTIVES]
    }]
  }], function() {
    return [];
  }, null);
})();
var ClrStackViewCustomTags = class {
};
ClrStackViewCustomTags.ɵfac = function ClrStackViewCustomTags_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrStackViewCustomTags)();
};
ClrStackViewCustomTags.ɵdir = ɵɵdefineDirective({
  type: ClrStackViewCustomTags,
  selectors: [["clr-stack-content"]],
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrStackViewCustomTags, [{
    type: Directive,
    args: [{
      selector: "clr-stack-content"
    }]
  }], null, null);
})();
var ClrStackViewLabel = class {
  constructor() {
    this._generatedId = null;
    this._id = null;
  }
  get id() {
    return this._id;
  }
  set id(val) {
    if (typeof val === "string" && val !== "") {
      this._id = val;
    } else {
      this._id = this._generatedId + "";
    }
  }
  ngOnInit() {
    this._generatedId = "clr-stack-label-" + uniqueIdFactory();
    if (!this.id) {
      this._id = this._generatedId + "";
    }
  }
};
ClrStackViewLabel.ɵfac = function ClrStackViewLabel_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrStackViewLabel)();
};
ClrStackViewLabel.ɵcmp = ɵɵdefineComponent({
  type: ClrStackViewLabel,
  selectors: [["clr-stack-label"]],
  hostVars: 1,
  hostBindings: function ClrStackViewLabel_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("id", ctx.id);
    }
  },
  inputs: {
    id: "id"
  },
  standalone: false,
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrStackViewLabel_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrStackViewLabel, [{
    type: Component,
    args: [{
      selector: "clr-stack-label",
      template: "<ng-content></ng-content>",
      host: {
        "[attr.id]": "id"
      }
    }]
  }], null, {
    id: [{
      type: Input
    }]
  });
})();
var ClrStackBlock = class {
  /*
   * This would be more efficient with @ContentChildren, with the parent ClrStackBlock
   * querying for children StackBlocks, but this feature is not available when downgrading
   * the component for Angular 1.
   */
  constructor(parent, commonStrings) {
    this.parent = parent;
    this.commonStrings = commonStrings;
    this.expanded = false;
    this.expandable = false;
    this.expandedChange = new EventEmitter(false);
    this.focused = false;
    this.uniqueId = uniqueIdFactory();
    this._changedChildren = 0;
    this._fullyInitialized = false;
    this._changed = false;
    if (parent) {
      parent.addChild();
    }
  }
  set setChangedValue(value) {
    this._changed = value;
    if (this.parent && this._fullyInitialized) {
      if (value) {
        this.parent._changedChildren++;
      } else {
        this.parent._changedChildren--;
      }
    }
  }
  get getChangedValue() {
    return this._changed || this._changedChildren > 0 && !this.expanded;
  }
  get onStackLabelFocus() {
    return this.expandable && !this.expanded && this.focused;
  }
  get labelledById() {
    return this.stackBlockTitle.id;
  }
  get headingLevel() {
    if (this.ariaLevel) {
      return this.ariaLevel + "";
    }
    return this.parent ? "4" : "3";
  }
  get caretDirection() {
    return this.expanded ? "down" : "right";
  }
  get role() {
    return this.expandable ? "button" : null;
  }
  get tabIndex() {
    return this.expandable ? "0" : null;
  }
  get ariaExpanded() {
    if (!this.expandable) {
      return null;
    } else {
      return this.expanded ? "true" : "false";
    }
  }
  ngOnInit() {
    this._fullyInitialized = true;
  }
  addChild() {
    this.expandable = true;
  }
  toggleExpand(event) {
    if (eventIsInputEvent(event)) {
      return;
    }
    if (this.expandable) {
      this.expanded = !this.expanded;
      this.expandedChange.emit(this.expanded);
    }
  }
  getStackChildrenId() {
    return this.expanded ? `clr-stack-children-${this.uniqueId}` : null;
  }
  preventDefaultIfNotInputEvent(event) {
    if (eventIsInputEvent(event)) {
      return;
    }
    event.preventDefault();
  }
};
ClrStackBlock.ɵfac = function ClrStackBlock_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrStackBlock)(ɵɵdirectiveInject(ClrStackBlock, 12), ɵɵdirectiveInject(ClrCommonStringsService));
};
ClrStackBlock.ɵcmp = ɵɵdefineComponent({
  type: ClrStackBlock,
  selectors: [["clr-stack-block"]],
  contentQueries: function ClrStackBlock_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrStackViewLabel, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.stackBlockTitle = _t.first);
    }
  },
  hostVars: 12,
  hostBindings: function ClrStackBlock_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", "heading")("aria-level", ctx.headingLevel);
      ɵɵclassProp("stack-block", true)("stack-block-expanded", ctx.expanded)("stack-block-expandable", ctx.expandable)("stack-block-changed", ctx.getChangedValue)("on-focus", ctx.onStackLabelFocus);
    }
  },
  inputs: {
    expanded: [0, "clrSbExpanded", "expanded"],
    expandable: [0, "clrSbExpandable", "expandable"],
    ariaLevel: [0, "clrStackViewLevel", "ariaLevel"],
    setChangedValue: [0, "clrSbNotifyChange", "setChangedValue"]
  },
  outputs: {
    expandedChange: "clrSbExpandedChange"
  },
  standalone: false,
  ngContentSelectors: _c88,
  decls: 9,
  vars: 9,
  consts: [[1, "stack-block-label", 3, "click", "keyup.enter", "keyup.space", "keydown.space", "focus", "blur", "id"], ["shape", "angle", "class", "stack-block-caret", 4, "ngIf"], ["class", "clr-sr-only", 4, "ngIf"], [1, "stack-view-key"], [1, "stack-block-content"], [1, "stack-children", 3, "clrExpandTrigger"], ["role", "region", 3, "height", 4, "ngIf"], ["shape", "angle", 1, "stack-block-caret"], [1, "clr-sr-only"], ["role", "region"]],
  template: function ClrStackBlock_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c87);
      ɵɵelementStart(0, "div", 0);
      ɵɵlistener("click", function ClrStackBlock_Template_div_click_0_listener($event) {
        return ctx.toggleExpand($event);
      })("keyup.enter", function ClrStackBlock_Template_div_keyup_enter_0_listener($event) {
        return ctx.toggleExpand($event);
      })("keyup.space", function ClrStackBlock_Template_div_keyup_space_0_listener($event) {
        return ctx.toggleExpand($event);
      })("keydown.space", function ClrStackBlock_Template_div_keydown_space_0_listener($event) {
        return ctx.preventDefaultIfNotInputEvent($event);
      })("focus", function ClrStackBlock_Template_div_focus_0_listener() {
        return ctx.focused = true;
      })("blur", function ClrStackBlock_Template_div_blur_0_listener() {
        return ctx.focused = false;
      });
      ɵɵtemplate(1, ClrStackBlock_cds_icon_1_Template, 1, 1, "cds-icon", 1)(2, ClrStackBlock_span_2_Template, 2, 1, "span", 2);
      ɵɵelementStart(3, "div", 3);
      ɵɵprojection(4);
      ɵɵelementEnd();
      ɵɵelementStart(5, "div", 4);
      ɵɵprojection(6, 1);
      ɵɵelementEnd()();
      ɵɵelementStart(7, "clr-expandable-animation", 5);
      ɵɵtemplate(8, ClrStackBlock_div_8_Template, 2, 4, "div", 6);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("id", ctx.uniqueId);
      ɵɵattribute("role", ctx.role)("tabindex", ctx.tabIndex)("aria-expanded", ctx.ariaExpanded)("aria-controls", ctx.getStackChildrenId());
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.expandable);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.getChangedValue);
      ɵɵadvance(5);
      ɵɵproperty("clrExpandTrigger", ctx.expanded);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.expanded);
    }
  },
  dependencies: [NgIf, CdsIconCustomTag, ClrExpandableAnimation],
  styles: ["[_nghost-%COMP%]{display:block}"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrStackBlock, [{
    type: Component,
    args: [{
      selector: "clr-stack-block",
      template: `
    <!-- The 'preventDefault' for the space keydown event prevents the page
         from scrolling when a stack block is toggled via the space key. -->
    <div
      class="stack-block-label"
      (click)="toggleExpand($event)"
      (keyup.enter)="toggleExpand($event)"
      (keyup.space)="toggleExpand($event)"
      (keydown.space)="preventDefaultIfNotInputEvent($event)"
      (focus)="focused = true"
      (blur)="focused = false"
      [id]="uniqueId"
      [attr.role]="role"
      [attr.tabindex]="tabIndex"
      [attr.aria-expanded]="ariaExpanded"
      [attr.aria-controls]="getStackChildrenId()"
    >
      <cds-icon shape="angle" class="stack-block-caret" *ngIf="expandable" [attr.direction]="caretDirection"></cds-icon>
      <span class="clr-sr-only" *ngIf="getChangedValue">{{ commonStrings.keys.stackViewChanged }}</span>
      <div class="stack-view-key">
        <!-- This structure changed to fix #3567 and the a11y request was to move away from dl's -->
        <!-- I added the key class to update css targets for the original component style -->
        <ng-content select="clr-stack-label"></ng-content>
      </div>
      <div class="stack-block-content">
        <ng-content></ng-content>
      </div>
    </div>

    <clr-expandable-animation [clrExpandTrigger]="expanded" class="stack-children">
      <div
        [style.height]="expanded ? 'auto' : 0"
        role="region"
        *ngIf="expanded"
        [attr.id]="getStackChildrenId()"
        [attr.aria-labelledby]="labelledById"
      >
        <ng-content select="clr-stack-block"></ng-content>
      </div>
    </clr-expandable-animation>
  `,
      host: {
        "[class.stack-block]": "true",
        "[attr.role]": '"heading"',
        "[attr.aria-level]": "headingLevel"
      },
      styles: [":host{display:block}\n"]
    }]
  }], function() {
    return [{
      type: ClrStackBlock,
      decorators: [{
        type: SkipSelf
      }, {
        type: Optional
      }]
    }, {
      type: ClrCommonStringsService
    }];
  }, {
    expanded: [{
      type: Input,
      args: ["clrSbExpanded"]
    }, {
      type: HostBinding,
      args: ["class.stack-block-expanded"]
    }],
    expandable: [{
      type: Input,
      args: ["clrSbExpandable"]
    }, {
      type: HostBinding,
      args: ["class.stack-block-expandable"]
    }],
    ariaLevel: [{
      type: Input,
      args: ["clrStackViewLevel"]
    }],
    expandedChange: [{
      type: Output,
      args: ["clrSbExpandedChange"]
    }],
    stackBlockTitle: [{
      type: ContentChild,
      args: [ClrStackViewLabel]
    }],
    setChangedValue: [{
      type: Input,
      args: ["clrSbNotifyChange"]
    }],
    getChangedValue: [{
      type: HostBinding,
      args: ["class.stack-block-changed"]
    }],
    onStackLabelFocus: [{
      type: HostBinding,
      args: ["class.on-focus"]
    }]
  });
})();
function eventIsInputEvent(event) {
  const targetElement = event?.target;
  return targetElement?.tagName ? ["INPUT", "TEXTAREA", "BUTTON", "A", "SELECT", "OPTION"].includes(targetElement.tagName) : false;
}
var ClrStackContentInput = class {
  constructor() {
    this.uniqueId = uniqueIdFactory();
  }
};
ClrStackContentInput.ɵfac = function ClrStackContentInput_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrStackContentInput)();
};
ClrStackContentInput.ɵdir = ɵɵdefineDirective({
  type: ClrStackContentInput,
  selectors: [["", "clrStackInput", ""]],
  hostVars: 3,
  hostBindings: function ClrStackContentInput_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("aria-labelledby", ctx.uniqueId);
      ɵɵclassProp("clr-input", true);
    }
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrStackContentInput, [{
    type: Directive,
    args: [{
      selector: "[clrStackInput]",
      host: {
        "[class.clr-input]": "true",
        "[attr.aria-labelledby]": "uniqueId"
      }
    }]
  }], null, null);
})();
var ClrStackView = class {
};
ClrStackView.ɵfac = function ClrStackView_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrStackView)();
};
ClrStackView.ɵcmp = ɵɵdefineComponent({
  type: ClrStackView,
  selectors: [["clr-stack-view"]],
  standalone: false,
  ngContentSelectors: _c90,
  decls: 3,
  vars: 0,
  consts: [[1, "stack-view"]],
  template: function ClrStackView_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c89);
      ɵɵprojection(0);
      ɵɵelementStart(1, "div", 0);
      ɵɵprojection(2, 1);
      ɵɵelementEnd();
    }
  },
  styles: ["[_nghost-%COMP%]{display:block}"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrStackView, [{
    type: Component,
    args: [{
      selector: "clr-stack-view",
      template: `
    <ng-content select="clr-stack-header"></ng-content>
    <div class="stack-view"><ng-content></ng-content></div>
  `,
      styles: [":host{display:block}\n"]
    }]
  }], null, null);
})();
var ClrStackHeader = class {
  constructor(stackView) {
    this.stackView = stackView;
  }
};
ClrStackHeader.ɵfac = function ClrStackHeader_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrStackHeader)(ɵɵdirectiveInject(ClrStackView));
};
ClrStackHeader.ɵcmp = ɵɵdefineComponent({
  type: ClrStackHeader,
  selectors: [["clr-stack-header"]],
  standalone: false,
  ngContentSelectors: _c92,
  decls: 5,
  vars: 0,
  consts: [[1, "stack-header"], [1, "stack-title"], [1, "stack-actions"]],
  template: function ClrStackHeader_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c91);
      ɵɵelementStart(0, "div", 0)(1, "h4", 1);
      ɵɵprojection(2);
      ɵɵelementEnd();
      ɵɵelementStart(3, "span", 2);
      ɵɵprojection(4, 1);
      ɵɵelementEnd()();
    }
  },
  styles: ["[_nghost-%COMP%]{display:block}"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrStackHeader, [{
    type: Component,
    args: [{
      selector: "clr-stack-header",
      template: `
    <div class="stack-header">
      <h4 class="stack-title"><ng-content></ng-content></h4>

      <span class="stack-actions">
        <ng-content select=".stack-action"></ng-content>
      </span>
    </div>
  `,
      styles: [":host{display:block}\n"]
    }]
  }], function() {
    return [{
      type: ClrStackView
    }];
  }, null);
})();
var CLR_STACK_VIEW_DIRECTIVES = [ClrStackView, ClrStackHeader, ClrStackBlock, ClrStackContentInput, ClrStackViewLabel, ClrStackViewCustomTags];
var ClrStackViewModule = class {
  constructor() {
    r.addIcons(o);
  }
};
ClrStackViewModule.ɵfac = function ClrStackViewModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrStackViewModule)();
};
ClrStackViewModule.ɵmod = ɵɵdefineNgModule({
  type: ClrStackViewModule,
  declarations: [ClrStackView, ClrStackHeader, ClrStackBlock, ClrStackContentInput, ClrStackViewLabel, ClrStackViewCustomTags],
  imports: [CommonModule, FormsModule, ClrIconModule, ClrExpandableAnimationModule],
  exports: [ClrStackView, ClrStackHeader, ClrStackBlock, ClrStackContentInput, ClrStackViewLabel, ClrStackViewCustomTags]
});
ClrStackViewModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, FormsModule, ClrIconModule, ClrExpandableAnimationModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrStackViewModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, ClrIconModule, ClrExpandableAnimationModule],
      declarations: [CLR_STACK_VIEW_DIRECTIVES],
      exports: [CLR_STACK_VIEW_DIRECTIVES]
    }]
  }], function() {
    return [];
  }, null);
})();
var TreeFeaturesService = class {
  constructor() {
    this.selectable = false;
    this.eager = true;
    this.childrenFetched = new Subject();
  }
};
TreeFeaturesService.ɵfac = function TreeFeaturesService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TreeFeaturesService)();
};
TreeFeaturesService.ɵprov = ɵɵdefineInjectable({
  token: TreeFeaturesService,
  factory: TreeFeaturesService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TreeFeaturesService, [{
    type: Injectable
  }], null, null);
})();
function treeFeaturesFactory(existing) {
  return existing || new TreeFeaturesService();
}
var TREE_FEATURES_PROVIDER = {
  provide: TreeFeaturesService,
  useFactory: treeFeaturesFactory,
  /*
   * The Optional + SkipSelf pattern ensures that in case of nested components, only the root one will
   * instantiate a new service and all its children will reuse the root's instance.
   * If there are several roots (in this case, several independent trees on a page), each root will instantiate
   * its own service so they won't interfere with one another.
   *
   * TL;DR - Optional + SkipSelf = 1 instance of TreeFeaturesService per tree.
   */
  deps: [[new Optional(), new SkipSelf(), TreeFeaturesService]]
};
var RecursiveChildren = class {
  constructor(featuresService, expandService) {
    this.featuresService = featuresService;
    this.expandService = expandService;
    if (expandService) {
      this.subscription = expandService.expandChange.subscribe((value) => {
        if (!value && this.parent && !featuresService.eager && featuresService.recursion) {
          this.parent.clearChildren();
        }
      });
    }
  }
  ngAfterContentInit() {
    this.setAriaRoles();
  }
  shouldRender() {
    return this.featuresService.recursion && // In the smart case, we eagerly render all the recursive children
    // to make sure two-way bindings for selection are available.
    // They will be hidden with CSS by the parent.
    (this.featuresService.eager || !this.expandService || this.expandService.expanded);
  }
  getContext(node) {
    return {
      $implicit: node.model,
      clrModel: node
    };
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }
  setAriaRoles() {
    this.role = this.parent ? "group" : null;
  }
};
RecursiveChildren.ɵfac = function RecursiveChildren_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || RecursiveChildren)(ɵɵdirectiveInject(TreeFeaturesService), ɵɵdirectiveInject(IfExpandService, 8));
};
RecursiveChildren.ɵcmp = ɵɵdefineComponent({
  type: RecursiveChildren,
  selectors: [["clr-recursive-children"]],
  hostVars: 1,
  hostBindings: function RecursiveChildren_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", ctx.role);
    }
  },
  inputs: {
    parent: "parent",
    children: "children"
  },
  standalone: false,
  decls: 1,
  vars: 1,
  consts: [[4, "ngIf"], [4, "ngFor", "ngForOf"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"]],
  template: function RecursiveChildren_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, RecursiveChildren_ng_container_0_Template, 2, 1, "ng-container", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.shouldRender());
    }
  },
  dependencies: [NgForOf, NgIf, NgTemplateOutlet],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RecursiveChildren, [{
    type: Component,
    args: [{
      selector: "clr-recursive-children",
      template: `
    <ng-container *ngIf="shouldRender()">
      <ng-container *ngFor="let child of parent?.children || children">
        <ng-container *ngTemplateOutlet="featuresService.recursion.template; context: getContext(child)"></ng-container>
      </ng-container>
    </ng-container>
  `,
      host: {
        "[attr.role]": "role"
        // Safari + VO needs direct relationship between treeitem and group; no element should exist between them
      }
    }]
  }], function() {
    return [{
      type: TreeFeaturesService
    }, {
      type: IfExpandService,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    parent: [{
      type: Input,
      args: ["parent"]
    }],
    children: [{
      type: Input,
      args: ["children"]
    }]
  });
})();
function isPromise2(o10) {
  return o10 && typeof o10.then === "function";
}
var ClrSelectedState;
(function(ClrSelectedState2) {
  ClrSelectedState2[ClrSelectedState2["UNSELECTED"] = 0] = "UNSELECTED";
  ClrSelectedState2[ClrSelectedState2["SELECTED"] = 1] = "SELECTED";
  ClrSelectedState2[ClrSelectedState2["INDETERMINATE"] = 2] = "INDETERMINATE";
})(ClrSelectedState || (ClrSelectedState = {}));
var TreeNodeModel = class {
  constructor() {
    this.loading$ = new BehaviorSubject(false);
    this.selected = new BehaviorSubject(ClrSelectedState.UNSELECTED);
    this._loading = false;
  }
  get loading() {
    return this._loading;
  }
  set loading(isLoading) {
    this._loading = isLoading;
    this.loading$.next(isLoading);
  }
  get disabled() {
    return !!(this._disabled || this.parent?.disabled);
  }
  set disabled(value) {
    this._disabled = value;
  }
  destroy() {
    this.selected.complete();
  }
  // Propagate by default when eager, don't propagate in the lazy-loaded tree.
  setSelected(state2, propagateUp, propagateDown) {
    if (state2 === this.selected.value) {
      return;
    }
    this.selected.next(state2);
    if (propagateDown && state2 !== ClrSelectedState.INDETERMINATE && this.children) {
      this.children.forEach((child) => {
        if (!child.disabled) {
          child.setSelected(state2, false, true);
        }
      });
    }
    if (propagateUp && this.parent) {
      this.parent._updateSelectionFromChildren();
    }
  }
  toggleSelection(propagate) {
    if (this.disabled) {
      return;
    }
    const newState = this.selected.value === ClrSelectedState.SELECTED ? ClrSelectedState.UNSELECTED : ClrSelectedState.SELECTED;
    this.setSelected(newState, true, propagate);
  }
  /*
   * Internal, but needs to be called by other nodes
   */
  _updateSelectionFromChildren() {
    const newState = this.computeSelectionStateFromChildren();
    if (newState === this.selected.value) {
      return;
    }
    this.selected.next(newState);
    if (this.parent) {
      this.parent._updateSelectionFromChildren();
    }
  }
  computeSelectionStateFromChildren() {
    let oneSelected = false;
    let oneUnselected = false;
    for (const child of this.children) {
      switch (child.selected.value) {
        case ClrSelectedState.INDETERMINATE:
          if (child.disabled) {
            continue;
          }
          return ClrSelectedState.INDETERMINATE;
        case ClrSelectedState.SELECTED:
          oneSelected = true;
          if (oneUnselected) {
            return ClrSelectedState.INDETERMINATE;
          }
          break;
        case ClrSelectedState.UNSELECTED:
        default:
          oneUnselected = true;
          if (oneSelected) {
            return ClrSelectedState.INDETERMINATE;
          }
          break;
      }
    }
    if (!oneSelected) {
      return ClrSelectedState.UNSELECTED;
    } else if (!oneUnselected) {
      return ClrSelectedState.SELECTED;
    } else {
      return ClrSelectedState.UNSELECTED;
    }
  }
};
var RecursiveTreeNodeModel = class _RecursiveTreeNodeModel extends TreeNodeModel {
  constructor(model, parent, getChildren, featuresService) {
    super();
    this.getChildren = getChildren;
    this.featuresService = featuresService;
    this.childrenFetched = false;
    this._children = [];
    this.model = model;
    this.parent = parent;
  }
  get children() {
    this.fetchChildren();
    return this._children;
  }
  set children(value) {
    this._children = value;
  }
  destroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
    super.destroy();
  }
  clearChildren() {
    this._children.forEach((child) => child.destroy());
    delete this._children;
    this.childrenFetched = false;
  }
  fetchChildren() {
    if (this.childrenFetched) {
      return;
    }
    const asyncChildren = this.getChildren(this.model);
    if (isPromise2(asyncChildren)) {
      this.loading = true;
      asyncChildren.then((raw) => {
        this._children = this.wrapChildren(raw);
        this.loading = false;
      });
    } else if (isObservable(asyncChildren)) {
      this.loading = true;
      this.subscription = asyncChildren.subscribe((raw) => {
        this._children = this.wrapChildren(raw);
        this.loading = false;
      });
    } else if (asyncChildren) {
      this._children = this.wrapChildren(asyncChildren);
    } else {
      this._children = [];
    }
    this.childrenFetched = true;
    if (this.featuresService) {
      this.featuresService.childrenFetched.next();
    }
  }
  wrapChildren(rawModels) {
    return rawModels.map((m) => new _RecursiveTreeNodeModel(m, this, this.getChildren, this.featuresService));
  }
};
var ClrRecursiveForOf = class {
  constructor(template, featuresService, cdr) {
    this.template = template;
    this.featuresService = featuresService;
    this.cdr = cdr;
  }
  // I'm using OnChanges instead of OnInit to easily keep up to date with dynamic trees. Maybe optimizable later.
  ngOnChanges() {
    let wrapped;
    if (Array.isArray(this.nodes)) {
      wrapped = this.nodes.map((node) => new RecursiveTreeNodeModel(node, null, this.getChildren, this.featuresService));
    } else {
      wrapped = [new RecursiveTreeNodeModel(this.nodes, null, this.getChildren, this.featuresService)];
    }
    if (!this.childrenFetchSubscription) {
      this.childrenFetchSubscription = this.featuresService.childrenFetched.pipe(debounceTime(0)).subscribe(() => {
        this.cdr.detectChanges();
      });
    }
    this.featuresService.recursion = {
      template: this.template,
      root: wrapped
    };
  }
  ngOnDestroy() {
    if (this.childrenFetchSubscription) {
      this.childrenFetchSubscription.unsubscribe();
    }
  }
};
ClrRecursiveForOf.ɵfac = function ClrRecursiveForOf_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrRecursiveForOf)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(TreeFeaturesService), ɵɵdirectiveInject(ChangeDetectorRef));
};
ClrRecursiveForOf.ɵdir = ɵɵdefineDirective({
  type: ClrRecursiveForOf,
  selectors: [["", "clrRecursiveFor", "", "clrRecursiveForOf", ""]],
  inputs: {
    nodes: [0, "clrRecursiveForOf", "nodes"],
    getChildren: [0, "clrRecursiveForGetChildren", "getChildren"]
  },
  standalone: false,
  features: [ɵɵNgOnChangesFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrRecursiveForOf, [{
    type: Directive,
    args: [{
      selector: "[clrRecursiveFor][clrRecursiveForOf]"
    }]
  }], function() {
    return [{
      type: TemplateRef
    }, {
      type: TreeFeaturesService
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    nodes: [{
      type: Input,
      args: ["clrRecursiveForOf"]
    }],
    getChildren: [{
      type: Input,
      args: ["clrRecursiveForGetChildren"]
    }]
  });
})();
var TreeFocusManagerService = class {
  constructor() {
    this._focusRequest = new Subject();
    this._focusChange = new Subject();
  }
  get focusRequest() {
    return this._focusRequest.asObservable();
  }
  get focusChange() {
    return this._focusChange.asObservable();
  }
  focusNode(model) {
    if (model) {
      this._focusRequest.next(model.nodeId);
    }
  }
  broadcastFocusedNode(nodeId) {
    if (this.focusedNodeId !== nodeId) {
      this.focusedNodeId = nodeId;
      this._focusChange.next(nodeId);
    }
  }
  focusParent(model) {
    if (model) {
      this.focusNode(model.parent);
    }
  }
  focusFirstVisibleNode() {
    const focusModel = this.rootNodeModels && this.rootNodeModels[0];
    this.focusNode(focusModel);
  }
  focusLastVisibleNode() {
    this.focusNode(this.findLastVisibleInTree());
  }
  focusNodeAbove(model) {
    this.focusNode(this.findNodeAbove(model));
  }
  focusNodeBelow(model) {
    this.focusNode(this.findNodeBelow(model));
  }
  focusNodeStartsWith(searchString, model) {
    this.focusNode(this.findClosestNodeStartsWith(searchString, model));
  }
  findSiblings(model) {
    if (model.parent) {
      return model.parent.children;
    } else {
      return this.rootNodeModels;
    }
  }
  findLastVisibleInNode(model) {
    if (!model) {
      return null;
    }
    if (model.expanded && model.children.length > 0) {
      const children = model.children;
      const lastChild = children[children.length - 1];
      return this.findLastVisibleInNode(lastChild);
    } else {
      return model;
    }
  }
  findNextFocusable(model) {
    if (!model) {
      return null;
    }
    const siblings = this.findSiblings(model);
    const selfIndex = siblings.indexOf(model);
    if (selfIndex < siblings.length - 1) {
      return siblings[selfIndex + 1];
    } else if (selfIndex === siblings.length - 1) {
      return this.findNextFocusable(model.parent);
    }
    return null;
  }
  findLastVisibleInTree() {
    const lastRootNode = this.rootNodeModels && this.rootNodeModels.length && this.rootNodeModels[this.rootNodeModels.length - 1];
    return this.findLastVisibleInNode(lastRootNode);
  }
  findNodeAbove(model) {
    if (!model) {
      return null;
    }
    const siblings = this.findSiblings(model);
    const selfIndex = siblings.indexOf(model);
    if (selfIndex === 0) {
      return model.parent;
    } else if (selfIndex > 0) {
      return this.findLastVisibleInNode(siblings[selfIndex - 1]);
    }
    return null;
  }
  findNodeBelow(model) {
    if (!model) {
      return null;
    }
    if (model.expanded && model.children.length > 0) {
      return model.children[0];
    } else {
      return this.findNextFocusable(model);
    }
  }
  findDescendentNodeStartsWith(searchString, model) {
    if (model.expanded && model.children.length > 0) {
      for (const childModel of model.children) {
        const found = this.findNodeStartsWith(searchString, childModel);
        if (found) {
          return found;
        }
      }
    }
    return null;
  }
  findSiblingNodeStartsWith(searchString, model) {
    const siblings = this.findSiblings(model);
    const selfIndex = siblings.indexOf(model);
    for (let i = selfIndex + 1; i < siblings.length; i++) {
      const siblingModel = siblings[i];
      const found = this.findNodeStartsWith(searchString, siblingModel);
      if (found) {
        return found;
      }
    }
    return null;
  }
  findRootNodeStartsWith(searchString, model) {
    for (const rootModel of this.rootNodeModels) {
      if (model.parent && model.parent === rootModel) {
        continue;
      }
      const found = this.findNodeStartsWith(searchString, rootModel);
      if (found) {
        return found;
      }
    }
    return null;
  }
  findNodeStartsWith(searchString, model) {
    if (!model) {
      return null;
    }
    if (model.textContent.startsWith(searchString)) {
      return model;
    }
    return this.findDescendentNodeStartsWith(searchString, model);
  }
  findClosestNodeStartsWith(searchString, model) {
    if (!model) {
      return null;
    }
    const foundFromDescendents = this.findDescendentNodeStartsWith(searchString, model);
    if (foundFromDescendents) {
      return foundFromDescendents;
    }
    const foundFromSiblings = this.findSiblingNodeStartsWith(searchString, model);
    if (foundFromSiblings) {
      return foundFromSiblings;
    }
    const foundFromRootNodes = this.findRootNodeStartsWith(searchString, model);
    if (foundFromRootNodes) {
      return foundFromRootNodes;
    }
    return this.findNodeStartsWith(searchString, model.parent);
  }
};
TreeFocusManagerService.ɵfac = function TreeFocusManagerService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TreeFocusManagerService)();
};
TreeFocusManagerService.ɵprov = ɵɵdefineInjectable({
  token: TreeFocusManagerService,
  factory: TreeFocusManagerService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TreeFocusManagerService, [{
    type: Injectable
  }], null, null);
})();
var DeclarativeTreeNodeModel = class extends TreeNodeModel {
  constructor(parent) {
    super();
    this.parent = parent;
    if (parent) {
      parent._addChild(this);
    }
    this.children = [];
  }
  destroy() {
    if (this.parent) {
      this.parent._removeChild(this);
    }
    super.destroy();
  }
  _addChild(child) {
    this.children.push(child);
  }
  _removeChild(child) {
    const index = this.children.indexOf(child);
    if (index > -1) {
      this.children.splice(index, 1);
    }
  }
};
var ClrTreeNodeLink = class {
  constructor(el) {
    this.el = el;
  }
  get active() {
    return this.el.nativeElement.classList.contains("active");
  }
  activate() {
    if (this.el.nativeElement && this.el.nativeElement.click) {
      this.el.nativeElement.click();
    }
  }
};
ClrTreeNodeLink.ɵfac = function ClrTreeNodeLink_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrTreeNodeLink)(ɵɵdirectiveInject(ElementRef));
};
ClrTreeNodeLink.ɵdir = ɵɵdefineDirective({
  type: ClrTreeNodeLink,
  selectors: [["", 8, "clr-treenode-link"]],
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTreeNodeLink, [{
    type: Directive,
    args: [{
      selector: ".clr-treenode-link"
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, null);
})();
var LVIEW_CONTEXT_INDEX = 8;
var TREE_TYPE_AHEAD_TIMEOUT = 200;
var ClrTreeNode = class {
  constructor(platformId, parent, featuresService, expandService, commonStrings, focusManager, elementRef, injector) {
    this.platformId = platformId;
    this.featuresService = featuresService;
    this.expandService = expandService;
    this.commonStrings = commonStrings;
    this.focusManager = focusManager;
    this.elementRef = elementRef;
    this.selectedChange = new EventEmitter(false);
    this.expandedChange = new EventEmitter();
    this.STATES = ClrSelectedState;
    this.isModelLoading = false;
    this.nodeId = uniqueIdFactory();
    this.contentContainerTabindex = -1;
    this.skipEmitChange = false;
    this.typeAheadKeyBuffer = "";
    this.typeAheadKeyEvent = new Subject();
    this.subscriptions = [];
    if (featuresService.recursion) {
      if (injector.view) {
        this._model = injector.view.context.clrModel;
      } else {
        this._model = injector._lView[LVIEW_CONTEXT_INDEX].clrModel;
      }
    } else {
      this._model = new DeclarativeTreeNodeModel(parent ? parent._model : null);
    }
    this._model.nodeId = this.nodeId;
  }
  get disabled() {
    return this._model.disabled;
  }
  set disabled(value) {
    this._model.disabled = value;
  }
  get selected() {
    return this._model.selected.value;
  }
  set selected(value) {
    this.featuresService.selectable = true;
    if (value === null || typeof value === "undefined") {
      value = ClrSelectedState.UNSELECTED;
    }
    if (typeof value === "boolean") {
      value = value ? ClrSelectedState.SELECTED : ClrSelectedState.UNSELECTED;
    }
    this.skipEmitChange = true;
    this._model.setSelected(value, this.featuresService.eager, this.featuresService.eager);
    this.skipEmitChange = false;
  }
  // I'm caving on this, for tree nodes I think we can tolerate having a two-way binding on the component
  // rather than enforce the clrIfExpanded structural directive for dynamic cases. Mostly because for the smart
  // case, you can't use a structural directive, it would need to go on an ng-container.
  get expanded() {
    return this.expandService.expanded;
  }
  set expanded(value) {
    this.expandService.expanded = value;
  }
  set clrForTypeAhead(value) {
    this._model.textContent = trimAndLowerCase(value || this.elementRef.nativeElement.textContent);
  }
  get ariaSelected() {
    if (this.isSelectable()) {
      return this._model.selected.value === ClrSelectedState.SELECTED;
    } else if (this.treeNodeLink?.active) {
      return true;
    } else {
      return null;
    }
  }
  get treeNodeContentTextOnly() {
    return this.treeNodeLinkList.length === 0;
  }
  get treeNodeLink() {
    return this.treeNodeLinkList && this.treeNodeLinkList.first;
  }
  get isParent() {
    return this._model.children && this._model.children.length > 0;
  }
  ngOnInit() {
    this._model.expanded = this.expanded;
    this._model.disabled = this.disabled;
    this.subscriptions.push(this._model.selected.pipe(filter(() => !this.skipEmitChange)).subscribe((value) => {
      this.selectedChange.emit(value);
    }));
    this.subscriptions.push(this.expandService.expandChange.subscribe((value) => {
      this.expandedChange.emit(value);
      this._model.expanded = value;
    }));
    this.subscriptions.push(this.focusManager.focusRequest.subscribe((nodeId) => {
      if (this.nodeId === nodeId) {
        this.focusTreeNode();
      }
    }), this.focusManager.focusChange.subscribe((nodeId) => {
      this.checkTabIndex(nodeId);
    }));
    this.subscriptions.push(this._model.loading$.pipe(debounceTime(0)).subscribe((isLoading) => this.isModelLoading = isLoading));
  }
  ngAfterContentInit() {
    this.subscriptions.push(this.typeAheadKeyEvent.pipe(debounceTime(TREE_TYPE_AHEAD_TIMEOUT)).subscribe((bufferedKeys) => {
      this.focusManager.focusNodeStartsWith(bufferedKeys, this._model);
      this.typeAheadKeyBuffer = "";
    }));
  }
  ngAfterViewInit() {
    if (!this._model.textContent) {
      this._model.textContent = trimAndLowerCase(this.elementRef.nativeElement.textContent);
    }
  }
  ngOnDestroy() {
    this._model.destroy();
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
  isExpandable() {
    if (typeof this.expandable !== "undefined") {
      return this.expandable;
    }
    return !!this.expandService.expandable || this.isParent;
  }
  isSelectable() {
    return this.featuresService.selectable;
  }
  focusTreeNode() {
    const containerEl = this.contentContainer.nativeElement;
    if (isPlatformBrowser(this.platformId) && document.activeElement !== containerEl) {
      this.setTabIndex(0);
      containerEl.focus();
      containerEl.scrollIntoView({
        block: "nearest",
        inline: "nearest"
      });
    }
  }
  broadcastFocusOnContainer() {
    this.focusManager.broadcastFocusedNode(this.nodeId);
  }
  onKeyDown(event) {
    preventArrowKeyScroll(event);
    switch (normalizeKey(event.key)) {
      case Keys.ArrowUp:
        this.focusManager.focusNodeAbove(this._model);
        break;
      case Keys.ArrowDown:
        this.focusManager.focusNodeBelow(this._model);
        break;
      case Keys.ArrowRight:
        this.expandOrFocusFirstChild();
        break;
      case Keys.ArrowLeft:
        this.collapseOrFocusParent();
        break;
      case Keys.Home:
        event.preventDefault();
        this.focusManager.focusFirstVisibleNode();
        break;
      case Keys.End:
        event.preventDefault();
        this.focusManager.focusLastVisibleNode();
        break;
      case Keys.Enter:
        this.toggleExpandOrTriggerDefault();
        break;
      case Keys.Space:
      case Keys.Spacebar:
        event.preventDefault();
        this.toggleExpandOrTriggerDefault();
        break;
      default:
        if (this._model.textContent && isKeyEitherLetterOrNumber(event)) {
          this.typeAheadKeyBuffer += event.key;
          this.typeAheadKeyEvent.next(this.typeAheadKeyBuffer);
          return;
        }
        break;
    }
    this.typeAheadKeyBuffer = "";
  }
  setTabIndex(value) {
    this.contentContainerTabindex = value;
    this.contentContainer.nativeElement.setAttribute("tabindex", value.toString());
  }
  checkTabIndex(nodeId) {
    if (isPlatformBrowser(this.platformId) && this.nodeId !== nodeId && this.contentContainerTabindex !== -1) {
      this.setTabIndex(-1);
    }
  }
  toggleExpandOrTriggerDefault() {
    if (this.disabled) {
      return;
    }
    if (this.isExpandable() && !this.isSelectable()) {
      this.expandService.expanded = !this.expanded;
    } else {
      this.triggerDefaultAction();
    }
  }
  expandOrFocusFirstChild() {
    if (this.disabled) {
      return;
    }
    if (this.expanded) {
      if (this.isParent) {
        this.focusManager.focusNodeBelow(this._model);
      }
    } else {
      if (this.isExpandable()) {
        this.expandService.expanded = true;
      }
    }
  }
  collapseOrFocusParent() {
    if (this.disabled) {
      return;
    }
    if (this.expanded) {
      this.expandService.expanded = false;
    } else {
      this.focusManager.focusParent(this._model);
    }
  }
  triggerDefaultAction() {
    if (this.treeNodeLink) {
      this.treeNodeLink.activate();
    } else {
      if (this.isSelectable()) {
        this._model.toggleSelection(this.featuresService.eager);
      }
    }
  }
};
ClrTreeNode.ɵfac = function ClrTreeNode_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrTreeNode)(ɵɵdirectiveInject(PLATFORM_ID), ɵɵdirectiveInject(ClrTreeNode, 12), ɵɵdirectiveInject(TreeFeaturesService), ɵɵdirectiveInject(IfExpandService), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(TreeFocusManagerService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Injector));
};
ClrTreeNode.ɵcmp = ɵɵdefineComponent({
  type: ClrTreeNode,
  selectors: [["clr-tree-node"]],
  contentQueries: function ClrTreeNode_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrTreeNodeLink, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.treeNodeLinkList = _t);
    }
  },
  viewQuery: function ClrTreeNode_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c93, 7, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.contentContainer = _t.first);
    }
  },
  hostVars: 4,
  hostBindings: function ClrTreeNode_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-tree-node", true)("disabled", ctx._model.disabled);
    }
  },
  inputs: {
    expandable: [0, "clrExpandable", "expandable"],
    disabled: [0, "clrDisabled", "disabled"],
    selected: [0, "clrSelected", "selected"],
    expanded: [0, "clrExpanded", "expanded"],
    clrForTypeAhead: "clrForTypeAhead"
  },
  outputs: {
    selectedChange: "clrSelectedChange",
    expandedChange: "clrExpandedChange"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([TREE_FEATURES_PROVIDER, IfExpandService, {
    provide: LoadingListener,
    useExisting: IfExpandService
  }])],
  ngContentSelectors: _c95,
  decls: 12,
  vars: 12,
  consts: [["contentContainer", ""], ["treenodeContent", ""], ["role", "treeitem", "tabindex", "-1", 1, "clr-tree-node-content-container", 3, "keydown", "focus"], ["aria-hidden", "true", "type", "button", "tabindex", "-1", "class", "clr-treenode-caret", 3, "disabled", "click", "focus", 4, "ngIf"], ["class", "clr-treenode-spinner-container", 4, "ngIf"], ["class", "clr-checkbox-wrapper clr-treenode-checkbox", 4, "ngIf"], ["class", "clr-treenode-content", 3, "clr-treenode-text-only", "mouseup", 4, "ngIf"], [1, "clr-treenode-children"], [3, "parent"], ["aria-hidden", "true", "type", "button", "tabindex", "-1", 1, "clr-treenode-caret", 3, "click", "focus", "disabled"], ["shape", "angle", 1, "clr-treenode-caret-icon"], [1, "clr-treenode-spinner-container"], [1, "clr-treenode-spinner", "spinner"], [1, "clr-checkbox-wrapper", "clr-treenode-checkbox"], ["aria-hidden", "true", "type", "checkbox", "tabindex", "-1", 1, "clr-checkbox", 3, "change", "focus", "id", "disabled", "checked", "indeterminate"], [1, "clr-control-label", 3, "for"], [3, "ngTemplateOutlet"], [1, "clr-treenode-content", 3, "mouseup"], ["class", "clr-sr-only", 4, "ngIf"], [1, "clr-sr-only"]],
  template: function ClrTreeNode_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵprojectionDef(_c94);
      ɵɵelementStart(0, "div", 2, 0);
      ɵɵlistener("keydown", function ClrTreeNode_Template_div_keydown_0_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onKeyDown($event));
      })("focus", function ClrTreeNode_Template_div_focus_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.broadcastFocusOnContainer());
      });
      ɵɵtemplate(2, ClrTreeNode_button_2_Template, 2, 2, "button", 3)(3, ClrTreeNode_div_3_Template, 2, 0, "div", 4)(4, ClrTreeNode_div_4_Template, 4, 8, "div", 5)(5, ClrTreeNode_div_5_Template, 2, 3, "div", 6)(6, ClrTreeNode_ng_template_6_Template, 2, 1, "ng-template", null, 1, ɵɵtemplateRefExtractor);
      ɵɵelementEnd();
      ɵɵelementStart(8, "div", 7);
      ɵɵprojection(9);
      ɵɵprojection(10, 1);
      ɵɵelement(11, "clr-recursive-children", 8);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵclassProp("clr-form-control-disabled", ctx.disabled);
      ɵɵattribute("aria-disabled", ctx.disabled)("aria-expanded", ctx.isExpandable() ? ctx.expanded : null)("aria-selected", ctx.ariaSelected);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.isExpandable() && !ctx.isModelLoading && !ctx.expandService.loading);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.expandService.loading || ctx.isModelLoading);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.featuresService.selectable);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.featuresService.selectable);
      ɵɵadvance(3);
      ɵɵproperty("@toggleChildrenAnim", ctx.expandService.expanded ? "expanded" : "collapsed");
      ɵɵattribute("role", ctx.isExpandable() && !ctx.featuresService.recursion ? "group" : null);
      ɵɵadvance(3);
      ɵɵproperty("parent", ctx._model);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, CdsIconCustomTag, RecursiveChildren],
  encapsulation: 2,
  data: {
    animation: [trigger("toggleChildrenAnim", [transition("collapsed => expanded", [style({
      height: 0
    }), animate(200, style({
      height: "*"
    }))]), transition("expanded => collapsed", [style({
      height: "*"
    }), animate(200, style({
      height: 0
    }))]), state("expanded", style({
      height: "*",
      "overflow-y": "visible"
    })), state("collapsed", style({
      height: 0
    }))])]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTreeNode, [{
    type: Component,
    args: [{
      selector: "clr-tree-node",
      providers: [TREE_FEATURES_PROVIDER, IfExpandService, {
        provide: LoadingListener,
        useExisting: IfExpandService
      }],
      animations: [trigger("toggleChildrenAnim", [transition("collapsed => expanded", [style({
        height: 0
      }), animate(200, style({
        height: "*"
      }))]), transition("expanded => collapsed", [style({
        height: "*"
      }), animate(200, style({
        height: 0
      }))]), state("expanded", style({
        height: "*",
        "overflow-y": "visible"
      })), state("collapsed", style({
        height: 0
      }))])],
      host: {
        "[class.clr-tree-node]": "true",
        "[class.disabled]": "this._model.disabled"
      },
      template: `<!--
  ~ Copyright (c) 2016-2024 Broadcom. All Rights Reserved.
  ~ The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.
  ~ This software is released under MIT license.
  ~ The full license information can be found in LICENSE in the root directory of this project.
  -->

<div
  #contentContainer
  role="treeitem"
  class="clr-tree-node-content-container"
  tabindex="-1"
  [class.clr-form-control-disabled]="disabled"
  [attr.aria-disabled]="disabled"
  [attr.aria-expanded]="isExpandable() ? expanded : null"
  [attr.aria-selected]="ariaSelected"
  (keydown)="onKeyDown($event)"
  (focus)="broadcastFocusOnContainer()"
>
  <button
    *ngIf="isExpandable() && !isModelLoading && !expandService.loading"
    aria-hidden="true"
    type="button"
    tabindex="-1"
    class="clr-treenode-caret"
    (click)="expandService.toggle();"
    (focus)="focusTreeNode()"
    [disabled]="disabled"
  >
    <cds-icon
      class="clr-treenode-caret-icon"
      shape="angle"
      [attr.direction]="expandService.expanded ? 'down' : 'right'"
    ></cds-icon>
  </button>
  <div class="clr-treenode-spinner-container" *ngIf="expandService.loading || isModelLoading">
    <span class="clr-treenode-spinner spinner"></span>
  </div>
  <div class="clr-checkbox-wrapper clr-treenode-checkbox" *ngIf="featuresService.selectable">
    <input
      aria-hidden="true"
      type="checkbox"
      id="{{nodeId}}-check"
      class="clr-checkbox"
      [disabled]="disabled"
      [checked]="_model.selected.value === STATES.SELECTED"
      [indeterminate]="_model.selected.value === STATES.INDETERMINATE"
      (change)="_model.toggleSelection(featuresService.eager)"
      (focus)="focusTreeNode()"
      tabindex="-1"
    />
    <label for="{{nodeId}}-check" class="clr-control-label">
      <ng-container [ngTemplateOutlet]="treenodeContent"></ng-container>
    </label>
  </div>
  <div
    class="clr-treenode-content"
    [class.clr-treenode-text-only]="treeNodeContentTextOnly"
    (mouseup)="focusTreeNode()"
    *ngIf="!featuresService.selectable"
  >
    <ng-container [ngTemplateOutlet]="treenodeContent"></ng-container>
  </div>

  <ng-template #treenodeContent>
    <ng-content></ng-content>
    <div class="clr-sr-only" *ngIf="featuresService.selectable || ariaSelected">
      <span> {{ariaSelected ? commonStrings.keys.selectedTreeNode : commonStrings.keys.unselectedTreeNode}}</span>
    </div>
  </ng-template>
</div>
<div
  class="clr-treenode-children"
  [@toggleChildrenAnim]="expandService.expanded ? 'expanded' : 'collapsed'"
  [attr.role]="isExpandable() && !featuresService.recursion ? 'group' : null"
>
  <ng-content select="clr-tree-node"></ng-content>
  <ng-content select="[clrIfExpanded]"></ng-content>
  <clr-recursive-children [parent]="_model"></clr-recursive-children>
</div>
`
    }]
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }, {
      type: ClrTreeNode,
      decorators: [{
        type: Optional
      }, {
        type: SkipSelf
      }]
    }, {
      type: TreeFeaturesService
    }, {
      type: IfExpandService
    }, {
      type: ClrCommonStringsService
    }, {
      type: TreeFocusManagerService
    }, {
      type: ElementRef
    }, {
      type: Injector
    }];
  }, {
    expandable: [{
      type: Input,
      args: ["clrExpandable"]
    }],
    selectedChange: [{
      type: Output,
      args: ["clrSelectedChange"]
    }],
    expandedChange: [{
      type: Output,
      args: ["clrExpandedChange"]
    }],
    contentContainer: [{
      type: ViewChild,
      args: ["contentContainer", {
        read: ElementRef,
        static: true
      }]
    }],
    treeNodeLinkList: [{
      type: ContentChildren,
      args: [ClrTreeNodeLink, {
        descendants: false
      }]
    }],
    disabled: [{
      type: Input,
      args: ["clrDisabled"]
    }],
    selected: [{
      type: Input,
      args: ["clrSelected"]
    }],
    expanded: [{
      type: Input,
      args: ["clrExpanded"]
    }],
    clrForTypeAhead: [{
      type: Input,
      args: ["clrForTypeAhead"]
    }]
  });
})();
function trimAndLowerCase(value) {
  return value.toLocaleLowerCase().trim();
}
var ClrTree = class {
  constructor(featuresService, focusManagerService, renderer, el, ngZone) {
    this.featuresService = featuresService;
    this.focusManagerService = focusManagerService;
    this.renderer = renderer;
    this.el = el;
    this.subscriptions = [];
    this._isMultiSelectable = false;
    const subscription = ngZone.runOutsideAngular(() => fromEvent(el.nativeElement, "focusin").subscribe((event) => {
      if (event.target === el.nativeElement) {
        focusManagerService.focusFirstVisibleNode();
        renderer.removeAttribute(el.nativeElement, "tabindex");
      }
    }));
    this.subscriptions.push(subscription);
  }
  set lazy(value) {
    this.featuresService.eager = !value;
  }
  get isMultiSelectable() {
    return this._isMultiSelectable;
  }
  ngAfterContentInit() {
    this.setRootNodes();
    this.subscriptions.push(this.rootNodes.changes.subscribe(() => {
      this.setMultiSelectable();
      this.setRootNodes();
    }));
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
  setMultiSelectable() {
    if (this.featuresService.selectable && this.rootNodes.length > 0) {
      this._isMultiSelectable = true;
      this.renderer.setAttribute(this.el.nativeElement, "aria-multiselectable", "true");
    } else {
      this._isMultiSelectable = false;
      this.renderer.removeAttribute(this.el.nativeElement, "aria-multiselectable");
    }
  }
  setRootNodes() {
    this.focusManagerService.rootNodeModels = this.rootNodes.map((node) => node._model).filter((node) => !node.parent);
  }
};
ClrTree.ɵfac = function ClrTree_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrTree)(ɵɵdirectiveInject(TreeFeaturesService), ɵɵdirectiveInject(TreeFocusManagerService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
ClrTree.ɵcmp = ɵɵdefineComponent({
  type: ClrTree,
  selectors: [["clr-tree"]],
  contentQueries: function ClrTree_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrTreeNode, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.rootNodes = _t);
    }
  },
  hostAttrs: ["tabindex", "0"],
  hostVars: 1,
  hostBindings: function ClrTree_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", "tree");
    }
  },
  inputs: {
    lazy: [0, "clrLazy", "lazy"]
  },
  standalone: false,
  features: [ɵɵProvidersFeature([TREE_FEATURES_PROVIDER, TreeFocusManagerService])],
  ngContentSelectors: _c02,
  decls: 2,
  vars: 1,
  consts: [[3, "children", 4, "ngIf"], [3, "children"]],
  template: function ClrTree_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
      ɵɵtemplate(1, ClrTree_clr_recursive_children_1_Template, 1, 1, "clr-recursive-children", 0);
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.featuresService.recursion);
    }
  },
  dependencies: [NgIf, RecursiveChildren],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTree, [{
    type: Component,
    args: [{
      selector: "clr-tree",
      template: `
    <ng-content></ng-content>
    <clr-recursive-children
      *ngIf="featuresService.recursion"
      [children]="featuresService.recursion.root"
    ></clr-recursive-children>
  `,
      providers: [TREE_FEATURES_PROVIDER, TreeFocusManagerService],
      host: {
        tabindex: "0",
        "[attr.role]": '"tree"'
      }
    }]
  }], function() {
    return [{
      type: TreeFeaturesService
    }, {
      type: TreeFocusManagerService
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, {
    rootNodes: [{
      type: ContentChildren,
      args: [ClrTreeNode]
    }],
    lazy: [{
      type: Input,
      args: ["clrLazy"]
    }]
  });
})();
var CLR_TREE_VIEW_DIRECTIVES = [ClrTree, ClrTreeNode, ClrRecursiveForOf, ClrTreeNodeLink];
var ClrTreeViewModule = class {
  constructor() {
    r.addIcons(o);
  }
};
ClrTreeViewModule.ɵfac = function ClrTreeViewModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrTreeViewModule)();
};
ClrTreeViewModule.ɵmod = ɵɵdefineNgModule({
  type: ClrTreeViewModule,
  declarations: [ClrTree, ClrTreeNode, ClrRecursiveForOf, ClrTreeNodeLink, RecursiveChildren],
  imports: [CommonModule, ClrIconModule, ClrLoadingModule],
  exports: [ClrTree, ClrTreeNode, ClrRecursiveForOf, ClrTreeNodeLink]
});
ClrTreeViewModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrIconModule, ClrLoadingModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTreeViewModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ClrIconModule, ClrLoadingModule],
      declarations: [CLR_TREE_VIEW_DIRECTIVES, RecursiveChildren],
      exports: [CLR_TREE_VIEW_DIRECTIVES]
    }]
  }], function() {
    return [];
  }, null);
})();
var ClrDataModule = class {
};
ClrDataModule.ɵfac = function ClrDataModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrDataModule)();
};
ClrDataModule.ɵmod = ɵɵdefineNgModule({
  type: ClrDataModule,
  exports: [ClrDatagridModule, ClrStackViewModule, ClrTreeViewModule]
});
ClrDataModule.ɵinj = ɵɵdefineInjector({
  imports: [ClrDatagridModule, ClrStackViewModule, ClrTreeViewModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDataModule, [{
    type: NgModule,
    args: [{
      exports: [ClrDatagridModule, ClrStackViewModule, ClrTreeViewModule]
    }]
  }], null, null);
})();
var ALERT_TYPES = ["info", "warning", "danger", "success", "neutral", "unknown", "loading"];
var AlertIconAndTypesService = class {
  constructor(commonStrings) {
    this.commonStrings = commonStrings;
    this.defaultIconShape = "info-standard";
    this._alertIconShape = "";
    this._alertType = "info";
  }
  get alertType() {
    return this._alertType;
  }
  set alertType(val) {
    if (ALERT_TYPES.indexOf(val) > -1) {
      this._alertType = val;
    }
  }
  get alertIconShape() {
    if ("" === this._alertIconShape) {
      return this.iconInfoFromType(this._alertType).shape;
    }
    return this._alertIconShape;
  }
  set alertIconShape(val) {
    if (!val) {
      this._alertIconShape = "";
    } else if (val !== this._alertIconShape) {
      this._alertIconShape = val;
    }
  }
  get alertIconTitle() {
    return this.iconInfoFromType(this._alertType).title;
  }
  iconInfoFromType(type) {
    const returnObj = {
      shape: "",
      cssClass: "",
      title: ""
    };
    switch (type) {
      case "warning":
        returnObj.shape = "warning-standard";
        returnObj.cssClass = "alert-warning";
        returnObj.title = this.commonStrings.keys.warning;
        break;
      case "danger":
        returnObj.shape = "error-standard";
        returnObj.cssClass = "alert-danger";
        returnObj.title = this.commonStrings.keys.danger;
        break;
      case "success":
        returnObj.shape = "success-standard";
        returnObj.cssClass = "alert-success";
        returnObj.title = this.commonStrings.keys.success;
        break;
      case "neutral":
        returnObj.shape = "note";
        returnObj.cssClass = "alert-neutral";
        returnObj.title = this.commonStrings.keys.neutral;
        break;
      case "unknown":
        returnObj.shape = "help";
        returnObj.cssClass = "alert-neutral";
        returnObj.title = this.commonStrings.keys.unknown;
        break;
      case "loading":
        returnObj.shape = "loading";
        returnObj.cssClass = "alert-neutral";
        returnObj.title = this.commonStrings.keys.unknown;
        break;
      default:
        returnObj.shape = this.defaultIconShape;
        returnObj.cssClass = "alert-info";
        returnObj.title = this.commonStrings.keys.info;
        break;
    }
    return returnObj;
  }
};
AlertIconAndTypesService.ɵfac = function AlertIconAndTypesService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || AlertIconAndTypesService)(ɵɵinject(ClrCommonStringsService));
};
AlertIconAndTypesService.ɵprov = ɵɵdefineInjectable({
  token: AlertIconAndTypesService,
  factory: AlertIconAndTypesService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AlertIconAndTypesService, [{
    type: Injectable
  }], function() {
    return [{
      type: ClrCommonStringsService
    }];
  }, null);
})();
var MultiAlertService = class {
  constructor() {
    this._change = new Subject();
  }
  /**
   * The Observable that lets other classes subscribe to changes
   */
  get changes() {
    return this._change.asObservable();
  }
  get current() {
    return this._current;
  }
  set current(index) {
    if (index !== this._current) {
      this._current = index;
      this._change.next(index);
    }
  }
  get activeAlerts() {
    return this.allAlerts && this.allAlerts.filter((alert) => !alert._closed);
  }
  get currentAlert() {
    return this.activeAlerts && this.activeAlerts[this.current];
  }
  set currentAlert(alert) {
    this.current = this.activeAlerts.indexOf(alert);
  }
  get count() {
    return this.activeAlerts && this.activeAlerts.length || 0;
  }
  manage(alerts) {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
    this.allAlerts = alerts;
    this.current = typeof this._current === "number" ? this._current : 0;
    this._change.next(this.current);
    this.subscription = this.allAlerts.changes.subscribe(() => {
      if (this.current >= this.allAlerts.length) {
        this.current = Math.max(0, this.allAlerts.length - 1);
      }
    });
  }
  next() {
    this._current = this.current === this.activeAlerts.length - 1 ? 0 : this.current + 1;
    this._change.next(this._current);
  }
  previous() {
    if (this.activeAlerts.length === 0) {
      return;
    }
    this._current = this.current === 0 ? this.activeAlerts.length - 1 : this.current - 1;
    this._change.next(this._current);
  }
  open() {
    if (this.activeAlerts.length === 0) {
      return;
    }
    if (!this.currentAlert) {
      this._current = 0;
    }
    this._change.next(this._current);
  }
  close(isCurrentAlert) {
    if (this.activeAlerts.length === 0) {
      return;
    }
    if (isCurrentAlert) {
      this._current = Math.max(0, this.current - 1);
    }
    this._change.next(this._current);
  }
  destroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }
};
MultiAlertService.ɵfac = function MultiAlertService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || MultiAlertService)();
};
MultiAlertService.ɵprov = ɵɵdefineInjectable({
  token: MultiAlertService,
  factory: MultiAlertService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiAlertService, [{
    type: Injectable
  }], null, null);
})();
var ClrAlert = class {
  constructor(iconService, cdr, multiAlertService, commonStrings, renderer, hostElement) {
    this.iconService = iconService;
    this.cdr = cdr;
    this.multiAlertService = multiAlertService;
    this.commonStrings = commonStrings;
    this.renderer = renderer;
    this.hostElement = hostElement;
    this.isSmall = false;
    this.closable = true;
    this.isAppLevel = false;
    this.clrCloseButtonAriaLabel = this.commonStrings.keys.alertCloseButtonAriaLabel;
    this._closedChanged = new EventEmitter(false);
    this._closed = false;
    this.subscriptions = [];
    this._isLightweight = false;
  }
  get isLightweight() {
    return this._isLightweight;
  }
  set isLightweight(val) {
    this._isLightweight = val;
    this.configAlertType(this._origAlertType);
  }
  get alertType() {
    return this.iconService.alertType;
  }
  set alertType(val) {
    this._origAlertType = val;
    this.configAlertType(val);
  }
  set alertIconShape(value) {
    this.iconService.alertIconShape = value;
  }
  set closed(value) {
    if (value && !this._closed) {
      this.close();
    } else if (!value && this._closed) {
      this.open();
    }
  }
  get alertClass() {
    return this.iconService.iconInfoFromType(this.iconService.alertType).cssClass;
  }
  get hidden() {
    return this._hidden;
  }
  set hidden(value) {
    if (value !== this._hidden) {
      this._hidden = value;
      if (this._hidden) {
        this.renderer.addClass(this.hostElement.nativeElement, "alert-hidden");
      } else {
        this.renderer.removeClass(this.hostElement.nativeElement, "alert-hidden");
      }
      this.cdr.detectChanges();
    }
  }
  ngOnInit() {
    if (this.multiAlertService) {
      this.subscriptions.push(this.multiAlertService.changes.subscribe(() => {
        this.hidden = this.multiAlertService.currentAlert !== this;
      }));
    }
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
  configAlertType(val) {
    this.iconService.alertType = val;
  }
  open() {
    this._closed = false;
    if (this.multiAlertService) {
      this.multiAlertService.open();
    }
    this._closedChanged.emit(false);
  }
  close() {
    if (!this.closable) {
      return;
    }
    const isCurrentAlert = this.multiAlertService?.currentAlert === this;
    this._closed = true;
    if (this.multiAlertService?.activeAlerts) {
      this.multiAlertService.close(isCurrentAlert);
    }
    this._closedChanged.emit(true);
  }
};
ClrAlert.ɵfac = function ClrAlert_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrAlert)(ɵɵdirectiveInject(AlertIconAndTypesService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(MultiAlertService, 8), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
};
ClrAlert.ɵcmp = ɵɵdefineComponent({
  type: ClrAlert,
  selectors: [["clr-alert"]],
  inputs: {
    isSmall: [0, "clrAlertSizeSmall", "isSmall"],
    closable: [0, "clrAlertClosable", "closable"],
    isAppLevel: [0, "clrAlertAppLevel", "isAppLevel"],
    clrCloseButtonAriaLabel: "clrCloseButtonAriaLabel",
    isLightweight: [0, "clrAlertLightweight", "isLightweight"],
    alertType: [0, "clrAlertType", "alertType"],
    alertIconShape: [0, "clrAlertIcon", "alertIconShape"],
    closed: [0, "clrAlertClosed", "closed"]
  },
  outputs: {
    _closedChanged: "clrAlertClosedChange"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([AlertIconAndTypesService])],
  ngContentSelectors: _c02,
  decls: 1,
  vars: 1,
  consts: [["class", "alert", 3, "ngClass", "alert-sm", "alert-lightweight", "alert-app-level", 4, "ngIf"], [1, "alert", 3, "ngClass"], [1, "alert-items"], ["type", "button", "class", "close", 3, "click", 4, "ngIf"], ["type", "button", 1, "close", 3, "click"], ["shape", "window-close"]],
  template: function ClrAlert_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, ClrAlert_div_0_Template, 4, 8, "div", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", !ctx._closed);
    }
  },
  dependencies: [NgClass, NgIf, CdsIconCustomTag],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrAlert, [{
    type: Component,
    args: [{
      selector: "clr-alert",
      providers: [AlertIconAndTypesService],
      template: '<!--\n  ~ Copyright (c) 2016-2024 Broadcom. All Rights Reserved.\n  ~ The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<div\n  *ngIf="!_closed"\n  class="alert"\n  [ngClass]="alertClass"\n  [class.alert-sm]="isSmall"\n  [class.alert-lightweight]="isLightweight"\n  [class.alert-app-level]="isAppLevel"\n>\n  <div class="alert-items">\n    <ng-content></ng-content>\n  </div>\n  <button type="button" class="close" *ngIf="closable" (click)="close()" [attr.aria-label]="clrCloseButtonAriaLabel">\n    <cds-icon shape="window-close"></cds-icon>\n  </button>\n</div>\n'
    }]
  }], function() {
    return [{
      type: AlertIconAndTypesService
    }, {
      type: ChangeDetectorRef
    }, {
      type: MultiAlertService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ClrCommonStringsService
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }];
  }, {
    isSmall: [{
      type: Input,
      args: ["clrAlertSizeSmall"]
    }],
    closable: [{
      type: Input,
      args: ["clrAlertClosable"]
    }],
    isAppLevel: [{
      type: Input,
      args: ["clrAlertAppLevel"]
    }],
    clrCloseButtonAriaLabel: [{
      type: Input
    }],
    _closedChanged: [{
      type: Output,
      args: ["clrAlertClosedChange"]
    }],
    isLightweight: [{
      type: Input,
      args: ["clrAlertLightweight"]
    }],
    alertType: [{
      type: Input,
      args: ["clrAlertType"]
    }],
    alertIconShape: [{
      type: Input,
      args: ["clrAlertIcon"]
    }],
    closed: [{
      type: Input,
      args: ["clrAlertClosed"]
    }]
  });
})();
var ClrAlertItem = class {
  constructor(iconService) {
    this.iconService = iconService;
  }
};
ClrAlertItem.ɵfac = function ClrAlertItem_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrAlertItem)(ɵɵdirectiveInject(AlertIconAndTypesService));
};
ClrAlertItem.ɵcmp = ɵɵdefineComponent({
  type: ClrAlertItem,
  selectors: [["clr-alert-item"]],
  hostAttrs: [1, "alert-item"],
  standalone: false,
  ngContentSelectors: _c02,
  decls: 4,
  vars: 2,
  consts: [[1, "alert-icon-wrapper"], ["class", "alert-spinner", "clrInline", "", 4, "ngIf"], ["class", "alert-icon", "role", "img", 4, "ngIf"], ["clrInline", "", 1, "alert-spinner"], ["role", "img", 1, "alert-icon"]],
  template: function ClrAlertItem_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 0);
      ɵɵtemplate(1, ClrAlertItem_clr_spinner_1_Template, 1, 0, "clr-spinner", 1)(2, ClrAlertItem_cds_icon_2_Template, 1, 2, "cds-icon", 2);
      ɵɵelementEnd();
      ɵɵprojection(3);
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.iconService.alertIconShape === "loading");
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.iconService.alertIconShape !== "loading");
    }
  },
  dependencies: [NgIf, CdsIconCustomTag, ClrSpinner],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrAlertItem, [{
    type: Component,
    args: [{
      selector: "clr-alert-item",
      template: `
    <div class="alert-icon-wrapper">
      <clr-spinner class="alert-spinner" clrInline *ngIf="iconService.alertIconShape === 'loading'"></clr-spinner>
      <cds-icon
        class="alert-icon"
        role="img"
        *ngIf="iconService.alertIconShape !== 'loading'"
        [attr.shape]="iconService.alertIconShape"
        [attr.aria-label]="iconService.alertIconTitle"
      ></cds-icon>
    </div>
    <ng-content></ng-content>
  `,
      host: {
        class: "alert-item"
      }
    }]
  }], function() {
    return [{
      type: AlertIconAndTypesService
    }];
  }, null);
})();
var ClrAlertText = class {
};
ClrAlertText.ɵfac = function ClrAlertText_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrAlertText)();
};
ClrAlertText.ɵdir = ɵɵdefineDirective({
  type: ClrAlertText,
  selectors: [["", 8, "alert-text"]],
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrAlertText, [{
    type: Directive,
    args: [{
      selector: ".alert-text"
    }]
  }], null, null);
})();
var ClrAlertsPager = class {
  constructor(multiAlertService, commonStrings) {
    this.multiAlertService = multiAlertService;
    this.commonStrings = commonStrings;
    this.currentAlertChange = new EventEmitter(false);
    this.currentAlertIndexChange = new EventEmitter();
  }
  /**
   * Input/Output to support two way binding on current alert instance
   */
  get currentAlert() {
    return this.multiAlertService.currentAlert;
  }
  set currentAlert(alert) {
    if (alert) {
      this.multiAlertService.currentAlert = alert;
    }
  }
  /**
   * Input/Output to support two way binding on current alert index
   */
  get currentAlertIndex() {
    return this.multiAlertService.current;
  }
  set currentAlertIndex(index) {
    this.multiAlertService.current = index;
  }
  get previousAlertAriaLabel() {
    const CURRENT = this.currentAlertIndex + 1;
    return this.commonStrings.parse(this.commonStrings.keys.alertPreviousAlertAriaLabel, {
      CURRENT: (CURRENT === 1 ? this.multiAlertService.count : CURRENT - 1).toString(),
      COUNT: this.multiAlertService.count.toString()
    });
  }
  get nextAlertAriaLabel() {
    const CURRENT = this.currentAlertIndex + 1;
    return this.commonStrings.parse(this.commonStrings.keys.alertNextAlertAriaLabel, {
      CURRENT: (CURRENT === this.multiAlertService.count ? 1 : CURRENT + 1).toString(),
      COUNT: this.multiAlertService.count.toString()
    });
  }
  ngOnInit() {
    this.multiAlertServiceChanges = this.multiAlertService.changes.subscribe((index) => {
      this.currentAlertIndexChange.emit(index);
      this.currentAlertChange.emit(this.multiAlertService.activeAlerts[index]);
    });
  }
  ngOnDestroy() {
    this.multiAlertServiceChanges.unsubscribe();
  }
  pageUp() {
    this.multiAlertService.next();
  }
  pageDown() {
    this.multiAlertService.previous();
  }
};
ClrAlertsPager.ɵfac = function ClrAlertsPager_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrAlertsPager)(ɵɵdirectiveInject(MultiAlertService), ɵɵdirectiveInject(ClrCommonStringsService));
};
ClrAlertsPager.ɵcmp = ɵɵdefineComponent({
  type: ClrAlertsPager,
  selectors: [["clr-alerts-pager"]],
  hostVars: 2,
  hostBindings: function ClrAlertsPager_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("alerts-pager", true);
    }
  },
  inputs: {
    currentAlert: [0, "clrCurrentAlert", "currentAlert"],
    currentAlertIndex: [0, "clrCurrentAlertIndex", "currentAlertIndex"]
  },
  outputs: {
    currentAlertChange: "clrCurrentAlertChange",
    currentAlertIndexChange: "clrCurrentAlertIndexChange"
  },
  standalone: false,
  decls: 9,
  vars: 4,
  consts: [[1, "alerts-pager-control"], [1, "alerts-page-down"], ["type", "button", 1, "alerts-pager-button", 3, "click"], ["shape", "angle", "direction", "left"], [1, "alerts-pager-text"], [1, "alerts-page-up"], ["shape", "angle", "direction", "right"]],
  template: function ClrAlertsPager_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0)(1, "div", 1)(2, "button", 2);
      ɵɵlistener("click", function ClrAlertsPager_Template_button_click_2_listener() {
        return ctx.pageDown();
      });
      ɵɵelement(3, "cds-icon", 3);
      ɵɵelementEnd()();
      ɵɵelementStart(4, "div", 4);
      ɵɵtext(5);
      ɵɵelementEnd();
      ɵɵelementStart(6, "div", 5)(7, "button", 2);
      ɵɵlistener("click", function ClrAlertsPager_Template_button_click_7_listener() {
        return ctx.pageUp();
      });
      ɵɵelement(8, "cds-icon", 6);
      ɵɵelementEnd()()();
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵattribute("aria-label", ctx.previousAlertAriaLabel);
      ɵɵadvance(3);
      ɵɵtextInterpolate2("", ctx.multiAlertService.current + 1, " / ", ctx.multiAlertService.count, "");
      ɵɵadvance(2);
      ɵɵattribute("aria-label", ctx.nextAlertAriaLabel);
    }
  },
  dependencies: [CdsIconCustomTag],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrAlertsPager, [{
    type: Component,
    args: [{
      selector: "clr-alerts-pager",
      host: {
        "[class.alerts-pager]": "true"
      },
      template: '<!--\n  ~ Copyright (c) 2016-2024 Broadcom. All Rights Reserved.\n  ~ The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<div class="alerts-pager-control">\n  <div class="alerts-page-down">\n    <button class="alerts-pager-button" type="button" (click)="pageDown()" [attr.aria-label]="previousAlertAriaLabel">\n      <cds-icon shape="angle" direction="left"></cds-icon>\n    </button>\n  </div>\n  <div class="alerts-pager-text">{{this.multiAlertService.current+1}} / {{this.multiAlertService.count}}</div>\n  <div class="alerts-page-up">\n    <button class="alerts-pager-button" type="button" (click)="pageUp()" [attr.aria-label]="nextAlertAriaLabel">\n      <cds-icon shape="angle" direction="right"></cds-icon>\n    </button>\n  </div>\n</div>\n'
    }]
  }], function() {
    return [{
      type: MultiAlertService
    }, {
      type: ClrCommonStringsService
    }];
  }, {
    currentAlertChange: [{
      type: Output,
      args: ["clrCurrentAlertChange"]
    }],
    currentAlertIndexChange: [{
      type: Output,
      args: ["clrCurrentAlertIndexChange"]
    }],
    currentAlert: [{
      type: Input,
      args: ["clrCurrentAlert"]
    }],
    currentAlertIndex: [{
      type: Input,
      args: ["clrCurrentAlertIndex"]
    }]
  });
})();
var ClrAlerts = class {
  constructor(multiAlertService) {
    this.multiAlertService = multiAlertService;
    this.currentAlertChange = new EventEmitter(false);
    this.currentAlertIndexChange = new EventEmitter(false);
    this.subscriptions = [];
  }
  set allAlerts(value) {
    this.multiAlertService.manage(value);
  }
  /**
   * Input/Output to support two way binding on current alert index
   */
  set _inputCurrentIndex(index) {
    if (Number.isInteger(index) && index >= 0) {
      this.multiAlertService.current = index;
    }
  }
  get currentAlertIndex() {
    return this.multiAlertService.current;
  }
  set currentAlertIndex(index) {
    this.multiAlertService.current = index;
  }
  /**
   * Input/Output to support two way binding on current alert instance
   */
  get currentAlert() {
    return this.multiAlertService.currentAlert;
  }
  set currentAlert(alert) {
    if (alert) {
      this.multiAlertService.currentAlert = alert;
    }
  }
  /**
   * Ensure we are only dealing with alerts that have not been closed yet
   */
  get alerts() {
    return this.allAlerts.filter((alert) => {
      return alert.hidden === false;
    });
  }
  get currentAlertType() {
    if (this.multiAlertService.currentAlert) {
      return this.multiAlertService.currentAlert.alertType;
    }
    return "";
  }
  ngAfterContentInit() {
    this.subscriptions.push(this.multiAlertService.changes.subscribe((index) => {
      this.currentAlertIndexChange.next(index);
      this.currentAlertChange.next(this.multiAlertService.currentAlert);
    }));
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
    this.multiAlertService.destroy();
  }
};
ClrAlerts.ɵfac = function ClrAlerts_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrAlerts)(ɵɵdirectiveInject(MultiAlertService));
};
ClrAlerts.ɵcmp = ɵɵdefineComponent({
  type: ClrAlerts,
  selectors: [["clr-alerts"]],
  contentQueries: function ClrAlerts_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrAlert, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.allAlerts = _t);
    }
  },
  hostVars: 12,
  hostBindings: function ClrAlerts_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("alerts", true)("alert-danger", ctx.currentAlertType == "danger")("alert-info", ctx.currentAlertType == "info")("alert-success", ctx.currentAlertType == "success")("alert-warning", ctx.currentAlertType == "warning")("alert-neutral", ctx.currentAlertType == "neutral");
    }
  },
  inputs: {
    _inputCurrentIndex: [0, "clrCurrentAlertIndex", "_inputCurrentIndex"],
    currentAlert: [0, "clrCurrentAlert", "currentAlert"]
  },
  outputs: {
    currentAlertChange: "clrCurrentAlertChange",
    currentAlertIndexChange: "clrCurrentAlertIndexChange"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([MultiAlertService])],
  ngContentSelectors: _c97,
  decls: 3,
  vars: 1,
  consts: [[1, "alerts-wrapper"], [3, "clrCurrentAlertIndex", 4, "ngIf"], [3, "clrCurrentAlertIndex"]],
  template: function ClrAlerts_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c96);
      ɵɵelementStart(0, "div", 0);
      ɵɵtemplate(1, ClrAlerts_clr_alerts_pager_1_Template, 1, 1, "clr-alerts-pager", 1);
      ɵɵprojection(2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.multiAlertService.count > 1);
    }
  },
  dependencies: [NgIf, ClrAlertsPager],
  styles: ["[_nghost-%COMP%]{display:block}"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrAlerts, [{
    type: Component,
    args: [{
      selector: "clr-alerts",
      providers: [MultiAlertService],
      host: {
        "[class.alerts]": "true",
        "[class.alert-danger]": "this.currentAlertType == 'danger'",
        "[class.alert-info]": "this.currentAlertType == 'info'",
        "[class.alert-success]": "this.currentAlertType == 'success'",
        "[class.alert-warning]": "this.currentAlertType == 'warning'",
        "[class.alert-neutral]": "this.currentAlertType == 'neutral'"
      },
      template: '<!--\n  ~ Copyright (c) 2016-2024 Broadcom. All Rights Reserved.\n  ~ The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n<div class="alerts-wrapper">\n  <clr-alerts-pager *ngIf="multiAlertService.count > 1" [clrCurrentAlertIndex]="currentAlertIndex"></clr-alerts-pager>\n  <ng-content select="clr-alert"></ng-content>\n</div>\n',
      styles: [":host{display:block}\n"]
    }]
  }], function() {
    return [{
      type: MultiAlertService
    }];
  }, {
    currentAlertChange: [{
      type: Output,
      args: ["clrCurrentAlertChange"]
    }],
    currentAlertIndexChange: [{
      type: Output,
      args: ["clrCurrentAlertIndexChange"]
    }],
    allAlerts: [{
      type: ContentChildren,
      args: [ClrAlert]
    }],
    _inputCurrentIndex: [{
      type: Input,
      args: ["clrCurrentAlertIndex"]
    }],
    currentAlert: [{
      type: Input,
      args: ["clrCurrentAlert"]
    }]
  });
})();
var CLR_ALERT_DIRECTIVES = [ClrAlert, ClrAlertItem, ClrAlerts, ClrAlertsPager, ClrAlertText];
var ClrAlertModule = class {
  constructor() {
    r.addIcons(d, d3, o7, o9, d2, r2, L3);
  }
};
ClrAlertModule.ɵfac = function ClrAlertModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrAlertModule)();
};
ClrAlertModule.ɵmod = ɵɵdefineNgModule({
  type: ClrAlertModule,
  declarations: [ClrAlert, ClrAlertItem, ClrAlerts, ClrAlertsPager, ClrAlertText],
  imports: [CommonModule, ClrIconModule, ClrDropdownModule, ClrSpinnerModule],
  exports: [ClrAlert, ClrAlertItem, ClrAlerts, ClrAlertsPager, ClrAlertText]
});
ClrAlertModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrIconModule, ClrDropdownModule, ClrSpinnerModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrAlertModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ClrIconModule, ClrDropdownModule, ClrSpinnerModule],
      declarations: [CLR_ALERT_DIRECTIVES],
      exports: [CLR_ALERT_DIRECTIVES]
    }]
  }], function() {
    return [];
  }, null);
})();
var ClrEmphasisModule = class {
};
ClrEmphasisModule.ɵfac = function ClrEmphasisModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrEmphasisModule)();
};
ClrEmphasisModule.ɵmod = ɵɵdefineNgModule({
  type: ClrEmphasisModule,
  exports: [ClrAlertModule]
});
ClrEmphasisModule.ɵinj = ɵɵdefineInjector({
  imports: [ClrAlertModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrEmphasisModule, [{
    type: NgModule,
    args: [{
      exports: [ClrAlertModule]
    }]
  }], null, null);
})();
var MAX_DISPLAY_ITEMS = 3;
var ClrBreadcrumbItem = class {
};
ClrBreadcrumbItem.ɵfac = function ClrBreadcrumbItem_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrBreadcrumbItem)();
};
ClrBreadcrumbItem.ɵcmp = ɵɵdefineComponent({
  type: ClrBreadcrumbItem,
  selectors: [["clr-breadcrumb-item"]],
  hostAttrs: [1, "clr-breadcrumb-item"],
  hostVars: 1,
  hostBindings: function ClrBreadcrumbItem_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", "list-item");
    }
  },
  standalone: false,
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrBreadcrumbItem_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrBreadcrumbItem, [{
    type: Component,
    args: [{
      selector: "clr-breadcrumb-item",
      template: "<ng-content />",
      host: {
        class: "clr-breadcrumb-item",
        "[attr.role]": '"list-item"'
      }
    }]
  }], null, null);
})();
var ClrBreadcrumbs = class {
  constructor(commonStrings) {
    this.commonStrings = commonStrings;
    this.isExpanded = false;
    this.items = [];
    this.clrBreadcrumbItemClick = new EventEmitter();
    this.limit = MAX_DISPLAY_ITEMS;
    this.max = MAX_DISPLAY_ITEMS;
  }
  expand() {
    this.isExpanded = true;
    this.limit = this.items?.length;
  }
  handleItemClick(breadcrumb) {
    this.clrBreadcrumbItemClick.emit(breadcrumb);
  }
};
ClrBreadcrumbs.ɵfac = function ClrBreadcrumbs_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrBreadcrumbs)(ɵɵdirectiveInject(ClrCommonStringsService));
};
ClrBreadcrumbs.ɵcmp = ɵɵdefineComponent({
  type: ClrBreadcrumbs,
  selectors: [["clr-breadcrumbs"]],
  hostAttrs: [1, "clr-breadcrumb"],
  hostVars: 2,
  hostBindings: function ClrBreadcrumbs_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("aria-label", ctx.commonStrings.keys.breadcrumbsLabel)("role", "navigation");
    }
  },
  inputs: {
    items: "items"
  },
  outputs: {
    clrBreadcrumbItemClick: "clrBreadcrumbItemClick"
  },
  standalone: false,
  decls: 1,
  vars: 1,
  consts: [["breadcrumbLinks", ""], ["role", "list", "class", "clr-breadcrumb-menu", 4, "ngIf"], ["role", "list", 1, "clr-breadcrumb-menu"], [4, "ngIf"], [4, "ngFor", "ngForOf"], [1, "btn", "btn-link", "btn-sm", "clr-breadcrumb-expand", 3, "click", "keydown"], ["shape", "ellipsis-horizontal"], ["aria-current", "page", 4, "ngIf", "ngIfElse"], ["aria-current", "page"], [3, "routerLink", "queryParams", "target", "click", 4, "ngIf"], [3, "href", "target", "click", 4, "ngIf"], [3, "click", "routerLink", "queryParams", "target"], [3, "click", "href", "target"]],
  template: function ClrBreadcrumbs_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, ClrBreadcrumbs_div_0_Template, 4, 6, "div", 1);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.items == null ? null : ctx.items.length);
    }
  },
  dependencies: [NgForOf, NgIf, CdsIconCustomTag, RouterLink, ClrBreadcrumbItem, SlicePipe],
  styles: ['[_ngcontent-%COMP%]:root   [cds-theme][_ngcontent-%COMP%]{--clr-breadcrumb-link-color: var(--cds-alias-object-interaction-background-highlight);--clr-breadcrumb-item-space: var(--cds-global-space-8);--clr-breadcrumb-font-weight: var(--cds-global-typography-font-weight-regular);--clr-breadcrumb-font-size: var(--cds-alias-typography-secondary-font-size);--clr-breadcrumb-line-height: var(--cds-global-space-7)}.clr-breadcrumb-menu[_ngcontent-%COMP%]{display:flex;flex-wrap:wrap;align-items:center}.clr-breadcrumb-menu[_ngcontent-%COMP%]   .clr-breadcrumb-item[_ngcontent-%COMP%]{display:flex;align-items:center;min-height:calc(24 * (1rem / var(--cds-global-base)));font-family:var(--clr-font);color:var(--clr-breadcrumb-link-color);font-size:var(--cds-alias-typography-secondary-font-size);font-weight:var(--cds-alias-typography-secondary-font-weight);line-height:var(--cds-alias-typography-secondary-line-height);letter-spacing:var(--cds-alias-typography-secondary-letter-spacing)}.clr-breadcrumb-menu[_ngcontent-%COMP%]   .clr-breadcrumb-item[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{text-decoration:none}.clr-breadcrumb-menu[_ngcontent-%COMP%]   .clr-breadcrumb-item[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:after{content:"/";margin:0 var(--clr-breadcrumb-item-space);color:var(--cds-alias-typography-color-400)}.clr-breadcrumb-menu[_ngcontent-%COMP%]   .active[_ngcontent-%COMP%]{color:var(--cds-alias-typography-color-400)}.clr-breadcrumb-menu[_ngcontent-%COMP%]   .clr-breadcrumb-item[_ngcontent-%COMP%]:last-child{color:var(--cds-alias-typography-color-400)}.clr-breadcrumb-menu[_ngcontent-%COMP%]   .clr-breadcrumb-expand[_ngcontent-%COMP%]{margin:0;padding:0;gap:0;min-width:-moz-fit-content;min-width:fit-content}.clr-breadcrumb-menu[_ngcontent-%COMP%]   .clr-breadcrumb-expand[_ngcontent-%COMP%]:after{content:"/";margin:0 var(--clr-breadcrumb-item-space);color:var(--cds-alias-typography-color-400)}']
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrBreadcrumbs, [{
    type: Component,
    args: [{
      selector: "clr-breadcrumbs",
      host: {
        class: "clr-breadcrumb",
        "[attr.aria-label]": "commonStrings.keys.breadcrumbsLabel",
        "[attr.role]": '"navigation"'
      },
      template: '<div *ngIf="items?.length" role="list" class="clr-breadcrumb-menu">\n  <clr-breadcrumb-item *ngIf="items.length > max && !isExpanded">\n    <button\n      [attr.aria-label]="commonStrings.keys.expandBreadcrumbsLabel"\n      class="btn btn-link btn-sm clr-breadcrumb-expand"\n      (click)="expand()"\n      (keydown)="expand()"\n    >\n      <cds-icon shape="ellipsis-horizontal"></cds-icon>\n    </button>\n  </clr-breadcrumb-item>\n  <clr-breadcrumb-item *ngFor="let breadcrumb of items | slice: -limit : items.length; let isLastItem=last">\n    <span *ngIf="isLastItem; else breadcrumbLinks" aria-current="page">{{ breadcrumb.label }}</span>\n\n    <ng-template #breadcrumbLinks>\n      <a\n        *ngIf="breadcrumb.routerLink"\n        [routerLink]="breadcrumb.routerLink"\n        [queryParams]="breadcrumb.queryParams"\n        [target]="breadcrumb.target"\n        (click)="handleItemClick(breadcrumb)"\n      >\n        {{ breadcrumb.label }}\n      </a>\n      <a\n        *ngIf="breadcrumb.href"\n        [href]="breadcrumb.href"\n        [target]="breadcrumb.target"\n        (click)="handleItemClick(breadcrumb)"\n      >\n        {{ breadcrumb.label }}\n      </a>\n    </ng-template>\n  </clr-breadcrumb-item>\n</div>\n',
      styles: [':root [cds-theme]{--clr-breadcrumb-link-color: var(--cds-alias-object-interaction-background-highlight);--clr-breadcrumb-item-space: var(--cds-global-space-8);--clr-breadcrumb-font-weight: var(--cds-global-typography-font-weight-regular);--clr-breadcrumb-font-size: var(--cds-alias-typography-secondary-font-size);--clr-breadcrumb-line-height: var(--cds-global-space-7)}.clr-breadcrumb-menu{display:flex;flex-wrap:wrap;align-items:center}.clr-breadcrumb-menu .clr-breadcrumb-item{display:flex;align-items:center;min-height:calc(24 * (1rem / var(--cds-global-base)));font-family:var(--clr-font);color:var(--clr-breadcrumb-link-color);font-size:var(--cds-alias-typography-secondary-font-size);font-weight:var(--cds-alias-typography-secondary-font-weight);line-height:var(--cds-alias-typography-secondary-line-height);letter-spacing:var(--cds-alias-typography-secondary-letter-spacing)}.clr-breadcrumb-menu .clr-breadcrumb-item a{text-decoration:none}.clr-breadcrumb-menu .clr-breadcrumb-item a:after{content:"/";margin:0 var(--clr-breadcrumb-item-space);color:var(--cds-alias-typography-color-400)}.clr-breadcrumb-menu .active{color:var(--cds-alias-typography-color-400)}.clr-breadcrumb-menu .clr-breadcrumb-item:last-child{color:var(--cds-alias-typography-color-400)}.clr-breadcrumb-menu .clr-breadcrumb-expand{margin:0;padding:0;gap:0;min-width:-moz-fit-content;min-width:fit-content}.clr-breadcrumb-menu .clr-breadcrumb-expand:after{content:"/";margin:0 var(--clr-breadcrumb-item-space);color:var(--cds-alias-typography-color-400)}\n']
    }]
  }], function() {
    return [{
      type: ClrCommonStringsService
    }];
  }, {
    items: [{
      type: Input
    }],
    clrBreadcrumbItemClick: [{
      type: Output
    }]
  });
})();
var ClrBreadcrumbsModule = class {
};
ClrBreadcrumbsModule.ɵfac = function ClrBreadcrumbsModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrBreadcrumbsModule)();
};
ClrBreadcrumbsModule.ɵmod = ɵɵdefineNgModule({
  type: ClrBreadcrumbsModule,
  declarations: [ClrBreadcrumbs, ClrBreadcrumbItem],
  imports: [CommonModule, ClrIconModule, ClrHostWrappingModule, RouterModule],
  exports: [ClrBreadcrumbs]
});
ClrBreadcrumbsModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrIconModule, ClrHostWrappingModule, RouterModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrBreadcrumbsModule, [{
    type: NgModule,
    args: [{
      declarations: [ClrBreadcrumbs, ClrBreadcrumbItem],
      exports: [ClrBreadcrumbs],
      imports: [CommonModule, ClrIconModule, ClrHostWrappingModule, RouterModule]
    }]
  }], null, null);
})();
var ResponsiveNavCodes = class {
};
ResponsiveNavCodes.NAV_LEVEL_1 = 1;
ResponsiveNavCodes.NAV_LEVEL_2 = 2;
ResponsiveNavCodes.NAV_CLOSE_ALL = "NAV_CLOSE_ALL";
ResponsiveNavCodes.NAV_OPEN = "NAV_OPEN";
ResponsiveNavCodes.NAV_CLOSE = "NAV_CLOSE";
ResponsiveNavCodes.NAV_TOGGLE = "NAV_TOGGLE";
ResponsiveNavCodes.NAV_CLASS_HAMBURGER_MENU = "open-hamburger-menu";
ResponsiveNavCodes.NAV_CLASS_OVERFLOW_MENU = "open-overflow-menu";
ResponsiveNavCodes.NAV_CLASS_TRIGGER_1 = "header-hamburger-trigger";
ResponsiveNavCodes.NAV_CLASS_TRIGGER_2 = "header-overflow-trigger";
ResponsiveNavCodes.NAV_CLASS_LEVEL_1 = "clr-nav-level-1";
ResponsiveNavCodes.NAV_CLASS_LEVEL_2 = "clr-nav-level-2";
var ResponsiveNavControlMessage = class {
  constructor(_controlCode, _navLevel) {
    this._controlCode = _controlCode;
    this._navLevel = _navLevel;
  }
  get controlCode() {
    return this._controlCode;
  }
  get navLevel() {
    return this._navLevel;
  }
};
var ResponsiveNavigationService = class {
  constructor() {
    this.responsiveNavList = [];
    this.registerNavSubject = new ReplaySubject();
    this.controlNavSubject = new Subject();
    this.closeAllNavs();
  }
  get registeredNavs() {
    return this.registerNavSubject.asObservable();
  }
  get navControl() {
    return this.controlNavSubject.asObservable();
  }
  registerNav(navLevel) {
    if (!navLevel || this.isNavRegistered(navLevel)) {
      return;
    }
    this.responsiveNavList.push(navLevel);
    this.registerNavSubject.next(this.responsiveNavList);
  }
  isNavRegistered(navLevel) {
    if (this.responsiveNavList.indexOf(navLevel) > -1) {
      console.error("Multiple clr-nav-level " + navLevel + " attributes found. Please make sure that only one exists");
      return true;
    }
    return false;
  }
  unregisterNav(navLevel) {
    const index = this.responsiveNavList.indexOf(navLevel);
    if (index > -1) {
      this.responsiveNavList.splice(index, 1);
      this.registerNavSubject.next(this.responsiveNavList);
    }
  }
  sendControlMessage(controlCode, navLevel) {
    const message = new ResponsiveNavControlMessage(controlCode, navLevel);
    this.controlNavSubject.next(message);
  }
  closeAllNavs() {
    const message = new ResponsiveNavControlMessage(ResponsiveNavCodes.NAV_CLOSE_ALL, -999);
    this.controlNavSubject.next(message);
  }
};
ResponsiveNavigationService.ɵfac = function ResponsiveNavigationService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ResponsiveNavigationService)();
};
ResponsiveNavigationService.ɵprov = ɵɵdefineInjectable({
  token: ResponsiveNavigationService,
  factory: ResponsiveNavigationService.ɵfac,
  providedIn: "root"
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ResponsiveNavigationService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [];
  }, null);
})();
var ClrMainContainer = class {
  constructor(elRef, responsiveNavService) {
    this.elRef = elRef;
    this.responsiveNavService = responsiveNavService;
  }
  ngOnInit() {
    this._classList = this.elRef.nativeElement.classList;
    this._subscription = this.responsiveNavService.navControl.subscribe({
      next: (message) => {
        this.processMessage(message);
      }
    });
  }
  processMessage(message) {
    let navClass = ResponsiveNavCodes.NAV_CLASS_HAMBURGER_MENU;
    if (message.controlCode === ResponsiveNavCodes.NAV_CLOSE_ALL) {
      this._classList.remove(ResponsiveNavCodes.NAV_CLASS_HAMBURGER_MENU);
      this._classList.remove(ResponsiveNavCodes.NAV_CLASS_OVERFLOW_MENU);
    } else if (message.navLevel === ResponsiveNavCodes.NAV_LEVEL_1) {
      this.controlNav(message.controlCode, navClass);
    } else if (message.navLevel === ResponsiveNavCodes.NAV_LEVEL_2) {
      navClass = ResponsiveNavCodes.NAV_CLASS_OVERFLOW_MENU;
      this.controlNav(message.controlCode, navClass);
    }
  }
  controlNav(controlCode, navClass) {
    if (controlCode === ResponsiveNavCodes.NAV_OPEN) {
      this._classList.add(navClass);
    } else if (controlCode === ResponsiveNavCodes.NAV_CLOSE) {
      this._classList.remove(navClass);
    } else if (controlCode === ResponsiveNavCodes.NAV_TOGGLE) {
      this._classList.toggle(navClass);
    }
  }
  ngOnDestroy() {
    this._subscription.unsubscribe();
  }
};
ClrMainContainer.ɵfac = function ClrMainContainer_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrMainContainer)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ResponsiveNavigationService));
};
ClrMainContainer.ɵdir = ɵɵdefineDirective({
  type: ClrMainContainer,
  selectors: [["clr-main-container"]],
  hostVars: 2,
  hostBindings: function ClrMainContainer_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("main-container", true);
    }
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrMainContainer, [{
    type: Directive,
    args: [{
      selector: "clr-main-container",
      host: {
        "[class.main-container]": "true"
      }
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ResponsiveNavigationService
    }];
  }, null);
})();
var CLR_LAYOUT_DIRECTIVES = [ClrMainContainer];
var ClrMainContainerModule = class {
};
ClrMainContainerModule.ɵfac = function ClrMainContainerModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrMainContainerModule)();
};
ClrMainContainerModule.ɵmod = ɵɵdefineNgModule({
  type: ClrMainContainerModule,
  declarations: [ClrMainContainer],
  imports: [CommonModule, ClrIconModule],
  exports: [ClrMainContainer]
});
ClrMainContainerModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrIconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrMainContainerModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ClrIconModule],
      declarations: [CLR_LAYOUT_DIRECTIVES],
      exports: [CLR_LAYOUT_DIRECTIVES]
    }]
  }], null, null);
})();
var ClrAriaCurrentLink = class {
  constructor(rla) {
    this.rla = rla;
  }
  ngOnInit() {
    this.subscription = this.rla.isActiveChange.subscribe((isActive) => {
      this.ariaCurrent = isActive ? "page" : void 0;
    });
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
};
ClrAriaCurrentLink.ɵfac = function ClrAriaCurrentLink_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrAriaCurrentLink)(ɵɵdirectiveInject(RouterLinkActive));
};
ClrAriaCurrentLink.ɵdir = ɵɵdefineDirective({
  type: ClrAriaCurrentLink,
  selectors: [["", "clrAriaCurrentLink", ""]],
  hostVars: 1,
  hostBindings: function ClrAriaCurrentLink_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("aria-current", ctx.ariaCurrent);
    }
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrAriaCurrentLink, [{
    type: Directive,
    args: [{
      selector: "[clrAriaCurrentLink]",
      host: {
        "[attr.aria-current]": "ariaCurrent"
      }
    }]
  }], function() {
    return [{
      type: RouterLinkActive
    }];
  }, null);
})();
var MainContainerWillyWonka = class extends WillyWonka {
};
MainContainerWillyWonka.ɵfac = /* @__PURE__ */ (() => {
  let ɵMainContainerWillyWonka_BaseFactory;
  return function MainContainerWillyWonka_Factory(__ngFactoryType__) {
    return (ɵMainContainerWillyWonka_BaseFactory || (ɵMainContainerWillyWonka_BaseFactory = ɵɵgetInheritedFactory(MainContainerWillyWonka)))(__ngFactoryType__ || MainContainerWillyWonka);
  };
})();
MainContainerWillyWonka.ɵdir = ɵɵdefineDirective({
  type: MainContainerWillyWonka,
  selectors: [["clr-main-container"]],
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MainContainerWillyWonka, [{
    type: Directive,
    args: [{
      selector: "clr-main-container"
    }]
  }], null, null);
})();
var NavDetectionOompaLoompa = class extends OompaLoompa {
  constructor(cdr, willyWonka, responsiveNavService) {
    if (!willyWonka) {
      throw new Error("clr-header should only be used inside of a clr-main-container");
    }
    super(cdr, willyWonka);
    this.responsiveNavService = responsiveNavService;
  }
  // NavDetectionOompaLoompa is the addition of the nav levels
  // Since we support 2 levels, the possibilities are 0, 1 or 3 (1 + 2)
  get flavor() {
    return this.responsiveNavService.responsiveNavList.reduce((sum, navLevel) => sum + navLevel, 0);
  }
};
NavDetectionOompaLoompa.ɵfac = function NavDetectionOompaLoompa_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || NavDetectionOompaLoompa)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(MainContainerWillyWonka, 8), ɵɵdirectiveInject(ResponsiveNavigationService));
};
NavDetectionOompaLoompa.ɵdir = ɵɵdefineDirective({
  type: NavDetectionOompaLoompa,
  selectors: [["clr-header"]],
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavDetectionOompaLoompa, [{
    type: Directive,
    args: [{
      selector: "clr-header"
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: MainContainerWillyWonka,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ResponsiveNavigationService
    }];
  }, null);
})();
var ClrHeader = class {
  constructor(responsiveNavService, commonStrings) {
    this.responsiveNavService = responsiveNavService;
    this.commonStrings = commonStrings;
    this.role = "banner";
    this.isNavLevel1OnPage = false;
    this.isNavLevel2OnPage = false;
    this.openNavLevel = null;
    this.responsiveNavCodes = ResponsiveNavCodes;
    this._subscription = responsiveNavService.registeredNavs.subscribe({
      next: (navLevelList) => {
        this.initializeNavTriggers(navLevelList);
      }
    });
    this._subscription.add(responsiveNavService.navControl.pipe(filter(({
      controlCode
    }) => controlCode === ResponsiveNavCodes.NAV_CLOSE || controlCode === ResponsiveNavCodes.NAV_CLOSE_ALL)).subscribe(() => {
      this.openNavLevel = null;
    }));
  }
  get responsiveNavCommonString() {
    const myCommonStrings = this.commonStrings.keys;
    if (this.openNavLevel !== this.responsiveNavCodes.NAV_LEVEL_1) {
      return myCommonStrings.responsiveNavToggleOpen;
    } else {
      return myCommonStrings.responsiveNavToggleClose;
    }
  }
  get responsiveOverflowCommonString() {
    const myCommonStrings = this.commonStrings.keys;
    if (this.openNavLevel !== this.responsiveNavCodes.NAV_LEVEL_2) {
      return myCommonStrings.responsiveNavOverflowOpen;
    } else {
      return myCommonStrings.responsiveNavOverflowClose;
    }
  }
  // reset triggers. handles cases when an application has different nav levels on different pages.
  resetNavTriggers() {
    this.isNavLevel1OnPage = false;
    this.isNavLevel2OnPage = false;
  }
  // decides which triggers to show on the header
  initializeNavTriggers(navList) {
    this.resetNavTriggers();
    if (navList.length > 2) {
      console.error("More than 2 Nav Levels detected.");
      return;
    }
    navList.forEach((navLevel) => {
      if (navLevel === ResponsiveNavCodes.NAV_LEVEL_1) {
        this.isNavLevel1OnPage = true;
      } else if (navLevel === ResponsiveNavCodes.NAV_LEVEL_2) {
        this.isNavLevel2OnPage = true;
      }
    });
  }
  // closes the nav that is open
  closeOpenNav() {
    this.responsiveNavService.closeAllNavs();
  }
  /**
   * @deprecated Will be removed in with @clr/angular v15.0.0
   *
   * Use `openNav(navLevel)` instead to open the navigation and ResponsiveNavService to close it.
   */
  toggleNav(navLevel) {
    if (this.openNavLevel === navLevel) {
      this.responsiveNavService.sendControlMessage(ResponsiveNavCodes.NAV_CLOSE, navLevel);
      return;
    }
    this.openNav(navLevel);
  }
  openNav(navLevel) {
    this.openNavLevel = navLevel;
    this.responsiveNavService.sendControlMessage(ResponsiveNavCodes.NAV_OPEN, navLevel);
  }
  ngOnDestroy() {
    this._subscription.unsubscribe();
  }
};
ClrHeader.ɵfac = function ClrHeader_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrHeader)(ɵɵdirectiveInject(ResponsiveNavigationService), ɵɵdirectiveInject(ClrCommonStringsService));
};
ClrHeader.ɵcmp = ɵɵdefineComponent({
  type: ClrHeader,
  selectors: [["clr-header"]],
  hostVars: 3,
  hostBindings: function ClrHeader_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", ctx.role);
      ɵɵclassProp("header", true);
    }
  },
  inputs: {
    role: "role"
  },
  standalone: false,
  ngContentSelectors: _c02,
  decls: 4,
  vars: 2,
  consts: [["type", "button", "class", "header-hamburger-trigger", 3, "click", 4, "ngIf"], ["type", "button", "class", "header-overflow-trigger", 3, "click", 4, "ngIf"], [1, "header-backdrop", 3, "click"], ["type", "button", 1, "header-hamburger-trigger", 3, "click"], ["type", "button", 1, "header-overflow-trigger", 3, "click"]],
  template: function ClrHeader_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, ClrHeader_button_0_Template, 2, 1, "button", 0);
      ɵɵprojection(1);
      ɵɵtemplate(2, ClrHeader_button_2_Template, 2, 1, "button", 1);
      ɵɵelementStart(3, "div", 2);
      ɵɵlistener("click", function ClrHeader_Template_div_click_3_listener() {
        return ctx.closeOpenNav();
      });
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.isNavLevel1OnPage);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.isNavLevel2OnPage);
    }
  },
  dependencies: [NgIf],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrHeader, [{
    type: Component,
    args: [{
      selector: "clr-header",
      template: `
    <button
      type="button"
      *ngIf="isNavLevel1OnPage"
      class="header-hamburger-trigger"
      [attr.aria-label]="responsiveNavCommonString"
      (click)="openNav(responsiveNavCodes.NAV_LEVEL_1)"
    >
      <span></span>
    </button>
    <ng-content></ng-content>
    <button
      type="button"
      *ngIf="isNavLevel2OnPage"
      class="header-overflow-trigger"
      [attr.aria-label]="responsiveOverflowCommonString"
      (click)="openNav(responsiveNavCodes.NAV_LEVEL_2)"
    >
      <span></span>
    </button>
    <div class="header-backdrop" (click)="closeOpenNav()"></div>
  `,
      host: {
        "[class.header]": "true"
      }
    }]
  }], function() {
    return [{
      type: ResponsiveNavigationService
    }, {
      type: ClrCommonStringsService
    }];
  }, {
    role: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.role"]
    }]
  });
})();
var createCloseButton = (document2, ariaLabel) => {
  r.addIcons(e4);
  const closeButton = document2.createElement("button");
  closeButton.setAttribute("aria-label", ariaLabel);
  closeButton.setAttribute("aria-hidden", "true");
  closeButton.innerHTML = `
    <cds-icon
      inner-offset="1"
      shape="times"
      size="32"
    ></cds-icon>
  `;
  closeButton.setAttribute("hidden", "true");
  closeButton.className = "clr-nav-close";
  return closeButton;
};
var ClrNavLevel = class {
  constructor(platformId, cdkTrapFocus, responsiveNavService, elementRef, renderer, injector) {
    this.cdkTrapFocus = cdkTrapFocus;
    this.responsiveNavService = responsiveNavService;
    this.elementRef = elementRef;
    this.renderer = renderer;
    this._isOpen = false;
    if (isPlatformBrowser(platformId)) {
      this._document = injector.get(DOCUMENT);
    }
    this._subscription = responsiveNavService.navControl.pipe(filter((x) => x.navLevel === this.level), filter(({
      controlCode
    }) => controlCode === ResponsiveNavCodes.NAV_OPEN && !this.isOpen || controlCode === ResponsiveNavCodes.NAV_CLOSE && this.isOpen)).subscribe(({
      controlCode
    }) => {
      if (controlCode === ResponsiveNavCodes.NAV_OPEN) {
        this.open();
        return;
      }
      this.close();
    });
    this._subscription.add(responsiveNavService.navControl.pipe(filter(({
      controlCode
    }) => controlCode === ResponsiveNavCodes.NAV_CLOSE_ALL)).subscribe(() => this.close()));
  }
  get level() {
    return this._level;
  }
  // getter to access the responsive navigation codes from the template
  get responsiveNavCodes() {
    return ResponsiveNavCodes;
  }
  get isOpen() {
    return this._isOpen;
  }
  ngOnInit() {
    this.cdkTrapFocus.enabled = false;
    if (!this.closeButtonAriaLabel) {
      this.closeButtonAriaLabel = this._level === ResponsiveNavCodes.NAV_LEVEL_1 ? commonStringsDefault.responsiveNavToggleClose : commonStringsDefault.responsiveNavOverflowClose;
    }
    if (this.level !== ResponsiveNavCodes.NAV_LEVEL_1 && this.level !== ResponsiveNavCodes.NAV_LEVEL_2) {
      console.error("Nav Level can only be 1 or 2");
      return;
    }
    this.responsiveNavService.registerNav(this.level);
    this.addNavClass(this.level);
  }
  ngAfterViewInit() {
    const closeButton = createCloseButton(this._document, this.closeButtonAriaLabel);
    this.renderer.listen(closeButton, "click", this.close.bind(this));
    this.renderer.insertBefore(this.elementRef.nativeElement, closeButton, this.elementRef.nativeElement.firstChild);
    if (this._document.body.clientWidth < LARGE_BREAKPOINT) {
      this.close();
    }
  }
  ngOnDestroy() {
    this.responsiveNavService.unregisterNav(this.level);
    this._subscription.unsubscribe();
  }
  onResize(event) {
    const target = event.target;
    if (target.innerWidth < LARGE_BREAKPOINT && this.isOpen) {
      this.close();
      return;
    }
    this.showNavigation();
  }
  // TODO: Figure out whats the best way to do this. Possible methods
  // 1. HostListener (current solution)
  // 2. Directives on the .nav-link class. We discussed on moving away from class selectors but I forget the reason
  // why
  onMouseClick(target) {
    let current = target;
    const navHost = this.elementRef.nativeElement;
    while (current) {
      if (current === navHost) {
        return;
      } else if (current.classList.contains("nav-link") && this._document.body.clientWidth < LARGE_BREAKPOINT) {
        this.close();
        return;
      }
      current = current.parentNode;
    }
  }
  addNavClass(level) {
    const navHostClassList = this.elementRef.nativeElement.classList;
    if (level === ResponsiveNavCodes.NAV_LEVEL_1) {
      navHostClassList.add(ResponsiveNavCodes.NAV_CLASS_LEVEL_1);
    } else if (level === ResponsiveNavCodes.NAV_LEVEL_2) {
      navHostClassList.add(ResponsiveNavCodes.NAV_CLASS_LEVEL_2);
    }
  }
  open() {
    this._isOpen = true;
    this.showNavigation();
    this.cdkTrapFocus.enabled = true;
    this.showCloseButton();
    this.responsiveNavService.sendControlMessage(ResponsiveNavCodes.NAV_OPEN, this.level);
  }
  close() {
    this._isOpen = false;
    this.hideNavigation();
    this.cdkTrapFocus.enabled = false;
    this.hideCloseButton();
    this.responsiveNavService.sendControlMessage(ResponsiveNavCodes.NAV_CLOSE, this.level);
  }
  hideNavigation() {
    this.renderer.setAttribute(this.elementRef.nativeElement, "aria-hidden", "true");
    this.renderer.setAttribute(this.elementRef.nativeElement, "hidden", "true");
  }
  showNavigation() {
    this.renderer.setAttribute(this.elementRef.nativeElement, "aria-hidden", "false");
    this.renderer.removeAttribute(this.elementRef.nativeElement, "hidden");
  }
  hideCloseButton() {
    this.renderer.setAttribute(this.elementRef.nativeElement, "aria-hidden", "true");
    this.renderer.setAttribute(this.elementRef.nativeElement.querySelector(".clr-nav-close"), "hidden", "true");
  }
  showCloseButton() {
    this.renderer.setAttribute(this.elementRef.nativeElement.querySelector(".clr-nav-close"), "aria-hidden", "false");
    this.renderer.removeAttribute(this.elementRef.nativeElement.querySelector(".clr-nav-close"), "hidden");
  }
};
ClrNavLevel.ɵfac = function ClrNavLevel_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrNavLevel)(ɵɵdirectiveInject(PLATFORM_ID), ɵɵdirectiveInject(ClrStandaloneCdkTrapFocus), ɵɵdirectiveInject(ResponsiveNavigationService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(Injector));
};
ClrNavLevel.ɵdir = ɵɵdefineDirective({
  type: ClrNavLevel,
  selectors: [["", "clr-nav-level", ""]],
  hostBindings: function ClrNavLevel_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("resize", function ClrNavLevel_resize_HostBindingHandler($event) {
        return ctx.onResize($event);
      }, false, ɵɵresolveWindow)("click", function ClrNavLevel_click_HostBindingHandler($event) {
        return ctx.onMouseClick($event.target);
      });
    }
  },
  inputs: {
    _level: [0, "clr-nav-level", "_level"],
    closeButtonAriaLabel: [0, "closeAriaLabel", "closeButtonAriaLabel"]
  },
  standalone: false,
  features: [ɵɵHostDirectivesFeature([ClrStandaloneCdkTrapFocus])]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrNavLevel, [{
    type: Directive,
    args: [{
      selector: "[clr-nav-level]",
      hostDirectives: [ClrStandaloneCdkTrapFocus]
    }]
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }, {
      type: ClrStandaloneCdkTrapFocus
    }, {
      type: ResponsiveNavigationService
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: Injector
    }];
  }, {
    _level: [{
      type: Input,
      args: ["clr-nav-level"]
    }],
    closeButtonAriaLabel: [{
      type: Input,
      args: ["closeAriaLabel"]
    }],
    onResize: [{
      type: HostListener,
      args: ["window:resize", ["$event"]]
    }],
    onMouseClick: [{
      type: HostListener,
      args: ["click", ["$event.target"]]
    }]
  });
})();
var CLR_NAVIGATION_DIRECTIVES = [ClrHeader, ClrNavLevel, ClrAriaCurrentLink, NavDetectionOompaLoompa, MainContainerWillyWonka];
var ClrNavigationModule = class {
};
ClrNavigationModule.ɵfac = function ClrNavigationModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrNavigationModule)();
};
ClrNavigationModule.ɵmod = ɵɵdefineNgModule({
  type: ClrNavigationModule,
  declarations: [ClrHeader, ClrNavLevel, ClrAriaCurrentLink, NavDetectionOompaLoompa, MainContainerWillyWonka],
  imports: [CommonModule, ClrIconModule, ClrDropdownModule],
  exports: [ClrHeader, ClrNavLevel, ClrAriaCurrentLink, NavDetectionOompaLoompa, MainContainerWillyWonka]
});
ClrNavigationModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrIconModule, ClrDropdownModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrNavigationModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ClrIconModule, ClrDropdownModule],
      declarations: [CLR_NAVIGATION_DIRECTIVES],
      exports: [CLR_NAVIGATION_DIRECTIVES]
    }]
  }], null, null);
})();
var TemplateRefContainer = class {
};
TemplateRefContainer.ɵfac = function TemplateRefContainer_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TemplateRefContainer)();
};
TemplateRefContainer.ɵcmp = ɵɵdefineComponent({
  type: TemplateRefContainer,
  selectors: [["ng-component"]],
  viewQuery: function TemplateRefContainer_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(TemplateRef, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.template = _t.first);
    }
  },
  standalone: false,
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function TemplateRefContainer_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, TemplateRefContainer_ng_template_0_Template, 1, 0, "ng-template");
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TemplateRefContainer, [{
    type: Component,
    args: [{
      template: `
    <ng-template>
      <ng-content></ng-content>
    </ng-template>
  `
    }]
  }], null, {
    template: [{
      type: ViewChild,
      args: [TemplateRef]
    }]
  });
})();
var TEMPLATE_REF_DIRECTIVES = [TemplateRefContainer];
var ClrTemplateRefModule = class {
};
ClrTemplateRefModule.ɵfac = function ClrTemplateRefModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrTemplateRefModule)();
};
ClrTemplateRefModule.ɵmod = ɵɵdefineNgModule({
  type: ClrTemplateRefModule,
  declarations: [TemplateRefContainer],
  imports: [CommonModule],
  exports: [TemplateRefContainer]
});
ClrTemplateRefModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTemplateRefModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [TEMPLATE_REF_DIRECTIVES],
      exports: [TEMPLATE_REF_DIRECTIVES]
    }]
  }], null, null);
})();
var TabsWillyWonka = class extends WillyWonka {
};
TabsWillyWonka.ɵfac = /* @__PURE__ */ (() => {
  let ɵTabsWillyWonka_BaseFactory;
  return function TabsWillyWonka_Factory(__ngFactoryType__) {
    return (ɵTabsWillyWonka_BaseFactory || (ɵTabsWillyWonka_BaseFactory = ɵɵgetInheritedFactory(TabsWillyWonka)))(__ngFactoryType__ || TabsWillyWonka);
  };
})();
TabsWillyWonka.ɵdir = ɵɵdefineDirective({
  type: TabsWillyWonka,
  selectors: [["clr-tabs"]],
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TabsWillyWonka, [{
    type: Directive,
    args: [{
      selector: "clr-tabs"
    }]
  }], null, null);
})();
var ActiveOompaLoompa = class extends OompaLoompa {
  constructor(cdr, willyWonka, id, ifActive) {
    if (!willyWonka) {
      throw new Error("clrTabLink and clr-tab-content should only be used inside of a clr-tabs");
    }
    super(cdr, willyWonka);
    this.ifActive = ifActive;
    this.id = id;
  }
  get flavor() {
    return this.ifActive.current === this.id;
  }
};
ActiveOompaLoompa.ɵfac = function ActiveOompaLoompa_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ActiveOompaLoompa)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(TabsWillyWonka, 8), ɵɵdirectiveInject(IF_ACTIVE_ID), ɵɵdirectiveInject(IfActiveService));
};
ActiveOompaLoompa.ɵdir = ɵɵdefineDirective({
  type: ActiveOompaLoompa,
  selectors: [["", "clrTabLink", ""], ["clr-tab-content"]],
  standalone: false,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ActiveOompaLoompa, [{
    type: Directive,
    args: [{
      selector: "[clrTabLink], clr-tab-content"
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: TabsWillyWonka,
      decorators: [{
        type: Optional
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [IF_ACTIVE_ID]
      }]
    }, {
      type: IfActiveService
    }];
  }, null);
})();
var TabsLayout;
(function(TabsLayout2) {
  TabsLayout2["HORIZONTAL"] = "horizontal";
  TabsLayout2["VERTICAL"] = "vertical";
})(TabsLayout || (TabsLayout = {}));
var TabsService = class {
  constructor() {
    this.layout = TabsLayout.HORIZONTAL;
    this._children = [];
  }
  get children() {
    return this._children;
  }
  get activeTab() {
    return this.children.find((tab) => {
      return tab.active;
    });
  }
  get overflowTabs() {
    if (this.layout === TabsLayout.VERTICAL) {
      return [];
    } else {
      return this.children.filter((tab) => tab.tabLink.inOverflow === true);
    }
  }
  register(tab) {
    this._children.push(tab);
  }
  unregister(tab) {
    const index = this.children.indexOf(tab);
    if (index > -1) {
      this.children.splice(index, 1);
    }
  }
};
TabsService.ɵfac = function TabsService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TabsService)();
};
TabsService.ɵprov = ɵɵdefineInjectable({
  token: TabsService,
  factory: TabsService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TabsService, [{
    type: Injectable
  }], null, null);
})();
var nbTabContentComponents = 0;
var ClrTabContent = class {
  constructor(ifActiveService, id, tabsService) {
    this.ifActiveService = ifActiveService;
    this.id = id;
    this.tabsService = tabsService;
    if (!this.tabContentId) {
      this.tabContentId = "clr-tab-content-" + nbTabContentComponents++;
    }
  }
  get active() {
    return this.ifActiveService.current === this.id;
  }
  get ariaLabelledBy() {
    return this.tabsService.children.find((tab) => tab.tabLink.id === this.id)?.tabLink?.tabLinkId;
  }
  // The template must be applied on the top-down phase of view-child initialization to prevent
  // components in the content from initializing before a content container exists.
  // Some child components need their container for sizing calculations.
  set templateRef(value) {
    this.viewRef = this.tabsService.tabContentViewContainer.createEmbeddedView(value);
  }
  ngOnDestroy() {
    const index = this.tabsService.tabContentViewContainer.indexOf(this.viewRef);
    if (index > -1) {
      this.tabsService.tabContentViewContainer.remove(index);
    }
  }
};
ClrTabContent.ɵfac = function ClrTabContent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrTabContent)(ɵɵdirectiveInject(IfActiveService), ɵɵdirectiveInject(IF_ACTIVE_ID), ɵɵdirectiveInject(TabsService));
};
ClrTabContent.ɵcmp = ɵɵdefineComponent({
  type: ClrTabContent,
  selectors: [["clr-tab-content"]],
  viewQuery: function ClrTabContent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c98, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.templateRef = _t.first);
    }
  },
  inputs: {
    tabContentId: [0, "id", "tabContentId"]
  },
  standalone: false,
  ngContentSelectors: _c02,
  decls: 2,
  vars: 0,
  consts: [["tabContentProjectedRef", ""], ["role", "tabpanel", 1, "tab-content", 3, "id", "hidden"]],
  template: function ClrTabContent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, ClrTabContent_ng_template_0_Template, 2, 6, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTabContent, [{
    type: Component,
    args: [{
      selector: "clr-tab-content",
      template: `
    <ng-template #tabContentProjectedRef>
      <section
        [id]="tabContentId"
        role="tabpanel"
        class="tab-content"
        [class.active]="active"
        [hidden]="!active"
        [attr.aria-labelledby]="ariaLabelledBy"
        [attr.aria-hidden]="!active"
      >
        <ng-content></ng-content>
      </section>
    </ng-template>
  `
    }]
  }], function() {
    return [{
      type: IfActiveService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [IF_ACTIVE_ID]
      }]
    }, {
      type: TabsService
    }];
  }, {
    tabContentId: [{
      type: Input,
      args: ["id"]
    }],
    templateRef: [{
      type: ViewChild,
      args: ["tabContentProjectedRef", {
        static: true
      }]
    }]
  });
})();
var nbTabsComponent = 0;
var TABS_ID = new InjectionToken("TABS_ID");
function tokenFactory() {
  return "clr-tabs-" + nbTabsComponent++;
}
var TABS_ID_PROVIDER = {
  provide: TABS_ID,
  useFactory: tokenFactory
};
var nbTabLinkComponents = 0;
var ClrTabLink = class {
  constructor(ifActiveService, id, el, cfr, viewContainerRef, tabsService, tabsId) {
    this.ifActiveService = ifActiveService;
    this.id = id;
    this.el = el;
    this.tabsService = tabsService;
    this.tabsId = tabsId;
    if (!this.tabLinkId) {
      this.tabLinkId = "clr-tab-link-" + nbTabLinkComponents++;
    }
    const factory = cfr.resolveComponentFactory(TemplateRefContainer);
    this.templateRefContainer = viewContainerRef.createComponent(factory, void 0, void 0, [[el.nativeElement]]).instance;
  }
  get inOverflow() {
    return this._inOverflow && this.tabsService.layout !== TabsLayout.VERTICAL;
  }
  set inOverflow(inOverflow) {
    this._inOverflow = inOverflow;
  }
  get addLinkClasses() {
    return !this.inOverflow;
  }
  get ariaControls() {
    return this.tabsService.children.find((tab) => tab.tabLink === this)?.tabContent?.tabContentId;
  }
  get active() {
    return this.ifActiveService.current === this.id;
  }
  get tabindex() {
    return this.active ? 0 : -1;
  }
  activate() {
    this.ifActiveService.current = this.id;
  }
};
ClrTabLink.ɵfac = function ClrTabLink_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrTabLink)(ɵɵdirectiveInject(IfActiveService), ɵɵdirectiveInject(IF_ACTIVE_ID), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ComponentFactoryResolver$1), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(TabsService), ɵɵdirectiveInject(TABS_ID));
};
ClrTabLink.ɵdir = ɵɵdefineDirective({
  type: ClrTabLink,
  selectors: [["", "clrTabLink", ""]],
  hostAttrs: ["role", "tab", "type", "button"],
  hostVars: 12,
  hostBindings: function ClrTabLink_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function ClrTabLink_click_HostBindingHandler() {
        return ctx.activate();
      });
    }
    if (rf & 2) {
      ɵɵhostProperty("id", ctx.tabLinkId);
      ɵɵattribute("aria-controls", ctx.ariaControls)("aria-selected", ctx.active)("tabindex", ctx.tabindex);
      ɵɵclassProp("btn", true)("btn-link", ctx.addLinkClasses)("nav-link", ctx.addLinkClasses)("active", ctx.active);
    }
  },
  inputs: {
    tabLinkId: [0, "id", "tabLinkId"],
    inOverflow: [0, "clrTabLinkInOverflow", "inOverflow"]
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTabLink, [{
    type: Directive,
    args: [{
      selector: "[clrTabLink]",
      host: {
        "[class.btn]": "true",
        role: "tab",
        type: "button"
      }
    }]
  }], function() {
    return [{
      type: IfActiveService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [IF_ACTIVE_ID]
      }]
    }, {
      type: ElementRef
    }, {
      type: ComponentFactoryResolver$1
    }, {
      type: ViewContainerRef
    }, {
      type: TabsService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [TABS_ID]
      }]
    }];
  }, {
    tabLinkId: [{
      type: Input,
      args: ["id"]
    }, {
      type: HostBinding,
      args: ["id"]
    }],
    inOverflow: [{
      type: Input,
      args: ["clrTabLinkInOverflow"]
    }],
    addLinkClasses: [{
      type: HostBinding,
      args: ["class.btn-link"]
    }, {
      type: HostBinding,
      args: ["class.nav-link"]
    }],
    ariaControls: [{
      type: HostBinding,
      args: ["attr.aria-controls"]
    }],
    active: [{
      type: HostBinding,
      args: ["class.active"]
    }, {
      type: HostBinding,
      args: ["attr.aria-selected"]
    }],
    tabindex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    activate: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var ClrTab = class {
  constructor(ifActiveService, id, tabsService) {
    this.ifActiveService = ifActiveService;
    this.id = id;
    this.tabsService = tabsService;
    tabsService.register(this);
  }
  get active() {
    return this.ifActiveService.current === this.id;
  }
  ngOnDestroy() {
    this.tabsService.unregister(this);
  }
};
ClrTab.ɵfac = function ClrTab_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrTab)(ɵɵdirectiveInject(IfActiveService), ɵɵdirectiveInject(IF_ACTIVE_ID), ɵɵdirectiveInject(TabsService));
};
ClrTab.ɵcmp = ɵɵdefineComponent({
  type: ClrTab,
  selectors: [["clr-tab"]],
  contentQueries: function ClrTab_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrTabLink, 7);
      ɵɵcontentQuery(dirIndex, ClrTabContent, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabLink = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabContent = _t.first);
    }
  },
  standalone: false,
  features: [ɵɵProvidersFeature([IF_ACTIVE_ID_PROVIDER])],
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrTab_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTab, [{
    type: Component,
    args: [{
      selector: "clr-tab",
      template: `<ng-content></ng-content>`,
      providers: [IF_ACTIVE_ID_PROVIDER]
    }]
  }], function() {
    return [{
      type: IfActiveService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [IF_ACTIVE_ID]
      }]
    }, {
      type: TabsService
    }];
  }, {
    tabLink: [{
      type: ContentChild,
      args: [ClrTabLink, {
        static: true
      }]
    }],
    tabContent: [{
      type: ContentChild,
      args: [ClrTabContent, {
        static: true
      }]
    }]
  });
})();
var ClrTabAction = class {
};
ClrTabAction.ɵfac = function ClrTabAction_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrTabAction)();
};
ClrTabAction.ɵdir = ɵɵdefineDirective({
  type: ClrTabAction,
  selectors: [["", "clrTabAction", ""]],
  hostAttrs: ["tabindex", "0"],
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTabAction, [{
    type: Directive,
    args: [{
      selector: "[clrTabAction]",
      host: {
        tabindex: "0"
      }
    }]
  }], null, null);
})();
var ClrTabOverflowContent = class {
};
ClrTabOverflowContent.ɵfac = function ClrTabOverflowContent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrTabOverflowContent)();
};
ClrTabOverflowContent.ɵcmp = ɵɵdefineComponent({
  type: ClrTabOverflowContent,
  selectors: [["clr-tab-overflow-content"]],
  hostVars: 2,
  hostBindings: function ClrTabOverflowContent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("dropdown-menu", true);
    }
  },
  standalone: false,
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrTabOverflowContent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTabOverflowContent, [{
    type: Component,
    args: [{
      selector: "clr-tab-overflow-content",
      template: `<ng-content></ng-content>`,
      host: {
        "[class.dropdown-menu]": "true"
      }
    }]
  }], null, null);
})();
var ClrTabs = class {
  constructor(ifActiveService, toggleService, tabsService, tabsId, commonStrings) {
    this.ifActiveService = ifActiveService;
    this.toggleService = toggleService;
    this.tabsService = tabsService;
    this.tabsId = tabsId;
    this.commonStrings = commonStrings;
    this.tabLinkElements = [];
    this._mousedown = false;
    this.subscriptions = [];
    this._tabLinkDirectives = [];
  }
  get layout() {
    return this.tabsService.layout;
  }
  set layout(layout) {
    if (Object.keys(TabsLayout).map((key) => {
      return TabsLayout[key];
    }).indexOf(layout) >= 0) {
      this.tabsService.layout = layout;
    }
  }
  get tabLinkDirectives() {
    return this._tabLinkDirectives;
  }
  get activeTabInOverflow() {
    return this.tabsService.overflowTabs.indexOf(this.tabsService.activeTab) > -1;
  }
  get activeTabPosition() {
    return this._tabLinkDirectives.findIndex((link) => link.active);
  }
  get isCurrentInOverflow() {
    return this.keyFocus.current >= this.overflowPosition;
  }
  get isVertical() {
    return this.layout === TabsLayout.VERTICAL;
  }
  set tabOverflowEl(value) {
    this._tabOverflowEl = value && value.nativeElement;
    if (this.toggleService.open && value) {
      this.keyFocus.focusCurrent();
    }
  }
  get overflowPosition() {
    return this._tabLinkDirectives.filter((link) => !link.inOverflow).length;
  }
  set tabContentViewContainer(value) {
    this.tabsService.tabContentViewContainer = value;
  }
  ngAfterContentInit() {
    this.subscriptions.push(this.listenForTabLinkChanges());
    this.subscriptions.push(this.listedForTabsActionsChanges());
    if (typeof this.ifActiveService.current === "undefined" && this.tabLinkDirectives[0]) {
      this.tabLinkDirectives[0].activate();
    }
    this.keyFocus.current = this.activeTabPosition;
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => {
      sub.unsubscribe();
    });
  }
  toggleOverflowOnPosition(position) {
    this.toggleService.open = position >= this.overflowPosition;
  }
  resetKeyFocusCurrentToActive(event) {
    const keyFocusContainsFocus = this.keyFocus.nativeElement.contains(event.relatedTarget);
    if (!keyFocusContainsFocus && this.keyFocus.current !== this.activeTabPosition) {
      this.keyFocus.current = this.activeTabPosition;
    }
  }
  toggleOverflowOnClick() {
    if (this.isCurrentInOverflow && this.toggleService.open) {
      this.keyFocus.moveTo(this.overflowPosition - 1);
    } else {
      this.keyFocus.moveTo(this.overflowPosition);
    }
    this._mousedown = false;
  }
  openOverflowOnFocus() {
    if (!this._mousedown && !this.toggleService.open) {
      this.keyFocus.moveTo(this.activeTabPosition);
    }
  }
  closeOnFocusOut(event) {
    if (!this._tabOverflowEl.contains(event.relatedTarget) && this.toggleService.open && !this._mousedown) {
      this.toggleService.open = false;
      if (this.tabLinkElements[this.activeTabPosition] === event.relatedTarget) {
        this.keyFocus.current = this.activeTabPosition;
      }
    }
  }
  closeOnEscapeKey() {
    this.keyFocus.moveTo(this.overflowPosition - 1);
  }
  closeOnOutsideClick(event, tabOverflowTrigger) {
    const isTabsAction = this.tabsActions.some((action) => action.nativeElement.contains(event.target));
    if (event.target === tabOverflowTrigger || tabOverflowTrigger.contains(event.target) || isTabsAction) {
      return;
    }
    if (!this._tabOverflowEl.contains(event.target) && this.isCurrentInOverflow) {
      this.keyFocus.moveTo(this.overflowPosition - 1);
    }
  }
  setTabLinkElements() {
    this._tabLinkDirectives = this.tabs.map((tab) => tab.tabLink);
    this.tabLinkElements = this._tabLinkDirectives.map((tab) => tab.el.nativeElement);
    if (this.tabsActions && this.tabsActions) {
      this.tabLinkElements.push(...this.tabsActions.map((action) => action.nativeElement));
    }
  }
  listenForTabLinkChanges() {
    return this.tabs.changes.pipe(startWith(this.tabs.map((tab) => tab.tabLink))).subscribe(() => this.setTabLinkElements());
  }
  listedForTabsActionsChanges() {
    return this.tabsActions.changes.subscribe(() => this.setTabLinkElements());
  }
};
ClrTabs.ɵfac = function ClrTabs_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrTabs)(ɵɵdirectiveInject(IfActiveService), ɵɵdirectiveInject(ClrPopoverToggleService), ɵɵdirectiveInject(TabsService), ɵɵdirectiveInject(TABS_ID), ɵɵdirectiveInject(ClrCommonStringsService));
};
ClrTabs.ɵcmp = ɵɵdefineComponent({
  type: ClrTabs,
  selectors: [["clr-tabs"]],
  contentQueries: function ClrTabs_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrTabAction, 5, ElementRef);
      ɵɵcontentQuery(dirIndex, ClrTab, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabsActions = _t);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabs = _t);
    }
  },
  viewQuery: function ClrTabs_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(ClrKeyFocus, 7);
      ɵɵviewQuery(ClrTabOverflowContent, 5, ElementRef);
      ɵɵviewQuery(_c99, 7, ViewContainerRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.keyFocus = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabOverflowEl = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabContentViewContainer = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function ClrTabs_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("tabs-vertical", ctx.isVertical);
    }
  },
  inputs: {
    layout: [0, "clrLayout", "layout"]
  },
  standalone: false,
  features: [ɵɵProvidersFeature([IfActiveService, TabsService, TABS_ID_PROVIDER]), ɵɵHostDirectivesFeature([ClrPopoverHostDirective])],
  ngContentSelectors: _c101,
  decls: 6,
  vars: 3,
  consts: [["tabContentViewContainer", ""], ["tabOverflowTrigger", ""], ["role", "tablist", "clrDirection", "both", 1, "nav", 3, "clrFocusChange", "focusout", "clrKeyFocus"], [4, "ngFor", "ngForOf"], [4, "ngIf"], ["role", "presentation", 1, "nav-item"], [3, "ngTemplateOutlet"], ["role", "presentation", 1, "tabs-overflow", "bottom-right"], ["role", "application", 1, "nav-item"], ["type", "button", "aria-hidden", "true", 1, "btn", "btn-link", "nav-link", "dropdown-toggle", 3, "mousedown", "focus", "click"], ["shape", "ellipsis-horizontal"], [3, "keydown.escape", "click", "focusout", 4, "ngIf"], [3, "keydown.escape", "click", "focusout"], [3, "ngTemplateOutlet", 4, "ngIf"]],
  template: function ClrTabs_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵprojectionDef(_c100);
      ɵɵelementStart(0, "ul", 2);
      ɵɵlistener("clrFocusChange", function ClrTabs_Template_ul_clrFocusChange_0_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.toggleOverflowOnPosition($event));
      })("focusout", function ClrTabs_Template_ul_focusout_0_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.resetKeyFocusCurrentToActive($event));
      });
      ɵɵtemplate(1, ClrTabs_ng_container_1_Template, 2, 1, "ng-container", 3)(2, ClrTabs_ng_container_2_Template, 7, 11, "ng-container", 4);
      ɵɵprojection(3);
      ɵɵelementEnd();
      ɵɵelementContainer(4, null, 0);
    }
    if (rf & 2) {
      ɵɵproperty("clrKeyFocus", ctx.tabLinkElements);
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.tabLinkDirectives);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.tabsService.overflowTabs.length > 0);
    }
  },
  dependencies: [NgForOf, NgIf, NgTemplateOutlet, CdsIconCustomTag, ClrKeyFocus, ClrTabOverflowContent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTabs, [{
    type: Component,
    args: [{
      selector: "clr-tabs",
      template: `
    <ul
      class="nav"
      role="tablist"
      [clrKeyFocus]="tabLinkElements"
      clrDirection="both"
      (clrFocusChange)="toggleOverflowOnPosition($event)"
      (focusout)="resetKeyFocusCurrentToActive($event)"
    >
      <!--tab links-->
      <ng-container *ngFor="let link of tabLinkDirectives">
        <ng-container *ngIf="link.tabsId === tabsId && !link.inOverflow">
          <li role="presentation" class="nav-item">
            <ng-container [ngTemplateOutlet]="link.templateRefContainer.template"></ng-container>
          </li>
        </ng-container>
      </ng-container>
      <ng-container *ngIf="tabsService.overflowTabs.length > 0">
        <div class="tabs-overflow bottom-right" role="presentation" [class.open]="toggleService.open">
          <li role="application" class="nav-item">
            <button
              #tabOverflowTrigger
              class="btn btn-link nav-link dropdown-toggle"
              type="button"
              aria-hidden="true"
              [attr.tabindex]="activeTabInOverflow && !toggleService.open ? 0 : -1"
              [class.active]="activeTabInOverflow"
              [class.open]="toggleService.open"
              (mousedown)="_mousedown = true"
              (focus)="openOverflowOnFocus()"
              (click)="toggleOverflowOnClick()"
              [attr.title]="commonStrings.keys.more"
            >
              <cds-icon
                shape="ellipsis-horizontal"
                [attr.status]="toggleService.open ? 'info' : null"
                [attr.title]="commonStrings.keys.more"
              ></cds-icon>
            </button>
          </li>
          <!--tab links in overflow menu-->
          <clr-tab-overflow-content
            *ngIf="toggleService.open"
            (document:keydown.escape)="closeOnEscapeKey()"
            (document:click)="closeOnOutsideClick($event, tabOverflowTrigger)"
            (focusout)="closeOnFocusOut($event)"
          >
            <ng-container *ngFor="let link of tabLinkDirectives">
              <ng-container
                *ngIf="link.tabsId === tabsId && link.inOverflow"
                [ngTemplateOutlet]="link.templateRefContainer.template"
              ></ng-container>
            </ng-container>
          </clr-tab-overflow-content>
        </div>
      </ng-container>
      <ng-content select="clr-tabs-actions"></ng-content>
    </ul>
    <ng-container #tabContentViewContainer></ng-container>
  `,
      providers: [IfActiveService, TabsService, TABS_ID_PROVIDER],
      hostDirectives: [ClrPopoverHostDirective]
    }]
  }], function() {
    return [{
      type: IfActiveService
    }, {
      type: ClrPopoverToggleService
    }, {
      type: TabsService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [TABS_ID]
      }]
    }, {
      type: ClrCommonStringsService
    }];
  }, {
    keyFocus: [{
      type: ViewChild,
      args: [ClrKeyFocus, {
        static: true
      }]
    }],
    tabsActions: [{
      type: ContentChildren,
      args: [ClrTabAction, {
        read: ElementRef,
        descendants: true
      }]
    }],
    tabs: [{
      type: ContentChildren,
      args: [ClrTab]
    }],
    layout: [{
      type: Input,
      args: ["clrLayout"]
    }],
    isVertical: [{
      type: HostBinding,
      args: ["class.tabs-vertical"]
    }],
    tabOverflowEl: [{
      type: ViewChild,
      args: [ClrTabOverflowContent, {
        read: ElementRef
      }]
    }],
    tabContentViewContainer: [{
      type: ViewChild,
      args: ["tabContentViewContainer", {
        static: true,
        read: ViewContainerRef
      }]
    }]
  });
})();
var ClrTabsActions = class {
  constructor() {
    this.position = "right";
  }
};
ClrTabsActions.ɵfac = function ClrTabsActions_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrTabsActions)();
};
ClrTabsActions.ɵcmp = ɵɵdefineComponent({
  type: ClrTabsActions,
  selectors: [["clr-tabs-actions"]],
  hostVars: 3,
  hostBindings: function ClrTabsActions_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("position", ctx.position);
      ɵɵclassProp("tabs-actions", true);
    }
  },
  inputs: {
    position: "position"
  },
  standalone: false,
  ngContentSelectors: _c02,
  decls: 2,
  vars: 0,
  consts: [[1, "tabs-actions-wrapper"]],
  template: function ClrTabsActions_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 0);
      ɵɵprojection(1);
      ɵɵelementEnd();
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTabsActions, [{
    type: Component,
    args: [{
      selector: "clr-tabs-actions",
      template: `
    <div class="tabs-actions-wrapper">
      <ng-content></ng-content>
    </div>
  `,
      host: {
        "[class.tabs-actions]": "true"
      }
    }]
  }], null, {
    position: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.position"]
    }]
  });
})();
var CLR_TABS_DIRECTIVES = [ClrTabContent, ClrTab, ClrTabs, ClrTabOverflowContent, ClrTabLink, ClrTabAction, ClrTabsActions, TabsWillyWonka, ActiveOompaLoompa];
var ClrTabsModule = class {
  constructor() {
    r.addIcons(o3);
  }
};
ClrTabsModule.ɵfac = function ClrTabsModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrTabsModule)();
};
ClrTabsModule.ɵmod = ɵɵdefineNgModule({
  type: ClrTabsModule,
  declarations: [ClrTabContent, ClrTab, ClrTabs, ClrTabOverflowContent, ClrTabLink, ClrTabAction, ClrTabsActions, TabsWillyWonka, ActiveOompaLoompa],
  imports: [CommonModule, ClrConditionalModule, ClrIconModule, ClrTemplateRefModule, ClrKeyFocusModule],
  exports: [ClrTabContent, ClrTab, ClrTabs, ClrTabOverflowContent, ClrTabLink, ClrTabAction, ClrTabsActions, TabsWillyWonka, ActiveOompaLoompa, ClrConditionalModule]
});
ClrTabsModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrConditionalModule, ClrIconModule, ClrTemplateRefModule, ClrKeyFocusModule, ClrConditionalModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTabsModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ClrConditionalModule, ClrIconModule, ClrTemplateRefModule, ClrKeyFocusModule],
      declarations: [CLR_TABS_DIRECTIVES],
      exports: [CLR_TABS_DIRECTIVES, ClrConditionalModule]
    }]
  }], function() {
    return [];
  }, null);
})();
var VerticalNavGroupRegistrationService = class {
  constructor() {
    this.navGroupCount = 0;
  }
  registerNavGroup() {
    this.navGroupCount++;
  }
  unregisterNavGroup() {
    this.navGroupCount--;
  }
};
VerticalNavGroupRegistrationService.ɵfac = function VerticalNavGroupRegistrationService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || VerticalNavGroupRegistrationService)();
};
VerticalNavGroupRegistrationService.ɵprov = ɵɵdefineInjectable({
  token: VerticalNavGroupRegistrationService,
  factory: VerticalNavGroupRegistrationService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(VerticalNavGroupRegistrationService, [{
    type: Injectable
  }], null, null);
})();
var VerticalNavIconService = class {
  constructor() {
    this._icons = 0;
  }
  get hasIcons() {
    return this._icons > 0;
  }
  registerIcon() {
    this._icons++;
  }
  unregisterIcon() {
    this._icons--;
  }
};
VerticalNavIconService.ɵfac = function VerticalNavIconService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || VerticalNavIconService)();
};
VerticalNavIconService.ɵprov = ɵɵdefineInjectable({
  token: VerticalNavIconService,
  factory: VerticalNavIconService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(VerticalNavIconService, [{
    type: Injectable
  }], null, null);
})();
var VerticalNavService = class {
  constructor() {
    this._animateOnCollapsed = new Subject();
    this._collapsedChanged = new Subject();
    this._collapsed = false;
    this._collapsible = false;
  }
  get animateOnCollapsed() {
    return this._animateOnCollapsed.asObservable();
  }
  get collapsedChanged() {
    return this._collapsedChanged.asObservable();
  }
  get collapsed() {
    return this._collapsed;
  }
  set collapsed(value) {
    value = !!value;
    if (this.collapsible && this._collapsed !== value) {
      this.updateCollapseBehavior(value);
    }
  }
  get collapsible() {
    return this._collapsible;
  }
  set collapsible(value) {
    value = !!value;
    if (this._collapsible !== value) {
      if (!value && this.collapsed) {
        this.updateCollapseBehavior(false);
      }
      this._collapsible = value;
    }
  }
  updateCollapseBehavior(value) {
    this._animateOnCollapsed.next(value);
    this._collapsed = value;
    this._collapsedChanged.next(value);
  }
};
VerticalNavService.ɵfac = function VerticalNavService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || VerticalNavService)();
};
VerticalNavService.ɵprov = ɵɵdefineInjectable({
  token: VerticalNavService,
  factory: VerticalNavService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(VerticalNavService, [{
    type: Injectable
  }], null, null);
})();
var ClrVerticalNav = class {
  constructor(_navService, _navIconService, _navGroupRegistrationService, commonStrings) {
    this._navService = _navService;
    this._navIconService = _navIconService;
    this._navGroupRegistrationService = _navGroupRegistrationService;
    this.commonStrings = commonStrings;
    this._collapsedChanged = new EventEmitter(true);
    this._sub = _navService.collapsedChanged.subscribe((value) => {
      this._collapsedChanged.emit(value);
    });
  }
  get collapsible() {
    return this._navService.collapsible;
  }
  set collapsible(value) {
    this._navService.collapsible = value;
  }
  get collapsed() {
    return this._navService.collapsed;
  }
  set collapsed(value) {
    this._navService.collapsed = value;
  }
  get hasNavGroups() {
    return this._navGroupRegistrationService.navGroupCount > 0;
  }
  get hasIcons() {
    return this._navIconService.hasIcons;
  }
  get ariaExpanded() {
    if (!this.collapsible) {
      return null;
    }
    return !this.collapsed ? "true" : "false";
  }
  ngOnDestroy() {
    this._sub.unsubscribe();
  }
  toggleByButton() {
    this.collapsed = !this.collapsed;
  }
};
ClrVerticalNav.ɵfac = function ClrVerticalNav_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrVerticalNav)(ɵɵdirectiveInject(VerticalNavService), ɵɵdirectiveInject(VerticalNavIconService), ɵɵdirectiveInject(VerticalNavGroupRegistrationService), ɵɵdirectiveInject(ClrCommonStringsService));
};
ClrVerticalNav.ɵcmp = ɵɵdefineComponent({
  type: ClrVerticalNav,
  selectors: [["clr-vertical-nav"]],
  hostAttrs: [1, "clr-vertical-nav"],
  hostVars: 6,
  hostBindings: function ClrVerticalNav_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("is-collapsed", ctx.collapsed)("has-nav-groups", ctx.hasNavGroups)("has-icons", ctx.hasIcons);
    }
  },
  inputs: {
    collapsible: [0, "clrVerticalNavCollapsible", "collapsible"],
    collapsed: [0, "clrVerticalNavCollapsed", "collapsed"]
  },
  outputs: {
    _collapsedChanged: "clrVerticalNavCollapsedChange"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([VerticalNavService, VerticalNavIconService, VerticalNavGroupRegistrationService])],
  ngContentSelectors: _c02,
  decls: 4,
  vars: 2,
  consts: [["type", "button", "class", "nav-trigger", 3, "on-collapse", "click", 4, "ngIf"], [1, "nav-content"], ["type", "button", "class", "nav-btn", "aria-hidden", "true", "tabindex", "-1", 3, "click", 4, "ngIf"], ["type", "button", 1, "nav-trigger", 3, "click"], ["shape", "angle-double", 1, "nav-trigger-icon"], ["type", "button", "aria-hidden", "true", "tabindex", "-1", 1, "nav-btn", 3, "click"]],
  template: function ClrVerticalNav_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, ClrVerticalNav_button_0_Template, 2, 5, "button", 0);
      ɵɵelementStart(1, "div", 1);
      ɵɵprojection(2);
      ɵɵtemplate(3, ClrVerticalNav_button_3_Template, 1, 1, "button", 2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.collapsible);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.collapsible && ctx.collapsed);
    }
  },
  dependencies: [NgIf, CdsIconCustomTag],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrVerticalNav, [{
    type: Component,
    args: [{
      selector: "clr-vertical-nav",
      providers: [VerticalNavService, VerticalNavIconService, VerticalNavGroupRegistrationService],
      host: {
        class: "clr-vertical-nav",
        "[class.is-collapsed]": "collapsed",
        "[class.has-nav-groups]": "hasNavGroups",
        "[class.has-icons]": "hasIcons"
      },
      template: `<!--
  ~ Copyright (c) 2016-2024 Broadcom. All Rights Reserved.
  ~ The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.
  ~ This software is released under MIT license.
  ~ The full license information can be found in LICENSE in the root directory of this project.
  -->

<button
  type="button"
  class="nav-trigger"
  [class.on-collapse]="collapsed"
  [attr.aria-expanded]="ariaExpanded"
  [attr.aria-label]="commonStrings.keys.verticalNavToggle"
  (click)="toggleByButton()"
  *ngIf="collapsible"
>
  <cds-icon
    shape="angle-double"
    class="nav-trigger-icon"
    [attr.direction]="(this.collapsed) ? 'right' : 'left'"
  ></cds-icon>
</button>
<div class="nav-content">
  <ng-content></ng-content>
  <button
    type="button"
    (click)="collapsed = false"
    class="nav-btn"
    aria-hidden="true"
    tabindex="-1"
    [attr.aria-label]="commonStrings.keys.verticalNavToggle"
    *ngIf="collapsible && collapsed"
  ></button>
</div>
`
    }]
  }], function() {
    return [{
      type: VerticalNavService
    }, {
      type: VerticalNavIconService
    }, {
      type: VerticalNavGroupRegistrationService
    }, {
      type: ClrCommonStringsService
    }];
  }, {
    _collapsedChanged: [{
      type: Output,
      args: ["clrVerticalNavCollapsedChange"]
    }],
    collapsible: [{
      type: Input,
      args: ["clrVerticalNavCollapsible"]
    }],
    collapsed: [{
      type: Input,
      args: ["clrVerticalNavCollapsed"]
    }]
  });
})();
var VerticalNavGroupService = class {
  constructor() {
    this._expandChange = new Subject();
  }
  get expandChange() {
    return this._expandChange.asObservable();
  }
  expand() {
    this._expandChange.next(true);
  }
};
VerticalNavGroupService.ɵfac = function VerticalNavGroupService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || VerticalNavGroupService)();
};
VerticalNavGroupService.ɵprov = ɵɵdefineInjectable({
  token: VerticalNavGroupService,
  factory: VerticalNavGroupService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(VerticalNavGroupService, [{
    type: Injectable
  }], null, null);
})();
var EXPANDED_STATE = "expanded";
var COLLAPSED_STATE = "collapsed";
var ClrVerticalNavGroup = class {
  constructor(_itemExpand, _navGroupRegistrationService, navGroupService, _navService, commonStrings) {
    this._itemExpand = _itemExpand;
    this._navGroupRegistrationService = _navGroupRegistrationService;
    this._navService = _navService;
    this.commonStrings = commonStrings;
    this.expandedChange = new EventEmitter(true);
    this.wasExpanded = false;
    this._subscriptions = [];
    this._expandAnimationState = COLLAPSED_STATE;
    _navGroupRegistrationService.registerNavGroup();
    this._subscriptions.push(_itemExpand.expandChange.subscribe((value) => {
      if (value && this.expandAnimationState === COLLAPSED_STATE) {
        if (_navService.collapsed) {
          _navService.collapsed = false;
        }
        this.expandAnimationState = EXPANDED_STATE;
      } else if (!value && this.expandAnimationState === EXPANDED_STATE) {
        this.expandAnimationState = COLLAPSED_STATE;
      }
    }));
    this._subscriptions.push(_navService.animateOnCollapsed.subscribe((goingToCollapse) => {
      if (goingToCollapse && this.expanded) {
        this.wasExpanded = true;
        this.expandAnimationState = COLLAPSED_STATE;
      } else if (!goingToCollapse && this.wasExpanded) {
        this.expandGroup();
        this.wasExpanded = false;
      }
    }));
    this._subscriptions.push(navGroupService.expandChange.subscribe((expand) => {
      if (expand && !this.expanded) {
        this.expandGroup();
      }
    }));
  }
  get expanded() {
    return this._itemExpand.expanded;
  }
  set expanded(value) {
    if (this._itemExpand.expanded !== value) {
      this._itemExpand.expanded = value;
      this.expandedChange.emit(value);
    }
  }
  set userExpandedInput(value) {
    value = !!value;
    if (this.expanded !== value) {
      this.toggleExpand();
    }
  }
  get expandAnimationState() {
    return this._expandAnimationState;
  }
  set expandAnimationState(value) {
    if (value !== this._expandAnimationState) {
      this._expandAnimationState = value;
    }
  }
  ngAfterContentInit() {
    if (this._navService.collapsed && this.expanded) {
      this.wasExpanded = true;
      this.expandAnimationState = COLLAPSED_STATE;
    }
  }
  ngOnDestroy() {
    this._subscriptions.forEach((sub) => sub.unsubscribe());
    this._navGroupRegistrationService.unregisterNavGroup();
  }
  expandGroup() {
    this.expanded = true;
    this.expandAnimationState = EXPANDED_STATE;
  }
  collapseGroup() {
    this.expandAnimationState = COLLAPSED_STATE;
  }
  // closes a group after the collapse animation
  expandAnimationDone($event) {
    if ($event.toState === COLLAPSED_STATE) {
      this.expanded = false;
    }
  }
  toggleExpand() {
    if (this.expanded) {
      this.collapseGroup();
    } else {
      if (this._navService.collapsed) {
        this._navService.collapsed = false;
      }
      this.expandGroup();
    }
  }
};
ClrVerticalNavGroup.ɵfac = function ClrVerticalNavGroup_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrVerticalNavGroup)(ɵɵdirectiveInject(IfExpandService), ɵɵdirectiveInject(VerticalNavGroupRegistrationService), ɵɵdirectiveInject(VerticalNavGroupService), ɵɵdirectiveInject(VerticalNavService), ɵɵdirectiveInject(ClrCommonStringsService));
};
ClrVerticalNavGroup.ɵcmp = ɵɵdefineComponent({
  type: ClrVerticalNavGroup,
  selectors: [["clr-vertical-nav-group"]],
  hostAttrs: [1, "nav-group"],
  hostVars: 2,
  hostBindings: function ClrVerticalNavGroup_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("is-expanded", ctx.expanded);
    }
  },
  inputs: {
    userExpandedInput: [0, "clrVerticalNavGroupExpanded", "userExpandedInput"]
  },
  outputs: {
    expandedChange: "clrVerticalNavGroupExpandedChange"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([IfExpandService, VerticalNavGroupService])],
  ngContentSelectors: _c103,
  decls: 9,
  vars: 3,
  consts: [[1, "nav-group-content"], ["type", "button", 1, "nav-group-trigger", 3, "click"], [1, "nav-group-text"], ["shape", "angle", 1, "nav-group-trigger-icon"], [1, "nav-group-children"]],
  template: function ClrVerticalNavGroup_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c102);
      ɵɵelementStart(0, "div", 0);
      ɵɵprojection(1);
      ɵɵelementStart(2, "button", 1);
      ɵɵlistener("click", function ClrVerticalNavGroup_Template_button_click_2_listener() {
        return ctx.toggleExpand();
      });
      ɵɵprojection(3, 1);
      ɵɵelementStart(4, "div", 2);
      ɵɵprojection(5, 2);
      ɵɵelementEnd();
      ɵɵelement(6, "cds-icon", 3);
      ɵɵelementEnd()();
      ɵɵelementStart(7, "div", 4);
      ɵɵlistener("@clrExpand.done", function ClrVerticalNavGroup_Template_div_animation_clrExpand_done_7_listener($event) {
        return ctx.expandAnimationDone($event);
      });
      ɵɵprojection(8, 3);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵattribute("aria-expanded", ctx.expanded);
      ɵɵadvance(4);
      ɵɵattribute("direction", ctx.expanded ? "down" : "right");
      ɵɵadvance();
      ɵɵproperty("@clrExpand", ctx.expandAnimationState);
    }
  },
  dependencies: [CdsIconCustomTag],
  encapsulation: 2,
  data: {
    animation: [trigger("clrExpand", [state(EXPANDED_STATE, style({
      height: "*"
    })), state(COLLAPSED_STATE, style({
      height: 0,
      visibility: "hidden"
    })), transition(`${EXPANDED_STATE} <=> ${COLLAPSED_STATE}`, animate("0.2s ease-in-out"))])]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrVerticalNavGroup, [{
    type: Component,
    args: [{
      selector: "clr-vertical-nav-group",
      providers: [IfExpandService, VerticalNavGroupService],
      animations: [trigger("clrExpand", [state(EXPANDED_STATE, style({
        height: "*"
      })), state(COLLAPSED_STATE, style({
        height: 0,
        visibility: "hidden"
      })), transition(`${EXPANDED_STATE} <=> ${COLLAPSED_STATE}`, animate("0.2s ease-in-out"))])],
      host: {
        class: "nav-group"
      },
      template: `<!--
  ~ Copyright (c) 2016-2024 Broadcom. All Rights Reserved.
  ~ The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.
  ~ This software is released under MIT license.
  ~ The full license information can be found in LICENSE in the root directory of this project.
  -->

<div class="nav-group-content">
  <ng-content select="[clrVerticalNavLink]"></ng-content>
  <button class="nav-group-trigger" type="button" [attr.aria-expanded]="expanded" (click)="toggleExpand()">
    <ng-content select="[clrVerticalNavIcon]"></ng-content>
    <div class="nav-group-text">
      <ng-content></ng-content>
    </div>
    <cds-icon shape="angle" class="nav-group-trigger-icon" [attr.direction]="expanded ? 'down' : 'right'"></cds-icon>
  </button>
</div>
<!--TODO: This animation needs to be added to the clr-vertical-nav-group-children component-->
<div class="nav-group-children" [@clrExpand]="expandAnimationState" (@clrExpand.done)="expandAnimationDone($event)">
  <ng-content select="[clrIfExpanded], clr-vertical-nav-group-children"></ng-content>
</div>
`
    }]
  }], function() {
    return [{
      type: IfExpandService
    }, {
      type: VerticalNavGroupRegistrationService
    }, {
      type: VerticalNavGroupService
    }, {
      type: VerticalNavService
    }, {
      type: ClrCommonStringsService
    }];
  }, {
    expandedChange: [{
      type: Output,
      args: ["clrVerticalNavGroupExpandedChange"]
    }],
    expanded: [{
      type: HostBinding,
      args: ["class.is-expanded"]
    }],
    userExpandedInput: [{
      type: Input,
      args: ["clrVerticalNavGroupExpanded"]
    }]
  });
})();
var ClrVerticalNavGroupChildren = class {
};
ClrVerticalNavGroupChildren.ɵfac = function ClrVerticalNavGroupChildren_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrVerticalNavGroupChildren)();
};
ClrVerticalNavGroupChildren.ɵcmp = ɵɵdefineComponent({
  type: ClrVerticalNavGroupChildren,
  selectors: [["clr-vertical-nav-group-children"]],
  standalone: false,
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrVerticalNavGroupChildren_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrVerticalNavGroupChildren, [{
    type: Component,
    args: [{
      selector: "clr-vertical-nav-group-children",
      template: `<ng-content></ng-content>`
    }]
  }], null, null);
})();
var ClrVerticalNavIcon = class {
  constructor(_verticalNavIconService) {
    this._verticalNavIconService = _verticalNavIconService;
    _verticalNavIconService.registerIcon();
  }
  ngOnDestroy() {
    this._verticalNavIconService.unregisterIcon();
  }
};
ClrVerticalNavIcon.ɵfac = function ClrVerticalNavIcon_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrVerticalNavIcon)(ɵɵdirectiveInject(VerticalNavIconService));
};
ClrVerticalNavIcon.ɵdir = ɵɵdefineDirective({
  type: ClrVerticalNavIcon,
  selectors: [["", "clrVerticalNavIcon", ""]],
  hostAttrs: [1, "nav-icon"],
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrVerticalNavIcon, [{
    type: Directive,
    args: [{
      selector: "[clrVerticalNavIcon]",
      host: {
        class: "nav-icon"
      }
    }]
  }], function() {
    return [{
      type: VerticalNavIconService
    }];
  }, null);
})();
var ClrVerticalNavLink = class {
  constructor(host, ref, navGroupService) {
    this.destroy$ = new Subject();
    navGroupService && fromEvent(host.nativeElement, "click").pipe(takeUntil(this.destroy$)).subscribe(() => {
      navGroupService.expand();
      ref.markForCheck();
    });
  }
  ngOnDestroy() {
    this.destroy$.next();
  }
};
ClrVerticalNavLink.ɵfac = function ClrVerticalNavLink_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrVerticalNavLink)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(VerticalNavGroupService, 8));
};
ClrVerticalNavLink.ɵcmp = ɵɵdefineComponent({
  type: ClrVerticalNavLink,
  selectors: [["", "clrVerticalNavLink", ""]],
  hostAttrs: [1, "nav-link"],
  standalone: false,
  attrs: _c104,
  ngContentSelectors: _c106,
  decls: 3,
  vars: 0,
  consts: [[1, "nav-text"]],
  template: function ClrVerticalNavLink_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c105);
      ɵɵprojection(0);
      ɵɵelementStart(1, "span", 0);
      ɵɵprojection(2, 1);
      ɵɵelementEnd();
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrVerticalNavLink, [{
    type: Component,
    args: [{
      selector: "[clrVerticalNavLink]",
      template: `
    <ng-content select="[clrVerticalNavIcon]"></ng-content>
    <span class="nav-text">
      <ng-content></ng-content>
    </span>
  `,
      host: {
        class: "nav-link"
      }
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ChangeDetectorRef
    }, {
      type: VerticalNavGroupService,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [VerticalNavGroupService]
      }]
    }];
  }, null);
})();
var CLR_VERTICAL_NAV_DIRECTIVES = [ClrVerticalNav, ClrVerticalNavLink, ClrVerticalNavGroup, ClrVerticalNavGroupChildren, ClrVerticalNavIcon];
var ClrVerticalNavModule = class {
  constructor() {
    r.addIcons(o, o2);
  }
};
ClrVerticalNavModule.ɵfac = function ClrVerticalNavModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrVerticalNavModule)();
};
ClrVerticalNavModule.ɵmod = ɵɵdefineNgModule({
  type: ClrVerticalNavModule,
  declarations: [ClrVerticalNav, ClrVerticalNavLink, ClrVerticalNavGroup, ClrVerticalNavGroupChildren, ClrVerticalNavIcon],
  imports: [CommonModule, ClrIconModule, ClrConditionalModule, ClrFocusOnViewInitModule],
  exports: [ClrVerticalNav, ClrVerticalNavLink, ClrVerticalNavGroup, ClrVerticalNavGroupChildren, ClrVerticalNavIcon, ClrConditionalModule, ClrIconModule, ClrFocusOnViewInitModule]
});
ClrVerticalNavModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrIconModule, ClrConditionalModule, ClrFocusOnViewInitModule, ClrConditionalModule, ClrIconModule, ClrFocusOnViewInitModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrVerticalNavModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ClrIconModule, ClrConditionalModule, ClrFocusOnViewInitModule],
      declarations: [CLR_VERTICAL_NAV_DIRECTIVES],
      exports: [CLR_VERTICAL_NAV_DIRECTIVES, ClrConditionalModule, ClrIconModule, ClrFocusOnViewInitModule]
    }]
  }], function() {
    return [];
  }, null);
})();
var ClrLayoutModule = class {
};
ClrLayoutModule.ɵfac = function ClrLayoutModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrLayoutModule)();
};
ClrLayoutModule.ɵmod = ɵɵdefineNgModule({
  type: ClrLayoutModule,
  exports: [ClrMainContainerModule, ClrNavigationModule, ClrTabsModule, ClrVerticalNavModule, ClrBreadcrumbsModule]
});
ClrLayoutModule.ɵinj = ɵɵdefineInjector({
  imports: [ClrMainContainerModule, ClrNavigationModule, ClrTabsModule, ClrVerticalNavModule, ClrBreadcrumbsModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrLayoutModule, [{
    type: NgModule,
    args: [{
      exports: [ClrMainContainerModule, ClrNavigationModule, ClrTabsModule, ClrVerticalNavModule, ClrBreadcrumbsModule]
    }]
  }], null, null);
})();
var ScrollingService = class {
  constructor(_document) {
    this._document = _document;
  }
  stopScrolling() {
    this._document.body.classList.add("no-scrolling");
  }
  resumeScrolling() {
    if (this._document.body.classList.contains("no-scrolling")) {
      this._document.body.classList.remove("no-scrolling");
    }
  }
};
ScrollingService.ɵfac = function ScrollingService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ScrollingService)(ɵɵinject(DOCUMENT));
};
ScrollingService.ɵprov = ɵɵdefineInjectable({
  token: ScrollingService,
  factory: ScrollingService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollingService, [{
    type: Injectable
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [DOCUMENT]
      }]
    }];
  }, null);
})();
var ClrModalConfigurationService = class {
  constructor() {
    this.fadeMove = "fadeDown";
    this.backdrop = true;
  }
};
ClrModalConfigurationService.ɵfac = function ClrModalConfigurationService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrModalConfigurationService)();
};
ClrModalConfigurationService.ɵprov = ɵɵdefineInjectable({
  token: ClrModalConfigurationService,
  factory: ClrModalConfigurationService.ɵfac,
  providedIn: "root"
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrModalConfigurationService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var ClrModal = class {
  constructor(_scrollingService, commonStrings, modalStackService, configuration) {
    this._scrollingService = _scrollingService;
    this.commonStrings = commonStrings;
    this.modalStackService = modalStackService;
    this.configuration = configuration;
    this.modalId = uniqueIdFactory();
    this._open = false;
    this._openChanged = new EventEmitter(false);
    this.closable = true;
    this.closeButtonAriaLabel = this.commonStrings.keys.close;
    this.staticBackdrop = true;
    this.skipAnimation = "false";
    this.stopClose = false;
    this.altClose = new EventEmitter(false);
    this.bypassScrollService = false;
  }
  get fadeMove() {
    return this.skipAnimation ? "" : this.configuration.fadeMove;
  }
  set fadeMove(move) {
    this.configuration.fadeMove = move;
  }
  get backdrop() {
    return this.configuration.backdrop;
  }
  // Detect when _open is set to true and set no-scrolling to true
  ngOnChanges(changes) {
    if (!this.bypassScrollService && changes && Object.prototype.hasOwnProperty.call(changes, "_open")) {
      if (changes._open.currentValue) {
        this.backdrop && this._scrollingService.stopScrolling();
        this.modalStackService.trackModalOpen(this);
      } else {
        this._scrollingService.resumeScrolling();
      }
    }
  }
  ngOnDestroy() {
    this._scrollingService.resumeScrolling();
  }
  open() {
    if (this._open) {
      return;
    }
    this._open = true;
    this._openChanged.emit(true);
    this.modalStackService.trackModalOpen(this);
  }
  backdropClick() {
    if (this.staticBackdrop) {
      this.title.nativeElement.focus();
      return;
    }
    this.close();
  }
  close() {
    if (this.stopClose) {
      this.altClose.emit(false);
      return;
    }
    if (!this.closable || !this._open) {
      return;
    }
    this._open = false;
  }
  fadeDone(e5) {
    if (e5.toState === "void") {
      this._openChanged.emit(false);
      this.modalStackService.trackModalClose(this);
    }
  }
};
ClrModal.ɵfac = function ClrModal_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrModal)(ɵɵdirectiveInject(ScrollingService), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(ModalStackService), ɵɵdirectiveInject(ClrModalConfigurationService));
};
ClrModal.ɵcmp = ɵɵdefineComponent({
  type: ClrModal,
  selectors: [["clr-modal"]],
  viewQuery: function ClrModal_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c81, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.title = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function ClrModal_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("open", ctx._open);
    }
  },
  inputs: {
    _open: [0, "clrModalOpen", "_open"],
    closable: [0, "clrModalClosable", "closable"],
    closeButtonAriaLabel: [0, "clrModalCloseButtonAriaLabel", "closeButtonAriaLabel"],
    size: [0, "clrModalSize", "size"],
    staticBackdrop: [0, "clrModalStaticBackdrop", "staticBackdrop"],
    skipAnimation: [0, "clrModalSkipAnimation", "skipAnimation"],
    stopClose: [0, "clrModalPreventClose", "stopClose"],
    labelledBy: [0, "clrModalLabelledById", "labelledBy"],
    bypassScrollService: [0, "clrModalOverrideScrollService", "bypassScrollService"]
  },
  outputs: {
    _openChanged: "clrModalOpenChange",
    altClose: "clrModalAlternateClose"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([], [ScrollingService]), ɵɵNgOnChangesFeature],
  ngContentSelectors: _c108,
  decls: 1,
  vars: 1,
  consts: [["title", ""], ["class", "modal", 3, "modal-full-screen", 4, "ngIf"], [1, "modal"], ["cdkTrapFocus", "", "role", "dialog", "aria-modal", "true", 1, "modal-dialog", 3, "cdkTrapFocusAutoCapture"], [1, "clr-sr-only"], [1, "modal-content-wrapper"], [1, "modal-content"], [1, "modal-header--accessible"], ["cdkFocusInitial", "", "tabindex", "-1", 1, "modal-title-wrapper", 3, "id"], ["type", "button", "class", "close", 3, "click", 4, "ngIf"], [1, "modal-body-wrapper"], ["class", "modal-backdrop", "aria-hidden", "true", 3, "click", 4, "ngIf"], ["type", "button", 1, "close", 3, "click"], ["shape", "window-close"], ["aria-hidden", "true", 1, "modal-backdrop", 3, "click"]],
  template: function ClrModal_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c107);
      ɵɵtemplate(0, ClrModal_div_0_Template, 18, 17, "div", 1);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx._open);
    }
  },
  dependencies: [NgIf, CdkTrapFocusModule_CdkTrapFocus, CdsIconCustomTag],
  styles: ["[_nghost-%COMP%]{display:none}.open[_nghost-%COMP%]{display:inline}"],
  data: {
    animation: [trigger("fadeMove", [transition("* => fadeDown", [style({
      opacity: 0,
      transform: "translate(0, -25%)"
    }), animate("0.2s ease-in-out")]), transition("fadeDown => *", [animate("0.2s ease-in-out", style({
      opacity: 0,
      transform: "translate(0, -25%)"
    }))]), transition("* => fadeLeft", [style({
      opacity: 0,
      transform: "translate(25%, 0)"
    }), animate("0.2s ease-in-out")]), transition("fadeLeft => *", [animate("0.2s ease-in-out", style({
      opacity: 0,
      transform: "translate(25%, 0)"
    }))])]), trigger("fade", [transition("void => *", [style({
      opacity: 0
    }), animate("0.2s ease-in-out", style({
      opacity: 0.85
    }))]), transition("* => void", [animate("0.2s ease-in-out", style({
      opacity: 0
    }))])])]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrModal, [{
    type: Component,
    args: [{
      selector: "clr-modal",
      viewProviders: [ScrollingService],
      animations: [trigger("fadeMove", [transition("* => fadeDown", [style({
        opacity: 0,
        transform: "translate(0, -25%)"
      }), animate("0.2s ease-in-out")]), transition("fadeDown => *", [animate("0.2s ease-in-out", style({
        opacity: 0,
        transform: "translate(0, -25%)"
      }))]), transition("* => fadeLeft", [style({
        opacity: 0,
        transform: "translate(25%, 0)"
      }), animate("0.2s ease-in-out")]), transition("fadeLeft => *", [animate("0.2s ease-in-out", style({
        opacity: 0,
        transform: "translate(25%, 0)"
      }))])]), trigger("fade", [transition("void => *", [style({
        opacity: 0
      }), animate("0.2s ease-in-out", style({
        opacity: 0.85
      }))]), transition("* => void", [animate("0.2s ease-in-out", style({
        opacity: 0
      }))])])],
      template: `<!--
  ~ Copyright (c) 2016-2024 Broadcom. All Rights Reserved.
  ~ The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.
  ~ This software is released under MIT license.
  ~ The full license information can be found in LICENSE in the root directory of this project.
  -->

<div *ngIf="_open" class="modal" [class.modal-full-screen]="size == 'full-screen'">
  <!--fixme: revisit when ngClass works with exit animation-->
  <div
    cdkTrapFocus
    [cdkTrapFocusAutoCapture]="true"
    [@fadeMove]="fadeMove"
    (@fadeMove.done)="fadeDone($event)"
    class="modal-dialog"
    [class.modal-sm]="size == 'sm'"
    [class.modal-lg]="size == 'lg'"
    [class.modal-xl]="size == 'xl'"
    role="dialog"
    aria-modal="true"
    [attr.aria-hidden]="!_open"
    [attr.aria-labelledby]="labelledBy || modalId"
  >
    <div class="clr-sr-only">{{commonStrings.keys.modalContentStart}}</div>
    <div class="modal-content-wrapper">
      <!-- only used in wizards -->
      <ng-content select=".modal-nav"></ng-content>

      <div class="modal-content">
        <div class="modal-header--accessible">
          <div class="modal-title-wrapper" #title id="{{modalId}}" cdkFocusInitial tabindex="-1">
            <ng-content select=".modal-title"></ng-content>
          </div>
          <button
            type="button"
            [attr.aria-label]="closeButtonAriaLabel || commonStrings.keys.close"
            class="close"
            *ngIf="closable"
            (click)="close()"
          >
            <cds-icon shape="window-close"></cds-icon>
          </button>
        </div>
        <div class="modal-body-wrapper">
          <ng-content select=".modal-body"></ng-content>
        </div>
        <ng-content select=".modal-footer"></ng-content>
      </div>
    </div>
    <div class="clr-sr-only">{{commonStrings.keys.modalContentEnd}}</div>
  </div>

  <div [@fade] *ngIf="backdrop" class="modal-backdrop" aria-hidden="true" (click)="backdropClick()"></div>
</div>
`,
      styles: [":host{display:none}:host.open{display:inline}\n"]
    }]
  }], function() {
    return [{
      type: ScrollingService
    }, {
      type: ClrCommonStringsService
    }, {
      type: ModalStackService
    }, {
      type: ClrModalConfigurationService
    }];
  }, {
    title: [{
      type: ViewChild,
      args: ["title"]
    }],
    _open: [{
      type: Input,
      args: ["clrModalOpen"]
    }, {
      type: HostBinding,
      args: ["class.open"]
    }],
    _openChanged: [{
      type: Output,
      args: ["clrModalOpenChange"]
    }],
    closable: [{
      type: Input,
      args: ["clrModalClosable"]
    }],
    closeButtonAriaLabel: [{
      type: Input,
      args: ["clrModalCloseButtonAriaLabel"]
    }],
    size: [{
      type: Input,
      args: ["clrModalSize"]
    }],
    staticBackdrop: [{
      type: Input,
      args: ["clrModalStaticBackdrop"]
    }],
    skipAnimation: [{
      type: Input,
      args: ["clrModalSkipAnimation"]
    }],
    stopClose: [{
      type: Input,
      args: ["clrModalPreventClose"]
    }],
    altClose: [{
      type: Output,
      args: ["clrModalAlternateClose"]
    }],
    labelledBy: [{
      type: Input,
      args: ["clrModalLabelledById"]
    }],
    bypassScrollService: [{
      type: Input,
      args: ["clrModalOverrideScrollService"]
    }]
  });
})();
var ClrModalBody = class {
  constructor(renderer, host, ngZone) {
    this.renderer = renderer;
    this.host = host;
    this.tabindex = "0";
    this.unlisteners = [];
    ngZone.runOutsideAngular(() => {
      this.observer = new ResizeObserver(() => this.addOrRemoveTabIndex());
      this.observer.observe(host.nativeElement);
      this.unlisteners.push(renderer.listen(host.nativeElement, "mouseup", () => {
        this.addOrRemoveTabIndex();
      }), renderer.listen(host.nativeElement, "mousedown", () => {
        this.removeTabIndex();
      }));
    });
  }
  ngOnDestroy() {
    while (this.unlisteners.length) {
      this.unlisteners.pop()();
    }
    this.observer.disconnect();
    this.observer = null;
  }
  addTabIndex() {
    this.renderer.setAttribute(this.host.nativeElement, "tabindex", this.tabindex);
  }
  removeTabIndex() {
    this.renderer.removeAttribute(this.host.nativeElement, "tabindex");
  }
  addOrRemoveTabIndex() {
    const modalBody = this.host.nativeElement.parentElement;
    if (modalBody && modalBody.clientHeight < modalBody.scrollHeight) {
      this.addTabIndex();
    } else {
      this.removeTabIndex();
    }
  }
};
ClrModalBody.ɵfac = function ClrModalBody_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrModalBody)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
ClrModalBody.ɵdir = ɵɵdefineDirective({
  type: ClrModalBody,
  selectors: [["", 8, "modal-body"]],
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrModalBody, [{
    type: Directive,
    args: [{
      selector: ".modal-body"
    }]
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var CLR_MODAL_DIRECTIVES = [ClrModal, ClrModalBody];
var ClrModalModule = class {
  constructor() {
    r.addIcons(L3);
  }
};
ClrModalModule.ɵfac = function ClrModalModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrModalModule)();
};
ClrModalModule.ɵmod = ɵɵdefineNgModule({
  type: ClrModalModule,
  declarations: [ClrModal, ClrModalBody],
  imports: [CommonModule, CdkTrapFocusModule, ClrIconModule],
  exports: [ClrModal, ClrModalBody, ClrIconModule]
});
ClrModalModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, CdkTrapFocusModule, ClrIconModule, ClrIconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrModalModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, CdkTrapFocusModule, ClrIconModule],
      declarations: [CLR_MODAL_DIRECTIVES],
      exports: [CLR_MODAL_DIRECTIVES, ClrIconModule]
    }]
  }], function() {
    return [];
  }, null);
})();
var ClrSidePanel = class {
  constructor(element, configuration) {
    this.element = element;
    this.configuration = configuration;
    this._open = false;
    this.openChange = new EventEmitter(false);
    this.skipAnimation = "false";
    this.staticBackdrop = false;
    this.preventClose = false;
    this.altClose = new EventEmitter(false);
  }
  get clrSidePanelBackdrop() {
    return this.configuration.backdrop;
  }
  set clrSidePanelBackdrop(backdrop) {
    if (backdrop !== void 0) {
      this.configuration.backdrop = backdrop;
    }
  }
  ngOnInit() {
    this.configuration.fadeMove = "fadeLeft";
  }
  open() {
    this.modal.open();
  }
  close() {
    this.modal.close();
  }
  documentClick(event) {
    if (!this.element.nativeElement.contains(event.target) && this.modal._open && !this.configuration.backdrop) {
      this.modal.close();
    }
  }
};
ClrSidePanel.ɵfac = function ClrSidePanel_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrSidePanel)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ClrModalConfigurationService));
};
ClrSidePanel.ɵcmp = ɵɵdefineComponent({
  type: ClrSidePanel,
  selectors: [["clr-side-panel"]],
  viewQuery: function ClrSidePanel_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(ClrModal, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.modal = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function ClrSidePanel_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("pointerup", function ClrSidePanel_pointerup_HostBindingHandler($event) {
        return ctx.documentClick($event);
      }, false, ɵɵresolveDocument);
    }
    if (rf & 2) {
      ɵɵclassProp("side-panel", true);
    }
  },
  inputs: {
    _open: [0, "clrSidePanelOpen", "_open"],
    closeButtonAriaLabel: [0, "clrSidePanelCloseButtonAriaLabel", "closeButtonAriaLabel"],
    size: [0, "clrSidePanelSize", "size"],
    skipAnimation: [0, "clrSidePanelSkipAnimation", "skipAnimation"],
    labelledById: [0, "clrSidePanelLabelledById", "labelledById"],
    staticBackdrop: [0, "clrSidePanelStaticBackdrop", "staticBackdrop"],
    preventClose: [0, "clrSidePanelPreventClose", "preventClose"],
    clrSidePanelBackdrop: "clrSidePanelBackdrop"
  },
  outputs: {
    openChange: "clrSidePanelOpenChange",
    altClose: "clrSidePanelAlternateClose"
  },
  standalone: false,
  ngContentSelectors: _c110,
  decls: 7,
  vars: 7,
  consts: [[3, "clrModalOpenChange", "clrModalAlternateClose", "clrModalOpen", "clrModalCloseButtonAriaLabel", "clrModalSize", "clrModalSkipAnimation", "clrModalStaticBackdrop", "clrModalLabelledById", "clrModalPreventClose"], [1, "modal-title"], [1, "modal-body"], [1, "modal-footer"]],
  template: function ClrSidePanel_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c109);
      ɵɵelementStart(0, "clr-modal", 0);
      ɵɵlistener("clrModalOpenChange", function ClrSidePanel_Template_clr_modal_clrModalOpenChange_0_listener($event) {
        return ctx.openChange.emit($event);
      })("clrModalAlternateClose", function ClrSidePanel_Template_clr_modal_clrModalAlternateClose_0_listener($event) {
        return ctx.altClose.emit($event);
      });
      ɵɵelementStart(1, "div", 1);
      ɵɵprojection(2);
      ɵɵelementEnd();
      ɵɵelementStart(3, "div", 2);
      ɵɵprojection(4, 1);
      ɵɵelementEnd();
      ɵɵelementStart(5, "div", 3);
      ɵɵprojection(6, 2);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵproperty("clrModalOpen", ctx._open)("clrModalCloseButtonAriaLabel", ctx.closeButtonAriaLabel)("clrModalSize", ctx.size)("clrModalSkipAnimation", ctx.skipAnimation)("clrModalStaticBackdrop", ctx.staticBackdrop)("clrModalLabelledById", ctx.labelledById)("clrModalPreventClose", ctx.preventClose);
    }
  },
  dependencies: [ClrModal, ClrModalBody],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrSidePanel, [{
    type: Component,
    args: [{
      selector: "clr-side-panel",
      host: {
        "[class.side-panel]": "true"
      },
      template: '<clr-modal\n  [clrModalOpen]="_open"\n  (clrModalOpenChange)="openChange.emit($event)"\n  [clrModalCloseButtonAriaLabel]="closeButtonAriaLabel"\n  [clrModalSize]="size"\n  [clrModalSkipAnimation]="skipAnimation"\n  [clrModalStaticBackdrop]="staticBackdrop"\n  [clrModalLabelledById]="labelledById"\n  [clrModalPreventClose]="preventClose"\n  (clrModalAlternateClose)="altClose.emit($event)"\n>\n  <div class="modal-title"><ng-content select=".side-panel-title"></ng-content></div>\n  <div class="modal-body"><ng-content select=".side-panel-body"></ng-content></div>\n  <div class="modal-footer"><ng-content select=".side-panel-footer"></ng-content></div>\n</clr-modal>\n'
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ClrModalConfigurationService
    }];
  }, {
    _open: [{
      type: Input,
      args: ["clrSidePanelOpen"]
    }],
    openChange: [{
      type: Output,
      args: ["clrSidePanelOpenChange"]
    }],
    closeButtonAriaLabel: [{
      type: Input,
      args: ["clrSidePanelCloseButtonAriaLabel"]
    }],
    size: [{
      type: Input,
      args: ["clrSidePanelSize"]
    }],
    skipAnimation: [{
      type: Input,
      args: ["clrSidePanelSkipAnimation"]
    }],
    labelledById: [{
      type: Input,
      args: ["clrSidePanelLabelledById"]
    }],
    staticBackdrop: [{
      type: Input,
      args: ["clrSidePanelStaticBackdrop"]
    }],
    preventClose: [{
      type: Input,
      args: ["clrSidePanelPreventClose"]
    }],
    altClose: [{
      type: Output,
      args: ["clrSidePanelAlternateClose"]
    }],
    modal: [{
      type: ViewChild,
      args: [ClrModal]
    }],
    clrSidePanelBackdrop: [{
      type: Input
    }],
    documentClick: [{
      type: HostListener,
      args: ["document:pointerup", ["$event"]]
    }]
  });
})();
var CLR_SIDEPANEL_DIRECTIVES = [ClrSidePanel];
var ClrSidePanelModule = class {
};
ClrSidePanelModule.ɵfac = function ClrSidePanelModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrSidePanelModule)();
};
ClrSidePanelModule.ɵmod = ɵɵdefineNgModule({
  type: ClrSidePanelModule,
  declarations: [ClrSidePanel],
  imports: [CommonModule, CdkTrapFocusModule, ClrIconModule, ClrModalModule],
  exports: [ClrSidePanel, ClrIconModule]
});
ClrSidePanelModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, CdkTrapFocusModule, ClrIconModule, ClrModalModule, ClrIconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrSidePanelModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, CdkTrapFocusModule, ClrIconModule, ClrModalModule],
      declarations: [CLR_SIDEPANEL_DIRECTIVES],
      exports: [CLR_SIDEPANEL_DIRECTIVES, ClrIconModule]
    }]
  }], null, null);
})();
var ClrProgressBar = class {
  constructor() {
    this.max = 100;
    this.value = 0;
    this.externalId = "";
  }
  get id() {
    return this._ID;
  }
  set id(value) {
    this._ID = value;
    this.externalId = null;
  }
  get progressClass() {
    return true;
  }
  set clrCompact(value) {
    this._compact = isBooleanAttributeSet(value);
  }
  get compactClass() {
    return this._compact;
  }
  set clrLabeled(value) {
    this._labeled = isBooleanAttributeSet(value);
  }
  get labeledClass() {
    return this._labeled;
  }
  set clrFade(value) {
    this._fade = isBooleanAttributeSet(value);
  }
  get fadeClass() {
    return this._fade;
  }
  set clrLoop(value) {
    this._loop = isBooleanAttributeSet(value);
  }
  get loopClass() {
    return this._loop;
  }
  get warningClass() {
    return this.color === "warning";
  }
  get successClass() {
    return this.color === "success";
  }
  get dangerClass() {
    return this.color === "danger";
  }
  set clrFlash(value) {
    this._flash = isBooleanAttributeSet(value);
  }
  get flashClass() {
    return this._flash;
  }
  /** @deprecated since 2.0, remove in 4.0 */
  set clrFlashDanger(value) {
    this._flashDanger = isBooleanAttributeSet(value);
  }
  get flashDangerClass() {
    return this._flashDanger;
  }
  /**
   * Make sure that we always will have something that is readable
   * for the screen reader
   */
  get displayValue() {
    if (this.displayval) {
      return this.displayval;
    }
    return `${this.value || 0}%`;
  }
  /**
   * Display optional text only when labeled is eneabled
   */
  displayStringValue() {
    return this._labeled;
  }
};
ClrProgressBar.ɵfac = function ClrProgressBar_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrProgressBar)();
};
ClrProgressBar.ɵcmp = ɵɵdefineComponent({
  type: ClrProgressBar,
  selectors: [["clr-progress-bar"]],
  hostVars: 21,
  hostBindings: function ClrProgressBar_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("id", ctx.externalId);
      ɵɵclassProp("progress", ctx.progressClass)("compact", ctx.compactClass)("labeled", ctx.labeledClass)("progress-fade", ctx.fadeClass)("loop", ctx.loopClass)("warning", ctx.warningClass)("success", ctx.successClass)("danger", ctx.dangerClass)("flash", ctx.flashClass)("flash-danger", ctx.flashDangerClass);
    }
  },
  inputs: {
    max: [0, "clrMax", "max"],
    displayval: [0, "clrDisplayval", "displayval"],
    color: [0, "clrColor", "color"],
    value: [0, "clrValue", "value"],
    id: "id",
    clrCompact: "clrCompact",
    clrLabeled: "clrLabeled",
    clrFade: "clrFade",
    clrLoop: "clrLoop",
    clrFlash: "clrFlash",
    clrFlashDanger: "clrFlashDanger"
  },
  standalone: false,
  decls: 2,
  vars: 5,
  consts: [[3, "id"], [4, "ngIf"]],
  template: function ClrProgressBar_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelement(0, "progress", 0);
      ɵɵtemplate(1, ClrProgressBar_span_1_Template, 2, 1, "span", 1);
    }
    if (rf & 2) {
      ɵɵproperty("id", ctx.id);
      ɵɵattribute("max", ctx.max)("value", ctx.value)("data-displayval", ctx.displayValue);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.displayStringValue());
    }
  },
  dependencies: [NgIf],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrProgressBar, [{
    type: Component,
    args: [{
      selector: "clr-progress-bar",
      template: `
    <progress [id]="id" [attr.max]="max" [attr.value]="value" [attr.data-displayval]="displayValue"></progress>
    <span *ngIf="displayStringValue()">{{ displayValue }}</span>
  `
    }]
  }], null, {
    max: [{
      type: Input,
      args: ["clrMax"]
    }],
    displayval: [{
      type: Input,
      args: ["clrDisplayval"]
    }],
    color: [{
      type: Input,
      args: ["clrColor"]
    }],
    value: [{
      type: Input,
      args: ["clrValue"]
    }],
    externalId: [{
      type: HostBinding,
      args: ["attr.id"]
    }],
    id: [{
      type: Input
    }],
    progressClass: [{
      type: HostBinding,
      args: ["class.progress"]
    }],
    clrCompact: [{
      type: Input,
      args: ["clrCompact"]
    }],
    compactClass: [{
      type: HostBinding,
      args: ["class.compact"]
    }],
    clrLabeled: [{
      type: Input,
      args: ["clrLabeled"]
    }],
    labeledClass: [{
      type: HostBinding,
      args: ["class.labeled"]
    }],
    clrFade: [{
      type: Input,
      args: ["clrFade"]
    }],
    fadeClass: [{
      type: HostBinding,
      args: ["class.progress-fade"]
    }],
    clrLoop: [{
      type: Input,
      args: ["clrLoop"]
    }],
    loopClass: [{
      type: HostBinding,
      args: ["class.loop"]
    }],
    warningClass: [{
      type: HostBinding,
      args: ["class.warning"]
    }],
    successClass: [{
      type: HostBinding,
      args: ["class.success"]
    }],
    dangerClass: [{
      type: HostBinding,
      args: ["class.danger"]
    }],
    clrFlash: [{
      type: Input,
      args: ["clrFlash"]
    }],
    flashClass: [{
      type: HostBinding,
      args: ["class.flash"]
    }],
    clrFlashDanger: [{
      type: Input,
      args: ["clrFlashDanger"]
    }],
    flashDangerClass: [{
      type: HostBinding,
      args: ["class.flash-danger"]
    }]
  });
})();
var CLR_PROGRESS_BAR_DIRECTIVES = [ClrProgressBar];
var ClrProgressBarModule = class {
};
ClrProgressBarModule.ɵfac = function ClrProgressBarModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrProgressBarModule)();
};
ClrProgressBarModule.ɵmod = ɵɵdefineNgModule({
  type: ClrProgressBarModule,
  declarations: [ClrProgressBar],
  imports: [CommonModule],
  exports: [ClrProgressBar]
});
ClrProgressBarModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrProgressBarModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [CLR_PROGRESS_BAR_DIRECTIVES],
      exports: [CLR_PROGRESS_BAR_DIRECTIVES]
    }]
  }], null, null);
})();
var ClrTimelineLayout;
(function(ClrTimelineLayout2) {
  ClrTimelineLayout2["HORIZONTAL"] = "horizontal";
  ClrTimelineLayout2["VERTICAL"] = "vertical";
})(ClrTimelineLayout || (ClrTimelineLayout = {}));
var ClrTimelineStepState;
(function(ClrTimelineStepState2) {
  ClrTimelineStepState2["NOT_STARTED"] = "not-started";
  ClrTimelineStepState2["CURRENT"] = "current";
  ClrTimelineStepState2["PROCESSING"] = "processing";
  ClrTimelineStepState2["SUCCESS"] = "success";
  ClrTimelineStepState2["ERROR"] = "error";
})(ClrTimelineStepState || (ClrTimelineStepState = {}));
var TimelineIconAttributeService = class {
  constructor(commonStrings) {
    this.attributeMap = /* @__PURE__ */ new Map();
    this.attributeMap.set(ClrTimelineStepState.NOT_STARTED, {
      iconShape: "circle",
      iconStatus: null,
      ariaLabel: commonStrings.keys.timelineStepNotStarted
    });
    this.attributeMap.set(ClrTimelineStepState.CURRENT, {
      iconShape: "dot-circle",
      iconStatus: "info",
      ariaLabel: commonStrings.keys.timelineStepCurrent
    });
    this.attributeMap.set(ClrTimelineStepState.PROCESSING, {
      iconShape: void 0,
      iconStatus: null,
      ariaLabel: commonStrings.keys.timelineStepProcessing
    });
    this.attributeMap.set(ClrTimelineStepState.SUCCESS, {
      iconShape: "success-standard",
      iconStatus: "success",
      ariaLabel: commonStrings.keys.timelineStepSuccess
    });
    this.attributeMap.set(ClrTimelineStepState.ERROR, {
      iconShape: "error-standard",
      iconStatus: "danger",
      ariaLabel: commonStrings.keys.timelineStepError
    });
  }
  getAriaLabel(step) {
    return this.attributeMap.get(step).ariaLabel;
  }
  getIconShape(step) {
    return this.attributeMap.get(step).iconShape;
  }
  getIconStatus(step) {
    return this.attributeMap.get(step).iconStatus;
  }
};
TimelineIconAttributeService.ɵfac = function TimelineIconAttributeService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || TimelineIconAttributeService)(ɵɵinject(ClrCommonStringsService));
};
TimelineIconAttributeService.ɵprov = ɵɵdefineInjectable({
  token: TimelineIconAttributeService,
  factory: TimelineIconAttributeService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimelineIconAttributeService, [{
    type: Injectable
  }], function() {
    return [{
      type: ClrCommonStringsService
    }];
  }, null);
})();
var ClrTimeline = class {
  constructor() {
    this.layout = ClrTimelineLayout.HORIZONTAL;
  }
  get isVertical() {
    return this.layout === ClrTimelineLayout.VERTICAL;
  }
};
ClrTimeline.ɵfac = function ClrTimeline_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrTimeline)();
};
ClrTimeline.ɵcmp = ɵɵdefineComponent({
  type: ClrTimeline,
  selectors: [["clr-timeline"]],
  hostVars: 5,
  hostBindings: function ClrTimeline_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", "list");
      ɵɵclassProp("clr-timeline", true)("clr-timeline-vertical", ctx.isVertical);
    }
  },
  inputs: {
    layout: [0, "clrLayout", "layout"]
  },
  standalone: false,
  features: [ɵɵProvidersFeature([TimelineIconAttributeService])],
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrTimeline_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTimeline, [{
    type: Component,
    args: [{
      selector: "clr-timeline",
      template: `<ng-content></ng-content>`,
      host: {
        "[class.clr-timeline]": "true",
        "[attr.role]": '"list"'
      },
      providers: [TimelineIconAttributeService]
    }]
  }], null, {
    layout: [{
      type: Input,
      args: ["clrLayout"]
    }],
    isVertical: [{
      type: HostBinding,
      args: ["class.clr-timeline-vertical"]
    }]
  });
})();
var ClrTimelineStepTitle = class {
};
ClrTimelineStepTitle.ɵfac = function ClrTimelineStepTitle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrTimelineStepTitle)();
};
ClrTimelineStepTitle.ɵcmp = ɵɵdefineComponent({
  type: ClrTimelineStepTitle,
  selectors: [["clr-timeline-step-title"]],
  hostVars: 3,
  hostBindings: function ClrTimelineStepTitle_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("aria-hidden", true);
      ɵɵclassProp("clr-timeline-step-title", true);
    }
  },
  standalone: false,
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrTimelineStepTitle_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTimelineStepTitle, [{
    type: Component,
    args: [{
      selector: "clr-timeline-step-title",
      template: `<ng-content></ng-content>`,
      host: {
        "[class.clr-timeline-step-title]": "true",
        "[attr.aria-hidden]": "true"
      }
    }]
  }], null, null);
})();
var ClrTimelineStep = class {
  constructor(iconAttributeService, platformId) {
    this.iconAttributeService = iconAttributeService;
    this.platformId = platformId;
    this.state = ClrTimelineStepState.NOT_STARTED;
  }
  get iconAriaLabel() {
    return this.iconAttributeService.getAriaLabel(this.state);
  }
  get iconShape() {
    return this.iconAttributeService.getIconShape(this.state);
  }
  get iconStatus() {
    return this.iconAttributeService.getIconStatus(this.state);
  }
  get isProcessing() {
    return this.state === ClrTimelineStepState.PROCESSING;
  }
  ngAfterContentInit() {
    if (this.stepTitle && isPlatformBrowser(this.platformId)) {
      this.stepTitleText = this.stepTitle.nativeElement.innerText;
    }
  }
};
ClrTimelineStep.ɵfac = function ClrTimelineStep_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrTimelineStep)(ɵɵdirectiveInject(TimelineIconAttributeService), ɵɵdirectiveInject(PLATFORM_ID));
};
ClrTimelineStep.ɵcmp = ɵɵdefineComponent({
  type: ClrTimelineStep,
  selectors: [["clr-timeline-step"]],
  contentQueries: function ClrTimelineStep_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrTimelineStepTitle, 5, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.stepTitle = _t.first);
    }
  },
  hostVars: 3,
  hostBindings: function ClrTimelineStep_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", "listitem");
      ɵɵclassProp("clr-timeline-step", true);
    }
  },
  inputs: {
    state: [0, "clrState", "state"]
  },
  standalone: false,
  ngContentSelectors: _c112,
  decls: 9,
  vars: 3,
  consts: [["processing", ""], [1, "clr-sr-only"], [4, "ngIf", "ngIfElse"], [1, "clr-timeline-step-body"], ["role", "img"], ["clrMedium", ""]],
  template: function ClrTimelineStep_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c111);
      ɵɵprojection(0);
      ɵɵelementStart(1, "span", 1);
      ɵɵtext(2);
      ɵɵelementEnd();
      ɵɵtemplate(3, ClrTimelineStep_ng_container_3_Template, 2, 3, "ng-container", 2);
      ɵɵelementStart(4, "div", 3);
      ɵɵprojection(5, 1);
      ɵɵprojection(6, 2);
      ɵɵelementEnd();
      ɵɵtemplate(7, ClrTimelineStep_ng_template_7_Template, 1, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      const processing_r2 = ɵɵreference(8);
      ɵɵadvance(2);
      ɵɵtextInterpolate(ctx.stepTitleText);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.isProcessing)("ngIfElse", processing_r2);
    }
  },
  dependencies: [NgIf, CdsIconCustomTag, ClrSpinner],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTimelineStep, [{
    type: Component,
    args: [{
      selector: "clr-timeline-step",
      template: `
    <ng-content select="clr-timeline-step-header"></ng-content>
    <span class="clr-sr-only">{{ stepTitleText }}</span>
    <ng-container *ngIf="!isProcessing; else processing">
      <cds-icon
        [attr.status]="iconStatus"
        [attr.shape]="iconShape"
        [attr.aria-label]="iconAriaLabel"
        role="img"
      ></cds-icon>
    </ng-container>
    <div class="clr-timeline-step-body">
      <ng-content select="clr-timeline-step-title"></ng-content>
      <ng-content select="clr-timeline-step-description"></ng-content>
    </div>

    <ng-template #processing>
      <clr-spinner clrMedium [attr.aria-label]="iconAriaLabel"></clr-spinner>
    </ng-template>
  `,
      host: {
        "[class.clr-timeline-step]": "true",
        "[attr.role]": '"listitem"'
      }
    }]
  }], function() {
    return [{
      type: TimelineIconAttributeService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }];
  }, {
    state: [{
      type: Input,
      args: ["clrState"]
    }],
    stepTitle: [{
      type: ContentChild,
      args: [ClrTimelineStepTitle, {
        read: ElementRef
      }]
    }]
  });
})();
var ClrTimelineStepDescription = class {
};
ClrTimelineStepDescription.ɵfac = function ClrTimelineStepDescription_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrTimelineStepDescription)();
};
ClrTimelineStepDescription.ɵcmp = ɵɵdefineComponent({
  type: ClrTimelineStepDescription,
  selectors: [["clr-timeline-step-description"]],
  hostVars: 2,
  hostBindings: function ClrTimelineStepDescription_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-timeline-step-description", true);
    }
  },
  standalone: false,
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrTimelineStepDescription_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTimelineStepDescription, [{
    type: Component,
    args: [{
      selector: "clr-timeline-step-description",
      template: `<ng-content></ng-content>`,
      host: {
        "[class.clr-timeline-step-description]": "true"
      }
    }]
  }], null, null);
})();
var ClrTimelineStepHeader = class {
};
ClrTimelineStepHeader.ɵfac = function ClrTimelineStepHeader_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrTimelineStepHeader)();
};
ClrTimelineStepHeader.ɵcmp = ɵɵdefineComponent({
  type: ClrTimelineStepHeader,
  selectors: [["clr-timeline-step-header"]],
  hostVars: 2,
  hostBindings: function ClrTimelineStepHeader_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-timeline-step-header", true);
    }
  },
  standalone: false,
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrTimelineStepHeader_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTimelineStepHeader, [{
    type: Component,
    args: [{
      selector: "clr-timeline-step-header",
      template: `<ng-content></ng-content>`,
      host: {
        "[class.clr-timeline-step-header]": "true"
      }
    }]
  }], null, null);
})();
var CLR_TIMELINE_DIRECTIVES = [ClrTimeline, ClrTimelineStep, ClrTimelineStepDescription, ClrTimelineStepHeader, ClrTimelineStepTitle];
var ClrTimelineModule = class {
  constructor() {
    r.addIcons(r3, r4, d, d2);
  }
};
ClrTimelineModule.ɵfac = function ClrTimelineModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrTimelineModule)();
};
ClrTimelineModule.ɵmod = ɵɵdefineNgModule({
  type: ClrTimelineModule,
  declarations: [ClrTimeline, ClrTimelineStep, ClrTimelineStepDescription, ClrTimelineStepHeader, ClrTimelineStepTitle],
  imports: [CommonModule, ClrIconModule, ClrSpinnerModule],
  exports: [ClrTimeline, ClrTimelineStep, ClrTimelineStepDescription, ClrTimelineStepHeader, ClrTimelineStepTitle, ClrIconModule, ClrSpinnerModule]
});
ClrTimelineModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrIconModule, ClrSpinnerModule, ClrIconModule, ClrSpinnerModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTimelineModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ClrIconModule, ClrSpinnerModule],
      exports: [...CLR_TIMELINE_DIRECTIVES, ClrIconModule, ClrSpinnerModule],
      declarations: [CLR_TIMELINE_DIRECTIVES]
    }]
  }], function() {
    return [];
  }, null);
})();
var ButtonHubService = class {
  constructor() {
    this.buttonsReady = false;
    this._previousBtnClicked = new Subject();
    this._nextBtnClicked = new Subject();
    this._dangerBtnClicked = new Subject();
    this._cancelBtnClicked = new Subject();
    this._finishBtnClicked = new Subject();
    this._customBtnClicked = new Subject();
  }
  get previousBtnClicked() {
    return this._previousBtnClicked.asObservable();
  }
  get nextBtnClicked() {
    return this._nextBtnClicked.asObservable();
  }
  get dangerBtnClicked() {
    return this._dangerBtnClicked.asObservable();
  }
  get cancelBtnClicked() {
    return this._cancelBtnClicked.asObservable();
  }
  get finishBtnClicked() {
    return this._finishBtnClicked.asObservable();
  }
  get customBtnClicked() {
    return this._customBtnClicked.asObservable();
  }
  buttonClicked(buttonType) {
    if ("previous" === buttonType) {
      this._previousBtnClicked.next();
    } else if ("next" === buttonType) {
      this._nextBtnClicked.next();
    } else if ("finish" === buttonType) {
      this._finishBtnClicked.next();
    } else if ("danger" === buttonType) {
      this._dangerBtnClicked.next();
    } else if ("cancel" === buttonType) {
      this._cancelBtnClicked.next();
    } else {
      this._customBtnClicked.next(buttonType);
    }
  }
};
ButtonHubService.ɵfac = function ButtonHubService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ButtonHubService)();
};
ButtonHubService.ɵprov = ɵɵdefineInjectable({
  token: ButtonHubService,
  factory: ButtonHubService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ButtonHubService, [{
    type: Injectable
  }], null, null);
})();
var PageCollectionService = class {
  constructor() {
    this._pagesReset = new Subject();
  }
  /**
   * Converts the PageCollectionService.pages QueryList to an array and returns it.
   *
   * Useful for many instances when you would prefer a QueryList to act like an array.
   *
   * @memberof PageCollectionService
   */
  get pagesAsArray() {
    return this.pages ? this.pages.toArray() : [];
  }
  /**
   * Returns the length of the pages query list.
   *
   * @memberof PageCollectionService
   */
  get pagesCount() {
    return this.pages ? this.pages.length : 0;
  }
  /**
   * Returns the next-to-last page in the query list of pages. Operates as a getter
   * so that it isn't working with stale data.
   *
   * @memberof PageCollectionService
   */
  get penultimatePage() {
    const pageCount = this.pagesCount;
    if (pageCount < 2) {
      return null;
    }
    return this.pagesAsArray[pageCount - 2];
  }
  /**
   * Returns the last page in the query list of pages. Operates as a getter
   * so that it isn't working with stale data.
   *
   * @memberof PageCollectionService
   */
  get lastPage() {
    const pageCount = this.pagesCount;
    if (pageCount < 1) {
      return null;
    }
    return this.pagesAsArray[pageCount - 1];
  }
  /**
   * Returns the first page in the query list of pages. Operates as a getter
   * so that it isn't working with stale data.
   *
   * @memberof PageCollectionService
   */
  get firstPage() {
    if (!this.pagesCount) {
      return null;
    }
    return this.pagesAsArray[0];
  }
  /**
   * An observable that the navigation service listens to in order to know when
   * the page collection completed states have been reset to false so that way it
   * can also reset the navigation to make the first page in the page collection
   * current/active.
   *
   * @memberof PageCollectionService
   */
  get pagesReset() {
    return this._pagesReset.asObservable();
  }
  /**
   * Used mostly internally, but accepts a string ID and returns a ClrWizardPage
   * object that matches the ID passed. Note that IDs here should include the prefix
   * "clr-wizard-page-".
   *
   * Returns the next-to-last page in the query list of pages. Operates as a getter
   * so that it isn't working with stale data.
   *
   * @memberof PageCollectionService
   */
  getPageById(id) {
    const foundPages = this.pages.filter((page) => id === page.id);
    return this.checkResults(foundPages, id);
  }
  /**
   * Accepts s number as a parameter and treats that number as the index of the page
   * you're looking for in the collection of pages. Returns a  wizard page object.
   *
   * @memberof PageCollectionService
   */
  getPageByIndex(index) {
    const pageCount = this.pagesCount;
    const pagesLastIndex = pageCount > 1 ? pageCount - 1 : 0;
    if (index < 0) {
      throw new Error("Cannot retrieve page with index of " + index);
    }
    if (index > pagesLastIndex) {
      throw new Error("Page index is greater than length of pages array.");
    }
    return this.pagesAsArray[index];
  }
  /**
   * Takes a wizard page object as a parameter and returns its index in the
   * collection of pages.
   *
   * @memberof PageCollectionService
   */
  getPageIndex(page) {
    const index = this.pagesAsArray.indexOf(page);
    if (index < 0) {
      throw new Error("Requested page cannot be found in collection of pages.");
    }
    return index;
  }
  /**
   * Accepts two numeric indexes and returns an array of wizard page objects that include
   * all wizard pages in the page collection from the first index to the second.
   *
   * @memberof PageCollectionService
   */
  pageRange(start, end) {
    let pages = [];
    if (start < 0 || end < 0) {
      return [];
    }
    if (start === null || typeof start === "undefined" || isNaN(start)) {
      return [];
    }
    if (end === null || typeof end === "undefined" || isNaN(end)) {
      return [];
    }
    if (end > this.pagesCount) {
      end = this.pagesCount;
    }
    pages = this.pagesAsArray;
    if (end - start === 0) {
      return [this.getPageByIndex(start)];
    }
    end = end + 1;
    return pages.slice(start, end);
  }
  /**
   * Accepts two wizard page objects and returns those page objects with all other page
   * objects between them in the page collection. It doesn't care which page is ahead of the
   * other in the parameters. It will be smart enough to figure that out  on its own.
   *
   * @memberof PageCollectionService
   */
  getPageRangeFromPages(page, otherPage) {
    const pageIndex = this.getPageIndex(page);
    const otherPageIndex = this.getPageIndex(otherPage);
    let startIndex;
    let endIndex;
    if (pageIndex <= otherPageIndex) {
      startIndex = pageIndex;
      endIndex = otherPageIndex;
    } else {
      startIndex = otherPageIndex;
      endIndex = pageIndex;
    }
    return this.pageRange(startIndex, endIndex);
  }
  /**
   * Takes a wizard page object as a parameter and returns the wizard page object of
   * the page immediately before it in the page collection. Returns null if there is
   * no page before the page it is passed.
   *
   * @memberof PageCollectionService
   */
  getPreviousPage(page) {
    const myPageIndex = this.getPageIndex(page);
    const previousPageIndex = myPageIndex - 1;
    if (previousPageIndex < 0) {
      return null;
    }
    return this.getPageByIndex(previousPageIndex);
  }
  /**
   * Accepts a wizard page object as a parameter and returns a Boolean that says if
   * the page you sent it is complete.
   *
   * @memberof PageCollectionService
   */
  previousPageIsCompleted(page) {
    if (!page) {
      return false;
    }
    const previousPage = this.getPreviousPage(page);
    if (null === previousPage) {
      return true;
    }
    return previousPage.completed;
  }
  /**
   * Takes a wizard page object as a parameter and returns the wizard page object of
   * the page immediately after it in the page collection. Returns null if there is
   * no page after the page it is passed.
   *
   * @memberof PageCollectionService
   */
  getNextPage(page) {
    const myPageIndex = this.getPageIndex(page);
    const nextPageIndex = myPageIndex + 1;
    if (nextPageIndex >= this.pagesAsArray.length) {
      return null;
    }
    return this.getPageByIndex(nextPageIndex);
  }
  /**
   * Takes a wizard page object as a parameter and generates a step item id from the
   * page ID. Returns the generated step item ID as a string.
   *
   * @memberof PageCollectionService
   */
  getStepItemIdForPage(page) {
    const pageId = page.id;
    const pageIdParts = pageId.split("-").reverse();
    pageIdParts[1] = "step";
    return pageIdParts.reverse().join("-");
  }
  /**
   * Generally only used internally to mark that a specific page has been "committed".
   * This involves marking the page complete and firing the ClrWizardPage.onCommit
   * (clrWizardPageOnCommit) output. Takes the wizard page object that you intend to
   * mark completed as a parameter.
   *
   * @memberof PageCollectionService
   */
  commitPage(page) {
    const pageHasOverrides = page.stopNext || page.preventDefault;
    page.completed = true;
    if (!pageHasOverrides) {
      page.onCommit.emit(page.id);
    }
  }
  /**
   * Sets all completed states of the pages in the page collection to false and
   * notifies the navigation service to likewise reset the navigation.
   *
   * @memberof PageCollectionService
   */
  reset() {
    this.pagesAsArray.forEach((page) => {
      page.completed = false;
    });
    this._pagesReset.next(true);
  }
  /**
   * Rolls through all the pages in the page collection to make sure there are no
   * incomplete pages sandwiched between completed pages in the workflow. Identifies
   * the first incomplete page index and sets all pages behind it to a completed
   * state of false.
   *
   * @memberof PageCollectionService
   */
  updateCompletedStates() {
    const firstIncompleteIndex = this.findFirstIncompletePageIndex();
    if (firstIncompleteIndex === this.pagesAsArray.length - 1) {
      return;
    }
    this.pagesAsArray.forEach((page, index) => {
      if (index > firstIncompleteIndex) {
        page.completed = false;
      }
    });
  }
  /**
   * Retrieves the index of the first incomplete page in the page collection.
   *
   * @memberof PageCollectionService
   */
  findFirstIncompletePageIndex() {
    let returnIndex = null;
    this.pagesAsArray.forEach((page, index) => {
      if (null === returnIndex && false === page.completed) {
        returnIndex = index;
      }
    });
    if (null === returnIndex) {
      returnIndex = this.pagesCount - 1;
    }
    return returnIndex;
  }
  findFirstIncompletePage() {
    const myIncompleteIndex = this.findFirstIncompletePageIndex();
    return this.pagesAsArray[myIncompleteIndex];
  }
  /**
   * Consolidates guard logic that prevents a couple of unfortunate edge cases with
   * look ups on the collection of pages.
   *
   * @memberof PageCollectionService
   */
  checkResults(results, requestedPageId) {
    const foundPagesCount = results.length || 0;
    if (foundPagesCount > 1) {
      throw new Error("More than one page has the requested id " + requestedPageId + ".");
    } else if (foundPagesCount < 1) {
      throw new Error("No page can be found with the id " + requestedPageId + ".");
    } else {
      return results[0];
    }
  }
};
PageCollectionService.ɵfac = function PageCollectionService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || PageCollectionService)();
};
PageCollectionService.ɵprov = ɵɵdefineInjectable({
  token: PageCollectionService,
  factory: PageCollectionService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PageCollectionService, [{
    type: Injectable
  }], null, null);
})();
var WizardNavigationService = class {
  /**
   * Creates an instance of WizardNavigationService. Also sets up subscriptions
   * that listen to the button service to determine when a button has been clicked
   * in the wizard. Is also responsible for taking action when the page collection
   * requests that navigation be reset to its pristine state.
   *
   * @memberof WizardNavigationService
   */
  constructor(pageCollection, buttonService) {
    this.pageCollection = pageCollection;
    this.buttonService = buttonService;
    this.navServiceLoaded = false;
    this.forceForwardNavigation = false;
    this.wizardHasAltCancel = false;
    this.wizardHasAltNext = false;
    this.wizardStopNavigation = false;
    this.wizardDisableStepnav = false;
    this._currentChanged = new Subject();
    this._movedToNextPage = new Subject();
    this._wizardFinished = new Subject();
    this._movedToPreviousPage = new Subject();
    this._cancelWizard = new Subject();
    this.previousButtonSubscription = buttonService.previousBtnClicked.subscribe(() => {
      const currentPage = this.currentPage;
      if (this.currentPageIsFirst || currentPage.previousStepDisabled) {
        return;
      }
      currentPage.previousButtonClicked.emit(currentPage);
      if (!currentPage.preventDefault) {
        this.previous();
      }
    });
    this.nextButtonSubscription = buttonService.nextBtnClicked.subscribe(() => {
      this.checkAndCommitCurrentPage("next");
    });
    this.dangerButtonSubscription = buttonService.dangerBtnClicked.subscribe(() => {
      this.checkAndCommitCurrentPage("danger");
    });
    this.finishButtonSubscription = buttonService.finishBtnClicked.subscribe(() => {
      this.checkAndCommitCurrentPage("finish");
    });
    this.customButtonSubscription = buttonService.customBtnClicked.subscribe((type) => {
      if (!this.wizardStopNavigation) {
        this.currentPage.customButtonClicked.emit(type);
      }
    });
    this.cancelButtonSubscription = buttonService.cancelBtnClicked.subscribe(() => {
      if (this.wizardStopNavigation) {
        return;
      }
      if (this.currentPage.preventDefault) {
        this.currentPage.pageOnCancel.emit(this.currentPage);
      } else {
        this.cancel();
      }
    });
    this.pagesResetSubscription = pageCollection.pagesReset.subscribe(() => {
      this.setFirstPageCurrent();
    });
  }
  /**
   * An Observable that is predominantly used amongst the subcomponents and services
   * of the wizard. It is recommended that users listen to the ClrWizardPage.onLoad
   * (clrWizardPageOnLoad) output instead of this Observable.
   *
   * @memberof WizardNavigationService
   */
  get currentPageChanged() {
    return this._currentChanged.asObservable();
  }
  /**
   * @memberof WizardNavigationService
   */
  get currentPageTitle() {
    if (!this.currentPage) {
      return null;
    }
    return this.currentPage.title;
  }
  /**
   * Returns a Boolean that tells you whether or not the current page is the first
   * page in the Wizard.
   *
   * This is helpful for determining whether a page is navigable.
   *
   * @memberof WizardNavigationService
   */
  get currentPageIsFirst() {
    return this.pageCollection.firstPage === this.currentPage;
  }
  /**
   * Returns a Boolean that tells you whether or not the current page is the
   * last page in the Wizard.
   *
   * This is used to determine which buttons should display in the wizard footer.
   *
   * @memberof WizardNavigationService
   */
  get currentPageIsLast() {
    return this.pageCollection.lastPage === this.currentPage;
  }
  /**
   * Returns the ClrWizardPage object of the current page or null.
   *
   * @memberof WizardNavigationService
   */
  get currentPage() {
    if (!this._currentPage) {
      return null;
    }
    return this._currentPage;
  }
  /**
   * Accepts a ClrWizardPage object, since that object to be the current/active
   * page in the wizard, and emits the ClrWizardPage.onLoad (clrWizardPageOnLoad)
   * event for that page.
   *
   * Note that all of this work is bypassed if the ClrWizardPage object is already
   * the current page.
   *
   * @memberof WizardNavigationService
   */
  set currentPage(page) {
    if (this._currentPage !== page && !this.wizardStopNavigation) {
      this._currentPage = page;
      page.onLoad.emit(page.id);
      this._currentChanged.next(page);
    }
  }
  /**
   * An observable used internally to alert the wizard that forward navigation
   * has occurred. It is recommended that you use the Wizard.onMoveNext
   * (clrWizardOnNext) output instead of this one.
   *
   * @memberof WizardNavigationService
   */
  get movedToNextPage() {
    return this._movedToNextPage.asObservable();
  }
  /**
   * An observable used internally to alert the wizard that the nav service
   * has approved completion of the wizard.
   *
   * It is recommended that you use the Wizard.wizardFinished (clrWizardOnFinish)
   * output instead of this one.
   *
   * @memberof WizardNavigationService
   */
  get wizardFinished() {
    return this._wizardFinished.asObservable();
  }
  /**
   * Notifies the wizard when backwards navigation has occurred via the
   * previous button.
   *
   * @memberof WizardNavigationService
   */
  get movedToPreviousPage() {
    return this._movedToPreviousPage.asObservable();
  }
  /**
   * Notifies the wizard that a user is trying to cancel it.
   *
   * @memberof WizardNavigationService
   */
  get notifyWizardCancel() {
    return this._cancelWizard.asObservable();
  }
  /**
   *
   * @memberof WizardNavigationService
   */
  ngOnDestroy() {
    this.previousButtonSubscription.unsubscribe();
    this.nextButtonSubscription.unsubscribe();
    this.dangerButtonSubscription.unsubscribe();
    this.finishButtonSubscription.unsubscribe();
    this.customButtonSubscription.unsubscribe();
    this.cancelButtonSubscription.unsubscribe();
    this.pagesResetSubscription.unsubscribe();
  }
  /**
   * This is a public function that can be used to programmatically advance
   * the user to the next page.
   *
   * When invoked, this method will move the wizard to the next page after
   * successful validation. Note that this method goes through all checks
   * and event emissions as if Wizard.next(false) had been called.
   *
   * In most cases, it makes more sense to use Wizard.next(false).
   *
   * @memberof WizardNavigationService
   */
  next() {
    if (this.currentPageIsLast) {
      this.checkAndCommitCurrentPage("finish");
    } else {
      this.checkAndCommitCurrentPage("next");
    }
  }
  /**
   * Bypasses checks and most event emissions to force a page to navigate forward.
   *
   * Comparable to calling Wizard.next() or Wizard.forceNext().
   *
   * @memberof WizardNavigationService
   */
  forceNext() {
    const currentPage = this.currentPage;
    const nextPage = this.pageCollection.getNextPage(currentPage);
    if (!nextPage) {
      throw new Error("The wizard has no next page to go to.");
    }
    if (this.wizardStopNavigation) {
      return;
    }
    if (!currentPage.completed) {
      this.pageCollection.commitPage(currentPage);
    }
    this.currentPage = nextPage;
  }
  /**
   * Accepts a button/action type as a parameter. Encapsulates all logic for
   * event emissions, state of the current page, and wizard and page level overrides.
   *
   * Avoid calling this function directly unless you really know what you're doing.
   *
   * @memberof WizardNavigationService
   */
  checkAndCommitCurrentPage(buttonType) {
    const currentPage = this.currentPage;
    if (!currentPage.readyToComplete || this.wizardStopNavigation) {
      return;
    }
    const iAmTheLastPage = this.currentPageIsLast;
    const isNext = buttonType === "next";
    const isDanger = buttonType === "danger";
    const isDangerNext = isDanger && !iAmTheLastPage;
    const isDangerFinish = isDanger && iAmTheLastPage;
    const isFinish = buttonType === "finish" || isDangerFinish;
    if (isFinish && !iAmTheLastPage) {
      return;
    }
    currentPage.primaryButtonClicked.emit(buttonType);
    if (isFinish) {
      currentPage.finishButtonClicked.emit(currentPage);
    } else if (isDanger) {
      currentPage.dangerButtonClicked.emit();
    } else if (isNext) {
      currentPage.nextButtonClicked.emit();
    }
    if (currentPage.stopNext || currentPage.preventDefault) {
      currentPage.onCommit.emit(currentPage.id);
      return;
    }
    if (isFinish) {
      if (!this.wizardHasAltNext) {
        this.pageCollection.commitPage(currentPage);
      }
      this._wizardFinished.next();
    }
    if (this.wizardHasAltNext) {
      this.pageCollection.commitPage(currentPage);
      if (isNext || isDangerNext) {
        this._movedToNextPage.next(true);
      }
      return;
    }
    if (isNext || isDangerNext) {
      this.forceNext();
    }
    if (!this.wizardHasAltNext && !this.wizardStopNavigation) {
      this._movedToNextPage.next(true);
    }
  }
  /**
   * This is a public function that can be used to programmatically conclude
   * the wizard.
   *
   * When invoked, this method will  initiate the work involved with finalizing
   * and finishing the wizard workflow. Note that this method goes through all
   * checks and event emissions as if Wizard.finish(false) had been called.
   *
   * In most cases, it makes more sense to use Wizard.finish(false).
   *
   * @memberof WizardNavigationService
   */
  finish() {
    this.checkAndCommitCurrentPage("finish");
  }
  /**
   * Programmatically moves the wizard to the page before the current page.
   *
   * In most instances, it makes more sense to call Wizard.previous()
   * which does the same thing.
   *
   * @memberof WizardNavigationService
   */
  previous() {
    if (this.currentPageIsFirst || this.wizardStopNavigation) {
      return;
    }
    const previousPage = this.pageCollection.getPreviousPage(this.currentPage);
    if (!previousPage) {
      return;
    }
    this._movedToPreviousPage.next(true);
    if (this.forceForwardNavigation) {
      this.currentPage.completed = false;
    }
    this.currentPage = previousPage;
  }
  /**
   * Allows a hook into the cancel workflow of the wizard from the nav service. Note that
   * this route goes through all checks and event emissions as if a cancel button had
   * been clicked.
   *
   * In most cases, users looking for a hook into the cancel routine are actually looking
   * for a way to close the wizard from their host component because they have prevented
   * the default cancel action.
   *
   * In this instance, it is recommended that you use Wizard.close() to avoid any event
   * emission loop resulting from an event handler calling back into routine that will
   * again evoke the events it handles.
   *
   * @memberof WizardNavigationService
   */
  cancel() {
    this._cancelWizard.next();
  }
  /**
   * Performs all required checks to determine if a user can navigate to a page. Checking at each
   * point if a page is navigable -- completed where the page immediately after the last completed
   * page.
   *
   * Takes two parameters. The first one must be either the ClrWizardPage object or the ID of the
   * ClrWizardPage object that you want to make the current page.
   *
   * The second parameter is optional and is a Boolean flag for "lazy completion". What this means
   * is the Wizard will mark all pages between the current page and the page you want to navigate
   * to as completed. This is useful for informational wizards that do not require user action,
   * allowing an easy means for users to jump ahead.
   *
   * To avoid checks on navigation, use ClrWizardPage.makeCurrent() instead.
   *
   * @memberof WizardNavigationService
   */
  goTo(pageToGoToOrId, lazyComplete = false) {
    const myPages = this.pageCollection;
    const pageToGoTo = typeof pageToGoToOrId === "string" ? myPages.getPageById(pageToGoToOrId) : pageToGoToOrId;
    const currentPage = this.currentPage;
    if (pageToGoTo === currentPage || this.wizardStopNavigation) {
      return;
    }
    const currentPageIndex = myPages.getPageIndex(currentPage);
    const goToPageIndex = myPages.getPageIndex(pageToGoTo);
    const goingForward = goToPageIndex > currentPageIndex;
    const pagesToCheck = myPages.getPageRangeFromPages(this.currentPage, pageToGoTo);
    const okayToMove = lazyComplete || this.canGoTo(pagesToCheck);
    if (!okayToMove) {
      return;
    }
    if (goingForward && lazyComplete) {
      pagesToCheck.forEach((page) => {
        if (page !== pageToGoTo) {
          page.completed = true;
        }
      });
    } else if (!goingForward && this.forceForwardNavigation) {
      pagesToCheck.forEach((page) => {
        page.completed = false;
      });
    }
    this.currentPage = pageToGoTo;
  }
  /**
   * Accepts a range of ClrWizardPage objects as a parameter. Performs the work of checking
   * those objects to determine if navigation can be accomplished.
   *
   * @memberof WizardNavigationService
   */
  canGoTo(pagesToCheck) {
    let okayToMove = true;
    const myPages = this.pageCollection;
    let previousPagePasses;
    if (!pagesToCheck || pagesToCheck.length < 1) {
      return false;
    }
    pagesToCheck.forEach((page) => {
      if (!okayToMove) {
        return;
      }
      if (page.completed) {
        return;
      }
      const previousPage = myPages.getPageIndex(page) > 0 ? myPages.getPreviousPage(page) : null;
      previousPagePasses = previousPage === null || previousPage.completed === true;
      if (!page.current && !previousPagePasses) {
        okayToMove = false;
      }
    });
    return okayToMove;
  }
  /**
   * Looks through the collection of pages to find the first one that is incomplete
   * and makes that page the current/active page.
   *
   * @memberof WizardNavigationService
   */
  setLastEnabledPageCurrent() {
    const allPages = this.pageCollection.pagesAsArray;
    let lastCompletedPageIndex = null;
    allPages.forEach((page, index) => {
      if (page.completed) {
        lastCompletedPageIndex = index;
      }
    });
    if (lastCompletedPageIndex === null) {
      lastCompletedPageIndex = 0;
    } else if (lastCompletedPageIndex + 1 < allPages.length) {
      lastCompletedPageIndex = lastCompletedPageIndex + 1;
    }
    this.currentPage = allPages[lastCompletedPageIndex];
  }
  /**
   * Finds the first page in the collection of pages and makes that page the
   * current/active page.
   *
   * @memberof WizardNavigationService
   */
  setFirstPageCurrent() {
    this.currentPage = this.pageCollection.pagesAsArray[0];
  }
  /**
   * Updates the stepnav on the left side of the wizard when pages are dynamically
   * added or removed from the collection of pages.
   *
   * @memberof WizardNavigationService
   */
  updateNavigation() {
    let toSetCurrent;
    this.pageCollection.updateCompletedStates();
    const currentPageRemoved = this.pageCollection.pagesAsArray.indexOf(this.currentPage) < 0;
    if (currentPageRemoved) {
      toSetCurrent = this.pageCollection.findFirstIncompletePage();
      this.currentPage = toSetCurrent;
    }
  }
};
WizardNavigationService.ɵfac = function WizardNavigationService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || WizardNavigationService)(ɵɵinject(PageCollectionService), ɵɵinject(ButtonHubService));
};
WizardNavigationService.ɵprov = ɵɵdefineInjectable({
  token: WizardNavigationService,
  factory: WizardNavigationService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WizardNavigationService, [{
    type: Injectable
  }], function() {
    return [{
      type: PageCollectionService
    }, {
      type: ButtonHubService
    }];
  }, null);
})();
var HeaderActionService = class {
  constructor(navService) {
    this.navService = navService;
  }
  get wizardHasHeaderActions() {
    const wizardHdrActions = this.wizardHeaderActions;
    if (!wizardHdrActions) {
      return false;
    }
    return wizardHdrActions.toArray().length > 0;
  }
  get currentPageHasHeaderActions() {
    return this.navService.currentPage ? this.navService.currentPage.hasHeaderActions : false;
  }
  get showWizardHeaderActions() {
    return !this.currentPageHasHeaderActions && this.wizardHasHeaderActions;
  }
  get displayHeaderActionsWrapper() {
    return this.currentPageHasHeaderActions || this.wizardHasHeaderActions;
  }
};
HeaderActionService.ɵfac = function HeaderActionService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || HeaderActionService)(ɵɵinject(WizardNavigationService));
};
HeaderActionService.ɵprov = ɵɵdefineInjectable({
  token: HeaderActionService,
  factory: HeaderActionService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeaderActionService, [{
    type: Injectable
  }], function() {
    return [{
      type: WizardNavigationService
    }];
  }, null);
})();
var wizardHeaderActionIndex = 0;
var ClrWizardHeaderAction = class {
  constructor() {
    this.title = "";
    this._id = (wizardHeaderActionIndex++).toString();
    this.disabled = false;
    this.headerActionClicked = new EventEmitter(false);
  }
  get id() {
    return `clr-wizard-header-action-${this._id}`;
  }
  click() {
    if (this.disabled) {
      return;
    }
    this.headerActionClicked.emit(this._id);
  }
};
ClrWizardHeaderAction.ɵfac = function ClrWizardHeaderAction_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrWizardHeaderAction)();
};
ClrWizardHeaderAction.ɵcmp = ɵɵdefineComponent({
  type: ClrWizardHeaderAction,
  selectors: [["clr-wizard-header-action"]],
  hostAttrs: [1, "clr-wizard-header-action-wrapper"],
  inputs: {
    title: "title",
    _id: [0, "id", "_id"],
    disabled: [0, "clrWizardHeaderActionDisabled", "disabled"]
  },
  outputs: {
    headerActionClicked: "actionClicked"
  },
  standalone: false,
  ngContentSelectors: _c02,
  decls: 2,
  vars: 4,
  consts: [["type", "button", 1, "btn", "clr-wizard-header-action", "btn-link", 3, "click", "id", "title"]],
  template: function ClrWizardHeaderAction_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "button", 0);
      ɵɵlistener("click", function ClrWizardHeaderAction_Template_button_click_0_listener() {
        return ctx.click();
      });
      ɵɵprojection(1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵclassProp("disabled", ctx.disabled);
      ɵɵproperty("id", ctx.id)("title", ctx.title);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrWizardHeaderAction, [{
    type: Component,
    args: [{
      selector: "clr-wizard-header-action",
      template: `
    <button
      type="button"
      class="btn clr-wizard-header-action btn-link"
      [id]="id"
      [class.disabled]="disabled"
      (click)="click()"
      [title]="title"
    >
      <ng-content></ng-content>
    </button>
  `,
      host: {
        class: "clr-wizard-header-action-wrapper"
      }
    }]
  }], null, {
    title: [{
      type: Input,
      args: ["title"]
    }],
    _id: [{
      type: Input,
      args: ["id"]
    }],
    disabled: [{
      type: Input,
      args: ["clrWizardHeaderActionDisabled"]
    }],
    headerActionClicked: [{
      type: Output,
      args: ["actionClicked"]
    }]
  });
})();
var ClrWizardPageButtons = class {
  constructor(pageButtonsTemplateRef) {
    this.pageButtonsTemplateRef = pageButtonsTemplateRef;
  }
};
ClrWizardPageButtons.ɵfac = function ClrWizardPageButtons_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrWizardPageButtons)(ɵɵdirectiveInject(TemplateRef));
};
ClrWizardPageButtons.ɵdir = ɵɵdefineDirective({
  type: ClrWizardPageButtons,
  selectors: [["", "clrPageButtons", ""]],
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrWizardPageButtons, [{
    type: Directive,
    args: [{
      selector: "[clrPageButtons]"
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var ClrWizardPageHeaderActions = class {
  constructor(pageHeaderActionsTemplateRef) {
    this.pageHeaderActionsTemplateRef = pageHeaderActionsTemplateRef;
  }
};
ClrWizardPageHeaderActions.ɵfac = function ClrWizardPageHeaderActions_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrWizardPageHeaderActions)(ɵɵdirectiveInject(TemplateRef));
};
ClrWizardPageHeaderActions.ɵdir = ɵɵdefineDirective({
  type: ClrWizardPageHeaderActions,
  selectors: [["", "clrPageHeaderActions", ""]],
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrWizardPageHeaderActions, [{
    type: Directive,
    args: [{
      selector: "[clrPageHeaderActions]"
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var ClrWizardPageNavTitle = class {
  constructor(pageNavTitleTemplateRef) {
    this.pageNavTitleTemplateRef = pageNavTitleTemplateRef;
  }
};
ClrWizardPageNavTitle.ɵfac = function ClrWizardPageNavTitle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrWizardPageNavTitle)(ɵɵdirectiveInject(TemplateRef));
};
ClrWizardPageNavTitle.ɵdir = ɵɵdefineDirective({
  type: ClrWizardPageNavTitle,
  selectors: [["", "clrPageNavTitle", ""]],
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrWizardPageNavTitle, [{
    type: Directive,
    args: [{
      selector: "[clrPageNavTitle]"
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var ClrWizardPageTitle = class {
  constructor(pageTitleTemplateRef) {
    this.pageTitleTemplateRef = pageTitleTemplateRef;
  }
};
ClrWizardPageTitle.ɵfac = function ClrWizardPageTitle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrWizardPageTitle)(ɵɵdirectiveInject(TemplateRef));
};
ClrWizardPageTitle.ɵdir = ɵɵdefineDirective({
  type: ClrWizardPageTitle,
  selectors: [["", "clrPageTitle", ""]],
  inputs: {
    headingLevel: [0, "clrHeadingLevel", "headingLevel"]
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrWizardPageTitle, [{
    type: Directive,
    args: [{
      selector: "[clrPageTitle]"
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, {
    headingLevel: [{
      type: Input,
      args: ["clrHeadingLevel"]
    }]
  });
})();
var wizardPageIndex = 0;
var ClrWizardPage = class {
  /**
   * Creates an instance of ClrWizardPage.
   *
   * @memberof WizardPage
   */
  constructor(navService, pageCollection, buttonService) {
    this.navService = navService;
    this.pageCollection = pageCollection;
    this.buttonService = buttonService;
    this._id = (wizardPageIndex++).toString();
    this.preventDefault = false;
    this.nextStepDisabledChange = new EventEmitter();
    this.previousStepDisabledChange = new EventEmitter();
    this.stopCancelChange = new EventEmitter();
    this.onCommit = new EventEmitter(false);
    this.onLoad = new EventEmitter();
    this.pageOnCancel = new EventEmitter();
    this.finishButtonClicked = new EventEmitter();
    this.previousButtonClicked = new EventEmitter();
    this.nextButtonClicked = new EventEmitter();
    this.dangerButtonClicked = new EventEmitter();
    this.primaryButtonClicked = new EventEmitter();
    this.customButtonClicked = new EventEmitter();
    this._nextStepDisabled = false;
    this._previousStepDisabled = false;
    this._hasError = false;
    this._stopCancel = false;
    this._stopNext = false;
    this._complete = false;
  }
  /**
   * A property that tells whether or not the wizard should be allowed
   * to move to the next page.
   *
   * Useful for in-page validation because it prevents forward navigation
   * and visibly disables the next button.
   *
   * Does not require that you re-implement navigation routines like you
   * would if you were using ClrWizardPage.preventDefault or
   * Wizard.preventDefault.
   *
   * @memberof WizardPage
   *
   */
  get nextStepDisabled() {
    return this._nextStepDisabled;
  }
  set nextStepDisabled(val) {
    const valBool = !!val;
    if (valBool !== this._nextStepDisabled) {
      this._nextStepDisabled = valBool;
      this.nextStepDisabledChange.emit(valBool);
    }
  }
  /**
   * A property that tells whether or not the wizard should be allowed
   * to move to the previous page.
   *
   * Useful for in-page validation because it prevents backward navigation
   * and visibly disables the previous button.
   *
   * Does not require that you re-implement navigation routines like you
   * would if you were using ClrWizardPage.preventDefault or
   * Wizard.preventDefault.
   *
   * @memberof WizardPage
   *
   */
  get previousStepDisabled() {
    return this._previousStepDisabled;
  }
  set previousStepDisabled(val) {
    const valBool = !!val;
    if (valBool !== this._previousStepDisabled) {
      this._previousStepDisabled = valBool;
      this.previousStepDisabledChange.emit(valBool);
    }
  }
  /**
   * Whether the page has an error and also resolve the "falsy" value. The
   * current logic treat a "0" or an empty string as false and likewise will treat any
   * "truthy" value as true.
   *
   * @memberof WizardPage
   *
   */
  get hasError() {
    return this._hasError;
  }
  set hasError(val) {
    const valBool = !!val;
    if (valBool !== this._hasError) {
      this._hasError = valBool;
    }
  }
  /**
   * Overrides the cancel action from the page level. Allows you to use an
   * alternate function for validation or data-munging before cancelling the
   * wizard when combined with the ClrWizardPage.onCancel
   * (the clrWizardPageOnCancel output).
   *
   * Requires that you manually close the wizard from your host component,
   * usually with a call to Wizard.forceNext() or wizard.next();
   *
   * @memberof ClrWizardPage
   */
  get stopCancel() {
    return this._stopCancel;
  }
  set stopCancel(val) {
    const valBool = !!val;
    if (valBool !== this._stopCancel) {
      this._stopCancel = valBool;
      this.stopCancelChange.emit(valBool);
    }
  }
  /**
   * Overrides forward navigation from the page level. Allows you to use an
   * alternate function for validation or data-munging before moving the
   * wizard to the next pagewhen combined with the ClrWizardPage.onCommit
   * (clrWizardPageOnCommit) or ClrWizardPage.nextButtonClicked
   * (clrWizardPageNext) outputs.
   *
   * Requires that you manually tell the wizard to navigate forward from
   * the hostComponent, usually with a call to Wizard.forceNext() or
   * wizard.next();
   *
   * @memberof ClrWizardPage
   */
  get stopNext() {
    return this._stopNext;
  }
  set stopNext(val) {
    const valBool = !!val;
    if (valBool !== this._stopNext) {
      this._stopNext = valBool;
    }
  }
  /**
   * A read-only getter that generates an ID string for the wizard page from
   * either the value passed to the ClrWizardPage "id" input or a wizard page
   * counter shared across all wizard pages in the application.
   *
   * Note that the value passed into the ID input Will be prefixed with
   * "clr-wizard-page-".
   *
   * @readonly
   *
   * @memberof ClrWizardPage
   */
  get id() {
    const idIsNonZeroFalsy = !this._id && this._id !== 0;
    if (idIsNonZeroFalsy || this._id < 0) {
      this._id = (wizardPageIndex++).toString();
    }
    return `clr-wizard-page-${this._id}`;
  }
  /**
   * A read-only getter that serves as a convenience for those who would rather
   * not think in the terms of !ClrWizardPage.nextStepDisabled. For some use cases,
   * ClrWizardPage.readyToComplete is more logical and declarative.
   *
   * @memberof WizardPage
   *
   */
  get readyToComplete() {
    return !this.nextStepDisabled;
  }
  /**
   * A page is marked as completed if it is both readyToComplete and completed,
   * as in the next or finish action has been executed while this page was current.
   *
   * Note there is and open question about how to handle pages that are marked
   * complete but who are no longer readyToComplete. This might indicate an error
   * state for the ClrWizardPage. Currently, the wizard does not acknowledge this state
   * and only returns that the page is incomplete.
   *
   * @memberof WizardPage
   *
   */
  get completed() {
    return this._complete && this.readyToComplete;
  }
  /**
   * A ClrWizardPage can be manually set to completed using this boolean setter.
   * It is recommended that users rely on the convenience functions in the wizard
   * and navigation service instead of manually setting pages’ completion state.
   *
   * @memberof ClrWizardPage
   */
  set completed(value) {
    this._complete = value;
  }
  /**
   * Checks with the navigation service to see if it is the current page.
   *
   * @memberof WizardPage
   *
   */
  get current() {
    return this.navService.currentPage === this;
  }
  get disabled() {
    return !this.enabled;
  }
  /**
   * A read-only getter that returns whether or not the page is navigable
   * in the wizard. A wizard page can be navigated to if it is completed
   * or the page before it is completed.
   *
   * This getter handles the logic for enabling or disabling the links in
   * the step nav on the left Side of the wizard.
   *
   * @memberof WizardPage
   *
   */
  get enabled() {
    return this.current || this.completed || this.previousCompleted;
  }
  /**
   * A read-only getter that returns whether or not the page before this
   * ClrWizardPage is completed. This is useful for determining whether or not
   * a page is navigable if it is not current or already completed.
   *
   * @memberof WizardPage
   *
   */
  get previousCompleted() {
    const previousPage = this.pageCollection.getPreviousPage(this);
    if (!previousPage) {
      return true;
    }
    return previousPage.completed;
  }
  /**
   *
   * @memberof WizardPage
   *
   */
  get title() {
    return this.pageTitle.pageTitleTemplateRef;
  }
  /**
   *
   * @memberof WizardPage
   *
   */
  get navTitle() {
    if (this.pageNavTitle) {
      return this.pageNavTitle.pageNavTitleTemplateRef;
    }
    return this.pageTitle.pageTitleTemplateRef;
  }
  /**
   *
   * @memberof WizardPage
   *
   */
  get headerActions() {
    if (!this._headerActions) {
      return void 0;
    }
    return this._headerActions.pageHeaderActionsTemplateRef;
  }
  /**
   *
   * @memberof WizardPage
   *
   */
  get hasHeaderActions() {
    return !!this._headerActions;
  }
  /**
   *
   * @memberof WizardPage
   *
   */
  get buttons() {
    if (!this._buttons) {
      return void 0;
    }
    return this._buttons.pageButtonsTemplateRef;
  }
  /**
   * A read-only getter that returns a boolean that says whether or
   * not the ClrWizardPage includes buttons. Used to determine if the
   * Wizard should override the default button set defined as
   * its direct children.
   *
   * @memberof WizardPage
   *
   */
  get hasButtons() {
    return !!this._buttons;
  }
  /**
   * A read-only getter that returns the id used by the step nav item associated with the page.
   *
   * ClrWizardPage needs this ID string for aria information.
   *
   * @memberof WizardPage
   *
   */
  get stepItemId() {
    return this.pageCollection.getStepItemIdForPage(this);
  }
  /**
   * Links the nav service and establishes the current page if one is not defined.
   *
   * @memberof WizardPage
   *
   */
  ngOnInit() {
    const navService = this.navService;
    if (!navService.currentPage && !navService.navServiceLoaded) {
      this.makeCurrent();
      this.navService.navServiceLoaded = true;
    }
  }
  /**
   * Uses the nav service to make the ClrWizardPage the current page in the
   * wizard. Bypasses all checks but still emits the ClrWizardPage.onLoad
   * (clrWizardPageOnLoad) output.
   *
   * In most cases, it is better to use the default navigation functions
   * in Wizard.
   *
   * @memberof WizardPage
   *
   */
  makeCurrent() {
    this.navService.currentPage = this;
  }
};
ClrWizardPage.ɵfac = function ClrWizardPage_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrWizardPage)(ɵɵdirectiveInject(WizardNavigationService), ɵɵdirectiveInject(PageCollectionService), ɵɵdirectiveInject(ButtonHubService));
};
ClrWizardPage.ɵcmp = ɵɵdefineComponent({
  type: ClrWizardPage,
  selectors: [["clr-wizard-page"]],
  contentQueries: function ClrWizardPage_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrWizardPageTitle, 7);
      ɵɵcontentQuery(dirIndex, ClrWizardPageNavTitle, 7);
      ɵɵcontentQuery(dirIndex, ClrWizardPageButtons, 7);
      ɵɵcontentQuery(dirIndex, ClrWizardPageHeaderActions, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.pageTitle = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.pageNavTitle = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._buttons = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._headerActions = _t.first);
    }
  },
  hostVars: 7,
  hostBindings: function ClrWizardPage_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵhostProperty("id", ctx.id);
      ɵɵattribute("aria-hidden", !ctx.current)("aria-labelledby", ctx.stepItemId);
      ɵɵclassProp("active", ctx.current)("clr-wizard-page", true);
    }
  },
  inputs: {
    _id: [0, "id", "_id"],
    preventDefault: [0, "clrWizardPagePreventDefault", "preventDefault"],
    nextStepDisabled: [0, "clrWizardPageNextDisabled", "nextStepDisabled"],
    previousStepDisabled: [0, "clrWizardPagePreviousDisabled", "previousStepDisabled"],
    hasError: [0, "clrWizardPageHasError", "hasError"],
    stopCancel: [0, "clrWizardPagePreventDefaultCancel", "stopCancel"],
    stopNext: [0, "clrWizardPagePreventDefaultNext", "stopNext"]
  },
  outputs: {
    nextStepDisabledChange: "clrWizardPageNextDisabledChange",
    previousStepDisabledChange: "clrWizardPagePreviousDisabledChange",
    stopCancelChange: "clrWizardPagePreventDefaultCancelChange",
    onCommit: "clrWizardPageOnCommit",
    onLoad: "clrWizardPageOnLoad",
    pageOnCancel: "clrWizardPageOnCancel",
    finishButtonClicked: "clrWizardPageFinish",
    previousButtonClicked: "clrWizardPagePrevious",
    nextButtonClicked: "clrWizardPageNext",
    dangerButtonClicked: "clrWizardPageDanger",
    primaryButtonClicked: "clrWizardPagePrimary",
    customButtonClicked: "clrWizardPageCustomButton"
  },
  standalone: false,
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrWizardPage_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrWizardPage, [{
    type: Component,
    args: [{
      selector: "clr-wizard-page",
      template: "<ng-content></ng-content>",
      host: {
        "[id]": "id",
        "[attr.aria-hidden]": "!current",
        "[attr.aria-labelledby]": "stepItemId",
        "[class.active]": "current",
        "[class.clr-wizard-page]": "true"
      }
    }]
  }], function() {
    return [{
      type: WizardNavigationService
    }, {
      type: PageCollectionService
    }, {
      type: ButtonHubService
    }];
  }, {
    _id: [{
      type: Input,
      args: ["id"]
    }],
    preventDefault: [{
      type: Input,
      args: ["clrWizardPagePreventDefault"]
    }],
    nextStepDisabledChange: [{
      type: Output,
      args: ["clrWizardPageNextDisabledChange"]
    }],
    previousStepDisabledChange: [{
      type: Output,
      args: ["clrWizardPagePreviousDisabledChange"]
    }],
    stopCancelChange: [{
      type: Output,
      args: ["clrWizardPagePreventDefaultCancelChange"]
    }],
    onCommit: [{
      type: Output,
      args: ["clrWizardPageOnCommit"]
    }],
    onLoad: [{
      type: Output,
      args: ["clrWizardPageOnLoad"]
    }],
    pageOnCancel: [{
      type: Output,
      args: ["clrWizardPageOnCancel"]
    }],
    finishButtonClicked: [{
      type: Output,
      args: ["clrWizardPageFinish"]
    }],
    previousButtonClicked: [{
      type: Output,
      args: ["clrWizardPagePrevious"]
    }],
    nextButtonClicked: [{
      type: Output,
      args: ["clrWizardPageNext"]
    }],
    dangerButtonClicked: [{
      type: Output,
      args: ["clrWizardPageDanger"]
    }],
    primaryButtonClicked: [{
      type: Output,
      args: ["clrWizardPagePrimary"]
    }],
    customButtonClicked: [{
      type: Output,
      args: ["clrWizardPageCustomButton"]
    }],
    pageTitle: [{
      type: ContentChild,
      args: [ClrWizardPageTitle, {
        static: true
      }]
    }],
    pageNavTitle: [{
      type: ContentChild,
      args: [ClrWizardPageNavTitle, {
        static: true
      }]
    }],
    _buttons: [{
      type: ContentChild,
      args: [ClrWizardPageButtons, {
        static: true
      }]
    }],
    _headerActions: [{
      type: ContentChild,
      args: [ClrWizardPageHeaderActions, {
        static: true
      }]
    }],
    nextStepDisabled: [{
      type: Input,
      args: ["clrWizardPageNextDisabled"]
    }],
    previousStepDisabled: [{
      type: Input,
      args: ["clrWizardPagePreviousDisabled"]
    }],
    hasError: [{
      type: Input,
      args: ["clrWizardPageHasError"]
    }],
    stopCancel: [{
      type: Input,
      args: ["clrWizardPagePreventDefaultCancel"]
    }],
    stopNext: [{
      type: Input,
      args: ["clrWizardPagePreventDefaultNext"]
    }]
  });
})();
var ClrWizardTitle = class {
};
ClrWizardTitle.ɵfac = function ClrWizardTitle_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrWizardTitle)();
};
ClrWizardTitle.ɵdir = ɵɵdefineDirective({
  type: ClrWizardTitle,
  selectors: [["clr-wizard-title"]],
  inputs: {
    headingLevel: [0, "clrHeadingLevel", "headingLevel"]
  },
  standalone: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrWizardTitle, [{
    type: Directive,
    args: [{
      selector: "clr-wizard-title"
    }]
  }], null, {
    headingLevel: [{
      type: Input,
      args: ["clrHeadingLevel"]
    }]
  });
})();
var ClrWizardStepnavItem = class {
  constructor(navService, pageCollection, commonStrings) {
    this.navService = navService;
    this.pageCollection = pageCollection;
    this.commonStrings = commonStrings;
  }
  get id() {
    this.pageGuard();
    return this.pageCollection.getStepItemIdForPage(this.page);
  }
  get stepAriaCurrent() {
    return this.isCurrent && "step";
  }
  get isDisabled() {
    this.pageGuard();
    return this.page.disabled || this.navService.wizardStopNavigation || this.navService.wizardDisableStepnav;
  }
  get isCurrent() {
    this.pageGuard();
    return this.page.current;
  }
  get isComplete() {
    this.pageGuard();
    return this.page.completed;
  }
  get hasError() {
    this.pageGuard();
    return this.page.hasError && this.isComplete;
  }
  get canNavigate() {
    this.pageGuard();
    return this.pageCollection.previousPageIsCompleted(this.page);
  }
  click() {
    this.pageGuard();
    if (this.isDisabled || this.isCurrent) {
      return;
    }
    this.navService.goTo(this.page);
  }
  pageGuard() {
    if (!this.page) {
      throw new Error("Wizard stepnav item is not associated with a wizard page.");
    }
  }
};
ClrWizardStepnavItem.ɵfac = function ClrWizardStepnavItem_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrWizardStepnavItem)(ɵɵdirectiveInject(WizardNavigationService), ɵɵdirectiveInject(PageCollectionService), ɵɵdirectiveInject(ClrCommonStringsService));
};
ClrWizardStepnavItem.ɵcmp = ɵɵdefineComponent({
  type: ClrWizardStepnavItem,
  selectors: [["", "clr-wizard-stepnav-item", ""]],
  hostVars: 17,
  hostBindings: function ClrWizardStepnavItem_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵhostProperty("id", ctx.id);
      ɵɵattribute("aria-current", ctx.stepAriaCurrent)("aria-controls", ctx.page.id);
      ɵɵclassProp("clr-nav-link", true)("nav-item", true)("active", ctx.isCurrent)("disabled", ctx.isDisabled)("no-click", !ctx.canNavigate)("complete", ctx.isComplete)("error", ctx.hasError);
    }
  },
  inputs: {
    page: "page"
  },
  standalone: false,
  attrs: _c113,
  ngContentSelectors: _c02,
  decls: 10,
  vars: 5,
  consts: [["type", "button", 1, "btn", "btn-link", "clr-wizard-stepnav-link", 3, "click"], [1, "clr-wizard-stepnav-link-icon"], ["shape", "error-standard", 4, "ngIf"], ["shape", "success-standard", 4, "ngIf"], [1, "clr-sr-only"], [1, "clr-wizard-stepnav-link-page-number"], [1, "clr-wizard-stepnav-link-title"], [3, "ngTemplateOutlet"], ["shape", "error-standard"], ["shape", "success-standard"]],
  template: function ClrWizardStepnavItem_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "button", 0);
      ɵɵlistener("click", function ClrWizardStepnavItem_Template_button_click_0_listener() {
        return ctx.click();
      });
      ɵɵelementStart(1, "div", 1);
      ɵɵtemplate(2, ClrWizardStepnavItem_cds_icon_2_Template, 1, 1, "cds-icon", 2)(3, ClrWizardStepnavItem_cds_icon_3_Template, 1, 1, "cds-icon", 3);
      ɵɵelementEnd();
      ɵɵelementStart(4, "span", 4);
      ɵɵtext(5);
      ɵɵelementEnd();
      ɵɵelementStart(6, "div", 5);
      ɵɵprojection(7);
      ɵɵelementEnd();
      ɵɵelementStart(8, "span", 6);
      ɵɵtemplate(9, ClrWizardStepnavItem_ng_template_9_Template, 0, 0, "ng-template", 7);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵattribute("disabled", ctx.isDisabled ? "" : null);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.hasError);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.hasError && ctx.isComplete);
      ɵɵadvance(2);
      ɵɵtextInterpolate(ctx.commonStrings.keys.wizardStep);
      ɵɵadvance(4);
      ɵɵproperty("ngTemplateOutlet", ctx.page.navTitle);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, CdsIconCustomTag],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrWizardStepnavItem, [{
    type: Component,
    args: [{
      selector: "[clr-wizard-stepnav-item]",
      template: `
    <button
      type="button"
      class="btn btn-link clr-wizard-stepnav-link"
      (click)="click()"
      [attr.disabled]="isDisabled ? '' : null"
    >
      <div class="clr-wizard-stepnav-link-icon">
        <cds-icon
          *ngIf="hasError"
          shape="error-standard"
          [attr.aria-label]="commonStrings.keys.wizardStepError"
        ></cds-icon>
        <cds-icon
          *ngIf="!hasError && isComplete"
          shape="success-standard"
          [attr.aria-label]="commonStrings.keys.wizardStepSuccess"
        ></cds-icon>
      </div>

      <span class="clr-sr-only">{{ commonStrings.keys.wizardStep }}</span>
      <div class="clr-wizard-stepnav-link-page-number"><ng-content></ng-content></div>
      <span class="clr-wizard-stepnav-link-title">
        <ng-template [ngTemplateOutlet]="page.navTitle"></ng-template>
      </span>
    </button>
  `,
      host: {
        "[id]": "id",
        "[attr.aria-current]": "stepAriaCurrent",
        "[attr.aria-controls]": "page.id",
        "[class.clr-nav-link]": "true",
        "[class.nav-item]": "true",
        "[class.active]": "isCurrent",
        "[class.disabled]": "isDisabled",
        "[class.no-click]": "!canNavigate",
        "[class.complete]": "isComplete",
        "[class.error]": "hasError"
      }
    }]
  }], function() {
    return [{
      type: WizardNavigationService
    }, {
      type: PageCollectionService
    }, {
      type: ClrCommonStringsService
    }];
  }, {
    page: [{
      type: Input,
      args: ["page"]
    }]
  });
})();
var ClrWizardStepnav = class {
  constructor(pageService) {
    this.pageService = pageService;
  }
};
ClrWizardStepnav.ɵfac = function ClrWizardStepnav_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrWizardStepnav)(ɵɵdirectiveInject(PageCollectionService));
};
ClrWizardStepnav.ɵcmp = ɵɵdefineComponent({
  type: ClrWizardStepnav,
  selectors: [["clr-wizard-stepnav"]],
  hostAttrs: [1, "clr-wizard-stepnav"],
  standalone: false,
  decls: 2,
  vars: 1,
  consts: [[1, "clr-wizard-stepnav-list"], ["clr-wizard-stepnav-item", "", "class", "clr-wizard-stepnav-item", 3, "page", 4, "ngFor", "ngForOf"], ["clr-wizard-stepnav-item", "", 1, "clr-wizard-stepnav-item", 3, "page"]],
  template: function ClrWizardStepnav_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtemplate(1, ClrWizardStepnav_div_1_Template, 2, 2, "div", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.pageService.pages);
    }
  },
  dependencies: [NgForOf, ClrWizardStepnavItem],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrWizardStepnav, [{
    type: Component,
    args: [{
      selector: "clr-wizard-stepnav",
      template: `
    <div class="clr-wizard-stepnav-list">
      <div
        *ngFor="let page of pageService.pages; let i = index"
        clr-wizard-stepnav-item
        [page]="page"
        class="clr-wizard-stepnav-item"
      >
        {{ i + 1 }}
      </div>
    </div>
  `,
      host: {
        class: "clr-wizard-stepnav"
      }
    }]
  }], function() {
    return [{
      type: PageCollectionService
    }];
  }, null);
})();
var ClrWizard = class {
  constructor(platformId, commonStrings, navService, pageCollection, buttonService, headerActionService, elementRef, differs) {
    this.platformId = platformId;
    this.commonStrings = commonStrings;
    this.navService = navService;
    this.pageCollection = pageCollection;
    this.buttonService = buttonService;
    this.headerActionService = headerActionService;
    this.elementRef = elementRef;
    this.stepnavAriaLabel = this.commonStrings.keys.wizardStepnavAriaLabel;
    this.size = "xl";
    this.closable = true;
    this._stopModalAnimations = false;
    this._openChanged = new EventEmitter(false);
    this.onCancel = new EventEmitter(false);
    this.wizardFinished = new EventEmitter(false);
    this.onReset = new EventEmitter(false);
    this.currentPageChanged = new EventEmitter(false);
    this.onMoveNext = new EventEmitter(false);
    this.onMovePrevious = new EventEmitter(false);
    this._open = false;
    this.wizardId = uniqueIdFactory();
    this._forceForward = false;
    this._stopNext = false;
    this._stopCancel = false;
    this._stopNavigation = false;
    this._disableStepnav = false;
    this.subscriptions = [];
    this.subscriptions.push(this.listenForNextPageChanges(), this.listenForPreviousPageChanges(), this.listenForCancelChanges(), this.listenForFinishedChanges(), this.listenForPageChanges());
    this.differ = differs.find([]).create(null);
  }
  /**
   * Resets page completed states when navigating backwards.
   * Set using `[clrWizardForceForwardNavigation]` input.
   */
  get forceForward() {
    return this._forceForward;
  }
  set forceForward(value) {
    this._forceForward = !!value;
    this.navService.forceForwardNavigation = value;
  }
  /**
   * Toggles open/close of the wizard component.
   * Set using the `[clrWizardOpen]` input.
   */
  set clrWizardOpen(open) {
    if (open) {
      this.buttonService.buttonsReady = true;
    }
    this._open = open;
  }
  /**
   * Prevents ClrWizard from moving to the next page or closing itself on finishing.
   * Set using the `[clrWizardPreventDefaultNext]` input. Note that using stopNext
   * will require you to create your own calls to .next() and .finish() in your
   * host component to make the ClrWizard work as expected.
   */
  get stopNext() {
    return this._stopNext;
  }
  set stopNext(value) {
    this._stopNext = !!value;
    this.navService.wizardHasAltNext = value;
  }
  /**
   * Prevents ClrWizard from closing when the cancel button or close "X" is clicked.
   * Set using the `[clrWizardPreventDefaultCancel]` input.
   *
   * Note that using stopCancel will require you to create your own calls to `close()` in your host compone`nt
   * to make the ClrWizard work as expected. Useful for doing checks or prompts
   * before closing a ClrWizard.
   */
  get stopCancel() {
    return this._stopCancel;
  }
  set stopCancel(value) {
    this._stopCancel = !!value;
    this.navService.wizardHasAltCancel = value;
  }
  /**
   * Prevents ClrWizard from performing any form of navigation away from the current
   * page. Set using the `[clrWizardPreventNavigation]` input.
   * Note that stopNavigation is meant to freeze the wizard in place, typically
   * during a long validation or background action where you want the wizard to
   * display loading content but not allow the user to execute navigation in
   * the stepnav, close X, or the  back, finish, or next buttons.
   */
  get stopNavigation() {
    return this._stopNavigation;
  }
  set stopNavigation(value) {
    this._stopNavigation = !!value;
    this.navService.wizardStopNavigation = value;
  }
  /**
   * Prevents clicks on the links in the stepnav from working.
   * Set using `[clrWizardDisableStepnav]` input.
   * A more granular bypassing of navigation which can be useful when your
   * ClrWizard is in a state of completion and you don't want users to be
   * able to jump backwards and change things.
   */
  get disableStepnav() {
    return this._disableStepnav;
  }
  set disableStepnav(value) {
    this._disableStepnav = !!value;
    this.navService.wizardDisableStepnav = value;
  }
  get currentPage() {
    return this.navService.currentPage;
  }
  set currentPage(page) {
    this.navService.goTo(page, true);
  }
  get isLast() {
    return this.navService.currentPageIsLast;
  }
  get isFirst() {
    return this.navService.currentPageIsFirst;
  }
  get isInline() {
    return this.elementRef.nativeElement.classList.contains("clr-wizard--inline");
  }
  get stopModalAnimations() {
    return this._stopModalAnimations ? "true" : "false";
  }
  ngAfterContentInit() {
    this.pageCollection.pages = this.pages;
    this.headerActionService.wizardHeaderActions = this.headerActions;
    this.initializeButtons();
  }
  ngDoCheck() {
    this.updateNavOnPageChanges();
  }
  ngOnDestroy() {
    this.subscriptions.forEach((s) => s.unsubscribe());
  }
  /**
   * Marks Wizard as finished. By default it does not execute event
   * emissions or checks before completing and closing. This method is commonly
   * used as part of an alternative navigation with `[clrWizardPreventDefaultNext]`.
   *
   * If `skipChecksAndEmits` is true, the wizard will complete and close
   * regardless of the state of its current page. This is useful for alternative
   * navigation where event emissions have already been done and firing them again
   * may cause an event loop.
   */
  finish(skipChecksAndEmits = true) {
    if (skipChecksAndEmits) {
      this.forceFinish();
    } else {
      this.navService.finish();
    }
  }
  /**
   * Marks the wizard as finished but does run checks and emissions.
   * Good for a last step in an alternate workflow. Does the same thing as
   * calling `ClrWizard.finish(true)` or `ClrWizard.finish()` without a parameter.
   */
  forceFinish() {
    if (this.stopNavigation) {
      return;
    }
    this.close();
  }
  /**
   * Opens the wizard. If there is no current page defined, sets the first page in the wizard to be current.
   */
  open() {
    this._open = true;
    if (!this.currentPage) {
      this.navService.setFirstPageCurrent();
    }
    this.buttonService.buttonsReady = true;
    this._openChanged.emit(true);
  }
  /**
   * Closes the wizard. Call this directly instead of `cancel()` to implement alternative cancel functionality.
   */
  close() {
    if (this.stopNavigation) {
      return;
    }
    this._open = false;
    this._openChanged.emit(false);
  }
  /**
   * Used to open and close the wizard. By default the wizard will
   * close if invoked with no parameter. If parameter is true wizard will open
   * else if false will close.
   */
  toggle(open) {
    if (open) {
      this.open();
    } else {
      this.close();
    }
  }
  /**
   * Moves the wizard to the previous page.
   */
  previous() {
    this.navService.previous();
  }
  /**
   * By default, `next()` does not execute event emissions.
   * This method is commonly called as part of an alternative navigation
   * with `[clrWizardPreventDefaultNext]`. The wizard will move to the next page
   * regardless of the state of its current page. This is useful for alternative
   * navigation where event emissions have already been done and firing them again
   * may cause an event loop.
   *
   * If `skipChecksAndEmits` is false, the wizard will execute default checks
   * and emit events as normal. This is useful for custom buttons or programmatic
   * workflows that are not executing the wizards default checks and emissions.
   * It is another way to navigate without having to rewrite the wizard’s default
   * functionality from scratch.
   */
  next(skipChecksAndEmits = true) {
    if (skipChecksAndEmits) {
      this.forceNext();
    } else {
      this.navService.next();
    }
  }
  /**
   * Moves the wizard to the next page without the checks and emissions.
   * Good for a last step in an alternate workflow.
   * Alias for `ClrWizard.next(true)` or `ClrWizard.next()`
   */
  forceNext() {
    this.navService.forceNext();
  }
  /**
   * Cancels and closes the wizard. Do not use this for an override of the cancel
   * the functionality with `[clrWizardPreventDefaultCancel]`, `[clrWizardPreventPageDefaultCancel]`,
   * or `[clrWizardPagePreventDefault]` because it will initiate the same checks
   * and event emissions that invoked your event handler. Use `ClrWizard.close()` instead.
   */
  cancel() {
    this.navService.cancel();
  }
  /**
   * Overrides behavior of the underlying modal to avoid collisions with
   * alternative cancel functionality. In most cases, use `ClrWizard.cancel()` instead.
   */
  modalCancel() {
    if (this.closable) {
      this.checkAndCancel();
    }
  }
  /**
   * Checks for alternative cancel flows defined at the current page or
   * wizard level. Performs a canceled if not. Emits events that initiate
   * the alternative cancel outputs `(clrWizardPageOnCancel)` and `(clrWizardOnCancel)`.
   */
  checkAndCancel() {
    const currentPage = this.currentPage;
    const currentPageHasOverrides = currentPage.stopCancel || currentPage.preventDefault;
    if (this.stopNavigation) {
      return;
    }
    currentPage.pageOnCancel.emit();
    if (!currentPageHasOverrides) {
      this.onCancel.emit();
    }
    if (!this.stopCancel && !currentPageHasOverrides) {
      this.close();
    }
  }
  /**
   * Navigates to a given page in the Wizard. Navigation will invoke the wizard’s default
   * checks and event emissions.
   *
   * The format of the expected ID parameter can be found in the return of the
   * ClrWizardPage.id getter, usually prefixed with `clr-wizard-page-` and then either a
   * numeric ID or the ID specified for the `ClrWizardPage` component’s `id` input.
   */
  goTo(pageId) {
    if (!pageId) {
      return;
    }
    this.navService.goTo(pageId);
  }
  /**
   * Reset sets all WizardPages to incomplete and sets the first page in the `ClrWizard` to
   * be the current page, resetting the wizard navigation.
   * Use `(clrWizardOnReset)` event to reset the data or model of your wizard.
   */
  reset() {
    this.pageCollection.reset();
    this.onReset.emit();
  }
  listenForNextPageChanges() {
    return this.navService.movedToNextPage.pipe(filter(() => isPlatformBrowser(this.platformId))).subscribe(() => {
      this.onMoveNext.emit();
      this.pageTitle?.nativeElement.focus();
    });
  }
  listenForPreviousPageChanges() {
    return this.navService.movedToPreviousPage.pipe(filter(() => isPlatformBrowser(this.platformId))).subscribe(() => {
      this.onMovePrevious.emit();
      this.pageTitle?.nativeElement.focus();
    });
  }
  listenForCancelChanges() {
    return this.navService.notifyWizardCancel.subscribe(() => this.checkAndCancel());
  }
  listenForFinishedChanges() {
    return this.navService.wizardFinished.subscribe(() => this.emitWizardFinished());
  }
  listenForPageChanges() {
    return this.navService.currentPageChanged.subscribe(() => {
      this.pageTitle?.nativeElement.focus();
      this.currentPageChanged.emit();
    });
  }
  updateNavOnPageChanges() {
    const changes = this.differ.diff(this.pages);
    if (changes) {
      changes.forEachAddedItem(() => this.navService.updateNavigation());
      changes.forEachRemovedItem(() => this.navService.updateNavigation());
    }
  }
  initializeButtons() {
    if (this._open) {
      this.buttonService.buttonsReady = true;
    }
  }
  emitWizardFinished() {
    if (!this.stopNext) {
      this.forceFinish();
    }
    this.wizardFinished.emit();
  }
};
ClrWizard.ɵfac = function ClrWizard_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrWizard)(ɵɵdirectiveInject(PLATFORM_ID), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(WizardNavigationService), ɵɵdirectiveInject(PageCollectionService), ɵɵdirectiveInject(ButtonHubService), ɵɵdirectiveInject(HeaderActionService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(IterableDiffers));
};
ClrWizard.ɵcmp = ɵɵdefineComponent({
  type: ClrWizard,
  selectors: [["clr-wizard"]],
  contentQueries: function ClrWizard_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrWizardTitle, 5);
      ɵɵcontentQuery(dirIndex, ClrWizardPage, 5);
      ɵɵcontentQuery(dirIndex, ClrWizardHeaderAction, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.wizardTitle = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.pages = _t);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerActions = _t);
    }
  },
  viewQuery: function ClrWizard_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c114, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.pageTitle = _t.first);
    }
  },
  hostVars: 10,
  hostBindings: function ClrWizard_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-wizard", true)("wizard-md", ctx.size == "md")("wizard-lg", ctx.size == "lg")("wizard-xl", ctx.size == "xl")("lastPage", ctx.navService.currentPageIsLast);
    }
  },
  inputs: {
    stepnavAriaLabel: [0, "clrWizardStepnavAriaLabel", "stepnavAriaLabel"],
    size: [0, "clrWizardSize", "size"],
    closable: [0, "clrWizardClosable", "closable"],
    _stopModalAnimations: [0, "clrWizardPreventModalAnimation", "_stopModalAnimations"],
    forceForward: [0, "clrWizardForceForwardNavigation", "forceForward"],
    clrWizardOpen: "clrWizardOpen",
    stopNext: [0, "clrWizardPreventDefaultNext", "stopNext"],
    stopCancel: [0, "clrWizardPreventDefaultCancel", "stopCancel"],
    stopNavigation: [0, "clrWizardPreventNavigation", "stopNavigation"],
    disableStepnav: [0, "clrWizardDisableStepnav", "disableStepnav"]
  },
  outputs: {
    _openChanged: "clrWizardOpenChange",
    onCancel: "clrWizardOnCancel",
    wizardFinished: "clrWizardOnFinish",
    onReset: "clrWizardOnReset",
    currentPageChanged: "clrWizardCurrentPageChanged",
    onMoveNext: "clrWizardOnNext",
    onMovePrevious: "clrWizardOnPrevious"
  },
  standalone: false,
  features: [ɵɵProvidersFeature([WizardNavigationService, PageCollectionService, ButtonHubService, HeaderActionService])],
  ngContentSelectors: _c116,
  decls: 17,
  vars: 16,
  consts: [["pageTitle", ""], [3, "clrModalAlternateClose", "clrModalOpen", "clrModalSize", "clrModalClosable", "clrModalStaticBackdrop", "clrModalSkipAnimation", "clrModalOverrideScrollService", "clrModalPreventClose", "clrModalLabelledById"], ["role", "region", 1, "modal-nav", "clr-wizard-stepnav-wrapper"], ["role", "heading", 1, "clr-wizard-title", 3, "id"], ["role", "heading", 1, "modal-title"], ["tabindex", "-1", 1, "modal-title-text"], [3, "ngTemplateOutlet"], ["class", "modal-header-actions-wrapper", 4, "ngIf"], [1, "modal-body"], ["clr-wizard-pages-wrapper", "", 1, "clr-wizard-content"], [1, "modal-footer", "clr-wizard-footer"], [1, "clr-wizard-footer-buttons"], ["class", "clr-wizard-footer-buttons-wrapper", 4, "ngIf"], [1, "modal-header-actions-wrapper"], [4, "ngIf"], [1, "clr-wizard-footer-buttons-wrapper"]],
  template: function ClrWizard_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵprojectionDef(_c115);
      ɵɵelementStart(0, "clr-modal", 1);
      ɵɵlistener("clrModalAlternateClose", function ClrWizard_Template_clr_modal_clrModalAlternateClose_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.modalCancel());
      });
      ɵɵelementStart(1, "div", 2)(2, "div", 3);
      ɵɵprojection(3);
      ɵɵelementEnd();
      ɵɵelement(4, "clr-wizard-stepnav");
      ɵɵelementEnd();
      ɵɵelementStart(5, "div", 4)(6, "span", 5, 0);
      ɵɵtemplate(8, ClrWizard_ng_template_8_Template, 0, 0, "ng-template", 6);
      ɵɵelementEnd();
      ɵɵtemplate(9, ClrWizard_div_9_Template, 3, 2, "div", 7);
      ɵɵelementEnd();
      ɵɵelementStart(10, "div", 8)(11, "main", 9);
      ɵɵprojection(12, 1);
      ɵɵelementEnd()();
      ɵɵelementStart(13, "div", 10)(14, "div", 11);
      ɵɵtemplate(15, ClrWizard_div_15_Template, 2, 0, "div", 12)(16, ClrWizard_div_16_Template, 2, 1, "div", 12);
      ɵɵelementEnd()()();
    }
    if (rf & 2) {
      ɵɵproperty("clrModalOpen", ctx._open)("clrModalSize", ctx.size)("clrModalClosable", ctx.closable)("clrModalStaticBackdrop", true)("clrModalSkipAnimation", ctx.stopModalAnimations)("clrModalOverrideScrollService", ctx.isInline)("clrModalPreventClose", true)("clrModalLabelledById", ctx.wizardId);
      ɵɵadvance();
      ɵɵattribute("aria-label", ctx.stepnavAriaLabel);
      ɵɵadvance();
      ɵɵpropertyInterpolate("id", ctx.wizardId);
      ɵɵattribute("aria-level", ctx.wizardTitle.headingLevel || 1);
      ɵɵadvance(3);
      ɵɵattribute("aria-level", (ctx.navService.currentPage == null ? null : ctx.navService.currentPage.pageTitle.headingLevel) || 2);
      ɵɵadvance(3);
      ɵɵproperty("ngTemplateOutlet", ctx.navService.currentPageTitle);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.headerActionService.displayHeaderActionsWrapper);
      ɵɵadvance(6);
      ɵɵproperty("ngIf", ctx.navService.currentPage && !ctx.navService.currentPage.hasButtons);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.navService.currentPage && ctx.navService.currentPage.hasButtons);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, ClrModal, ClrModalBody, ClrWizardStepnav],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrWizard, [{
    type: Component,
    args: [{
      selector: "clr-wizard",
      providers: [WizardNavigationService, PageCollectionService, ButtonHubService, HeaderActionService],
      host: {
        "[class.clr-wizard]": "true",
        "[class.wizard-md]": "size == 'md'",
        "[class.wizard-lg]": "size == 'lg'",
        "[class.wizard-xl]": "size == 'xl'",
        "[class.lastPage]": "navService.currentPageIsLast"
      },
      template: '<!--\n  ~ Copyright (c) 2016-2024 Broadcom. All Rights Reserved.\n  ~ The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<clr-modal\n  [clrModalOpen]="_open"\n  [clrModalSize]="size"\n  [clrModalClosable]="closable"\n  [clrModalStaticBackdrop]="true"\n  [clrModalSkipAnimation]="stopModalAnimations"\n  [clrModalOverrideScrollService]="isInline"\n  [clrModalPreventClose]="true"\n  (clrModalAlternateClose)="modalCancel()"\n  [clrModalLabelledById]="wizardId"\n>\n  <div class="modal-nav clr-wizard-stepnav-wrapper" role="region" [attr.aria-label]="stepnavAriaLabel">\n    <div class="clr-wizard-title" id="{{wizardId}}" role="heading" [attr.aria-level]="wizardTitle.headingLevel || 1">\n      <ng-content select="clr-wizard-title"></ng-content>\n    </div>\n    <clr-wizard-stepnav></clr-wizard-stepnav>\n  </div>\n\n  <div class="modal-title" role="heading" [attr.aria-level]="navService.currentPage?.pageTitle.headingLevel || 2">\n    <span tabindex="-1" #pageTitle class="modal-title-text">\n      <ng-template [ngTemplateOutlet]="navService.currentPageTitle"></ng-template>\n    </span>\n\n    <div class="modal-header-actions-wrapper" *ngIf="headerActionService.displayHeaderActionsWrapper">\n      <div *ngIf="headerActionService.showWizardHeaderActions">\n        <ng-content select="clr-wizard-header-action"></ng-content>\n      </div>\n      <div *ngIf="headerActionService.currentPageHasHeaderActions">\n        <ng-template [ngTemplateOutlet]="navService.currentPage.headerActions"></ng-template>\n      </div>\n    </div>\n  </div>\n\n  <div class="modal-body">\n    <main clr-wizard-pages-wrapper class="clr-wizard-content">\n      <ng-content></ng-content>\n    </main>\n  </div>\n  <div class="modal-footer clr-wizard-footer">\n    <div class="clr-wizard-footer-buttons">\n      <div\n        *ngIf="navService.currentPage && !navService.currentPage.hasButtons"\n        class="clr-wizard-footer-buttons-wrapper"\n      >\n        <ng-content select="clr-wizard-button"></ng-content>\n      </div>\n      <div\n        *ngIf="navService.currentPage && navService.currentPage.hasButtons"\n        class="clr-wizard-footer-buttons-wrapper"\n      >\n        <ng-template [ngTemplateOutlet]="navService.currentPage.buttons"></ng-template>\n      </div>\n    </div>\n  </div>\n</clr-modal>\n'
    }]
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }, {
      type: ClrCommonStringsService
    }, {
      type: WizardNavigationService
    }, {
      type: PageCollectionService
    }, {
      type: ButtonHubService
    }, {
      type: HeaderActionService
    }, {
      type: ElementRef
    }, {
      type: IterableDiffers
    }];
  }, {
    stepnavAriaLabel: [{
      type: Input,
      args: ["clrWizardStepnavAriaLabel"]
    }],
    size: [{
      type: Input,
      args: ["clrWizardSize"]
    }],
    closable: [{
      type: Input,
      args: ["clrWizardClosable"]
    }],
    _stopModalAnimations: [{
      type: Input,
      args: ["clrWizardPreventModalAnimation"]
    }],
    _openChanged: [{
      type: Output,
      args: ["clrWizardOpenChange"]
    }],
    onCancel: [{
      type: Output,
      args: ["clrWizardOnCancel"]
    }],
    wizardFinished: [{
      type: Output,
      args: ["clrWizardOnFinish"]
    }],
    onReset: [{
      type: Output,
      args: ["clrWizardOnReset"]
    }],
    currentPageChanged: [{
      type: Output,
      args: ["clrWizardCurrentPageChanged"]
    }],
    onMoveNext: [{
      type: Output,
      args: ["clrWizardOnNext"]
    }],
    onMovePrevious: [{
      type: Output,
      args: ["clrWizardOnPrevious"]
    }],
    pageTitle: [{
      type: ViewChild,
      args: ["pageTitle"]
    }],
    pages: [{
      type: ContentChildren,
      args: [ClrWizardPage, {
        descendants: true
      }]
    }],
    headerActions: [{
      type: ContentChildren,
      args: [ClrWizardHeaderAction]
    }],
    wizardTitle: [{
      type: ContentChild,
      args: [ClrWizardTitle]
    }],
    forceForward: [{
      type: Input,
      args: ["clrWizardForceForwardNavigation"]
    }],
    clrWizardOpen: [{
      type: Input,
      args: ["clrWizardOpen"]
    }],
    stopNext: [{
      type: Input,
      args: ["clrWizardPreventDefaultNext"]
    }],
    stopCancel: [{
      type: Input,
      args: ["clrWizardPreventDefaultCancel"]
    }],
    stopNavigation: [{
      type: Input,
      args: ["clrWizardPreventNavigation"]
    }],
    disableStepnav: [{
      type: Input,
      args: ["clrWizardDisableStepnav"]
    }]
  });
})();
var DEFAULT_BUTTON_TYPES = {
  cancel: "cancel",
  previous: "previous",
  next: "next",
  finish: "finish",
  danger: "danger"
};
var CUSTOM_BUTTON_TYPES = {
  cancel: "custom-cancel",
  previous: "custom-previous",
  next: "custom-next",
  finish: "custom-finish",
  danger: "custom-danger"
};
var ClrWizardButton = class {
  constructor(navService, buttonService) {
    this.navService = navService;
    this.buttonService = buttonService;
    this.type = "";
    this.disabled = false;
    this.hidden = false;
    this.wasClicked = new EventEmitter(false);
  }
  get isCancel() {
    return this.checkDefaultAndCustomType(this.type, "cancel");
  }
  get isNext() {
    return this.checkDefaultAndCustomType(this.type, "next");
  }
  get isPrevious() {
    return this.checkDefaultAndCustomType(this.type, "previous");
  }
  get isFinish() {
    return this.checkDefaultAndCustomType(this.type, "finish");
  }
  get isDanger() {
    return this.checkDefaultAndCustomType(this.type, "danger");
  }
  get isPrimaryAction() {
    return this.isNext || this.isDanger || this.isFinish;
  }
  get _disabledAttribute() {
    if (this.isDisabled) {
      return "";
    }
    return null;
  }
  get isDisabled() {
    const disabled = true;
    const nav = this.navService;
    const page = this.navService.currentPage;
    if (!this.buttonService.buttonsReady) {
      return !disabled;
    }
    if (this.disabled || nav.wizardStopNavigation || !page) {
      return true;
    }
    if (this.isCancel) {
      return !disabled;
    }
    if (this.isPrevious && (nav.currentPageIsFirst || page.previousStepDisabled)) {
      return disabled;
    }
    if (this.isDanger && !page.readyToComplete) {
      return disabled;
    }
    if (this.isNext && (nav.currentPageIsLast || !page.readyToComplete)) {
      return disabled;
    }
    if (this.isFinish && (!nav.currentPageIsLast || !page.readyToComplete)) {
      return disabled;
    }
    return !disabled;
  }
  get isHidden() {
    const hidden = true;
    const nav = this.navService;
    if (!this.buttonService.buttonsReady) {
      return !hidden;
    }
    if (this.hidden) {
      return true;
    }
    if (this.isCancel) {
      return !hidden;
    }
    if (this.isPrevious && nav.currentPageIsFirst) {
      return hidden;
    }
    if (this.isNext && nav.currentPageIsLast) {
      return hidden;
    }
    if (this.isFinish && !nav.currentPageIsLast) {
      return hidden;
    }
    return !hidden;
  }
  click() {
    if (this.isDisabled) {
      return;
    }
    this.wasClicked.emit(this.type);
    this.buttonService.buttonClicked(this.type);
  }
  checkDefaultAndCustomType(valueToCheck = "", typeToLookUp) {
    if (DEFAULT_BUTTON_TYPES[typeToLookUp] === valueToCheck) {
      return true;
    }
    if (CUSTOM_BUTTON_TYPES[typeToLookUp] === valueToCheck) {
      return true;
    }
    return false;
  }
};
ClrWizardButton.ɵfac = function ClrWizardButton_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrWizardButton)(ɵɵdirectiveInject(WizardNavigationService), ɵɵdirectiveInject(ButtonHubService));
};
ClrWizardButton.ɵcmp = ɵɵdefineComponent({
  type: ClrWizardButton,
  selectors: [["clr-wizard-button"]],
  hostAttrs: [1, "clr-wizard-btn-wrapper"],
  hostVars: 1,
  hostBindings: function ClrWizardButton_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("aria-hidden", ctx.isHidden);
    }
  },
  inputs: {
    type: "type",
    disabled: [0, "clrWizardButtonDisabled", "disabled"],
    hidden: [0, "clrWizardButtonHidden", "hidden"]
  },
  outputs: {
    wasClicked: "clrWizardButtonClicked"
  },
  standalone: false,
  ngContentSelectors: _c02,
  decls: 2,
  vars: 19,
  consts: [["type", "button", 1, "btn", "clr-wizard-btn", 3, "click"]],
  template: function ClrWizardButton_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "button", 0);
      ɵɵlistener("click", function ClrWizardButton_Template_button_click_0_listener() {
        return ctx.click();
      });
      ɵɵprojection(1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵclassProp("btn-link", ctx.isCancel)("clr-wizard-btn--tertiary", ctx.isCancel)("btn-outline", ctx.isPrevious)("clr-wizard-btn--secondary", ctx.isPrevious)("btn-primary", ctx.isPrimaryAction)("clr-wizard-btn--primary", ctx.isPrimaryAction)("btn-success", ctx.isFinish)("btn-danger", ctx.isDanger)("disabled", ctx.isDisabled);
      ɵɵattribute("disabled", ctx._disabledAttribute);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrWizardButton, [{
    type: Component,
    args: [{
      selector: "clr-wizard-button",
      template: `
    <button
      type="button"
      class="btn clr-wizard-btn"
      [class.btn-link]="isCancel"
      [class.clr-wizard-btn--tertiary]="isCancel"
      [class.btn-outline]="isPrevious"
      [class.clr-wizard-btn--secondary]="isPrevious"
      [class.btn-primary]="isPrimaryAction"
      [class.clr-wizard-btn--primary]="isPrimaryAction"
      [class.btn-success]="isFinish"
      [class.btn-danger]="isDanger"
      [class.disabled]="isDisabled"
      [attr.disabled]="_disabledAttribute"
      (click)="click()"
    >
      <ng-content></ng-content>
    </button>
  `,
      host: {
        class: "clr-wizard-btn-wrapper",
        "[attr.aria-hidden]": "isHidden"
      }
    }]
  }], function() {
    return [{
      type: WizardNavigationService
    }, {
      type: ButtonHubService
    }];
  }, {
    type: [{
      type: Input,
      args: ["type"]
    }],
    disabled: [{
      type: Input,
      args: ["clrWizardButtonDisabled"]
    }],
    hidden: [{
      type: Input,
      args: ["clrWizardButtonHidden"]
    }],
    wasClicked: [{
      type: Output,
      args: ["clrWizardButtonClicked"]
    }]
  });
})();
var CLR_WIZARD_DIRECTIVES = [ClrWizard, ClrWizardPage, ClrWizardStepnav, ClrWizardStepnavItem, ClrWizardButton, ClrWizardHeaderAction, ClrWizardTitle, ClrWizardPageTitle, ClrWizardPageNavTitle, ClrWizardPageButtons, ClrWizardPageHeaderActions];
var ClrWizardModule = class {
  constructor() {
    r.addIcons(d, d2);
  }
};
ClrWizardModule.ɵfac = function ClrWizardModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClrWizardModule)();
};
ClrWizardModule.ɵmod = ɵɵdefineNgModule({
  type: ClrWizardModule,
  declarations: [ClrWizard, ClrWizardPage, ClrWizardStepnav, ClrWizardStepnavItem, ClrWizardButton, ClrWizardHeaderAction, ClrWizardTitle, ClrWizardPageTitle, ClrWizardPageNavTitle, ClrWizardPageButtons, ClrWizardPageHeaderActions],
  imports: [CommonModule, ClrModalModule, ClrAlertModule],
  exports: [ClrWizard, ClrWizardPage, ClrWizardStepnav, ClrWizardStepnavItem, ClrWizardButton, ClrWizardHeaderAction, ClrWizardTitle, ClrWizardPageTitle, ClrWizardPageNavTitle, ClrWizardPageButtons, ClrWizardPageHeaderActions]
});
ClrWizardModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrModalModule, ClrAlertModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrWizardModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ClrModalModule, ClrAlertModule],
      declarations: [CLR_WIZARD_DIRECTIVES],
      exports: [CLR_WIZARD_DIRECTIVES]
    }]
  }], function() {
    return [];
  }, null);
})();
var ClarityModule = class {
};
ClarityModule.ɵfac = function ClarityModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || ClarityModule)();
};
ClarityModule.ɵmod = ɵɵdefineNgModule({
  type: ClarityModule,
  exports: [ClrEmphasisModule, ClrDataModule, ClrIconModule, ClrModalModule, ClrLoadingModule, ClrConditionalModule, ClrFocusOnViewInitModule, ClrButtonModule, ClrFormsModule, ClrLayoutModule, ClrPopoverModule, ClrWizardModule, ClrSidePanelModule, ClrStepperModule, ClrSpinnerModule, ClrProgressBarModule, ClrPopoverModuleNext, ClrTimelineModule]
});
ClarityModule.ɵinj = ɵɵdefineInjector({
  imports: [ClrEmphasisModule, ClrDataModule, ClrIconModule, ClrModalModule, ClrLoadingModule, ClrConditionalModule, ClrFocusOnViewInitModule, ClrButtonModule, ClrFormsModule, ClrLayoutModule, ClrPopoverModule, ClrWizardModule, ClrSidePanelModule, ClrStepperModule, ClrSpinnerModule, ClrProgressBarModule, ClrPopoverModuleNext, ClrTimelineModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClarityModule, [{
    type: NgModule,
    args: [{
      exports: [ClrEmphasisModule, ClrDataModule, ClrIconModule, ClrModalModule, ClrLoadingModule, ClrConditionalModule, ClrFocusOnViewInitModule, ClrButtonModule, ClrFormsModule, ClrLayoutModule, ClrPopoverModule, ClrWizardModule, ClrSidePanelModule, ClrStepperModule, ClrSpinnerModule, ClrProgressBarModule, ClrPopoverModuleNext, ClrTimelineModule]
    }]
  }], null, null);
})();
export {
  CHANGE_KEYS,
  CLR_ALERT_DIRECTIVES,
  CLR_BUTTON_GROUP_DIRECTIVES,
  CLR_DATAGRID_DIRECTIVES,
  CLR_DATEPICKER_DIRECTIVES,
  CLR_DROPDOWN_DIRECTIVES,
  CLR_FILE_MESSAGES_TEMPLATE_CONTEXT,
  CLR_ICON_DIRECTIVES,
  CLR_LAYOUT_DIRECTIVES,
  CLR_LOADING_BUTTON_DIRECTIVES,
  CLR_LOADING_DIRECTIVES,
  CLR_MENU_POSITIONS,
  CLR_MODAL_DIRECTIVES,
  CLR_NAVIGATION_DIRECTIVES,
  CLR_PROGRESS_BAR_DIRECTIVES,
  CLR_SIDEPANEL_DIRECTIVES,
  CLR_SIGNPOST_DIRECTIVES,
  CLR_SPINNER_DIRECTIVES,
  CLR_STACK_VIEW_DIRECTIVES,
  CLR_TABS_DIRECTIVES,
  CLR_TOOLTIP_DIRECTIVES,
  CLR_TREE_VIEW_DIRECTIVES,
  CLR_VERTICAL_NAV_DIRECTIVES,
  CLR_WIZARD_DIRECTIVES,
  CONDITIONAL_DIRECTIVES,
  CUSTOM_BUTTON_TYPES,
  CdsIconCustomTag,
  ClarityModule,
  ClrAbstractContainer,
  ClrAccordion,
  ClrAccordionContent,
  ClrAccordionDescription,
  ClrAccordionModule,
  ClrAccordionPanel,
  ClrAccordionTitle,
  ClrAlert,
  ClrAlertItem,
  ClrAlertModule,
  ClrAlertText,
  ClrAlerts,
  ClrAlertsPager,
  ClrAlignment,
  ClrAriaCurrentLink,
  ClrAxis,
  ClrBreadcrumbItem,
  ClrBreadcrumbs,
  ClrBreadcrumbsModule,
  ClrButton,
  ClrButtonGroup,
  ClrButtonGroupModule,
  ClrButtonModule,
  ClrCalendar,
  ClrCheckbox,
  ClrCheckboxContainer,
  ClrCheckboxModule,
  ClrCheckboxWrapper,
  ClrCombobox,
  ClrComboboxContainer,
  ClrComboboxModule,
  ClrCommonFormsModule,
  ClrCommonStringsService,
  ClrConditionalModule,
  ClrControl,
  ClrControlContainer,
  ClrControlError,
  ClrControlHelper,
  ClrControlSuccess,
  ClrDataModule,
  ClrDatagrid,
  ClrDatagridActionBar,
  ClrDatagridActionOverflow,
  ClrDatagridCell,
  ClrDatagridColumn,
  ClrDatagridColumnSeparator,
  ClrDatagridColumnToggle,
  ClrDatagridColumnToggleButton,
  ClrDatagridDetail,
  ClrDatagridDetailBody,
  ClrDatagridDetailHeader,
  ClrDatagridFilter,
  ClrDatagridFooter,
  ClrDatagridHideableColumn,
  ClrDatagridItems,
  ClrDatagridModule,
  ClrDatagridPageSize,
  ClrDatagridPagination,
  ClrDatagridPlaceholder,
  ClrDatagridRow,
  ClrDatagridRowDetail,
  ClrDatagridSortOrder,
  ClrDatalist,
  ClrDatalistContainer,
  ClrDatalistInput,
  ClrDatalistModule,
  ClrDateContainer,
  ClrDateInput,
  ClrDateInputValidator,
  ClrDatepickerActions,
  ClrDatepickerModule,
  ClrDatepickerViewManager,
  ClrDay,
  ClrDaypicker,
  ClrDestroyService,
  ClrDropdown,
  ClrDropdownItem,
  ClrDropdownMenu,
  ClrDropdownModule,
  ClrDropdownTrigger,
  ClrEmphasisModule,
  ClrExpandableAnimation,
  ClrFileError,
  ClrFileInfo,
  ClrFileInput,
  ClrFileInputContainer,
  ClrFileInputModule,
  ClrFileInputValidator,
  ClrFileInputValueAccessor,
  ClrFileList,
  ClrFileMessagesTemplate,
  ClrFileSuccess,
  ClrFocusOnViewInit,
  ClrFocusOnViewInitModule,
  ClrForm,
  ClrFormLayout,
  ClrFormsModule,
  ClrHeader,
  ClrIconCustomTag,
  ClrIconModule,
  ClrIfActive,
  ClrIfDetail,
  ClrIfError,
  ClrIfExpanded,
  ClrIfOpen,
  ClrIfSuccess,
  ClrInput,
  ClrInputContainer,
  ClrInputModule,
  ClrLabel,
  ClrLayout,
  ClrLayoutModule,
  ClrLoading,
  ClrLoadingButton,
  ClrLoadingButtonModule,
  ClrLoadingModule,
  ClrLoadingState,
  ClrMainContainer,
  ClrMainContainerModule,
  ClrModal,
  ClrModalBody,
  ClrModalConfigurationService,
  ClrModalModule,
  ClrMonthpicker,
  ClrNavLevel,
  ClrNavigationModule,
  ClrNumberInput,
  ClrNumberInputContainer,
  ClrNumberInputModule,
  ClrOption,
  ClrOptionItems,
  ClrOptionSelected,
  ClrOptions,
  ClrPassword,
  ClrPasswordContainer,
  ClrPasswordModule,
  ClrPopoverAnchor,
  ClrPopoverContent,
  ClrPopoverEventsService,
  ClrPopoverHostDirective,
  ClrPopoverModule,
  ClrPopoverPositionService,
  ClrPopoverToggleService,
  ClrProgressBar,
  ClrProgressBarModule,
  ClrRadio,
  ClrRadioContainer,
  ClrRadioModule,
  ClrRadioWrapper,
  ClrRange,
  ClrRangeContainer,
  ClrRangeModule,
  ClrRecursiveForOf,
  ClrSelect,
  ClrSelectContainer,
  ClrSelectModule,
  ClrSelectedState,
  ClrSide,
  ClrSidePanel,
  ClrSidePanelModule,
  ClrSignpost,
  ClrSignpostContent,
  ClrSignpostModule,
  ClrSignpostTitle,
  ClrSignpostTrigger,
  ClrSpinner,
  ClrSpinnerModule,
  ClrStackBlock,
  ClrStackContentInput,
  ClrStackHeader,
  ClrStackView,
  ClrStackViewCustomTags,
  ClrStackViewLabel,
  ClrStackViewModule,
  ClrStandaloneCdkTrapFocus,
  ClrStepButton,
  ClrStepButtonType,
  ClrStepper,
  ClrStepperModule,
  ClrStepperPanel,
  ClrStopEscapePropagationDirective,
  ClrTab,
  ClrTabAction,
  ClrTabContent,
  ClrTabLink,
  ClrTabOverflowContent,
  ClrTabs,
  ClrTabsActions,
  ClrTabsModule,
  ClrTextarea,
  ClrTextareaContainer,
  ClrTextareaModule,
  ClrTimeline,
  ClrTimelineLayout,
  ClrTimelineModule,
  ClrTimelineStep,
  ClrTimelineStepDescription,
  ClrTimelineStepHeader,
  ClrTimelineStepState,
  ClrTimelineStepTitle,
  ClrTooltip,
  ClrTooltipContent,
  ClrTooltipModule,
  ClrTooltipTrigger,
  ClrTree,
  ClrTreeNode,
  ClrTreeNodeLink,
  ClrTreeViewModule,
  ClrVerticalNav,
  ClrVerticalNavGroup,
  ClrVerticalNavGroupChildren,
  ClrVerticalNavIcon,
  ClrVerticalNavLink,
  ClrVerticalNavModule,
  ClrWizard,
  ClrWizardButton,
  ClrWizardHeaderAction,
  ClrWizardModule,
  ClrWizardPage,
  ClrWizardPageButtons,
  ClrWizardPageHeaderActions,
  ClrWizardPageNavTitle,
  ClrWizardPageTitle,
  ClrWizardStepnav,
  ClrWizardStepnavItem,
  ClrWizardTitle,
  ClrYearpicker,
  DEFAULT_BUTTON_TYPES,
  DatagridNumericFilter,
  DatagridPropertyComparator,
  DatagridPropertyNumericFilter,
  DatagridPropertyStringFilter,
  DatagridStringFilter,
  EXPANDABLE_ANIMATION_DIRECTIVES,
  FOCUS_ON_VIEW_INIT,
  FOCUS_ON_VIEW_INIT_DIRECTIVES,
  IS_TOGGLE,
  IS_TOGGLE_PROVIDER,
  LoadingListener,
  MainContainerWillyWonka,
  NavDetectionOompaLoompa,
  TOGGLE_SERVICE,
  TOGGLE_SERVICE_PROVIDER,
  ToggleServiceFactory,
  WrappedFormControl,
  collapse,
  commonStringsDefault,
  fade,
  fadeSlide,
  isToggleFactory,
  slide,
  AccordionOompaLoompa as ÇlrAccordionOompaLoompa,
  AccordionWillyWonka as ÇlrAccordionWillyWonka,
  ActionableOompaLoompa as ÇlrActionableOompaLoompa,
  ActiveOompaLoompa as ÇlrActiveOompaLoompa,
  ClrPopoverCloseButton as ÇlrClrPopoverCloseButton,
  ClrPopoverModuleNext as ÇlrClrPopoverModuleNext,
  ClrPopoverOpenCloseButton as ÇlrClrPopoverOpenCloseButton,
  DatagridCellRenderer as ÇlrDatagridCellRenderer,
  DatagridDetailRegisterer as ÇlrDatagridDetailRegisterer,
  DatagridHeaderRenderer as ÇlrDatagridHeaderRenderer,
  DatagridMainRenderer as ÇlrDatagridMainRenderer,
  DatagridRowRenderer as ÇlrDatagridRowRenderer,
  ClrDatagridSelectionCellDirective as ÇlrDatagridSelectionCellDirective,
  ClrDatagridVirtualScrollDirective as ÇlrDatagridVirtualScrollDirective,
  DatagridWillyWonka as ÇlrDatagridWillyWonka,
  ExpandableOompaLoompa as ÇlrExpandableOompaLoompa,
  StepperOompaLoompa as ÇlrStepperOompaLoompa,
  StepperWillyWonka as ÇlrStepperWillyWonka,
  TabsWillyWonka as ÇlrTabsWillyWonka,
  WrappedCell as ÇlrWrappedCell,
  WrappedColumn as ÇlrWrappedColumn,
  WrappedRow as ÇlrWrappedRow
};
/*! Bundled license information:

@angular/forms/fesm2022/forms.mjs:
  (**
   * @license Angular v19.1.4
   * (c) 2010-2024 Google LLC. https://angular.io/
   * License: MIT
   *)
*/
//# sourceMappingURL=@clr_angular.js.map
